/* automatically generated by rust-bindgen 0.59.1 */

extern crate core;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __llvm__: u32 = 1;
pub const __clang__: u32 = 1;
pub const __clang_major__: u32 = 12;
pub const __clang_minor__: u32 = 0;
pub const __clang_patchlevel__: u32 = 5;
pub const __clang_version__: &'static [u8; 28usize] = b"12.0.5 (clang-1205.0.22.11)\0";
pub const __GNUC__: u32 = 4;
pub const __GNUC_MINOR__: u32 = 2;
pub const __GNUC_PATCHLEVEL__: u32 = 1;
pub const __GXX_ABI_VERSION: u32 = 1002;
pub const __ATOMIC_RELAXED: u32 = 0;
pub const __ATOMIC_CONSUME: u32 = 1;
pub const __ATOMIC_ACQUIRE: u32 = 2;
pub const __ATOMIC_RELEASE: u32 = 3;
pub const __ATOMIC_ACQ_REL: u32 = 4;
pub const __ATOMIC_SEQ_CST: u32 = 5;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: u32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: u32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: u32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: u32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: u32 = 4;
pub const __PRAGMA_REDEFINE_EXTNAME: u32 = 1;
pub const __VERSION__: &'static [u8; 39usize] = b"Apple LLVM 12.0.5 (clang-1205.0.22.11)\0";
pub const __OBJC_BOOL_IS_BOOL: u32 = 0;
pub const __CONSTANT_CFSTRINGS__: u32 = 1;
pub const __ORDER_LITTLE_ENDIAN__: u32 = 1234;
pub const __ORDER_BIG_ENDIAN__: u32 = 4321;
pub const __ORDER_PDP_ENDIAN__: u32 = 3412;
pub const __BYTE_ORDER__: u32 = 1234;
pub const __LITTLE_ENDIAN__: u32 = 1;
pub const _ILP32: u32 = 1;
pub const __ILP32__: u32 = 1;
pub const __CHAR_BIT__: u32 = 8;
pub const __SCHAR_MAX__: u32 = 127;
pub const __SHRT_MAX__: u32 = 32767;
pub const __INT_MAX__: u32 = 2147483647;
pub const __LONG_MAX__: u32 = 2147483647;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __WCHAR_MAX__: u32 = 4294967295;
pub const __WINT_MAX__: u32 = 2147483647;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __SIZE_MAX__: u32 = 4294967295;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __PTRDIFF_MAX__: u32 = 2147483647;
pub const __INTPTR_MAX__: u32 = 2147483647;
pub const __UINTPTR_MAX__: u32 = 4294967295;
pub const __SIZEOF_DOUBLE__: u32 = 8;
pub const __SIZEOF_FLOAT__: u32 = 4;
pub const __SIZEOF_INT__: u32 = 4;
pub const __SIZEOF_LONG__: u32 = 4;
pub const __SIZEOF_LONG_DOUBLE__: u32 = 8;
pub const __SIZEOF_LONG_LONG__: u32 = 8;
pub const __SIZEOF_POINTER__: u32 = 4;
pub const __SIZEOF_SHORT__: u32 = 2;
pub const __SIZEOF_PTRDIFF_T__: u32 = 4;
pub const __SIZEOF_SIZE_T__: u32 = 4;
pub const __SIZEOF_WCHAR_T__: u32 = 4;
pub const __SIZEOF_WINT_T__: u32 = 4;
pub const __INTMAX_FMTd__: &'static [u8; 4usize] = b"lld\0";
pub const __INTMAX_FMTi__: &'static [u8; 4usize] = b"lli\0";
pub const __UINTMAX_FMTo__: &'static [u8; 4usize] = b"llo\0";
pub const __UINTMAX_FMTu__: &'static [u8; 4usize] = b"llu\0";
pub const __UINTMAX_FMTx__: &'static [u8; 4usize] = b"llx\0";
pub const __UINTMAX_FMTX__: &'static [u8; 4usize] = b"llX\0";
pub const __INTMAX_WIDTH__: u32 = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __PTRDIFF_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __PTRDIFF_WIDTH__: u32 = 32;
pub const __INTPTR_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INTPTR_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __INTPTR_WIDTH__: u32 = 32;
pub const __SIZE_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __SIZE_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __SIZE_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __SIZE_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __SIZE_WIDTH__: u32 = 32;
pub const __WCHAR_WIDTH__: u32 = 32;
pub const __WINT_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __UINTMAX_WIDTH__: u32 = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINTPTR_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINTPTR_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINTPTR_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __UINTPTR_WIDTH__: u32 = 32;
pub const __FLT16_HAS_DENORM__: u32 = 1;
pub const __FLT16_DIG__: u32 = 3;
pub const __FLT16_DECIMAL_DIG__: u32 = 5;
pub const __FLT16_HAS_INFINITY__: u32 = 1;
pub const __FLT16_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT16_MANT_DIG__: u32 = 11;
pub const __FLT16_MAX_10_EXP__: u32 = 4;
pub const __FLT16_MAX_EXP__: u32 = 16;
pub const __FLT16_MIN_10_EXP__: i32 = -4;
pub const __FLT16_MIN_EXP__: i32 = -13;
pub const __FLT_HAS_DENORM__: u32 = 1;
pub const __FLT_DIG__: u32 = 6;
pub const __FLT_DECIMAL_DIG__: u32 = 9;
pub const __FLT_HAS_INFINITY__: u32 = 1;
pub const __FLT_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT_MANT_DIG__: u32 = 24;
pub const __FLT_MAX_10_EXP__: u32 = 38;
pub const __FLT_MAX_EXP__: u32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: u32 = 1;
pub const __DBL_DIG__: u32 = 15;
pub const __DBL_DECIMAL_DIG__: u32 = 17;
pub const __DBL_HAS_INFINITY__: u32 = 1;
pub const __DBL_HAS_QUIET_NAN__: u32 = 1;
pub const __DBL_MANT_DIG__: u32 = 53;
pub const __DBL_MAX_10_EXP__: u32 = 308;
pub const __DBL_MAX_EXP__: u32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: u32 = 1;
pub const __LDBL_DIG__: u32 = 15;
pub const __LDBL_DECIMAL_DIG__: u32 = 17;
pub const __LDBL_HAS_INFINITY__: u32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: u32 = 1;
pub const __LDBL_MANT_DIG__: u32 = 53;
pub const __LDBL_MAX_10_EXP__: u32 = 308;
pub const __LDBL_MAX_EXP__: u32 = 1024;
pub const __LDBL_MIN_10_EXP__: i32 = -307;
pub const __LDBL_MIN_EXP__: i32 = -1021;
pub const __POINTER_WIDTH__: u32 = 32;
pub const __BIGGEST_ALIGNMENT__: u32 = 8;
pub const __CHAR_UNSIGNED__: u32 = 1;
pub const __WCHAR_UNSIGNED__: u32 = 1;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __INT64_FMTd__: &'static [u8; 4usize] = b"lld\0";
pub const __INT64_FMTi__: &'static [u8; 4usize] = b"lli\0";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __UINT8_MAX__: u32 = 255;
pub const __INT8_MAX__: u32 = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __UINT16_MAX__: u32 = 65535;
pub const __INT16_MAX__: u32 = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __UINT32_MAX__: u32 = 4294967295;
pub const __INT32_MAX__: u32 = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 4usize] = b"llo\0";
pub const __UINT64_FMTu__: &'static [u8; 4usize] = b"llu\0";
pub const __UINT64_FMTx__: &'static [u8; 4usize] = b"llx\0";
pub const __UINT64_FMTX__: &'static [u8; 4usize] = b"llX\0";
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: u32 = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_LEAST8_MAX__: u32 = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_LEAST16_MAX__: u32 = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_LEAST16_MAX__: u32 = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 4usize] = b"lld\0";
pub const __INT_LEAST64_FMTi__: &'static [u8; 4usize] = b"lli\0";
pub const __UINT_LEAST64_MAX__: i32 = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 4usize] = b"llo\0";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 4usize] = b"llu\0";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 4usize] = b"llx\0";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 4usize] = b"llX\0";
pub const __INT_FAST8_MAX__: u32 = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_FAST8_MAX__: u32 = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_FAST16_MAX__: u32 = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_FAST16_MAX__: u32 = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 4usize] = b"lld\0";
pub const __INT_FAST64_FMTi__: &'static [u8; 4usize] = b"lli\0";
pub const __UINT_FAST64_MAX__: i32 = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 4usize] = b"llo\0";
pub const __UINT_FAST64_FMTu__: &'static [u8; 4usize] = b"llu\0";
pub const __UINT_FAST64_FMTx__: &'static [u8; 4usize] = b"llx\0";
pub const __UINT_FAST64_FMTX__: &'static [u8; 4usize] = b"llX\0";
pub const __FINITE_MATH_ONLY__: u32 = 0;
pub const __GNUC_STDC_INLINE__: u32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u32 = 1;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: u32 = 1;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u32 = 1;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __NO_INLINE__: u32 = 1;
pub const __FLT_EVAL_METHOD__: u32 = 0;
pub const __FLT_RADIX__: u32 = 2;
pub const __DECIMAL_DIG__: u32 = 17;
pub const __ARMEL__: u32 = 1;
pub const __arm: u32 = 1;
pub const __arm__: u32 = 1;
pub const __ELF__: u32 = 1;
pub const __ARM_ARCH_7EM__: u32 = 1;
pub const __ARM_ARCH: u32 = 7;
pub const __ARM_ARCH_ISA_THUMB: u32 = 2;
pub const __ARM_32BIT_STATE: u32 = 1;
pub const __ARM_ARCH_PROFILE: u8 = 77u8;
pub const __ARM_FEATURE_LDREX: u32 = 7;
pub const __ARM_FEATURE_CLZ: u32 = 1;
pub const __ARM_FP: u32 = 6;
pub const __ARM_ACLE: u32 = 200;
pub const __ARM_FP16_FORMAT_IEEE: u32 = 1;
pub const __ARM_FP16_ARGS: u32 = 1;
pub const __ARM_FEATURE_FMA: u32 = 1;
pub const __THUMB_INTERWORK__: u32 = 1;
pub const __ARM_EABI__: u32 = 1;
pub const __ARM_PCS: u32 = 1;
pub const __ARM_PCS_VFP: u32 = 1;
pub const __THUMBEL__: u32 = 1;
pub const __thumb__: u32 = 1;
pub const __thumb2__: u32 = 1;
pub const __ARM_FEATURE_SIMD32: u32 = 1;
pub const __ARM_FEATURE_IDIV: u32 = 1;
pub const __ARM_ARCH_EXT_IDIV__: u32 = 1;
pub const __APCS_32__: u32 = 1;
pub const __VFP_FP__: u32 = 1;
pub const __ARM_VFPV2__: u32 = 1;
pub const __ARM_VFPV3__: u32 = 1;
pub const __ARM_VFPV4__: u32 = 1;
pub const __ARM_SIZEOF_WCHAR_T: u32 = 4;
pub const __ARM_SIZEOF_MINIMAL_ENUM: u32 = 4;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: u32 = 1;
pub const __ARM_FEATURE_DSP: u32 = 1;
pub const __ARM_FEATURE_SAT: u32 = 1;
pub const __ARM_FEATURE_QBIT: u32 = 1;
pub const __STDC__: u32 = 1;
pub const __STDC_HOSTED__: u32 = 1;
pub const __STDC_VERSION__: u32 = 201710;
pub const __STDC_UTF_16__: u32 = 1;
pub const __STDC_UTF_32__: u32 = 1;
pub const STM32L475xx: u32 = 1;
pub const USE_HAL_DRIVER: u32 = 1;
pub const HSE_VALUE: u32 = 8000000;
pub const HSE_STARTUP_TIMEOUT: u32 = 100;
pub const MSI_VALUE: u32 = 4000000;
pub const HSI_VALUE: u32 = 16000000;
pub const HSI48_VALUE: u32 = 48000000;
pub const LSI_VALUE: u32 = 32000;
pub const LSE_VALUE: u32 = 32768;
pub const LSE_STARTUP_TIMEOUT: u32 = 5000;
pub const EXTERNAL_SAI1_CLOCK_VALUE: u32 = 48000;
pub const EXTERNAL_SAI2_CLOCK_VALUE: u32 = 48000;
pub const VDD_VALUE: u32 = 3300;
pub const TICK_INT_PRIORITY: u32 = 15;
pub const USE_RTOS: u32 = 0;
pub const PREFETCH_ENABLE: u32 = 0;
pub const INSTRUCTION_CACHE_ENABLE: u32 = 1;
pub const DATA_CACHE_ENABLE: u32 = 1;
pub const USE_HAL_ADC_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_CAN_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_COMP_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_CRYP_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_DAC_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_DCMI_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_DFSDM_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_DMA2D_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_DSI_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_GFXMMU_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_HASH_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_HCD_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_I2C_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_IRDA_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_LPTIM_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_LTDC_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_MMC_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_OPAMP_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_OSPI_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_PCD_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_QSPI_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_RNG_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_RTC_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_SAI_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_SD_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_SMARTCARD_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_SMBUS_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_SPI_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_SWPMI_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_TIM_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_TSC_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_UART_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_USART_REGISTER_CALLBACKS: u32 = 0;
pub const USE_HAL_WWDG_REGISTER_CALLBACKS: u32 = 0;
pub const USE_SPI_CRC: u32 = 1;
pub const __STM32L4_CMSIS_VERSION_MAIN: u32 = 1;
pub const __STM32L4_CMSIS_VERSION_SUB1: u32 = 7;
pub const __STM32L4_CMSIS_VERSION_SUB2: u32 = 1;
pub const __STM32L4_CMSIS_VERSION_RC: u32 = 0;
pub const __STM32L4_CMSIS_VERSION: u32 = 17236224;
pub const __CM4_REV: u32 = 1;
pub const __MPU_PRESENT: u32 = 1;
pub const __NVIC_PRIO_BITS: u32 = 4;
pub const __Vendor_SysTickConfig: u32 = 0;
pub const __FPU_PRESENT: u32 = 1;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const WCHAR_MAX: u32 = 4294967295;
pub const __CM_CMSIS_VERSION_MAIN: u32 = 5;
pub const __CM_CMSIS_VERSION_SUB: u32 = 3;
pub const __CM_CMSIS_VERSION: u32 = 327683;
pub const __CM4_CMSIS_VERSION_MAIN: u32 = 5;
pub const __CM4_CMSIS_VERSION_SUB: u32 = 3;
pub const __CM4_CMSIS_VERSION: u32 = 327683;
pub const __CORTEX_M: u32 = 4;
pub const __FPU_USED: u32 = 1;
pub const APSR_N_Pos: u32 = 31;
pub const APSR_N_Msk: u32 = 2147483648;
pub const APSR_Z_Pos: u32 = 30;
pub const APSR_Z_Msk: u32 = 1073741824;
pub const APSR_C_Pos: u32 = 29;
pub const APSR_C_Msk: u32 = 536870912;
pub const APSR_V_Pos: u32 = 28;
pub const APSR_V_Msk: u32 = 268435456;
pub const APSR_Q_Pos: u32 = 27;
pub const APSR_Q_Msk: u32 = 134217728;
pub const APSR_GE_Pos: u32 = 16;
pub const APSR_GE_Msk: u32 = 983040;
pub const IPSR_ISR_Pos: u32 = 0;
pub const IPSR_ISR_Msk: u32 = 511;
pub const xPSR_N_Pos: u32 = 31;
pub const xPSR_N_Msk: u32 = 2147483648;
pub const xPSR_Z_Pos: u32 = 30;
pub const xPSR_Z_Msk: u32 = 1073741824;
pub const xPSR_C_Pos: u32 = 29;
pub const xPSR_C_Msk: u32 = 536870912;
pub const xPSR_V_Pos: u32 = 28;
pub const xPSR_V_Msk: u32 = 268435456;
pub const xPSR_Q_Pos: u32 = 27;
pub const xPSR_Q_Msk: u32 = 134217728;
pub const xPSR_ICI_IT_2_Pos: u32 = 25;
pub const xPSR_ICI_IT_2_Msk: u32 = 100663296;
pub const xPSR_T_Pos: u32 = 24;
pub const xPSR_T_Msk: u32 = 16777216;
pub const xPSR_GE_Pos: u32 = 16;
pub const xPSR_GE_Msk: u32 = 983040;
pub const xPSR_ICI_IT_1_Pos: u32 = 10;
pub const xPSR_ICI_IT_1_Msk: u32 = 64512;
pub const xPSR_ISR_Pos: u32 = 0;
pub const xPSR_ISR_Msk: u32 = 511;
pub const CONTROL_FPCA_Pos: u32 = 2;
pub const CONTROL_FPCA_Msk: u32 = 4;
pub const CONTROL_SPSEL_Pos: u32 = 1;
pub const CONTROL_SPSEL_Msk: u32 = 2;
pub const CONTROL_nPRIV_Pos: u32 = 0;
pub const CONTROL_nPRIV_Msk: u32 = 1;
pub const NVIC_STIR_INTID_Pos: u32 = 0;
pub const NVIC_STIR_INTID_Msk: u32 = 511;
pub const SCB_CPUID_IMPLEMENTER_Pos: u32 = 24;
pub const SCB_CPUID_IMPLEMENTER_Msk: u32 = 4278190080;
pub const SCB_CPUID_VARIANT_Pos: u32 = 20;
pub const SCB_CPUID_VARIANT_Msk: u32 = 15728640;
pub const SCB_CPUID_ARCHITECTURE_Pos: u32 = 16;
pub const SCB_CPUID_ARCHITECTURE_Msk: u32 = 983040;
pub const SCB_CPUID_PARTNO_Pos: u32 = 4;
pub const SCB_CPUID_PARTNO_Msk: u32 = 65520;
pub const SCB_CPUID_REVISION_Pos: u32 = 0;
pub const SCB_CPUID_REVISION_Msk: u32 = 15;
pub const SCB_ICSR_NMIPENDSET_Pos: u32 = 31;
pub const SCB_ICSR_NMIPENDSET_Msk: u32 = 2147483648;
pub const SCB_ICSR_PENDSVSET_Pos: u32 = 28;
pub const SCB_ICSR_PENDSVSET_Msk: u32 = 268435456;
pub const SCB_ICSR_PENDSVCLR_Pos: u32 = 27;
pub const SCB_ICSR_PENDSVCLR_Msk: u32 = 134217728;
pub const SCB_ICSR_PENDSTSET_Pos: u32 = 26;
pub const SCB_ICSR_PENDSTSET_Msk: u32 = 67108864;
pub const SCB_ICSR_PENDSTCLR_Pos: u32 = 25;
pub const SCB_ICSR_PENDSTCLR_Msk: u32 = 33554432;
pub const SCB_ICSR_ISRPREEMPT_Pos: u32 = 23;
pub const SCB_ICSR_ISRPREEMPT_Msk: u32 = 8388608;
pub const SCB_ICSR_ISRPENDING_Pos: u32 = 22;
pub const SCB_ICSR_ISRPENDING_Msk: u32 = 4194304;
pub const SCB_ICSR_VECTPENDING_Pos: u32 = 12;
pub const SCB_ICSR_VECTPENDING_Msk: u32 = 2093056;
pub const SCB_ICSR_RETTOBASE_Pos: u32 = 11;
pub const SCB_ICSR_RETTOBASE_Msk: u32 = 2048;
pub const SCB_ICSR_VECTACTIVE_Pos: u32 = 0;
pub const SCB_ICSR_VECTACTIVE_Msk: u32 = 511;
pub const SCB_VTOR_TBLOFF_Pos: u32 = 7;
pub const SCB_VTOR_TBLOFF_Msk: u32 = 4294967168;
pub const SCB_AIRCR_VECTKEY_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEY_Msk: u32 = 4294901760;
pub const SCB_AIRCR_VECTKEYSTAT_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEYSTAT_Msk: u32 = 4294901760;
pub const SCB_AIRCR_ENDIANESS_Pos: u32 = 15;
pub const SCB_AIRCR_ENDIANESS_Msk: u32 = 32768;
pub const SCB_AIRCR_PRIGROUP_Pos: u32 = 8;
pub const SCB_AIRCR_PRIGROUP_Msk: u32 = 1792;
pub const SCB_AIRCR_SYSRESETREQ_Pos: u32 = 2;
pub const SCB_AIRCR_SYSRESETREQ_Msk: u32 = 4;
pub const SCB_AIRCR_VECTCLRACTIVE_Pos: u32 = 1;
pub const SCB_AIRCR_VECTCLRACTIVE_Msk: u32 = 2;
pub const SCB_AIRCR_VECTRESET_Pos: u32 = 0;
pub const SCB_AIRCR_VECTRESET_Msk: u32 = 1;
pub const SCB_SCR_SEVONPEND_Pos: u32 = 4;
pub const SCB_SCR_SEVONPEND_Msk: u32 = 16;
pub const SCB_SCR_SLEEPDEEP_Pos: u32 = 2;
pub const SCB_SCR_SLEEPDEEP_Msk: u32 = 4;
pub const SCB_SCR_SLEEPONEXIT_Pos: u32 = 1;
pub const SCB_SCR_SLEEPONEXIT_Msk: u32 = 2;
pub const SCB_CCR_STKALIGN_Pos: u32 = 9;
pub const SCB_CCR_STKALIGN_Msk: u32 = 512;
pub const SCB_CCR_BFHFNMIGN_Pos: u32 = 8;
pub const SCB_CCR_BFHFNMIGN_Msk: u32 = 256;
pub const SCB_CCR_DIV_0_TRP_Pos: u32 = 4;
pub const SCB_CCR_DIV_0_TRP_Msk: u32 = 16;
pub const SCB_CCR_UNALIGN_TRP_Pos: u32 = 3;
pub const SCB_CCR_UNALIGN_TRP_Msk: u32 = 8;
pub const SCB_CCR_USERSETMPEND_Pos: u32 = 1;
pub const SCB_CCR_USERSETMPEND_Msk: u32 = 2;
pub const SCB_CCR_NONBASETHRDENA_Pos: u32 = 0;
pub const SCB_CCR_NONBASETHRDENA_Msk: u32 = 1;
pub const SCB_SHCSR_USGFAULTENA_Pos: u32 = 18;
pub const SCB_SHCSR_USGFAULTENA_Msk: u32 = 262144;
pub const SCB_SHCSR_BUSFAULTENA_Pos: u32 = 17;
pub const SCB_SHCSR_BUSFAULTENA_Msk: u32 = 131072;
pub const SCB_SHCSR_MEMFAULTENA_Pos: u32 = 16;
pub const SCB_SHCSR_MEMFAULTENA_Msk: u32 = 65536;
pub const SCB_SHCSR_SVCALLPENDED_Pos: u32 = 15;
pub const SCB_SHCSR_SVCALLPENDED_Msk: u32 = 32768;
pub const SCB_SHCSR_BUSFAULTPENDED_Pos: u32 = 14;
pub const SCB_SHCSR_BUSFAULTPENDED_Msk: u32 = 16384;
pub const SCB_SHCSR_MEMFAULTPENDED_Pos: u32 = 13;
pub const SCB_SHCSR_MEMFAULTPENDED_Msk: u32 = 8192;
pub const SCB_SHCSR_USGFAULTPENDED_Pos: u32 = 12;
pub const SCB_SHCSR_USGFAULTPENDED_Msk: u32 = 4096;
pub const SCB_SHCSR_SYSTICKACT_Pos: u32 = 11;
pub const SCB_SHCSR_SYSTICKACT_Msk: u32 = 2048;
pub const SCB_SHCSR_PENDSVACT_Pos: u32 = 10;
pub const SCB_SHCSR_PENDSVACT_Msk: u32 = 1024;
pub const SCB_SHCSR_MONITORACT_Pos: u32 = 8;
pub const SCB_SHCSR_MONITORACT_Msk: u32 = 256;
pub const SCB_SHCSR_SVCALLACT_Pos: u32 = 7;
pub const SCB_SHCSR_SVCALLACT_Msk: u32 = 128;
pub const SCB_SHCSR_USGFAULTACT_Pos: u32 = 3;
pub const SCB_SHCSR_USGFAULTACT_Msk: u32 = 8;
pub const SCB_SHCSR_BUSFAULTACT_Pos: u32 = 1;
pub const SCB_SHCSR_BUSFAULTACT_Msk: u32 = 2;
pub const SCB_SHCSR_MEMFAULTACT_Pos: u32 = 0;
pub const SCB_SHCSR_MEMFAULTACT_Msk: u32 = 1;
pub const SCB_CFSR_USGFAULTSR_Pos: u32 = 16;
pub const SCB_CFSR_USGFAULTSR_Msk: u32 = 4294901760;
pub const SCB_CFSR_BUSFAULTSR_Pos: u32 = 8;
pub const SCB_CFSR_BUSFAULTSR_Msk: u32 = 65280;
pub const SCB_CFSR_MEMFAULTSR_Pos: u32 = 0;
pub const SCB_CFSR_MEMFAULTSR_Msk: u32 = 255;
pub const SCB_CFSR_MMARVALID_Pos: u32 = 7;
pub const SCB_CFSR_MMARVALID_Msk: u32 = 128;
pub const SCB_CFSR_MLSPERR_Pos: u32 = 5;
pub const SCB_CFSR_MLSPERR_Msk: u32 = 32;
pub const SCB_CFSR_MSTKERR_Pos: u32 = 4;
pub const SCB_CFSR_MSTKERR_Msk: u32 = 16;
pub const SCB_CFSR_MUNSTKERR_Pos: u32 = 3;
pub const SCB_CFSR_MUNSTKERR_Msk: u32 = 8;
pub const SCB_CFSR_DACCVIOL_Pos: u32 = 1;
pub const SCB_CFSR_DACCVIOL_Msk: u32 = 2;
pub const SCB_CFSR_IACCVIOL_Pos: u32 = 0;
pub const SCB_CFSR_IACCVIOL_Msk: u32 = 1;
pub const SCB_CFSR_BFARVALID_Pos: u32 = 15;
pub const SCB_CFSR_BFARVALID_Msk: u32 = 32768;
pub const SCB_CFSR_LSPERR_Pos: u32 = 13;
pub const SCB_CFSR_LSPERR_Msk: u32 = 8192;
pub const SCB_CFSR_STKERR_Pos: u32 = 12;
pub const SCB_CFSR_STKERR_Msk: u32 = 4096;
pub const SCB_CFSR_UNSTKERR_Pos: u32 = 11;
pub const SCB_CFSR_UNSTKERR_Msk: u32 = 2048;
pub const SCB_CFSR_IMPRECISERR_Pos: u32 = 10;
pub const SCB_CFSR_IMPRECISERR_Msk: u32 = 1024;
pub const SCB_CFSR_PRECISERR_Pos: u32 = 9;
pub const SCB_CFSR_PRECISERR_Msk: u32 = 512;
pub const SCB_CFSR_IBUSERR_Pos: u32 = 8;
pub const SCB_CFSR_IBUSERR_Msk: u32 = 256;
pub const SCB_CFSR_DIVBYZERO_Pos: u32 = 25;
pub const SCB_CFSR_DIVBYZERO_Msk: u32 = 33554432;
pub const SCB_CFSR_UNALIGNED_Pos: u32 = 24;
pub const SCB_CFSR_UNALIGNED_Msk: u32 = 16777216;
pub const SCB_CFSR_NOCP_Pos: u32 = 19;
pub const SCB_CFSR_NOCP_Msk: u32 = 524288;
pub const SCB_CFSR_INVPC_Pos: u32 = 18;
pub const SCB_CFSR_INVPC_Msk: u32 = 262144;
pub const SCB_CFSR_INVSTATE_Pos: u32 = 17;
pub const SCB_CFSR_INVSTATE_Msk: u32 = 131072;
pub const SCB_CFSR_UNDEFINSTR_Pos: u32 = 16;
pub const SCB_CFSR_UNDEFINSTR_Msk: u32 = 65536;
pub const SCB_HFSR_DEBUGEVT_Pos: u32 = 31;
pub const SCB_HFSR_DEBUGEVT_Msk: u32 = 2147483648;
pub const SCB_HFSR_FORCED_Pos: u32 = 30;
pub const SCB_HFSR_FORCED_Msk: u32 = 1073741824;
pub const SCB_HFSR_VECTTBL_Pos: u32 = 1;
pub const SCB_HFSR_VECTTBL_Msk: u32 = 2;
pub const SCB_DFSR_EXTERNAL_Pos: u32 = 4;
pub const SCB_DFSR_EXTERNAL_Msk: u32 = 16;
pub const SCB_DFSR_VCATCH_Pos: u32 = 3;
pub const SCB_DFSR_VCATCH_Msk: u32 = 8;
pub const SCB_DFSR_DWTTRAP_Pos: u32 = 2;
pub const SCB_DFSR_DWTTRAP_Msk: u32 = 4;
pub const SCB_DFSR_BKPT_Pos: u32 = 1;
pub const SCB_DFSR_BKPT_Msk: u32 = 2;
pub const SCB_DFSR_HALTED_Pos: u32 = 0;
pub const SCB_DFSR_HALTED_Msk: u32 = 1;
pub const SCnSCB_ICTR_INTLINESNUM_Pos: u32 = 0;
pub const SCnSCB_ICTR_INTLINESNUM_Msk: u32 = 15;
pub const SCnSCB_ACTLR_DISOOFP_Pos: u32 = 9;
pub const SCnSCB_ACTLR_DISOOFP_Msk: u32 = 512;
pub const SCnSCB_ACTLR_DISFPCA_Pos: u32 = 8;
pub const SCnSCB_ACTLR_DISFPCA_Msk: u32 = 256;
pub const SCnSCB_ACTLR_DISFOLD_Pos: u32 = 2;
pub const SCnSCB_ACTLR_DISFOLD_Msk: u32 = 4;
pub const SCnSCB_ACTLR_DISDEFWBUF_Pos: u32 = 1;
pub const SCnSCB_ACTLR_DISDEFWBUF_Msk: u32 = 2;
pub const SCnSCB_ACTLR_DISMCYCINT_Pos: u32 = 0;
pub const SCnSCB_ACTLR_DISMCYCINT_Msk: u32 = 1;
pub const SysTick_CTRL_COUNTFLAG_Pos: u32 = 16;
pub const SysTick_CTRL_COUNTFLAG_Msk: u32 = 65536;
pub const SysTick_CTRL_CLKSOURCE_Pos: u32 = 2;
pub const SysTick_CTRL_CLKSOURCE_Msk: u32 = 4;
pub const SysTick_CTRL_TICKINT_Pos: u32 = 1;
pub const SysTick_CTRL_TICKINT_Msk: u32 = 2;
pub const SysTick_CTRL_ENABLE_Pos: u32 = 0;
pub const SysTick_CTRL_ENABLE_Msk: u32 = 1;
pub const SysTick_LOAD_RELOAD_Pos: u32 = 0;
pub const SysTick_LOAD_RELOAD_Msk: u32 = 16777215;
pub const SysTick_VAL_CURRENT_Pos: u32 = 0;
pub const SysTick_VAL_CURRENT_Msk: u32 = 16777215;
pub const SysTick_CALIB_NOREF_Pos: u32 = 31;
pub const SysTick_CALIB_NOREF_Msk: u32 = 2147483648;
pub const SysTick_CALIB_SKEW_Pos: u32 = 30;
pub const SysTick_CALIB_SKEW_Msk: u32 = 1073741824;
pub const SysTick_CALIB_TENMS_Pos: u32 = 0;
pub const SysTick_CALIB_TENMS_Msk: u32 = 16777215;
pub const ITM_TPR_PRIVMASK_Pos: u32 = 0;
pub const ITM_TPR_PRIVMASK_Msk: u32 = 4294967295;
pub const ITM_TCR_BUSY_Pos: u32 = 23;
pub const ITM_TCR_BUSY_Msk: u32 = 8388608;
pub const ITM_TCR_TraceBusID_Pos: u32 = 16;
pub const ITM_TCR_TraceBusID_Msk: u32 = 8323072;
pub const ITM_TCR_GTSFREQ_Pos: u32 = 10;
pub const ITM_TCR_GTSFREQ_Msk: u32 = 3072;
pub const ITM_TCR_TSPrescale_Pos: u32 = 8;
pub const ITM_TCR_TSPrescale_Msk: u32 = 768;
pub const ITM_TCR_SWOENA_Pos: u32 = 4;
pub const ITM_TCR_SWOENA_Msk: u32 = 16;
pub const ITM_TCR_DWTENA_Pos: u32 = 3;
pub const ITM_TCR_DWTENA_Msk: u32 = 8;
pub const ITM_TCR_SYNCENA_Pos: u32 = 2;
pub const ITM_TCR_SYNCENA_Msk: u32 = 4;
pub const ITM_TCR_TSENA_Pos: u32 = 1;
pub const ITM_TCR_TSENA_Msk: u32 = 2;
pub const ITM_TCR_ITMENA_Pos: u32 = 0;
pub const ITM_TCR_ITMENA_Msk: u32 = 1;
pub const ITM_LSR_ByteAcc_Pos: u32 = 2;
pub const ITM_LSR_ByteAcc_Msk: u32 = 4;
pub const ITM_LSR_Access_Pos: u32 = 1;
pub const ITM_LSR_Access_Msk: u32 = 2;
pub const ITM_LSR_Present_Pos: u32 = 0;
pub const ITM_LSR_Present_Msk: u32 = 1;
pub const DWT_CTRL_NUMCOMP_Pos: u32 = 28;
pub const DWT_CTRL_NUMCOMP_Msk: u32 = 4026531840;
pub const DWT_CTRL_NOTRCPKT_Pos: u32 = 27;
pub const DWT_CTRL_NOTRCPKT_Msk: u32 = 134217728;
pub const DWT_CTRL_NOEXTTRIG_Pos: u32 = 26;
pub const DWT_CTRL_NOEXTTRIG_Msk: u32 = 67108864;
pub const DWT_CTRL_NOCYCCNT_Pos: u32 = 25;
pub const DWT_CTRL_NOCYCCNT_Msk: u32 = 33554432;
pub const DWT_CTRL_NOPRFCNT_Pos: u32 = 24;
pub const DWT_CTRL_NOPRFCNT_Msk: u32 = 16777216;
pub const DWT_CTRL_CYCEVTENA_Pos: u32 = 22;
pub const DWT_CTRL_CYCEVTENA_Msk: u32 = 4194304;
pub const DWT_CTRL_FOLDEVTENA_Pos: u32 = 21;
pub const DWT_CTRL_FOLDEVTENA_Msk: u32 = 2097152;
pub const DWT_CTRL_LSUEVTENA_Pos: u32 = 20;
pub const DWT_CTRL_LSUEVTENA_Msk: u32 = 1048576;
pub const DWT_CTRL_SLEEPEVTENA_Pos: u32 = 19;
pub const DWT_CTRL_SLEEPEVTENA_Msk: u32 = 524288;
pub const DWT_CTRL_EXCEVTENA_Pos: u32 = 18;
pub const DWT_CTRL_EXCEVTENA_Msk: u32 = 262144;
pub const DWT_CTRL_CPIEVTENA_Pos: u32 = 17;
pub const DWT_CTRL_CPIEVTENA_Msk: u32 = 131072;
pub const DWT_CTRL_EXCTRCENA_Pos: u32 = 16;
pub const DWT_CTRL_EXCTRCENA_Msk: u32 = 65536;
pub const DWT_CTRL_PCSAMPLENA_Pos: u32 = 12;
pub const DWT_CTRL_PCSAMPLENA_Msk: u32 = 4096;
pub const DWT_CTRL_SYNCTAP_Pos: u32 = 10;
pub const DWT_CTRL_SYNCTAP_Msk: u32 = 3072;
pub const DWT_CTRL_CYCTAP_Pos: u32 = 9;
pub const DWT_CTRL_CYCTAP_Msk: u32 = 512;
pub const DWT_CTRL_POSTINIT_Pos: u32 = 5;
pub const DWT_CTRL_POSTINIT_Msk: u32 = 480;
pub const DWT_CTRL_POSTPRESET_Pos: u32 = 1;
pub const DWT_CTRL_POSTPRESET_Msk: u32 = 30;
pub const DWT_CTRL_CYCCNTENA_Pos: u32 = 0;
pub const DWT_CTRL_CYCCNTENA_Msk: u32 = 1;
pub const DWT_CPICNT_CPICNT_Pos: u32 = 0;
pub const DWT_CPICNT_CPICNT_Msk: u32 = 255;
pub const DWT_EXCCNT_EXCCNT_Pos: u32 = 0;
pub const DWT_EXCCNT_EXCCNT_Msk: u32 = 255;
pub const DWT_SLEEPCNT_SLEEPCNT_Pos: u32 = 0;
pub const DWT_SLEEPCNT_SLEEPCNT_Msk: u32 = 255;
pub const DWT_LSUCNT_LSUCNT_Pos: u32 = 0;
pub const DWT_LSUCNT_LSUCNT_Msk: u32 = 255;
pub const DWT_FOLDCNT_FOLDCNT_Pos: u32 = 0;
pub const DWT_FOLDCNT_FOLDCNT_Msk: u32 = 255;
pub const DWT_MASK_MASK_Pos: u32 = 0;
pub const DWT_MASK_MASK_Msk: u32 = 31;
pub const DWT_FUNCTION_MATCHED_Pos: u32 = 24;
pub const DWT_FUNCTION_MATCHED_Msk: u32 = 16777216;
pub const DWT_FUNCTION_DATAVADDR1_Pos: u32 = 16;
pub const DWT_FUNCTION_DATAVADDR1_Msk: u32 = 983040;
pub const DWT_FUNCTION_DATAVADDR0_Pos: u32 = 12;
pub const DWT_FUNCTION_DATAVADDR0_Msk: u32 = 61440;
pub const DWT_FUNCTION_DATAVSIZE_Pos: u32 = 10;
pub const DWT_FUNCTION_DATAVSIZE_Msk: u32 = 3072;
pub const DWT_FUNCTION_LNK1ENA_Pos: u32 = 9;
pub const DWT_FUNCTION_LNK1ENA_Msk: u32 = 512;
pub const DWT_FUNCTION_DATAVMATCH_Pos: u32 = 8;
pub const DWT_FUNCTION_DATAVMATCH_Msk: u32 = 256;
pub const DWT_FUNCTION_CYCMATCH_Pos: u32 = 7;
pub const DWT_FUNCTION_CYCMATCH_Msk: u32 = 128;
pub const DWT_FUNCTION_EMITRANGE_Pos: u32 = 5;
pub const DWT_FUNCTION_EMITRANGE_Msk: u32 = 32;
pub const DWT_FUNCTION_FUNCTION_Pos: u32 = 0;
pub const DWT_FUNCTION_FUNCTION_Msk: u32 = 15;
pub const TPI_ACPR_PRESCALER_Pos: u32 = 0;
pub const TPI_ACPR_PRESCALER_Msk: u32 = 8191;
pub const TPI_SPPR_TXMODE_Pos: u32 = 0;
pub const TPI_SPPR_TXMODE_Msk: u32 = 3;
pub const TPI_FFSR_FtNonStop_Pos: u32 = 3;
pub const TPI_FFSR_FtNonStop_Msk: u32 = 8;
pub const TPI_FFSR_TCPresent_Pos: u32 = 2;
pub const TPI_FFSR_TCPresent_Msk: u32 = 4;
pub const TPI_FFSR_FtStopped_Pos: u32 = 1;
pub const TPI_FFSR_FtStopped_Msk: u32 = 2;
pub const TPI_FFSR_FlInProg_Pos: u32 = 0;
pub const TPI_FFSR_FlInProg_Msk: u32 = 1;
pub const TPI_FFCR_TrigIn_Pos: u32 = 8;
pub const TPI_FFCR_TrigIn_Msk: u32 = 256;
pub const TPI_FFCR_EnFCont_Pos: u32 = 1;
pub const TPI_FFCR_EnFCont_Msk: u32 = 2;
pub const TPI_TRIGGER_TRIGGER_Pos: u32 = 0;
pub const TPI_TRIGGER_TRIGGER_Msk: u32 = 1;
pub const TPI_FIFO0_ITM_ATVALID_Pos: u32 = 29;
pub const TPI_FIFO0_ITM_ATVALID_Msk: u32 = 536870912;
pub const TPI_FIFO0_ITM_bytecount_Pos: u32 = 27;
pub const TPI_FIFO0_ITM_bytecount_Msk: u32 = 402653184;
pub const TPI_FIFO0_ETM_ATVALID_Pos: u32 = 26;
pub const TPI_FIFO0_ETM_ATVALID_Msk: u32 = 67108864;
pub const TPI_FIFO0_ETM_bytecount_Pos: u32 = 24;
pub const TPI_FIFO0_ETM_bytecount_Msk: u32 = 50331648;
pub const TPI_FIFO0_ETM2_Pos: u32 = 16;
pub const TPI_FIFO0_ETM2_Msk: u32 = 16711680;
pub const TPI_FIFO0_ETM1_Pos: u32 = 8;
pub const TPI_FIFO0_ETM1_Msk: u32 = 65280;
pub const TPI_FIFO0_ETM0_Pos: u32 = 0;
pub const TPI_FIFO0_ETM0_Msk: u32 = 255;
pub const TPI_ITATBCTR2_ATREADY2_Pos: u32 = 0;
pub const TPI_ITATBCTR2_ATREADY2_Msk: u32 = 1;
pub const TPI_ITATBCTR2_ATREADY1_Pos: u32 = 0;
pub const TPI_ITATBCTR2_ATREADY1_Msk: u32 = 1;
pub const TPI_FIFO1_ITM_ATVALID_Pos: u32 = 29;
pub const TPI_FIFO1_ITM_ATVALID_Msk: u32 = 536870912;
pub const TPI_FIFO1_ITM_bytecount_Pos: u32 = 27;
pub const TPI_FIFO1_ITM_bytecount_Msk: u32 = 402653184;
pub const TPI_FIFO1_ETM_ATVALID_Pos: u32 = 26;
pub const TPI_FIFO1_ETM_ATVALID_Msk: u32 = 67108864;
pub const TPI_FIFO1_ETM_bytecount_Pos: u32 = 24;
pub const TPI_FIFO1_ETM_bytecount_Msk: u32 = 50331648;
pub const TPI_FIFO1_ITM2_Pos: u32 = 16;
pub const TPI_FIFO1_ITM2_Msk: u32 = 16711680;
pub const TPI_FIFO1_ITM1_Pos: u32 = 8;
pub const TPI_FIFO1_ITM1_Msk: u32 = 65280;
pub const TPI_FIFO1_ITM0_Pos: u32 = 0;
pub const TPI_FIFO1_ITM0_Msk: u32 = 255;
pub const TPI_ITATBCTR0_ATREADY2_Pos: u32 = 0;
pub const TPI_ITATBCTR0_ATREADY2_Msk: u32 = 1;
pub const TPI_ITATBCTR0_ATREADY1_Pos: u32 = 0;
pub const TPI_ITATBCTR0_ATREADY1_Msk: u32 = 1;
pub const TPI_ITCTRL_Mode_Pos: u32 = 0;
pub const TPI_ITCTRL_Mode_Msk: u32 = 3;
pub const TPI_DEVID_NRZVALID_Pos: u32 = 11;
pub const TPI_DEVID_NRZVALID_Msk: u32 = 2048;
pub const TPI_DEVID_MANCVALID_Pos: u32 = 10;
pub const TPI_DEVID_MANCVALID_Msk: u32 = 1024;
pub const TPI_DEVID_PTINVALID_Pos: u32 = 9;
pub const TPI_DEVID_PTINVALID_Msk: u32 = 512;
pub const TPI_DEVID_MinBufSz_Pos: u32 = 6;
pub const TPI_DEVID_MinBufSz_Msk: u32 = 448;
pub const TPI_DEVID_AsynClkIn_Pos: u32 = 5;
pub const TPI_DEVID_AsynClkIn_Msk: u32 = 32;
pub const TPI_DEVID_NrTraceInput_Pos: u32 = 0;
pub const TPI_DEVID_NrTraceInput_Msk: u32 = 31;
pub const TPI_DEVTYPE_SubType_Pos: u32 = 4;
pub const TPI_DEVTYPE_SubType_Msk: u32 = 15;
pub const TPI_DEVTYPE_MajorType_Pos: u32 = 0;
pub const TPI_DEVTYPE_MajorType_Msk: u32 = 15;
pub const MPU_TYPE_RALIASES: u32 = 4;
pub const MPU_TYPE_IREGION_Pos: u32 = 16;
pub const MPU_TYPE_IREGION_Msk: u32 = 16711680;
pub const MPU_TYPE_DREGION_Pos: u32 = 8;
pub const MPU_TYPE_DREGION_Msk: u32 = 65280;
pub const MPU_TYPE_SEPARATE_Pos: u32 = 0;
pub const MPU_TYPE_SEPARATE_Msk: u32 = 1;
pub const MPU_CTRL_PRIVDEFENA_Pos: u32 = 2;
pub const MPU_CTRL_PRIVDEFENA_Msk: u32 = 4;
pub const MPU_CTRL_HFNMIENA_Pos: u32 = 1;
pub const MPU_CTRL_HFNMIENA_Msk: u32 = 2;
pub const MPU_CTRL_ENABLE_Pos: u32 = 0;
pub const MPU_CTRL_ENABLE_Msk: u32 = 1;
pub const MPU_RNR_REGION_Pos: u32 = 0;
pub const MPU_RNR_REGION_Msk: u32 = 255;
pub const MPU_RBAR_ADDR_Pos: u32 = 5;
pub const MPU_RBAR_ADDR_Msk: u32 = 4294967264;
pub const MPU_RBAR_VALID_Pos: u32 = 4;
pub const MPU_RBAR_VALID_Msk: u32 = 16;
pub const MPU_RBAR_REGION_Pos: u32 = 0;
pub const MPU_RBAR_REGION_Msk: u32 = 15;
pub const MPU_RASR_ATTRS_Pos: u32 = 16;
pub const MPU_RASR_ATTRS_Msk: u32 = 4294901760;
pub const MPU_RASR_XN_Pos: u32 = 28;
pub const MPU_RASR_XN_Msk: u32 = 268435456;
pub const MPU_RASR_AP_Pos: u32 = 24;
pub const MPU_RASR_AP_Msk: u32 = 117440512;
pub const MPU_RASR_TEX_Pos: u32 = 19;
pub const MPU_RASR_TEX_Msk: u32 = 3670016;
pub const MPU_RASR_S_Pos: u32 = 18;
pub const MPU_RASR_S_Msk: u32 = 262144;
pub const MPU_RASR_C_Pos: u32 = 17;
pub const MPU_RASR_C_Msk: u32 = 131072;
pub const MPU_RASR_B_Pos: u32 = 16;
pub const MPU_RASR_B_Msk: u32 = 65536;
pub const MPU_RASR_SRD_Pos: u32 = 8;
pub const MPU_RASR_SRD_Msk: u32 = 65280;
pub const MPU_RASR_SIZE_Pos: u32 = 1;
pub const MPU_RASR_SIZE_Msk: u32 = 62;
pub const MPU_RASR_ENABLE_Pos: u32 = 0;
pub const MPU_RASR_ENABLE_Msk: u32 = 1;
pub const FPU_FPCCR_ASPEN_Pos: u32 = 31;
pub const FPU_FPCCR_ASPEN_Msk: u32 = 2147483648;
pub const FPU_FPCCR_LSPEN_Pos: u32 = 30;
pub const FPU_FPCCR_LSPEN_Msk: u32 = 1073741824;
pub const FPU_FPCCR_MONRDY_Pos: u32 = 8;
pub const FPU_FPCCR_MONRDY_Msk: u32 = 256;
pub const FPU_FPCCR_BFRDY_Pos: u32 = 6;
pub const FPU_FPCCR_BFRDY_Msk: u32 = 64;
pub const FPU_FPCCR_MMRDY_Pos: u32 = 5;
pub const FPU_FPCCR_MMRDY_Msk: u32 = 32;
pub const FPU_FPCCR_HFRDY_Pos: u32 = 4;
pub const FPU_FPCCR_HFRDY_Msk: u32 = 16;
pub const FPU_FPCCR_THREAD_Pos: u32 = 3;
pub const FPU_FPCCR_THREAD_Msk: u32 = 8;
pub const FPU_FPCCR_USER_Pos: u32 = 1;
pub const FPU_FPCCR_USER_Msk: u32 = 2;
pub const FPU_FPCCR_LSPACT_Pos: u32 = 0;
pub const FPU_FPCCR_LSPACT_Msk: u32 = 1;
pub const FPU_FPCAR_ADDRESS_Pos: u32 = 3;
pub const FPU_FPCAR_ADDRESS_Msk: u32 = 4294967288;
pub const FPU_FPDSCR_AHP_Pos: u32 = 26;
pub const FPU_FPDSCR_AHP_Msk: u32 = 67108864;
pub const FPU_FPDSCR_DN_Pos: u32 = 25;
pub const FPU_FPDSCR_DN_Msk: u32 = 33554432;
pub const FPU_FPDSCR_FZ_Pos: u32 = 24;
pub const FPU_FPDSCR_FZ_Msk: u32 = 16777216;
pub const FPU_FPDSCR_RMode_Pos: u32 = 22;
pub const FPU_FPDSCR_RMode_Msk: u32 = 12582912;
pub const FPU_MVFR0_FP_rounding_modes_Pos: u32 = 28;
pub const FPU_MVFR0_FP_rounding_modes_Msk: u32 = 4026531840;
pub const FPU_MVFR0_Short_vectors_Pos: u32 = 24;
pub const FPU_MVFR0_Short_vectors_Msk: u32 = 251658240;
pub const FPU_MVFR0_Square_root_Pos: u32 = 20;
pub const FPU_MVFR0_Square_root_Msk: u32 = 15728640;
pub const FPU_MVFR0_Divide_Pos: u32 = 16;
pub const FPU_MVFR0_Divide_Msk: u32 = 983040;
pub const FPU_MVFR0_FP_excep_trapping_Pos: u32 = 12;
pub const FPU_MVFR0_FP_excep_trapping_Msk: u32 = 61440;
pub const FPU_MVFR0_Double_precision_Pos: u32 = 8;
pub const FPU_MVFR0_Double_precision_Msk: u32 = 3840;
pub const FPU_MVFR0_Single_precision_Pos: u32 = 4;
pub const FPU_MVFR0_Single_precision_Msk: u32 = 240;
pub const FPU_MVFR0_A_SIMD_registers_Pos: u32 = 0;
pub const FPU_MVFR0_A_SIMD_registers_Msk: u32 = 15;
pub const FPU_MVFR1_FP_fused_MAC_Pos: u32 = 28;
pub const FPU_MVFR1_FP_fused_MAC_Msk: u32 = 4026531840;
pub const FPU_MVFR1_FP_HPFP_Pos: u32 = 24;
pub const FPU_MVFR1_FP_HPFP_Msk: u32 = 251658240;
pub const FPU_MVFR1_D_NaN_mode_Pos: u32 = 4;
pub const FPU_MVFR1_D_NaN_mode_Msk: u32 = 240;
pub const FPU_MVFR1_FtZ_mode_Pos: u32 = 0;
pub const FPU_MVFR1_FtZ_mode_Msk: u32 = 15;
pub const FPU_MVFR2_VFP_Misc_Pos: u32 = 4;
pub const FPU_MVFR2_VFP_Misc_Msk: u32 = 240;
pub const CoreDebug_DHCSR_DBGKEY_Pos: u32 = 16;
pub const CoreDebug_DHCSR_DBGKEY_Msk: u32 = 4294901760;
pub const CoreDebug_DHCSR_S_RESET_ST_Pos: u32 = 25;
pub const CoreDebug_DHCSR_S_RESET_ST_Msk: u32 = 33554432;
pub const CoreDebug_DHCSR_S_RETIRE_ST_Pos: u32 = 24;
pub const CoreDebug_DHCSR_S_RETIRE_ST_Msk: u32 = 16777216;
pub const CoreDebug_DHCSR_S_LOCKUP_Pos: u32 = 19;
pub const CoreDebug_DHCSR_S_LOCKUP_Msk: u32 = 524288;
pub const CoreDebug_DHCSR_S_SLEEP_Pos: u32 = 18;
pub const CoreDebug_DHCSR_S_SLEEP_Msk: u32 = 262144;
pub const CoreDebug_DHCSR_S_HALT_Pos: u32 = 17;
pub const CoreDebug_DHCSR_S_HALT_Msk: u32 = 131072;
pub const CoreDebug_DHCSR_S_REGRDY_Pos: u32 = 16;
pub const CoreDebug_DHCSR_S_REGRDY_Msk: u32 = 65536;
pub const CoreDebug_DHCSR_C_SNAPSTALL_Pos: u32 = 5;
pub const CoreDebug_DHCSR_C_SNAPSTALL_Msk: u32 = 32;
pub const CoreDebug_DHCSR_C_MASKINTS_Pos: u32 = 3;
pub const CoreDebug_DHCSR_C_MASKINTS_Msk: u32 = 8;
pub const CoreDebug_DHCSR_C_STEP_Pos: u32 = 2;
pub const CoreDebug_DHCSR_C_STEP_Msk: u32 = 4;
pub const CoreDebug_DHCSR_C_HALT_Pos: u32 = 1;
pub const CoreDebug_DHCSR_C_HALT_Msk: u32 = 2;
pub const CoreDebug_DHCSR_C_DEBUGEN_Pos: u32 = 0;
pub const CoreDebug_DHCSR_C_DEBUGEN_Msk: u32 = 1;
pub const CoreDebug_DCRSR_REGWnR_Pos: u32 = 16;
pub const CoreDebug_DCRSR_REGWnR_Msk: u32 = 65536;
pub const CoreDebug_DCRSR_REGSEL_Pos: u32 = 0;
pub const CoreDebug_DCRSR_REGSEL_Msk: u32 = 31;
pub const CoreDebug_DEMCR_TRCENA_Pos: u32 = 24;
pub const CoreDebug_DEMCR_TRCENA_Msk: u32 = 16777216;
pub const CoreDebug_DEMCR_MON_REQ_Pos: u32 = 19;
pub const CoreDebug_DEMCR_MON_REQ_Msk: u32 = 524288;
pub const CoreDebug_DEMCR_MON_STEP_Pos: u32 = 18;
pub const CoreDebug_DEMCR_MON_STEP_Msk: u32 = 262144;
pub const CoreDebug_DEMCR_MON_PEND_Pos: u32 = 17;
pub const CoreDebug_DEMCR_MON_PEND_Msk: u32 = 131072;
pub const CoreDebug_DEMCR_MON_EN_Pos: u32 = 16;
pub const CoreDebug_DEMCR_MON_EN_Msk: u32 = 65536;
pub const CoreDebug_DEMCR_VC_HARDERR_Pos: u32 = 10;
pub const CoreDebug_DEMCR_VC_HARDERR_Msk: u32 = 1024;
pub const CoreDebug_DEMCR_VC_INTERR_Pos: u32 = 9;
pub const CoreDebug_DEMCR_VC_INTERR_Msk: u32 = 512;
pub const CoreDebug_DEMCR_VC_BUSERR_Pos: u32 = 8;
pub const CoreDebug_DEMCR_VC_BUSERR_Msk: u32 = 256;
pub const CoreDebug_DEMCR_VC_STATERR_Pos: u32 = 7;
pub const CoreDebug_DEMCR_VC_STATERR_Msk: u32 = 128;
pub const CoreDebug_DEMCR_VC_CHKERR_Pos: u32 = 6;
pub const CoreDebug_DEMCR_VC_CHKERR_Msk: u32 = 64;
pub const CoreDebug_DEMCR_VC_NOCPERR_Pos: u32 = 5;
pub const CoreDebug_DEMCR_VC_NOCPERR_Msk: u32 = 32;
pub const CoreDebug_DEMCR_VC_MMERR_Pos: u32 = 4;
pub const CoreDebug_DEMCR_VC_MMERR_Msk: u32 = 16;
pub const CoreDebug_DEMCR_VC_CORERESET_Pos: u32 = 0;
pub const CoreDebug_DEMCR_VC_CORERESET_Msk: u32 = 1;
pub const SCS_BASE: u32 = 3758153728;
pub const ITM_BASE: u32 = 3758096384;
pub const DWT_BASE: u32 = 3758100480;
pub const TPI_BASE: u32 = 3758358528;
pub const CoreDebug_BASE: u32 = 3758157296;
pub const SysTick_BASE: u32 = 3758153744;
pub const NVIC_BASE: u32 = 3758153984;
pub const SCB_BASE: u32 = 3758157056;
pub const MPU_BASE: u32 = 3758157200;
pub const FPU_BASE: u32 = 3758157616;
pub const NVIC_USER_IRQ_OFFSET: u32 = 16;
pub const EXC_RETURN_HANDLER: u32 = 4294967281;
pub const EXC_RETURN_THREAD_MSP: u32 = 4294967289;
pub const EXC_RETURN_THREAD_PSP: u32 = 4294967293;
pub const EXC_RETURN_HANDLER_FPU: u32 = 4294967265;
pub const EXC_RETURN_THREAD_MSP_FPU: u32 = 4294967273;
pub const EXC_RETURN_THREAD_PSP_FPU: u32 = 4294967277;
pub const ARM_MPU_AP_NONE: u32 = 0;
pub const ARM_MPU_AP_PRIV: u32 = 1;
pub const ARM_MPU_AP_URO: u32 = 2;
pub const ARM_MPU_AP_FULL: u32 = 3;
pub const ARM_MPU_AP_PRO: u32 = 5;
pub const ARM_MPU_AP_RO: u32 = 6;
pub const ARM_MPU_CACHEP_NOCACHE: u32 = 0;
pub const ARM_MPU_CACHEP_WB_WRA: u32 = 1;
pub const ARM_MPU_CACHEP_WT_NWA: u32 = 2;
pub const ARM_MPU_CACHEP_WB_NWA: u32 = 3;
pub const FLASH_BASE: u32 = 134217728;
pub const FLASH_END: u32 = 135266303;
pub const FLASH_BANK1_END: u32 = 134742015;
pub const FLASH_BANK2_END: u32 = 135266303;
pub const SRAM1_BASE: u32 = 536870912;
pub const SRAM2_BASE: u32 = 268435456;
pub const PERIPH_BASE: u32 = 1073741824;
pub const FMC_BASE: u32 = 1610612736;
pub const QSPI_BASE: u32 = 2415919104;
pub const FMC_R_BASE: u32 = 2684354560;
pub const QSPI_R_BASE: u32 = 2684358656;
pub const SRAM1_BB_BASE: u32 = 570425344;
pub const PERIPH_BB_BASE: u32 = 1107296256;
pub const SRAM_BASE: u32 = 536870912;
pub const SRAM_BB_BASE: u32 = 570425344;
pub const SRAM1_SIZE_MAX: u32 = 98304;
pub const SRAM2_SIZE: u32 = 32768;
pub const APB1PERIPH_BASE: u32 = 1073741824;
pub const APB2PERIPH_BASE: u32 = 1073807360;
pub const AHB1PERIPH_BASE: u32 = 1073872896;
pub const AHB2PERIPH_BASE: u32 = 1207959552;
pub const FMC_BANK1: u32 = 1610612736;
pub const FMC_BANK1_1: u32 = 1610612736;
pub const FMC_BANK1_2: u32 = 1677721600;
pub const FMC_BANK1_3: u32 = 1744830464;
pub const FMC_BANK1_4: u32 = 1811939328;
pub const FMC_BANK3: u32 = 2147483648;
pub const TIM2_BASE: u32 = 1073741824;
pub const TIM3_BASE: u32 = 1073742848;
pub const TIM4_BASE: u32 = 1073743872;
pub const TIM5_BASE: u32 = 1073744896;
pub const TIM6_BASE: u32 = 1073745920;
pub const TIM7_BASE: u32 = 1073746944;
pub const RTC_BASE: u32 = 1073752064;
pub const WWDG_BASE: u32 = 1073753088;
pub const IWDG_BASE: u32 = 1073754112;
pub const SPI2_BASE: u32 = 1073756160;
pub const SPI3_BASE: u32 = 1073757184;
pub const USART2_BASE: u32 = 1073759232;
pub const USART3_BASE: u32 = 1073760256;
pub const UART4_BASE: u32 = 1073761280;
pub const UART5_BASE: u32 = 1073762304;
pub const I2C1_BASE: u32 = 1073763328;
pub const I2C2_BASE: u32 = 1073764352;
pub const I2C3_BASE: u32 = 1073765376;
pub const CAN1_BASE: u32 = 1073767424;
pub const PWR_BASE: u32 = 1073770496;
pub const DAC_BASE: u32 = 1073771520;
pub const DAC1_BASE: u32 = 1073771520;
pub const OPAMP_BASE: u32 = 1073772544;
pub const OPAMP1_BASE: u32 = 1073772544;
pub const OPAMP2_BASE: u32 = 1073772560;
pub const LPTIM1_BASE: u32 = 1073773568;
pub const LPUART1_BASE: u32 = 1073774592;
pub const SWPMI1_BASE: u32 = 1073776640;
pub const LPTIM2_BASE: u32 = 1073779712;
pub const SYSCFG_BASE: u32 = 1073807360;
pub const VREFBUF_BASE: u32 = 1073807408;
pub const COMP1_BASE: u32 = 1073807872;
pub const COMP2_BASE: u32 = 1073807876;
pub const EXTI_BASE: u32 = 1073808384;
pub const FIREWALL_BASE: u32 = 1073814528;
pub const SDMMC1_BASE: u32 = 1073817600;
pub const TIM1_BASE: u32 = 1073818624;
pub const SPI1_BASE: u32 = 1073819648;
pub const TIM8_BASE: u32 = 1073820672;
pub const USART1_BASE: u32 = 1073821696;
pub const TIM15_BASE: u32 = 1073823744;
pub const TIM16_BASE: u32 = 1073824768;
pub const TIM17_BASE: u32 = 1073825792;
pub const SAI1_BASE: u32 = 1073828864;
pub const SAI1_Block_A_BASE: u32 = 1073828868;
pub const SAI1_Block_B_BASE: u32 = 1073828900;
pub const SAI2_BASE: u32 = 1073829888;
pub const SAI2_Block_A_BASE: u32 = 1073829892;
pub const SAI2_Block_B_BASE: u32 = 1073829924;
pub const DFSDM1_BASE: u32 = 1073831936;
pub const DFSDM1_Channel0_BASE: u32 = 1073831936;
pub const DFSDM1_Channel1_BASE: u32 = 1073831968;
pub const DFSDM1_Channel2_BASE: u32 = 1073832000;
pub const DFSDM1_Channel3_BASE: u32 = 1073832032;
pub const DFSDM1_Channel4_BASE: u32 = 1073832064;
pub const DFSDM1_Channel5_BASE: u32 = 1073832096;
pub const DFSDM1_Channel6_BASE: u32 = 1073832128;
pub const DFSDM1_Channel7_BASE: u32 = 1073832160;
pub const DFSDM1_Filter0_BASE: u32 = 1073832192;
pub const DFSDM1_Filter1_BASE: u32 = 1073832320;
pub const DFSDM1_Filter2_BASE: u32 = 1073832448;
pub const DFSDM1_Filter3_BASE: u32 = 1073832576;
pub const DMA1_BASE: u32 = 1073872896;
pub const DMA2_BASE: u32 = 1073873920;
pub const RCC_BASE: u32 = 1073876992;
pub const FLASH_R_BASE: u32 = 1073881088;
pub const CRC_BASE: u32 = 1073885184;
pub const TSC_BASE: u32 = 1073889280;
pub const DMA1_Channel1_BASE: u32 = 1073872904;
pub const DMA1_Channel2_BASE: u32 = 1073872924;
pub const DMA1_Channel3_BASE: u32 = 1073872944;
pub const DMA1_Channel4_BASE: u32 = 1073872964;
pub const DMA1_Channel5_BASE: u32 = 1073872984;
pub const DMA1_Channel6_BASE: u32 = 1073873004;
pub const DMA1_Channel7_BASE: u32 = 1073873024;
pub const DMA1_CSELR_BASE: u32 = 1073873064;
pub const DMA2_Channel1_BASE: u32 = 1073873928;
pub const DMA2_Channel2_BASE: u32 = 1073873948;
pub const DMA2_Channel3_BASE: u32 = 1073873968;
pub const DMA2_Channel4_BASE: u32 = 1073873988;
pub const DMA2_Channel5_BASE: u32 = 1073874008;
pub const DMA2_Channel6_BASE: u32 = 1073874028;
pub const DMA2_Channel7_BASE: u32 = 1073874048;
pub const DMA2_CSELR_BASE: u32 = 1073874088;
pub const GPIOA_BASE: u32 = 1207959552;
pub const GPIOB_BASE: u32 = 1207960576;
pub const GPIOC_BASE: u32 = 1207961600;
pub const GPIOD_BASE: u32 = 1207962624;
pub const GPIOE_BASE: u32 = 1207963648;
pub const GPIOF_BASE: u32 = 1207964672;
pub const GPIOG_BASE: u32 = 1207965696;
pub const GPIOH_BASE: u32 = 1207966720;
pub const USBOTG_BASE: u32 = 1342177280;
pub const ADC1_BASE: u32 = 1342439424;
pub const ADC2_BASE: u32 = 1342439680;
pub const ADC3_BASE: u32 = 1342439936;
pub const ADC123_COMMON_BASE: u32 = 1342440192;
pub const RNG_BASE: u32 = 1342572544;
pub const FMC_Bank1_R_BASE: u32 = 2684354560;
pub const FMC_Bank1E_R_BASE: u32 = 2684354820;
pub const FMC_Bank3_R_BASE: u32 = 2684354688;
pub const DBGMCU_BASE: u32 = 3758366720;
pub const USB_OTG_FS_PERIPH_BASE: u32 = 1342177280;
pub const USB_OTG_GLOBAL_BASE: u32 = 0;
pub const USB_OTG_DEVICE_BASE: u32 = 2048;
pub const USB_OTG_IN_ENDPOINT_BASE: u32 = 2304;
pub const USB_OTG_OUT_ENDPOINT_BASE: u32 = 2816;
pub const USB_OTG_EP_REG_SIZE: u32 = 32;
pub const USB_OTG_HOST_BASE: u32 = 1024;
pub const USB_OTG_HOST_PORT_BASE: u32 = 1088;
pub const USB_OTG_HOST_CHANNEL_BASE: u32 = 1280;
pub const USB_OTG_HOST_CHANNEL_SIZE: u32 = 32;
pub const USB_OTG_PCGCCTL_BASE: u32 = 3584;
pub const USB_OTG_FIFO_BASE: u32 = 4096;
pub const USB_OTG_FIFO_SIZE: u32 = 4096;
pub const PACKAGE_BASE: u32 = 536835328;
pub const UID_BASE: u32 = 536835472;
pub const FLASHSIZE_BASE: u32 = 536835552;
pub const ADC_ISR_ADRDY_Pos: u32 = 0;
pub const ADC_ISR_ADRDY_Msk: u32 = 1;
pub const ADC_ISR_ADRDY: u32 = 1;
pub const ADC_ISR_EOSMP_Pos: u32 = 1;
pub const ADC_ISR_EOSMP_Msk: u32 = 2;
pub const ADC_ISR_EOSMP: u32 = 2;
pub const ADC_ISR_EOC_Pos: u32 = 2;
pub const ADC_ISR_EOC_Msk: u32 = 4;
pub const ADC_ISR_EOC: u32 = 4;
pub const ADC_ISR_EOS_Pos: u32 = 3;
pub const ADC_ISR_EOS_Msk: u32 = 8;
pub const ADC_ISR_EOS: u32 = 8;
pub const ADC_ISR_OVR_Pos: u32 = 4;
pub const ADC_ISR_OVR_Msk: u32 = 16;
pub const ADC_ISR_OVR: u32 = 16;
pub const ADC_ISR_JEOC_Pos: u32 = 5;
pub const ADC_ISR_JEOC_Msk: u32 = 32;
pub const ADC_ISR_JEOC: u32 = 32;
pub const ADC_ISR_JEOS_Pos: u32 = 6;
pub const ADC_ISR_JEOS_Msk: u32 = 64;
pub const ADC_ISR_JEOS: u32 = 64;
pub const ADC_ISR_AWD1_Pos: u32 = 7;
pub const ADC_ISR_AWD1_Msk: u32 = 128;
pub const ADC_ISR_AWD1: u32 = 128;
pub const ADC_ISR_AWD2_Pos: u32 = 8;
pub const ADC_ISR_AWD2_Msk: u32 = 256;
pub const ADC_ISR_AWD2: u32 = 256;
pub const ADC_ISR_AWD3_Pos: u32 = 9;
pub const ADC_ISR_AWD3_Msk: u32 = 512;
pub const ADC_ISR_AWD3: u32 = 512;
pub const ADC_ISR_JQOVF_Pos: u32 = 10;
pub const ADC_ISR_JQOVF_Msk: u32 = 1024;
pub const ADC_ISR_JQOVF: u32 = 1024;
pub const ADC_IER_ADRDYIE_Pos: u32 = 0;
pub const ADC_IER_ADRDYIE_Msk: u32 = 1;
pub const ADC_IER_ADRDYIE: u32 = 1;
pub const ADC_IER_EOSMPIE_Pos: u32 = 1;
pub const ADC_IER_EOSMPIE_Msk: u32 = 2;
pub const ADC_IER_EOSMPIE: u32 = 2;
pub const ADC_IER_EOCIE_Pos: u32 = 2;
pub const ADC_IER_EOCIE_Msk: u32 = 4;
pub const ADC_IER_EOCIE: u32 = 4;
pub const ADC_IER_EOSIE_Pos: u32 = 3;
pub const ADC_IER_EOSIE_Msk: u32 = 8;
pub const ADC_IER_EOSIE: u32 = 8;
pub const ADC_IER_OVRIE_Pos: u32 = 4;
pub const ADC_IER_OVRIE_Msk: u32 = 16;
pub const ADC_IER_OVRIE: u32 = 16;
pub const ADC_IER_JEOCIE_Pos: u32 = 5;
pub const ADC_IER_JEOCIE_Msk: u32 = 32;
pub const ADC_IER_JEOCIE: u32 = 32;
pub const ADC_IER_JEOSIE_Pos: u32 = 6;
pub const ADC_IER_JEOSIE_Msk: u32 = 64;
pub const ADC_IER_JEOSIE: u32 = 64;
pub const ADC_IER_AWD1IE_Pos: u32 = 7;
pub const ADC_IER_AWD1IE_Msk: u32 = 128;
pub const ADC_IER_AWD1IE: u32 = 128;
pub const ADC_IER_AWD2IE_Pos: u32 = 8;
pub const ADC_IER_AWD2IE_Msk: u32 = 256;
pub const ADC_IER_AWD2IE: u32 = 256;
pub const ADC_IER_AWD3IE_Pos: u32 = 9;
pub const ADC_IER_AWD3IE_Msk: u32 = 512;
pub const ADC_IER_AWD3IE: u32 = 512;
pub const ADC_IER_JQOVFIE_Pos: u32 = 10;
pub const ADC_IER_JQOVFIE_Msk: u32 = 1024;
pub const ADC_IER_JQOVFIE: u32 = 1024;
pub const ADC_IER_ADRDY: u32 = 1;
pub const ADC_IER_EOSMP: u32 = 2;
pub const ADC_IER_EOC: u32 = 4;
pub const ADC_IER_EOS: u32 = 8;
pub const ADC_IER_OVR: u32 = 16;
pub const ADC_IER_JEOC: u32 = 32;
pub const ADC_IER_JEOS: u32 = 64;
pub const ADC_IER_AWD1: u32 = 128;
pub const ADC_IER_AWD2: u32 = 256;
pub const ADC_IER_AWD3: u32 = 512;
pub const ADC_IER_JQOVF: u32 = 1024;
pub const ADC_CR_ADEN_Pos: u32 = 0;
pub const ADC_CR_ADEN_Msk: u32 = 1;
pub const ADC_CR_ADEN: u32 = 1;
pub const ADC_CR_ADDIS_Pos: u32 = 1;
pub const ADC_CR_ADDIS_Msk: u32 = 2;
pub const ADC_CR_ADDIS: u32 = 2;
pub const ADC_CR_ADSTART_Pos: u32 = 2;
pub const ADC_CR_ADSTART_Msk: u32 = 4;
pub const ADC_CR_ADSTART: u32 = 4;
pub const ADC_CR_JADSTART_Pos: u32 = 3;
pub const ADC_CR_JADSTART_Msk: u32 = 8;
pub const ADC_CR_JADSTART: u32 = 8;
pub const ADC_CR_ADSTP_Pos: u32 = 4;
pub const ADC_CR_ADSTP_Msk: u32 = 16;
pub const ADC_CR_ADSTP: u32 = 16;
pub const ADC_CR_JADSTP_Pos: u32 = 5;
pub const ADC_CR_JADSTP_Msk: u32 = 32;
pub const ADC_CR_JADSTP: u32 = 32;
pub const ADC_CR_ADVREGEN_Pos: u32 = 28;
pub const ADC_CR_ADVREGEN_Msk: u32 = 268435456;
pub const ADC_CR_ADVREGEN: u32 = 268435456;
pub const ADC_CR_DEEPPWD_Pos: u32 = 29;
pub const ADC_CR_DEEPPWD_Msk: u32 = 536870912;
pub const ADC_CR_DEEPPWD: u32 = 536870912;
pub const ADC_CR_ADCALDIF_Pos: u32 = 30;
pub const ADC_CR_ADCALDIF_Msk: u32 = 1073741824;
pub const ADC_CR_ADCALDIF: u32 = 1073741824;
pub const ADC_CR_ADCAL_Pos: u32 = 31;
pub const ADC_CR_ADCAL_Msk: u32 = 2147483648;
pub const ADC_CR_ADCAL: u32 = 2147483648;
pub const ADC_CFGR_DMAEN_Pos: u32 = 0;
pub const ADC_CFGR_DMAEN_Msk: u32 = 1;
pub const ADC_CFGR_DMAEN: u32 = 1;
pub const ADC_CFGR_DMACFG_Pos: u32 = 1;
pub const ADC_CFGR_DMACFG_Msk: u32 = 2;
pub const ADC_CFGR_DMACFG: u32 = 2;
pub const ADC_CFGR_RES_Pos: u32 = 3;
pub const ADC_CFGR_RES_Msk: u32 = 24;
pub const ADC_CFGR_RES: u32 = 24;
pub const ADC_CFGR_RES_0: u32 = 8;
pub const ADC_CFGR_RES_1: u32 = 16;
pub const ADC_CFGR_ALIGN_Pos: u32 = 5;
pub const ADC_CFGR_ALIGN_Msk: u32 = 32;
pub const ADC_CFGR_ALIGN: u32 = 32;
pub const ADC_CFGR_EXTSEL_Pos: u32 = 6;
pub const ADC_CFGR_EXTSEL_Msk: u32 = 960;
pub const ADC_CFGR_EXTSEL: u32 = 960;
pub const ADC_CFGR_EXTSEL_0: u32 = 64;
pub const ADC_CFGR_EXTSEL_1: u32 = 128;
pub const ADC_CFGR_EXTSEL_2: u32 = 256;
pub const ADC_CFGR_EXTSEL_3: u32 = 512;
pub const ADC_CFGR_EXTEN_Pos: u32 = 10;
pub const ADC_CFGR_EXTEN_Msk: u32 = 3072;
pub const ADC_CFGR_EXTEN: u32 = 3072;
pub const ADC_CFGR_EXTEN_0: u32 = 1024;
pub const ADC_CFGR_EXTEN_1: u32 = 2048;
pub const ADC_CFGR_OVRMOD_Pos: u32 = 12;
pub const ADC_CFGR_OVRMOD_Msk: u32 = 4096;
pub const ADC_CFGR_OVRMOD: u32 = 4096;
pub const ADC_CFGR_CONT_Pos: u32 = 13;
pub const ADC_CFGR_CONT_Msk: u32 = 8192;
pub const ADC_CFGR_CONT: u32 = 8192;
pub const ADC_CFGR_AUTDLY_Pos: u32 = 14;
pub const ADC_CFGR_AUTDLY_Msk: u32 = 16384;
pub const ADC_CFGR_AUTDLY: u32 = 16384;
pub const ADC_CFGR_DISCEN_Pos: u32 = 16;
pub const ADC_CFGR_DISCEN_Msk: u32 = 65536;
pub const ADC_CFGR_DISCEN: u32 = 65536;
pub const ADC_CFGR_DISCNUM_Pos: u32 = 17;
pub const ADC_CFGR_DISCNUM_Msk: u32 = 917504;
pub const ADC_CFGR_DISCNUM: u32 = 917504;
pub const ADC_CFGR_DISCNUM_0: u32 = 131072;
pub const ADC_CFGR_DISCNUM_1: u32 = 262144;
pub const ADC_CFGR_DISCNUM_2: u32 = 524288;
pub const ADC_CFGR_JDISCEN_Pos: u32 = 20;
pub const ADC_CFGR_JDISCEN_Msk: u32 = 1048576;
pub const ADC_CFGR_JDISCEN: u32 = 1048576;
pub const ADC_CFGR_JQM_Pos: u32 = 21;
pub const ADC_CFGR_JQM_Msk: u32 = 2097152;
pub const ADC_CFGR_JQM: u32 = 2097152;
pub const ADC_CFGR_AWD1SGL_Pos: u32 = 22;
pub const ADC_CFGR_AWD1SGL_Msk: u32 = 4194304;
pub const ADC_CFGR_AWD1SGL: u32 = 4194304;
pub const ADC_CFGR_AWD1EN_Pos: u32 = 23;
pub const ADC_CFGR_AWD1EN_Msk: u32 = 8388608;
pub const ADC_CFGR_AWD1EN: u32 = 8388608;
pub const ADC_CFGR_JAWD1EN_Pos: u32 = 24;
pub const ADC_CFGR_JAWD1EN_Msk: u32 = 16777216;
pub const ADC_CFGR_JAWD1EN: u32 = 16777216;
pub const ADC_CFGR_JAUTO_Pos: u32 = 25;
pub const ADC_CFGR_JAUTO_Msk: u32 = 33554432;
pub const ADC_CFGR_JAUTO: u32 = 33554432;
pub const ADC_CFGR_AWD1CH_Pos: u32 = 26;
pub const ADC_CFGR_AWD1CH_Msk: u32 = 2080374784;
pub const ADC_CFGR_AWD1CH: u32 = 2080374784;
pub const ADC_CFGR_AWD1CH_0: u32 = 67108864;
pub const ADC_CFGR_AWD1CH_1: u32 = 134217728;
pub const ADC_CFGR_AWD1CH_2: u32 = 268435456;
pub const ADC_CFGR_AWD1CH_3: u32 = 536870912;
pub const ADC_CFGR_AWD1CH_4: u32 = 1073741824;
pub const ADC_CFGR_JQDIS_Pos: u32 = 31;
pub const ADC_CFGR_JQDIS_Msk: u32 = 2147483648;
pub const ADC_CFGR_JQDIS: u32 = 2147483648;
pub const ADC_CFGR2_ROVSE_Pos: u32 = 0;
pub const ADC_CFGR2_ROVSE_Msk: u32 = 1;
pub const ADC_CFGR2_ROVSE: u32 = 1;
pub const ADC_CFGR2_JOVSE_Pos: u32 = 1;
pub const ADC_CFGR2_JOVSE_Msk: u32 = 2;
pub const ADC_CFGR2_JOVSE: u32 = 2;
pub const ADC_CFGR2_OVSR_Pos: u32 = 2;
pub const ADC_CFGR2_OVSR_Msk: u32 = 28;
pub const ADC_CFGR2_OVSR: u32 = 28;
pub const ADC_CFGR2_OVSR_0: u32 = 4;
pub const ADC_CFGR2_OVSR_1: u32 = 8;
pub const ADC_CFGR2_OVSR_2: u32 = 16;
pub const ADC_CFGR2_OVSS_Pos: u32 = 5;
pub const ADC_CFGR2_OVSS_Msk: u32 = 480;
pub const ADC_CFGR2_OVSS: u32 = 480;
pub const ADC_CFGR2_OVSS_0: u32 = 32;
pub const ADC_CFGR2_OVSS_1: u32 = 64;
pub const ADC_CFGR2_OVSS_2: u32 = 128;
pub const ADC_CFGR2_OVSS_3: u32 = 256;
pub const ADC_CFGR2_TROVS_Pos: u32 = 9;
pub const ADC_CFGR2_TROVS_Msk: u32 = 512;
pub const ADC_CFGR2_TROVS: u32 = 512;
pub const ADC_CFGR2_ROVSM_Pos: u32 = 10;
pub const ADC_CFGR2_ROVSM_Msk: u32 = 1024;
pub const ADC_CFGR2_ROVSM: u32 = 1024;
pub const ADC_SMPR1_SMP0_Pos: u32 = 0;
pub const ADC_SMPR1_SMP0_Msk: u32 = 7;
pub const ADC_SMPR1_SMP0: u32 = 7;
pub const ADC_SMPR1_SMP0_0: u32 = 1;
pub const ADC_SMPR1_SMP0_1: u32 = 2;
pub const ADC_SMPR1_SMP0_2: u32 = 4;
pub const ADC_SMPR1_SMP1_Pos: u32 = 3;
pub const ADC_SMPR1_SMP1_Msk: u32 = 56;
pub const ADC_SMPR1_SMP1: u32 = 56;
pub const ADC_SMPR1_SMP1_0: u32 = 8;
pub const ADC_SMPR1_SMP1_1: u32 = 16;
pub const ADC_SMPR1_SMP1_2: u32 = 32;
pub const ADC_SMPR1_SMP2_Pos: u32 = 6;
pub const ADC_SMPR1_SMP2_Msk: u32 = 448;
pub const ADC_SMPR1_SMP2: u32 = 448;
pub const ADC_SMPR1_SMP2_0: u32 = 64;
pub const ADC_SMPR1_SMP2_1: u32 = 128;
pub const ADC_SMPR1_SMP2_2: u32 = 256;
pub const ADC_SMPR1_SMP3_Pos: u32 = 9;
pub const ADC_SMPR1_SMP3_Msk: u32 = 3584;
pub const ADC_SMPR1_SMP3: u32 = 3584;
pub const ADC_SMPR1_SMP3_0: u32 = 512;
pub const ADC_SMPR1_SMP3_1: u32 = 1024;
pub const ADC_SMPR1_SMP3_2: u32 = 2048;
pub const ADC_SMPR1_SMP4_Pos: u32 = 12;
pub const ADC_SMPR1_SMP4_Msk: u32 = 28672;
pub const ADC_SMPR1_SMP4: u32 = 28672;
pub const ADC_SMPR1_SMP4_0: u32 = 4096;
pub const ADC_SMPR1_SMP4_1: u32 = 8192;
pub const ADC_SMPR1_SMP4_2: u32 = 16384;
pub const ADC_SMPR1_SMP5_Pos: u32 = 15;
pub const ADC_SMPR1_SMP5_Msk: u32 = 229376;
pub const ADC_SMPR1_SMP5: u32 = 229376;
pub const ADC_SMPR1_SMP5_0: u32 = 32768;
pub const ADC_SMPR1_SMP5_1: u32 = 65536;
pub const ADC_SMPR1_SMP5_2: u32 = 131072;
pub const ADC_SMPR1_SMP6_Pos: u32 = 18;
pub const ADC_SMPR1_SMP6_Msk: u32 = 1835008;
pub const ADC_SMPR1_SMP6: u32 = 1835008;
pub const ADC_SMPR1_SMP6_0: u32 = 262144;
pub const ADC_SMPR1_SMP6_1: u32 = 524288;
pub const ADC_SMPR1_SMP6_2: u32 = 1048576;
pub const ADC_SMPR1_SMP7_Pos: u32 = 21;
pub const ADC_SMPR1_SMP7_Msk: u32 = 14680064;
pub const ADC_SMPR1_SMP7: u32 = 14680064;
pub const ADC_SMPR1_SMP7_0: u32 = 2097152;
pub const ADC_SMPR1_SMP7_1: u32 = 4194304;
pub const ADC_SMPR1_SMP7_2: u32 = 8388608;
pub const ADC_SMPR1_SMP8_Pos: u32 = 24;
pub const ADC_SMPR1_SMP8_Msk: u32 = 117440512;
pub const ADC_SMPR1_SMP8: u32 = 117440512;
pub const ADC_SMPR1_SMP8_0: u32 = 16777216;
pub const ADC_SMPR1_SMP8_1: u32 = 33554432;
pub const ADC_SMPR1_SMP8_2: u32 = 67108864;
pub const ADC_SMPR1_SMP9_Pos: u32 = 27;
pub const ADC_SMPR1_SMP9_Msk: u32 = 939524096;
pub const ADC_SMPR1_SMP9: u32 = 939524096;
pub const ADC_SMPR1_SMP9_0: u32 = 134217728;
pub const ADC_SMPR1_SMP9_1: u32 = 268435456;
pub const ADC_SMPR1_SMP9_2: u32 = 536870912;
pub const ADC_SMPR2_SMP10_Pos: u32 = 0;
pub const ADC_SMPR2_SMP10_Msk: u32 = 7;
pub const ADC_SMPR2_SMP10: u32 = 7;
pub const ADC_SMPR2_SMP10_0: u32 = 1;
pub const ADC_SMPR2_SMP10_1: u32 = 2;
pub const ADC_SMPR2_SMP10_2: u32 = 4;
pub const ADC_SMPR2_SMP11_Pos: u32 = 3;
pub const ADC_SMPR2_SMP11_Msk: u32 = 56;
pub const ADC_SMPR2_SMP11: u32 = 56;
pub const ADC_SMPR2_SMP11_0: u32 = 8;
pub const ADC_SMPR2_SMP11_1: u32 = 16;
pub const ADC_SMPR2_SMP11_2: u32 = 32;
pub const ADC_SMPR2_SMP12_Pos: u32 = 6;
pub const ADC_SMPR2_SMP12_Msk: u32 = 448;
pub const ADC_SMPR2_SMP12: u32 = 448;
pub const ADC_SMPR2_SMP12_0: u32 = 64;
pub const ADC_SMPR2_SMP12_1: u32 = 128;
pub const ADC_SMPR2_SMP12_2: u32 = 256;
pub const ADC_SMPR2_SMP13_Pos: u32 = 9;
pub const ADC_SMPR2_SMP13_Msk: u32 = 3584;
pub const ADC_SMPR2_SMP13: u32 = 3584;
pub const ADC_SMPR2_SMP13_0: u32 = 512;
pub const ADC_SMPR2_SMP13_1: u32 = 1024;
pub const ADC_SMPR2_SMP13_2: u32 = 2048;
pub const ADC_SMPR2_SMP14_Pos: u32 = 12;
pub const ADC_SMPR2_SMP14_Msk: u32 = 28672;
pub const ADC_SMPR2_SMP14: u32 = 28672;
pub const ADC_SMPR2_SMP14_0: u32 = 4096;
pub const ADC_SMPR2_SMP14_1: u32 = 8192;
pub const ADC_SMPR2_SMP14_2: u32 = 16384;
pub const ADC_SMPR2_SMP15_Pos: u32 = 15;
pub const ADC_SMPR2_SMP15_Msk: u32 = 229376;
pub const ADC_SMPR2_SMP15: u32 = 229376;
pub const ADC_SMPR2_SMP15_0: u32 = 32768;
pub const ADC_SMPR2_SMP15_1: u32 = 65536;
pub const ADC_SMPR2_SMP15_2: u32 = 131072;
pub const ADC_SMPR2_SMP16_Pos: u32 = 18;
pub const ADC_SMPR2_SMP16_Msk: u32 = 1835008;
pub const ADC_SMPR2_SMP16: u32 = 1835008;
pub const ADC_SMPR2_SMP16_0: u32 = 262144;
pub const ADC_SMPR2_SMP16_1: u32 = 524288;
pub const ADC_SMPR2_SMP16_2: u32 = 1048576;
pub const ADC_SMPR2_SMP17_Pos: u32 = 21;
pub const ADC_SMPR2_SMP17_Msk: u32 = 14680064;
pub const ADC_SMPR2_SMP17: u32 = 14680064;
pub const ADC_SMPR2_SMP17_0: u32 = 2097152;
pub const ADC_SMPR2_SMP17_1: u32 = 4194304;
pub const ADC_SMPR2_SMP17_2: u32 = 8388608;
pub const ADC_SMPR2_SMP18_Pos: u32 = 24;
pub const ADC_SMPR2_SMP18_Msk: u32 = 117440512;
pub const ADC_SMPR2_SMP18: u32 = 117440512;
pub const ADC_SMPR2_SMP18_0: u32 = 16777216;
pub const ADC_SMPR2_SMP18_1: u32 = 33554432;
pub const ADC_SMPR2_SMP18_2: u32 = 67108864;
pub const ADC_TR1_LT1_Pos: u32 = 0;
pub const ADC_TR1_LT1_Msk: u32 = 4095;
pub const ADC_TR1_LT1: u32 = 4095;
pub const ADC_TR1_LT1_0: u32 = 1;
pub const ADC_TR1_LT1_1: u32 = 2;
pub const ADC_TR1_LT1_2: u32 = 4;
pub const ADC_TR1_LT1_3: u32 = 8;
pub const ADC_TR1_LT1_4: u32 = 16;
pub const ADC_TR1_LT1_5: u32 = 32;
pub const ADC_TR1_LT1_6: u32 = 64;
pub const ADC_TR1_LT1_7: u32 = 128;
pub const ADC_TR1_LT1_8: u32 = 256;
pub const ADC_TR1_LT1_9: u32 = 512;
pub const ADC_TR1_LT1_10: u32 = 1024;
pub const ADC_TR1_LT1_11: u32 = 2048;
pub const ADC_TR1_HT1_Pos: u32 = 16;
pub const ADC_TR1_HT1_Msk: u32 = 268369920;
pub const ADC_TR1_HT1: u32 = 268369920;
pub const ADC_TR1_HT1_0: u32 = 65536;
pub const ADC_TR1_HT1_1: u32 = 131072;
pub const ADC_TR1_HT1_2: u32 = 262144;
pub const ADC_TR1_HT1_3: u32 = 524288;
pub const ADC_TR1_HT1_4: u32 = 1048576;
pub const ADC_TR1_HT1_5: u32 = 2097152;
pub const ADC_TR1_HT1_6: u32 = 4194304;
pub const ADC_TR1_HT1_7: u32 = 8388608;
pub const ADC_TR1_HT1_8: u32 = 16777216;
pub const ADC_TR1_HT1_9: u32 = 33554432;
pub const ADC_TR1_HT1_10: u32 = 67108864;
pub const ADC_TR1_HT1_11: u32 = 134217728;
pub const ADC_TR2_LT2_Pos: u32 = 0;
pub const ADC_TR2_LT2_Msk: u32 = 255;
pub const ADC_TR2_LT2: u32 = 255;
pub const ADC_TR2_LT2_0: u32 = 1;
pub const ADC_TR2_LT2_1: u32 = 2;
pub const ADC_TR2_LT2_2: u32 = 4;
pub const ADC_TR2_LT2_3: u32 = 8;
pub const ADC_TR2_LT2_4: u32 = 16;
pub const ADC_TR2_LT2_5: u32 = 32;
pub const ADC_TR2_LT2_6: u32 = 64;
pub const ADC_TR2_LT2_7: u32 = 128;
pub const ADC_TR2_HT2_Pos: u32 = 16;
pub const ADC_TR2_HT2_Msk: u32 = 16711680;
pub const ADC_TR2_HT2: u32 = 16711680;
pub const ADC_TR2_HT2_0: u32 = 65536;
pub const ADC_TR2_HT2_1: u32 = 131072;
pub const ADC_TR2_HT2_2: u32 = 262144;
pub const ADC_TR2_HT2_3: u32 = 524288;
pub const ADC_TR2_HT2_4: u32 = 1048576;
pub const ADC_TR2_HT2_5: u32 = 2097152;
pub const ADC_TR2_HT2_6: u32 = 4194304;
pub const ADC_TR2_HT2_7: u32 = 8388608;
pub const ADC_TR3_LT3_Pos: u32 = 0;
pub const ADC_TR3_LT3_Msk: u32 = 255;
pub const ADC_TR3_LT3: u32 = 255;
pub const ADC_TR3_LT3_0: u32 = 1;
pub const ADC_TR3_LT3_1: u32 = 2;
pub const ADC_TR3_LT3_2: u32 = 4;
pub const ADC_TR3_LT3_3: u32 = 8;
pub const ADC_TR3_LT3_4: u32 = 16;
pub const ADC_TR3_LT3_5: u32 = 32;
pub const ADC_TR3_LT3_6: u32 = 64;
pub const ADC_TR3_LT3_7: u32 = 128;
pub const ADC_TR3_HT3_Pos: u32 = 16;
pub const ADC_TR3_HT3_Msk: u32 = 16711680;
pub const ADC_TR3_HT3: u32 = 16711680;
pub const ADC_TR3_HT3_0: u32 = 65536;
pub const ADC_TR3_HT3_1: u32 = 131072;
pub const ADC_TR3_HT3_2: u32 = 262144;
pub const ADC_TR3_HT3_3: u32 = 524288;
pub const ADC_TR3_HT3_4: u32 = 1048576;
pub const ADC_TR3_HT3_5: u32 = 2097152;
pub const ADC_TR3_HT3_6: u32 = 4194304;
pub const ADC_TR3_HT3_7: u32 = 8388608;
pub const ADC_SQR1_L_Pos: u32 = 0;
pub const ADC_SQR1_L_Msk: u32 = 15;
pub const ADC_SQR1_L: u32 = 15;
pub const ADC_SQR1_L_0: u32 = 1;
pub const ADC_SQR1_L_1: u32 = 2;
pub const ADC_SQR1_L_2: u32 = 4;
pub const ADC_SQR1_L_3: u32 = 8;
pub const ADC_SQR1_SQ1_Pos: u32 = 6;
pub const ADC_SQR1_SQ1_Msk: u32 = 1984;
pub const ADC_SQR1_SQ1: u32 = 1984;
pub const ADC_SQR1_SQ1_0: u32 = 64;
pub const ADC_SQR1_SQ1_1: u32 = 128;
pub const ADC_SQR1_SQ1_2: u32 = 256;
pub const ADC_SQR1_SQ1_3: u32 = 512;
pub const ADC_SQR1_SQ1_4: u32 = 1024;
pub const ADC_SQR1_SQ2_Pos: u32 = 12;
pub const ADC_SQR1_SQ2_Msk: u32 = 126976;
pub const ADC_SQR1_SQ2: u32 = 126976;
pub const ADC_SQR1_SQ2_0: u32 = 4096;
pub const ADC_SQR1_SQ2_1: u32 = 8192;
pub const ADC_SQR1_SQ2_2: u32 = 16384;
pub const ADC_SQR1_SQ2_3: u32 = 32768;
pub const ADC_SQR1_SQ2_4: u32 = 65536;
pub const ADC_SQR1_SQ3_Pos: u32 = 18;
pub const ADC_SQR1_SQ3_Msk: u32 = 8126464;
pub const ADC_SQR1_SQ3: u32 = 8126464;
pub const ADC_SQR1_SQ3_0: u32 = 262144;
pub const ADC_SQR1_SQ3_1: u32 = 524288;
pub const ADC_SQR1_SQ3_2: u32 = 1048576;
pub const ADC_SQR1_SQ3_3: u32 = 2097152;
pub const ADC_SQR1_SQ3_4: u32 = 4194304;
pub const ADC_SQR1_SQ4_Pos: u32 = 24;
pub const ADC_SQR1_SQ4_Msk: u32 = 520093696;
pub const ADC_SQR1_SQ4: u32 = 520093696;
pub const ADC_SQR1_SQ4_0: u32 = 16777216;
pub const ADC_SQR1_SQ4_1: u32 = 33554432;
pub const ADC_SQR1_SQ4_2: u32 = 67108864;
pub const ADC_SQR1_SQ4_3: u32 = 134217728;
pub const ADC_SQR1_SQ4_4: u32 = 268435456;
pub const ADC_SQR2_SQ5_Pos: u32 = 0;
pub const ADC_SQR2_SQ5_Msk: u32 = 31;
pub const ADC_SQR2_SQ5: u32 = 31;
pub const ADC_SQR2_SQ5_0: u32 = 1;
pub const ADC_SQR2_SQ5_1: u32 = 2;
pub const ADC_SQR2_SQ5_2: u32 = 4;
pub const ADC_SQR2_SQ5_3: u32 = 8;
pub const ADC_SQR2_SQ5_4: u32 = 16;
pub const ADC_SQR2_SQ6_Pos: u32 = 6;
pub const ADC_SQR2_SQ6_Msk: u32 = 1984;
pub const ADC_SQR2_SQ6: u32 = 1984;
pub const ADC_SQR2_SQ6_0: u32 = 64;
pub const ADC_SQR2_SQ6_1: u32 = 128;
pub const ADC_SQR2_SQ6_2: u32 = 256;
pub const ADC_SQR2_SQ6_3: u32 = 512;
pub const ADC_SQR2_SQ6_4: u32 = 1024;
pub const ADC_SQR2_SQ7_Pos: u32 = 12;
pub const ADC_SQR2_SQ7_Msk: u32 = 126976;
pub const ADC_SQR2_SQ7: u32 = 126976;
pub const ADC_SQR2_SQ7_0: u32 = 4096;
pub const ADC_SQR2_SQ7_1: u32 = 8192;
pub const ADC_SQR2_SQ7_2: u32 = 16384;
pub const ADC_SQR2_SQ7_3: u32 = 32768;
pub const ADC_SQR2_SQ7_4: u32 = 65536;
pub const ADC_SQR2_SQ8_Pos: u32 = 18;
pub const ADC_SQR2_SQ8_Msk: u32 = 8126464;
pub const ADC_SQR2_SQ8: u32 = 8126464;
pub const ADC_SQR2_SQ8_0: u32 = 262144;
pub const ADC_SQR2_SQ8_1: u32 = 524288;
pub const ADC_SQR2_SQ8_2: u32 = 1048576;
pub const ADC_SQR2_SQ8_3: u32 = 2097152;
pub const ADC_SQR2_SQ8_4: u32 = 4194304;
pub const ADC_SQR2_SQ9_Pos: u32 = 24;
pub const ADC_SQR2_SQ9_Msk: u32 = 520093696;
pub const ADC_SQR2_SQ9: u32 = 520093696;
pub const ADC_SQR2_SQ9_0: u32 = 16777216;
pub const ADC_SQR2_SQ9_1: u32 = 33554432;
pub const ADC_SQR2_SQ9_2: u32 = 67108864;
pub const ADC_SQR2_SQ9_3: u32 = 134217728;
pub const ADC_SQR2_SQ9_4: u32 = 268435456;
pub const ADC_SQR3_SQ10_Pos: u32 = 0;
pub const ADC_SQR3_SQ10_Msk: u32 = 31;
pub const ADC_SQR3_SQ10: u32 = 31;
pub const ADC_SQR3_SQ10_0: u32 = 1;
pub const ADC_SQR3_SQ10_1: u32 = 2;
pub const ADC_SQR3_SQ10_2: u32 = 4;
pub const ADC_SQR3_SQ10_3: u32 = 8;
pub const ADC_SQR3_SQ10_4: u32 = 16;
pub const ADC_SQR3_SQ11_Pos: u32 = 6;
pub const ADC_SQR3_SQ11_Msk: u32 = 1984;
pub const ADC_SQR3_SQ11: u32 = 1984;
pub const ADC_SQR3_SQ11_0: u32 = 64;
pub const ADC_SQR3_SQ11_1: u32 = 128;
pub const ADC_SQR3_SQ11_2: u32 = 256;
pub const ADC_SQR3_SQ11_3: u32 = 512;
pub const ADC_SQR3_SQ11_4: u32 = 1024;
pub const ADC_SQR3_SQ12_Pos: u32 = 12;
pub const ADC_SQR3_SQ12_Msk: u32 = 126976;
pub const ADC_SQR3_SQ12: u32 = 126976;
pub const ADC_SQR3_SQ12_0: u32 = 4096;
pub const ADC_SQR3_SQ12_1: u32 = 8192;
pub const ADC_SQR3_SQ12_2: u32 = 16384;
pub const ADC_SQR3_SQ12_3: u32 = 32768;
pub const ADC_SQR3_SQ12_4: u32 = 65536;
pub const ADC_SQR3_SQ13_Pos: u32 = 18;
pub const ADC_SQR3_SQ13_Msk: u32 = 8126464;
pub const ADC_SQR3_SQ13: u32 = 8126464;
pub const ADC_SQR3_SQ13_0: u32 = 262144;
pub const ADC_SQR3_SQ13_1: u32 = 524288;
pub const ADC_SQR3_SQ13_2: u32 = 1048576;
pub const ADC_SQR3_SQ13_3: u32 = 2097152;
pub const ADC_SQR3_SQ13_4: u32 = 4194304;
pub const ADC_SQR3_SQ14_Pos: u32 = 24;
pub const ADC_SQR3_SQ14_Msk: u32 = 520093696;
pub const ADC_SQR3_SQ14: u32 = 520093696;
pub const ADC_SQR3_SQ14_0: u32 = 16777216;
pub const ADC_SQR3_SQ14_1: u32 = 33554432;
pub const ADC_SQR3_SQ14_2: u32 = 67108864;
pub const ADC_SQR3_SQ14_3: u32 = 134217728;
pub const ADC_SQR3_SQ14_4: u32 = 268435456;
pub const ADC_SQR4_SQ15_Pos: u32 = 0;
pub const ADC_SQR4_SQ15_Msk: u32 = 31;
pub const ADC_SQR4_SQ15: u32 = 31;
pub const ADC_SQR4_SQ15_0: u32 = 1;
pub const ADC_SQR4_SQ15_1: u32 = 2;
pub const ADC_SQR4_SQ15_2: u32 = 4;
pub const ADC_SQR4_SQ15_3: u32 = 8;
pub const ADC_SQR4_SQ15_4: u32 = 16;
pub const ADC_SQR4_SQ16_Pos: u32 = 6;
pub const ADC_SQR4_SQ16_Msk: u32 = 1984;
pub const ADC_SQR4_SQ16: u32 = 1984;
pub const ADC_SQR4_SQ16_0: u32 = 64;
pub const ADC_SQR4_SQ16_1: u32 = 128;
pub const ADC_SQR4_SQ16_2: u32 = 256;
pub const ADC_SQR4_SQ16_3: u32 = 512;
pub const ADC_SQR4_SQ16_4: u32 = 1024;
pub const ADC_DR_RDATA_Pos: u32 = 0;
pub const ADC_DR_RDATA_Msk: u32 = 65535;
pub const ADC_DR_RDATA: u32 = 65535;
pub const ADC_DR_RDATA_0: u32 = 1;
pub const ADC_DR_RDATA_1: u32 = 2;
pub const ADC_DR_RDATA_2: u32 = 4;
pub const ADC_DR_RDATA_3: u32 = 8;
pub const ADC_DR_RDATA_4: u32 = 16;
pub const ADC_DR_RDATA_5: u32 = 32;
pub const ADC_DR_RDATA_6: u32 = 64;
pub const ADC_DR_RDATA_7: u32 = 128;
pub const ADC_DR_RDATA_8: u32 = 256;
pub const ADC_DR_RDATA_9: u32 = 512;
pub const ADC_DR_RDATA_10: u32 = 1024;
pub const ADC_DR_RDATA_11: u32 = 2048;
pub const ADC_DR_RDATA_12: u32 = 4096;
pub const ADC_DR_RDATA_13: u32 = 8192;
pub const ADC_DR_RDATA_14: u32 = 16384;
pub const ADC_DR_RDATA_15: u32 = 32768;
pub const ADC_JSQR_JL_Pos: u32 = 0;
pub const ADC_JSQR_JL_Msk: u32 = 3;
pub const ADC_JSQR_JL: u32 = 3;
pub const ADC_JSQR_JL_0: u32 = 1;
pub const ADC_JSQR_JL_1: u32 = 2;
pub const ADC_JSQR_JEXTSEL_Pos: u32 = 2;
pub const ADC_JSQR_JEXTSEL_Msk: u32 = 60;
pub const ADC_JSQR_JEXTSEL: u32 = 60;
pub const ADC_JSQR_JEXTSEL_0: u32 = 4;
pub const ADC_JSQR_JEXTSEL_1: u32 = 8;
pub const ADC_JSQR_JEXTSEL_2: u32 = 16;
pub const ADC_JSQR_JEXTSEL_3: u32 = 32;
pub const ADC_JSQR_JEXTEN_Pos: u32 = 6;
pub const ADC_JSQR_JEXTEN_Msk: u32 = 192;
pub const ADC_JSQR_JEXTEN: u32 = 192;
pub const ADC_JSQR_JEXTEN_0: u32 = 64;
pub const ADC_JSQR_JEXTEN_1: u32 = 128;
pub const ADC_JSQR_JSQ1_Pos: u32 = 8;
pub const ADC_JSQR_JSQ1_Msk: u32 = 7936;
pub const ADC_JSQR_JSQ1: u32 = 7936;
pub const ADC_JSQR_JSQ1_0: u32 = 256;
pub const ADC_JSQR_JSQ1_1: u32 = 512;
pub const ADC_JSQR_JSQ1_2: u32 = 1024;
pub const ADC_JSQR_JSQ1_3: u32 = 2048;
pub const ADC_JSQR_JSQ1_4: u32 = 4096;
pub const ADC_JSQR_JSQ2_Pos: u32 = 14;
pub const ADC_JSQR_JSQ2_Msk: u32 = 507904;
pub const ADC_JSQR_JSQ2: u32 = 507904;
pub const ADC_JSQR_JSQ2_0: u32 = 16384;
pub const ADC_JSQR_JSQ2_1: u32 = 32768;
pub const ADC_JSQR_JSQ2_2: u32 = 65536;
pub const ADC_JSQR_JSQ2_3: u32 = 131072;
pub const ADC_JSQR_JSQ2_4: u32 = 262144;
pub const ADC_JSQR_JSQ3_Pos: u32 = 20;
pub const ADC_JSQR_JSQ3_Msk: u32 = 32505856;
pub const ADC_JSQR_JSQ3: u32 = 32505856;
pub const ADC_JSQR_JSQ3_0: u32 = 1048576;
pub const ADC_JSQR_JSQ3_1: u32 = 2097152;
pub const ADC_JSQR_JSQ3_2: u32 = 4194304;
pub const ADC_JSQR_JSQ3_3: u32 = 8388608;
pub const ADC_JSQR_JSQ3_4: u32 = 16777216;
pub const ADC_JSQR_JSQ4_Pos: u32 = 26;
pub const ADC_JSQR_JSQ4_Msk: u32 = 2080374784;
pub const ADC_JSQR_JSQ4: u32 = 2080374784;
pub const ADC_JSQR_JSQ4_0: u32 = 67108864;
pub const ADC_JSQR_JSQ4_1: u32 = 134217728;
pub const ADC_JSQR_JSQ4_2: u32 = 268435456;
pub const ADC_JSQR_JSQ4_3: u32 = 536870912;
pub const ADC_JSQR_JSQ4_4: u32 = 1073741824;
pub const ADC_OFR1_OFFSET1_Pos: u32 = 0;
pub const ADC_OFR1_OFFSET1_Msk: u32 = 4095;
pub const ADC_OFR1_OFFSET1: u32 = 4095;
pub const ADC_OFR1_OFFSET1_0: u32 = 1;
pub const ADC_OFR1_OFFSET1_1: u32 = 2;
pub const ADC_OFR1_OFFSET1_2: u32 = 4;
pub const ADC_OFR1_OFFSET1_3: u32 = 8;
pub const ADC_OFR1_OFFSET1_4: u32 = 16;
pub const ADC_OFR1_OFFSET1_5: u32 = 32;
pub const ADC_OFR1_OFFSET1_6: u32 = 64;
pub const ADC_OFR1_OFFSET1_7: u32 = 128;
pub const ADC_OFR1_OFFSET1_8: u32 = 256;
pub const ADC_OFR1_OFFSET1_9: u32 = 512;
pub const ADC_OFR1_OFFSET1_10: u32 = 1024;
pub const ADC_OFR1_OFFSET1_11: u32 = 2048;
pub const ADC_OFR1_OFFSET1_CH_Pos: u32 = 26;
pub const ADC_OFR1_OFFSET1_CH_Msk: u32 = 2080374784;
pub const ADC_OFR1_OFFSET1_CH: u32 = 2080374784;
pub const ADC_OFR1_OFFSET1_CH_0: u32 = 67108864;
pub const ADC_OFR1_OFFSET1_CH_1: u32 = 134217728;
pub const ADC_OFR1_OFFSET1_CH_2: u32 = 268435456;
pub const ADC_OFR1_OFFSET1_CH_3: u32 = 536870912;
pub const ADC_OFR1_OFFSET1_CH_4: u32 = 1073741824;
pub const ADC_OFR1_OFFSET1_EN_Pos: u32 = 31;
pub const ADC_OFR1_OFFSET1_EN_Msk: u32 = 2147483648;
pub const ADC_OFR1_OFFSET1_EN: u32 = 2147483648;
pub const ADC_OFR2_OFFSET2_Pos: u32 = 0;
pub const ADC_OFR2_OFFSET2_Msk: u32 = 4095;
pub const ADC_OFR2_OFFSET2: u32 = 4095;
pub const ADC_OFR2_OFFSET2_0: u32 = 1;
pub const ADC_OFR2_OFFSET2_1: u32 = 2;
pub const ADC_OFR2_OFFSET2_2: u32 = 4;
pub const ADC_OFR2_OFFSET2_3: u32 = 8;
pub const ADC_OFR2_OFFSET2_4: u32 = 16;
pub const ADC_OFR2_OFFSET2_5: u32 = 32;
pub const ADC_OFR2_OFFSET2_6: u32 = 64;
pub const ADC_OFR2_OFFSET2_7: u32 = 128;
pub const ADC_OFR2_OFFSET2_8: u32 = 256;
pub const ADC_OFR2_OFFSET2_9: u32 = 512;
pub const ADC_OFR2_OFFSET2_10: u32 = 1024;
pub const ADC_OFR2_OFFSET2_11: u32 = 2048;
pub const ADC_OFR2_OFFSET2_CH_Pos: u32 = 26;
pub const ADC_OFR2_OFFSET2_CH_Msk: u32 = 2080374784;
pub const ADC_OFR2_OFFSET2_CH: u32 = 2080374784;
pub const ADC_OFR2_OFFSET2_CH_0: u32 = 67108864;
pub const ADC_OFR2_OFFSET2_CH_1: u32 = 134217728;
pub const ADC_OFR2_OFFSET2_CH_2: u32 = 268435456;
pub const ADC_OFR2_OFFSET2_CH_3: u32 = 536870912;
pub const ADC_OFR2_OFFSET2_CH_4: u32 = 1073741824;
pub const ADC_OFR2_OFFSET2_EN_Pos: u32 = 31;
pub const ADC_OFR2_OFFSET2_EN_Msk: u32 = 2147483648;
pub const ADC_OFR2_OFFSET2_EN: u32 = 2147483648;
pub const ADC_OFR3_OFFSET3_Pos: u32 = 0;
pub const ADC_OFR3_OFFSET3_Msk: u32 = 4095;
pub const ADC_OFR3_OFFSET3: u32 = 4095;
pub const ADC_OFR3_OFFSET3_0: u32 = 1;
pub const ADC_OFR3_OFFSET3_1: u32 = 2;
pub const ADC_OFR3_OFFSET3_2: u32 = 4;
pub const ADC_OFR3_OFFSET3_3: u32 = 8;
pub const ADC_OFR3_OFFSET3_4: u32 = 16;
pub const ADC_OFR3_OFFSET3_5: u32 = 32;
pub const ADC_OFR3_OFFSET3_6: u32 = 64;
pub const ADC_OFR3_OFFSET3_7: u32 = 128;
pub const ADC_OFR3_OFFSET3_8: u32 = 256;
pub const ADC_OFR3_OFFSET3_9: u32 = 512;
pub const ADC_OFR3_OFFSET3_10: u32 = 1024;
pub const ADC_OFR3_OFFSET3_11: u32 = 2048;
pub const ADC_OFR3_OFFSET3_CH_Pos: u32 = 26;
pub const ADC_OFR3_OFFSET3_CH_Msk: u32 = 2080374784;
pub const ADC_OFR3_OFFSET3_CH: u32 = 2080374784;
pub const ADC_OFR3_OFFSET3_CH_0: u32 = 67108864;
pub const ADC_OFR3_OFFSET3_CH_1: u32 = 134217728;
pub const ADC_OFR3_OFFSET3_CH_2: u32 = 268435456;
pub const ADC_OFR3_OFFSET3_CH_3: u32 = 536870912;
pub const ADC_OFR3_OFFSET3_CH_4: u32 = 1073741824;
pub const ADC_OFR3_OFFSET3_EN_Pos: u32 = 31;
pub const ADC_OFR3_OFFSET3_EN_Msk: u32 = 2147483648;
pub const ADC_OFR3_OFFSET3_EN: u32 = 2147483648;
pub const ADC_OFR4_OFFSET4_Pos: u32 = 0;
pub const ADC_OFR4_OFFSET4_Msk: u32 = 4095;
pub const ADC_OFR4_OFFSET4: u32 = 4095;
pub const ADC_OFR4_OFFSET4_0: u32 = 1;
pub const ADC_OFR4_OFFSET4_1: u32 = 2;
pub const ADC_OFR4_OFFSET4_2: u32 = 4;
pub const ADC_OFR4_OFFSET4_3: u32 = 8;
pub const ADC_OFR4_OFFSET4_4: u32 = 16;
pub const ADC_OFR4_OFFSET4_5: u32 = 32;
pub const ADC_OFR4_OFFSET4_6: u32 = 64;
pub const ADC_OFR4_OFFSET4_7: u32 = 128;
pub const ADC_OFR4_OFFSET4_8: u32 = 256;
pub const ADC_OFR4_OFFSET4_9: u32 = 512;
pub const ADC_OFR4_OFFSET4_10: u32 = 1024;
pub const ADC_OFR4_OFFSET4_11: u32 = 2048;
pub const ADC_OFR4_OFFSET4_CH_Pos: u32 = 26;
pub const ADC_OFR4_OFFSET4_CH_Msk: u32 = 2080374784;
pub const ADC_OFR4_OFFSET4_CH: u32 = 2080374784;
pub const ADC_OFR4_OFFSET4_CH_0: u32 = 67108864;
pub const ADC_OFR4_OFFSET4_CH_1: u32 = 134217728;
pub const ADC_OFR4_OFFSET4_CH_2: u32 = 268435456;
pub const ADC_OFR4_OFFSET4_CH_3: u32 = 536870912;
pub const ADC_OFR4_OFFSET4_CH_4: u32 = 1073741824;
pub const ADC_OFR4_OFFSET4_EN_Pos: u32 = 31;
pub const ADC_OFR4_OFFSET4_EN_Msk: u32 = 2147483648;
pub const ADC_OFR4_OFFSET4_EN: u32 = 2147483648;
pub const ADC_JDR1_JDATA_Pos: u32 = 0;
pub const ADC_JDR1_JDATA_Msk: u32 = 65535;
pub const ADC_JDR1_JDATA: u32 = 65535;
pub const ADC_JDR1_JDATA_0: u32 = 1;
pub const ADC_JDR1_JDATA_1: u32 = 2;
pub const ADC_JDR1_JDATA_2: u32 = 4;
pub const ADC_JDR1_JDATA_3: u32 = 8;
pub const ADC_JDR1_JDATA_4: u32 = 16;
pub const ADC_JDR1_JDATA_5: u32 = 32;
pub const ADC_JDR1_JDATA_6: u32 = 64;
pub const ADC_JDR1_JDATA_7: u32 = 128;
pub const ADC_JDR1_JDATA_8: u32 = 256;
pub const ADC_JDR1_JDATA_9: u32 = 512;
pub const ADC_JDR1_JDATA_10: u32 = 1024;
pub const ADC_JDR1_JDATA_11: u32 = 2048;
pub const ADC_JDR1_JDATA_12: u32 = 4096;
pub const ADC_JDR1_JDATA_13: u32 = 8192;
pub const ADC_JDR1_JDATA_14: u32 = 16384;
pub const ADC_JDR1_JDATA_15: u32 = 32768;
pub const ADC_JDR2_JDATA_Pos: u32 = 0;
pub const ADC_JDR2_JDATA_Msk: u32 = 65535;
pub const ADC_JDR2_JDATA: u32 = 65535;
pub const ADC_JDR2_JDATA_0: u32 = 1;
pub const ADC_JDR2_JDATA_1: u32 = 2;
pub const ADC_JDR2_JDATA_2: u32 = 4;
pub const ADC_JDR2_JDATA_3: u32 = 8;
pub const ADC_JDR2_JDATA_4: u32 = 16;
pub const ADC_JDR2_JDATA_5: u32 = 32;
pub const ADC_JDR2_JDATA_6: u32 = 64;
pub const ADC_JDR2_JDATA_7: u32 = 128;
pub const ADC_JDR2_JDATA_8: u32 = 256;
pub const ADC_JDR2_JDATA_9: u32 = 512;
pub const ADC_JDR2_JDATA_10: u32 = 1024;
pub const ADC_JDR2_JDATA_11: u32 = 2048;
pub const ADC_JDR2_JDATA_12: u32 = 4096;
pub const ADC_JDR2_JDATA_13: u32 = 8192;
pub const ADC_JDR2_JDATA_14: u32 = 16384;
pub const ADC_JDR2_JDATA_15: u32 = 32768;
pub const ADC_JDR3_JDATA_Pos: u32 = 0;
pub const ADC_JDR3_JDATA_Msk: u32 = 65535;
pub const ADC_JDR3_JDATA: u32 = 65535;
pub const ADC_JDR3_JDATA_0: u32 = 1;
pub const ADC_JDR3_JDATA_1: u32 = 2;
pub const ADC_JDR3_JDATA_2: u32 = 4;
pub const ADC_JDR3_JDATA_3: u32 = 8;
pub const ADC_JDR3_JDATA_4: u32 = 16;
pub const ADC_JDR3_JDATA_5: u32 = 32;
pub const ADC_JDR3_JDATA_6: u32 = 64;
pub const ADC_JDR3_JDATA_7: u32 = 128;
pub const ADC_JDR3_JDATA_8: u32 = 256;
pub const ADC_JDR3_JDATA_9: u32 = 512;
pub const ADC_JDR3_JDATA_10: u32 = 1024;
pub const ADC_JDR3_JDATA_11: u32 = 2048;
pub const ADC_JDR3_JDATA_12: u32 = 4096;
pub const ADC_JDR3_JDATA_13: u32 = 8192;
pub const ADC_JDR3_JDATA_14: u32 = 16384;
pub const ADC_JDR3_JDATA_15: u32 = 32768;
pub const ADC_JDR4_JDATA_Pos: u32 = 0;
pub const ADC_JDR4_JDATA_Msk: u32 = 65535;
pub const ADC_JDR4_JDATA: u32 = 65535;
pub const ADC_JDR4_JDATA_0: u32 = 1;
pub const ADC_JDR4_JDATA_1: u32 = 2;
pub const ADC_JDR4_JDATA_2: u32 = 4;
pub const ADC_JDR4_JDATA_3: u32 = 8;
pub const ADC_JDR4_JDATA_4: u32 = 16;
pub const ADC_JDR4_JDATA_5: u32 = 32;
pub const ADC_JDR4_JDATA_6: u32 = 64;
pub const ADC_JDR4_JDATA_7: u32 = 128;
pub const ADC_JDR4_JDATA_8: u32 = 256;
pub const ADC_JDR4_JDATA_9: u32 = 512;
pub const ADC_JDR4_JDATA_10: u32 = 1024;
pub const ADC_JDR4_JDATA_11: u32 = 2048;
pub const ADC_JDR4_JDATA_12: u32 = 4096;
pub const ADC_JDR4_JDATA_13: u32 = 8192;
pub const ADC_JDR4_JDATA_14: u32 = 16384;
pub const ADC_JDR4_JDATA_15: u32 = 32768;
pub const ADC_AWD2CR_AWD2CH_Pos: u32 = 0;
pub const ADC_AWD2CR_AWD2CH_Msk: u32 = 524287;
pub const ADC_AWD2CR_AWD2CH: u32 = 524287;
pub const ADC_AWD2CR_AWD2CH_0: u32 = 1;
pub const ADC_AWD2CR_AWD2CH_1: u32 = 2;
pub const ADC_AWD2CR_AWD2CH_2: u32 = 4;
pub const ADC_AWD2CR_AWD2CH_3: u32 = 8;
pub const ADC_AWD2CR_AWD2CH_4: u32 = 16;
pub const ADC_AWD2CR_AWD2CH_5: u32 = 32;
pub const ADC_AWD2CR_AWD2CH_6: u32 = 64;
pub const ADC_AWD2CR_AWD2CH_7: u32 = 128;
pub const ADC_AWD2CR_AWD2CH_8: u32 = 256;
pub const ADC_AWD2CR_AWD2CH_9: u32 = 512;
pub const ADC_AWD2CR_AWD2CH_10: u32 = 1024;
pub const ADC_AWD2CR_AWD2CH_11: u32 = 2048;
pub const ADC_AWD2CR_AWD2CH_12: u32 = 4096;
pub const ADC_AWD2CR_AWD2CH_13: u32 = 8192;
pub const ADC_AWD2CR_AWD2CH_14: u32 = 16384;
pub const ADC_AWD2CR_AWD2CH_15: u32 = 32768;
pub const ADC_AWD2CR_AWD2CH_16: u32 = 65536;
pub const ADC_AWD2CR_AWD2CH_17: u32 = 131072;
pub const ADC_AWD2CR_AWD2CH_18: u32 = 262144;
pub const ADC_AWD3CR_AWD3CH_Pos: u32 = 0;
pub const ADC_AWD3CR_AWD3CH_Msk: u32 = 524287;
pub const ADC_AWD3CR_AWD3CH: u32 = 524287;
pub const ADC_AWD3CR_AWD3CH_0: u32 = 1;
pub const ADC_AWD3CR_AWD3CH_1: u32 = 2;
pub const ADC_AWD3CR_AWD3CH_2: u32 = 4;
pub const ADC_AWD3CR_AWD3CH_3: u32 = 8;
pub const ADC_AWD3CR_AWD3CH_4: u32 = 16;
pub const ADC_AWD3CR_AWD3CH_5: u32 = 32;
pub const ADC_AWD3CR_AWD3CH_6: u32 = 64;
pub const ADC_AWD3CR_AWD3CH_7: u32 = 128;
pub const ADC_AWD3CR_AWD3CH_8: u32 = 256;
pub const ADC_AWD3CR_AWD3CH_9: u32 = 512;
pub const ADC_AWD3CR_AWD3CH_10: u32 = 1024;
pub const ADC_AWD3CR_AWD3CH_11: u32 = 2048;
pub const ADC_AWD3CR_AWD3CH_12: u32 = 4096;
pub const ADC_AWD3CR_AWD3CH_13: u32 = 8192;
pub const ADC_AWD3CR_AWD3CH_14: u32 = 16384;
pub const ADC_AWD3CR_AWD3CH_15: u32 = 32768;
pub const ADC_AWD3CR_AWD3CH_16: u32 = 65536;
pub const ADC_AWD3CR_AWD3CH_17: u32 = 131072;
pub const ADC_AWD3CR_AWD3CH_18: u32 = 262144;
pub const ADC_DIFSEL_DIFSEL_Pos: u32 = 0;
pub const ADC_DIFSEL_DIFSEL_Msk: u32 = 524287;
pub const ADC_DIFSEL_DIFSEL: u32 = 524287;
pub const ADC_DIFSEL_DIFSEL_0: u32 = 1;
pub const ADC_DIFSEL_DIFSEL_1: u32 = 2;
pub const ADC_DIFSEL_DIFSEL_2: u32 = 4;
pub const ADC_DIFSEL_DIFSEL_3: u32 = 8;
pub const ADC_DIFSEL_DIFSEL_4: u32 = 16;
pub const ADC_DIFSEL_DIFSEL_5: u32 = 32;
pub const ADC_DIFSEL_DIFSEL_6: u32 = 64;
pub const ADC_DIFSEL_DIFSEL_7: u32 = 128;
pub const ADC_DIFSEL_DIFSEL_8: u32 = 256;
pub const ADC_DIFSEL_DIFSEL_9: u32 = 512;
pub const ADC_DIFSEL_DIFSEL_10: u32 = 1024;
pub const ADC_DIFSEL_DIFSEL_11: u32 = 2048;
pub const ADC_DIFSEL_DIFSEL_12: u32 = 4096;
pub const ADC_DIFSEL_DIFSEL_13: u32 = 8192;
pub const ADC_DIFSEL_DIFSEL_14: u32 = 16384;
pub const ADC_DIFSEL_DIFSEL_15: u32 = 32768;
pub const ADC_DIFSEL_DIFSEL_16: u32 = 65536;
pub const ADC_DIFSEL_DIFSEL_17: u32 = 131072;
pub const ADC_DIFSEL_DIFSEL_18: u32 = 262144;
pub const ADC_CALFACT_CALFACT_S_Pos: u32 = 0;
pub const ADC_CALFACT_CALFACT_S_Msk: u32 = 127;
pub const ADC_CALFACT_CALFACT_S: u32 = 127;
pub const ADC_CALFACT_CALFACT_S_0: u32 = 1;
pub const ADC_CALFACT_CALFACT_S_1: u32 = 2;
pub const ADC_CALFACT_CALFACT_S_2: u32 = 4;
pub const ADC_CALFACT_CALFACT_S_3: u32 = 8;
pub const ADC_CALFACT_CALFACT_S_4: u32 = 16;
pub const ADC_CALFACT_CALFACT_S_5: u32 = 32;
pub const ADC_CALFACT_CALFACT_S_6: u32 = 64;
pub const ADC_CALFACT_CALFACT_D_Pos: u32 = 16;
pub const ADC_CALFACT_CALFACT_D_Msk: u32 = 8323072;
pub const ADC_CALFACT_CALFACT_D: u32 = 8323072;
pub const ADC_CALFACT_CALFACT_D_0: u32 = 65536;
pub const ADC_CALFACT_CALFACT_D_1: u32 = 131072;
pub const ADC_CALFACT_CALFACT_D_2: u32 = 262144;
pub const ADC_CALFACT_CALFACT_D_3: u32 = 524288;
pub const ADC_CALFACT_CALFACT_D_4: u32 = 1048576;
pub const ADC_CALFACT_CALFACT_D_5: u32 = 2097152;
pub const ADC_CALFACT_CALFACT_D_6: u32 = 4194304;
pub const ADC_CSR_ADRDY_MST_Pos: u32 = 0;
pub const ADC_CSR_ADRDY_MST_Msk: u32 = 1;
pub const ADC_CSR_ADRDY_MST: u32 = 1;
pub const ADC_CSR_EOSMP_MST_Pos: u32 = 1;
pub const ADC_CSR_EOSMP_MST_Msk: u32 = 2;
pub const ADC_CSR_EOSMP_MST: u32 = 2;
pub const ADC_CSR_EOC_MST_Pos: u32 = 2;
pub const ADC_CSR_EOC_MST_Msk: u32 = 4;
pub const ADC_CSR_EOC_MST: u32 = 4;
pub const ADC_CSR_EOS_MST_Pos: u32 = 3;
pub const ADC_CSR_EOS_MST_Msk: u32 = 8;
pub const ADC_CSR_EOS_MST: u32 = 8;
pub const ADC_CSR_OVR_MST_Pos: u32 = 4;
pub const ADC_CSR_OVR_MST_Msk: u32 = 16;
pub const ADC_CSR_OVR_MST: u32 = 16;
pub const ADC_CSR_JEOC_MST_Pos: u32 = 5;
pub const ADC_CSR_JEOC_MST_Msk: u32 = 32;
pub const ADC_CSR_JEOC_MST: u32 = 32;
pub const ADC_CSR_JEOS_MST_Pos: u32 = 6;
pub const ADC_CSR_JEOS_MST_Msk: u32 = 64;
pub const ADC_CSR_JEOS_MST: u32 = 64;
pub const ADC_CSR_AWD1_MST_Pos: u32 = 7;
pub const ADC_CSR_AWD1_MST_Msk: u32 = 128;
pub const ADC_CSR_AWD1_MST: u32 = 128;
pub const ADC_CSR_AWD2_MST_Pos: u32 = 8;
pub const ADC_CSR_AWD2_MST_Msk: u32 = 256;
pub const ADC_CSR_AWD2_MST: u32 = 256;
pub const ADC_CSR_AWD3_MST_Pos: u32 = 9;
pub const ADC_CSR_AWD3_MST_Msk: u32 = 512;
pub const ADC_CSR_AWD3_MST: u32 = 512;
pub const ADC_CSR_JQOVF_MST_Pos: u32 = 10;
pub const ADC_CSR_JQOVF_MST_Msk: u32 = 1024;
pub const ADC_CSR_JQOVF_MST: u32 = 1024;
pub const ADC_CSR_ADRDY_SLV_Pos: u32 = 16;
pub const ADC_CSR_ADRDY_SLV_Msk: u32 = 65536;
pub const ADC_CSR_ADRDY_SLV: u32 = 65536;
pub const ADC_CSR_EOSMP_SLV_Pos: u32 = 17;
pub const ADC_CSR_EOSMP_SLV_Msk: u32 = 131072;
pub const ADC_CSR_EOSMP_SLV: u32 = 131072;
pub const ADC_CSR_EOC_SLV_Pos: u32 = 18;
pub const ADC_CSR_EOC_SLV_Msk: u32 = 262144;
pub const ADC_CSR_EOC_SLV: u32 = 262144;
pub const ADC_CSR_EOS_SLV_Pos: u32 = 19;
pub const ADC_CSR_EOS_SLV_Msk: u32 = 524288;
pub const ADC_CSR_EOS_SLV: u32 = 524288;
pub const ADC_CSR_OVR_SLV_Pos: u32 = 20;
pub const ADC_CSR_OVR_SLV_Msk: u32 = 1048576;
pub const ADC_CSR_OVR_SLV: u32 = 1048576;
pub const ADC_CSR_JEOC_SLV_Pos: u32 = 21;
pub const ADC_CSR_JEOC_SLV_Msk: u32 = 2097152;
pub const ADC_CSR_JEOC_SLV: u32 = 2097152;
pub const ADC_CSR_JEOS_SLV_Pos: u32 = 22;
pub const ADC_CSR_JEOS_SLV_Msk: u32 = 4194304;
pub const ADC_CSR_JEOS_SLV: u32 = 4194304;
pub const ADC_CSR_AWD1_SLV_Pos: u32 = 23;
pub const ADC_CSR_AWD1_SLV_Msk: u32 = 8388608;
pub const ADC_CSR_AWD1_SLV: u32 = 8388608;
pub const ADC_CSR_AWD2_SLV_Pos: u32 = 24;
pub const ADC_CSR_AWD2_SLV_Msk: u32 = 16777216;
pub const ADC_CSR_AWD2_SLV: u32 = 16777216;
pub const ADC_CSR_AWD3_SLV_Pos: u32 = 25;
pub const ADC_CSR_AWD3_SLV_Msk: u32 = 33554432;
pub const ADC_CSR_AWD3_SLV: u32 = 33554432;
pub const ADC_CSR_JQOVF_SLV_Pos: u32 = 26;
pub const ADC_CSR_JQOVF_SLV_Msk: u32 = 67108864;
pub const ADC_CSR_JQOVF_SLV: u32 = 67108864;
pub const ADC_CCR_DUAL_Pos: u32 = 0;
pub const ADC_CCR_DUAL_Msk: u32 = 31;
pub const ADC_CCR_DUAL: u32 = 31;
pub const ADC_CCR_DUAL_0: u32 = 1;
pub const ADC_CCR_DUAL_1: u32 = 2;
pub const ADC_CCR_DUAL_2: u32 = 4;
pub const ADC_CCR_DUAL_3: u32 = 8;
pub const ADC_CCR_DUAL_4: u32 = 16;
pub const ADC_CCR_DELAY_Pos: u32 = 8;
pub const ADC_CCR_DELAY_Msk: u32 = 3840;
pub const ADC_CCR_DELAY: u32 = 3840;
pub const ADC_CCR_DELAY_0: u32 = 256;
pub const ADC_CCR_DELAY_1: u32 = 512;
pub const ADC_CCR_DELAY_2: u32 = 1024;
pub const ADC_CCR_DELAY_3: u32 = 2048;
pub const ADC_CCR_DMACFG_Pos: u32 = 13;
pub const ADC_CCR_DMACFG_Msk: u32 = 8192;
pub const ADC_CCR_DMACFG: u32 = 8192;
pub const ADC_CCR_MDMA_Pos: u32 = 14;
pub const ADC_CCR_MDMA_Msk: u32 = 49152;
pub const ADC_CCR_MDMA: u32 = 49152;
pub const ADC_CCR_MDMA_0: u32 = 16384;
pub const ADC_CCR_MDMA_1: u32 = 32768;
pub const ADC_CCR_CKMODE_Pos: u32 = 16;
pub const ADC_CCR_CKMODE_Msk: u32 = 196608;
pub const ADC_CCR_CKMODE: u32 = 196608;
pub const ADC_CCR_CKMODE_0: u32 = 65536;
pub const ADC_CCR_CKMODE_1: u32 = 131072;
pub const ADC_CCR_PRESC_Pos: u32 = 18;
pub const ADC_CCR_PRESC_Msk: u32 = 3932160;
pub const ADC_CCR_PRESC: u32 = 3932160;
pub const ADC_CCR_PRESC_0: u32 = 262144;
pub const ADC_CCR_PRESC_1: u32 = 524288;
pub const ADC_CCR_PRESC_2: u32 = 1048576;
pub const ADC_CCR_PRESC_3: u32 = 2097152;
pub const ADC_CCR_VREFEN_Pos: u32 = 22;
pub const ADC_CCR_VREFEN_Msk: u32 = 4194304;
pub const ADC_CCR_VREFEN: u32 = 4194304;
pub const ADC_CCR_TSEN_Pos: u32 = 23;
pub const ADC_CCR_TSEN_Msk: u32 = 8388608;
pub const ADC_CCR_TSEN: u32 = 8388608;
pub const ADC_CCR_VBATEN_Pos: u32 = 24;
pub const ADC_CCR_VBATEN_Msk: u32 = 16777216;
pub const ADC_CCR_VBATEN: u32 = 16777216;
pub const ADC_CDR_RDATA_MST_Pos: u32 = 0;
pub const ADC_CDR_RDATA_MST_Msk: u32 = 65535;
pub const ADC_CDR_RDATA_MST: u32 = 65535;
pub const ADC_CDR_RDATA_MST_0: u32 = 1;
pub const ADC_CDR_RDATA_MST_1: u32 = 2;
pub const ADC_CDR_RDATA_MST_2: u32 = 4;
pub const ADC_CDR_RDATA_MST_3: u32 = 8;
pub const ADC_CDR_RDATA_MST_4: u32 = 16;
pub const ADC_CDR_RDATA_MST_5: u32 = 32;
pub const ADC_CDR_RDATA_MST_6: u32 = 64;
pub const ADC_CDR_RDATA_MST_7: u32 = 128;
pub const ADC_CDR_RDATA_MST_8: u32 = 256;
pub const ADC_CDR_RDATA_MST_9: u32 = 512;
pub const ADC_CDR_RDATA_MST_10: u32 = 1024;
pub const ADC_CDR_RDATA_MST_11: u32 = 2048;
pub const ADC_CDR_RDATA_MST_12: u32 = 4096;
pub const ADC_CDR_RDATA_MST_13: u32 = 8192;
pub const ADC_CDR_RDATA_MST_14: u32 = 16384;
pub const ADC_CDR_RDATA_MST_15: u32 = 32768;
pub const ADC_CDR_RDATA_SLV_Pos: u32 = 16;
pub const ADC_CDR_RDATA_SLV_Msk: u32 = 4294901760;
pub const ADC_CDR_RDATA_SLV: u32 = 4294901760;
pub const ADC_CDR_RDATA_SLV_0: u32 = 65536;
pub const ADC_CDR_RDATA_SLV_1: u32 = 131072;
pub const ADC_CDR_RDATA_SLV_2: u32 = 262144;
pub const ADC_CDR_RDATA_SLV_3: u32 = 524288;
pub const ADC_CDR_RDATA_SLV_4: u32 = 1048576;
pub const ADC_CDR_RDATA_SLV_5: u32 = 2097152;
pub const ADC_CDR_RDATA_SLV_6: u32 = 4194304;
pub const ADC_CDR_RDATA_SLV_7: u32 = 8388608;
pub const ADC_CDR_RDATA_SLV_8: u32 = 16777216;
pub const ADC_CDR_RDATA_SLV_9: u32 = 33554432;
pub const ADC_CDR_RDATA_SLV_10: u32 = 67108864;
pub const ADC_CDR_RDATA_SLV_11: u32 = 134217728;
pub const ADC_CDR_RDATA_SLV_12: u32 = 268435456;
pub const ADC_CDR_RDATA_SLV_13: u32 = 536870912;
pub const ADC_CDR_RDATA_SLV_14: u32 = 1073741824;
pub const ADC_CDR_RDATA_SLV_15: u32 = 2147483648;
pub const CAN_MCR_INRQ_Pos: u32 = 0;
pub const CAN_MCR_INRQ_Msk: u32 = 1;
pub const CAN_MCR_INRQ: u32 = 1;
pub const CAN_MCR_SLEEP_Pos: u32 = 1;
pub const CAN_MCR_SLEEP_Msk: u32 = 2;
pub const CAN_MCR_SLEEP: u32 = 2;
pub const CAN_MCR_TXFP_Pos: u32 = 2;
pub const CAN_MCR_TXFP_Msk: u32 = 4;
pub const CAN_MCR_TXFP: u32 = 4;
pub const CAN_MCR_RFLM_Pos: u32 = 3;
pub const CAN_MCR_RFLM_Msk: u32 = 8;
pub const CAN_MCR_RFLM: u32 = 8;
pub const CAN_MCR_NART_Pos: u32 = 4;
pub const CAN_MCR_NART_Msk: u32 = 16;
pub const CAN_MCR_NART: u32 = 16;
pub const CAN_MCR_AWUM_Pos: u32 = 5;
pub const CAN_MCR_AWUM_Msk: u32 = 32;
pub const CAN_MCR_AWUM: u32 = 32;
pub const CAN_MCR_ABOM_Pos: u32 = 6;
pub const CAN_MCR_ABOM_Msk: u32 = 64;
pub const CAN_MCR_ABOM: u32 = 64;
pub const CAN_MCR_TTCM_Pos: u32 = 7;
pub const CAN_MCR_TTCM_Msk: u32 = 128;
pub const CAN_MCR_TTCM: u32 = 128;
pub const CAN_MCR_RESET_Pos: u32 = 15;
pub const CAN_MCR_RESET_Msk: u32 = 32768;
pub const CAN_MCR_RESET: u32 = 32768;
pub const CAN_MSR_INAK_Pos: u32 = 0;
pub const CAN_MSR_INAK_Msk: u32 = 1;
pub const CAN_MSR_INAK: u32 = 1;
pub const CAN_MSR_SLAK_Pos: u32 = 1;
pub const CAN_MSR_SLAK_Msk: u32 = 2;
pub const CAN_MSR_SLAK: u32 = 2;
pub const CAN_MSR_ERRI_Pos: u32 = 2;
pub const CAN_MSR_ERRI_Msk: u32 = 4;
pub const CAN_MSR_ERRI: u32 = 4;
pub const CAN_MSR_WKUI_Pos: u32 = 3;
pub const CAN_MSR_WKUI_Msk: u32 = 8;
pub const CAN_MSR_WKUI: u32 = 8;
pub const CAN_MSR_SLAKI_Pos: u32 = 4;
pub const CAN_MSR_SLAKI_Msk: u32 = 16;
pub const CAN_MSR_SLAKI: u32 = 16;
pub const CAN_MSR_TXM_Pos: u32 = 8;
pub const CAN_MSR_TXM_Msk: u32 = 256;
pub const CAN_MSR_TXM: u32 = 256;
pub const CAN_MSR_RXM_Pos: u32 = 9;
pub const CAN_MSR_RXM_Msk: u32 = 512;
pub const CAN_MSR_RXM: u32 = 512;
pub const CAN_MSR_SAMP_Pos: u32 = 10;
pub const CAN_MSR_SAMP_Msk: u32 = 1024;
pub const CAN_MSR_SAMP: u32 = 1024;
pub const CAN_MSR_RX_Pos: u32 = 11;
pub const CAN_MSR_RX_Msk: u32 = 2048;
pub const CAN_MSR_RX: u32 = 2048;
pub const CAN_TSR_RQCP0_Pos: u32 = 0;
pub const CAN_TSR_RQCP0_Msk: u32 = 1;
pub const CAN_TSR_RQCP0: u32 = 1;
pub const CAN_TSR_TXOK0_Pos: u32 = 1;
pub const CAN_TSR_TXOK0_Msk: u32 = 2;
pub const CAN_TSR_TXOK0: u32 = 2;
pub const CAN_TSR_ALST0_Pos: u32 = 2;
pub const CAN_TSR_ALST0_Msk: u32 = 4;
pub const CAN_TSR_ALST0: u32 = 4;
pub const CAN_TSR_TERR0_Pos: u32 = 3;
pub const CAN_TSR_TERR0_Msk: u32 = 8;
pub const CAN_TSR_TERR0: u32 = 8;
pub const CAN_TSR_ABRQ0_Pos: u32 = 7;
pub const CAN_TSR_ABRQ0_Msk: u32 = 128;
pub const CAN_TSR_ABRQ0: u32 = 128;
pub const CAN_TSR_RQCP1_Pos: u32 = 8;
pub const CAN_TSR_RQCP1_Msk: u32 = 256;
pub const CAN_TSR_RQCP1: u32 = 256;
pub const CAN_TSR_TXOK1_Pos: u32 = 9;
pub const CAN_TSR_TXOK1_Msk: u32 = 512;
pub const CAN_TSR_TXOK1: u32 = 512;
pub const CAN_TSR_ALST1_Pos: u32 = 10;
pub const CAN_TSR_ALST1_Msk: u32 = 1024;
pub const CAN_TSR_ALST1: u32 = 1024;
pub const CAN_TSR_TERR1_Pos: u32 = 11;
pub const CAN_TSR_TERR1_Msk: u32 = 2048;
pub const CAN_TSR_TERR1: u32 = 2048;
pub const CAN_TSR_ABRQ1_Pos: u32 = 15;
pub const CAN_TSR_ABRQ1_Msk: u32 = 32768;
pub const CAN_TSR_ABRQ1: u32 = 32768;
pub const CAN_TSR_RQCP2_Pos: u32 = 16;
pub const CAN_TSR_RQCP2_Msk: u32 = 65536;
pub const CAN_TSR_RQCP2: u32 = 65536;
pub const CAN_TSR_TXOK2_Pos: u32 = 17;
pub const CAN_TSR_TXOK2_Msk: u32 = 131072;
pub const CAN_TSR_TXOK2: u32 = 131072;
pub const CAN_TSR_ALST2_Pos: u32 = 18;
pub const CAN_TSR_ALST2_Msk: u32 = 262144;
pub const CAN_TSR_ALST2: u32 = 262144;
pub const CAN_TSR_TERR2_Pos: u32 = 19;
pub const CAN_TSR_TERR2_Msk: u32 = 524288;
pub const CAN_TSR_TERR2: u32 = 524288;
pub const CAN_TSR_ABRQ2_Pos: u32 = 23;
pub const CAN_TSR_ABRQ2_Msk: u32 = 8388608;
pub const CAN_TSR_ABRQ2: u32 = 8388608;
pub const CAN_TSR_CODE_Pos: u32 = 24;
pub const CAN_TSR_CODE_Msk: u32 = 50331648;
pub const CAN_TSR_CODE: u32 = 50331648;
pub const CAN_TSR_TME_Pos: u32 = 26;
pub const CAN_TSR_TME_Msk: u32 = 469762048;
pub const CAN_TSR_TME: u32 = 469762048;
pub const CAN_TSR_TME0_Pos: u32 = 26;
pub const CAN_TSR_TME0_Msk: u32 = 67108864;
pub const CAN_TSR_TME0: u32 = 67108864;
pub const CAN_TSR_TME1_Pos: u32 = 27;
pub const CAN_TSR_TME1_Msk: u32 = 134217728;
pub const CAN_TSR_TME1: u32 = 134217728;
pub const CAN_TSR_TME2_Pos: u32 = 28;
pub const CAN_TSR_TME2_Msk: u32 = 268435456;
pub const CAN_TSR_TME2: u32 = 268435456;
pub const CAN_TSR_LOW_Pos: u32 = 29;
pub const CAN_TSR_LOW_Msk: u32 = 3758096384;
pub const CAN_TSR_LOW: u32 = 3758096384;
pub const CAN_TSR_LOW0_Pos: u32 = 29;
pub const CAN_TSR_LOW0_Msk: u32 = 536870912;
pub const CAN_TSR_LOW0: u32 = 536870912;
pub const CAN_TSR_LOW1_Pos: u32 = 30;
pub const CAN_TSR_LOW1_Msk: u32 = 1073741824;
pub const CAN_TSR_LOW1: u32 = 1073741824;
pub const CAN_TSR_LOW2_Pos: u32 = 31;
pub const CAN_TSR_LOW2_Msk: u32 = 2147483648;
pub const CAN_TSR_LOW2: u32 = 2147483648;
pub const CAN_RF0R_FMP0_Pos: u32 = 0;
pub const CAN_RF0R_FMP0_Msk: u32 = 3;
pub const CAN_RF0R_FMP0: u32 = 3;
pub const CAN_RF0R_FULL0_Pos: u32 = 3;
pub const CAN_RF0R_FULL0_Msk: u32 = 8;
pub const CAN_RF0R_FULL0: u32 = 8;
pub const CAN_RF0R_FOVR0_Pos: u32 = 4;
pub const CAN_RF0R_FOVR0_Msk: u32 = 16;
pub const CAN_RF0R_FOVR0: u32 = 16;
pub const CAN_RF0R_RFOM0_Pos: u32 = 5;
pub const CAN_RF0R_RFOM0_Msk: u32 = 32;
pub const CAN_RF0R_RFOM0: u32 = 32;
pub const CAN_RF1R_FMP1_Pos: u32 = 0;
pub const CAN_RF1R_FMP1_Msk: u32 = 3;
pub const CAN_RF1R_FMP1: u32 = 3;
pub const CAN_RF1R_FULL1_Pos: u32 = 3;
pub const CAN_RF1R_FULL1_Msk: u32 = 8;
pub const CAN_RF1R_FULL1: u32 = 8;
pub const CAN_RF1R_FOVR1_Pos: u32 = 4;
pub const CAN_RF1R_FOVR1_Msk: u32 = 16;
pub const CAN_RF1R_FOVR1: u32 = 16;
pub const CAN_RF1R_RFOM1_Pos: u32 = 5;
pub const CAN_RF1R_RFOM1_Msk: u32 = 32;
pub const CAN_RF1R_RFOM1: u32 = 32;
pub const CAN_IER_TMEIE_Pos: u32 = 0;
pub const CAN_IER_TMEIE_Msk: u32 = 1;
pub const CAN_IER_TMEIE: u32 = 1;
pub const CAN_IER_FMPIE0_Pos: u32 = 1;
pub const CAN_IER_FMPIE0_Msk: u32 = 2;
pub const CAN_IER_FMPIE0: u32 = 2;
pub const CAN_IER_FFIE0_Pos: u32 = 2;
pub const CAN_IER_FFIE0_Msk: u32 = 4;
pub const CAN_IER_FFIE0: u32 = 4;
pub const CAN_IER_FOVIE0_Pos: u32 = 3;
pub const CAN_IER_FOVIE0_Msk: u32 = 8;
pub const CAN_IER_FOVIE0: u32 = 8;
pub const CAN_IER_FMPIE1_Pos: u32 = 4;
pub const CAN_IER_FMPIE1_Msk: u32 = 16;
pub const CAN_IER_FMPIE1: u32 = 16;
pub const CAN_IER_FFIE1_Pos: u32 = 5;
pub const CAN_IER_FFIE1_Msk: u32 = 32;
pub const CAN_IER_FFIE1: u32 = 32;
pub const CAN_IER_FOVIE1_Pos: u32 = 6;
pub const CAN_IER_FOVIE1_Msk: u32 = 64;
pub const CAN_IER_FOVIE1: u32 = 64;
pub const CAN_IER_EWGIE_Pos: u32 = 8;
pub const CAN_IER_EWGIE_Msk: u32 = 256;
pub const CAN_IER_EWGIE: u32 = 256;
pub const CAN_IER_EPVIE_Pos: u32 = 9;
pub const CAN_IER_EPVIE_Msk: u32 = 512;
pub const CAN_IER_EPVIE: u32 = 512;
pub const CAN_IER_BOFIE_Pos: u32 = 10;
pub const CAN_IER_BOFIE_Msk: u32 = 1024;
pub const CAN_IER_BOFIE: u32 = 1024;
pub const CAN_IER_LECIE_Pos: u32 = 11;
pub const CAN_IER_LECIE_Msk: u32 = 2048;
pub const CAN_IER_LECIE: u32 = 2048;
pub const CAN_IER_ERRIE_Pos: u32 = 15;
pub const CAN_IER_ERRIE_Msk: u32 = 32768;
pub const CAN_IER_ERRIE: u32 = 32768;
pub const CAN_IER_WKUIE_Pos: u32 = 16;
pub const CAN_IER_WKUIE_Msk: u32 = 65536;
pub const CAN_IER_WKUIE: u32 = 65536;
pub const CAN_IER_SLKIE_Pos: u32 = 17;
pub const CAN_IER_SLKIE_Msk: u32 = 131072;
pub const CAN_IER_SLKIE: u32 = 131072;
pub const CAN_ESR_EWGF_Pos: u32 = 0;
pub const CAN_ESR_EWGF_Msk: u32 = 1;
pub const CAN_ESR_EWGF: u32 = 1;
pub const CAN_ESR_EPVF_Pos: u32 = 1;
pub const CAN_ESR_EPVF_Msk: u32 = 2;
pub const CAN_ESR_EPVF: u32 = 2;
pub const CAN_ESR_BOFF_Pos: u32 = 2;
pub const CAN_ESR_BOFF_Msk: u32 = 4;
pub const CAN_ESR_BOFF: u32 = 4;
pub const CAN_ESR_LEC_Pos: u32 = 4;
pub const CAN_ESR_LEC_Msk: u32 = 112;
pub const CAN_ESR_LEC: u32 = 112;
pub const CAN_ESR_LEC_0: u32 = 16;
pub const CAN_ESR_LEC_1: u32 = 32;
pub const CAN_ESR_LEC_2: u32 = 64;
pub const CAN_ESR_TEC_Pos: u32 = 16;
pub const CAN_ESR_TEC_Msk: u32 = 16711680;
pub const CAN_ESR_TEC: u32 = 16711680;
pub const CAN_ESR_REC_Pos: u32 = 24;
pub const CAN_ESR_REC_Msk: u32 = 4278190080;
pub const CAN_ESR_REC: u32 = 4278190080;
pub const CAN_BTR_BRP_Pos: u32 = 0;
pub const CAN_BTR_BRP_Msk: u32 = 1023;
pub const CAN_BTR_BRP: u32 = 1023;
pub const CAN_BTR_TS1_Pos: u32 = 16;
pub const CAN_BTR_TS1_Msk: u32 = 983040;
pub const CAN_BTR_TS1: u32 = 983040;
pub const CAN_BTR_TS1_0: u32 = 65536;
pub const CAN_BTR_TS1_1: u32 = 131072;
pub const CAN_BTR_TS1_2: u32 = 262144;
pub const CAN_BTR_TS1_3: u32 = 524288;
pub const CAN_BTR_TS2_Pos: u32 = 20;
pub const CAN_BTR_TS2_Msk: u32 = 7340032;
pub const CAN_BTR_TS2: u32 = 7340032;
pub const CAN_BTR_TS2_0: u32 = 1048576;
pub const CAN_BTR_TS2_1: u32 = 2097152;
pub const CAN_BTR_TS2_2: u32 = 4194304;
pub const CAN_BTR_SJW_Pos: u32 = 24;
pub const CAN_BTR_SJW_Msk: u32 = 50331648;
pub const CAN_BTR_SJW: u32 = 50331648;
pub const CAN_BTR_SJW_0: u32 = 16777216;
pub const CAN_BTR_SJW_1: u32 = 33554432;
pub const CAN_BTR_LBKM_Pos: u32 = 30;
pub const CAN_BTR_LBKM_Msk: u32 = 1073741824;
pub const CAN_BTR_LBKM: u32 = 1073741824;
pub const CAN_BTR_SILM_Pos: u32 = 31;
pub const CAN_BTR_SILM_Msk: u32 = 2147483648;
pub const CAN_BTR_SILM: u32 = 2147483648;
pub const CAN_TI0R_TXRQ_Pos: u32 = 0;
pub const CAN_TI0R_TXRQ_Msk: u32 = 1;
pub const CAN_TI0R_TXRQ: u32 = 1;
pub const CAN_TI0R_RTR_Pos: u32 = 1;
pub const CAN_TI0R_RTR_Msk: u32 = 2;
pub const CAN_TI0R_RTR: u32 = 2;
pub const CAN_TI0R_IDE_Pos: u32 = 2;
pub const CAN_TI0R_IDE_Msk: u32 = 4;
pub const CAN_TI0R_IDE: u32 = 4;
pub const CAN_TI0R_EXID_Pos: u32 = 3;
pub const CAN_TI0R_EXID_Msk: u32 = 2097144;
pub const CAN_TI0R_EXID: u32 = 2097144;
pub const CAN_TI0R_STID_Pos: u32 = 21;
pub const CAN_TI0R_STID_Msk: u32 = 4292870144;
pub const CAN_TI0R_STID: u32 = 4292870144;
pub const CAN_TDT0R_DLC_Pos: u32 = 0;
pub const CAN_TDT0R_DLC_Msk: u32 = 15;
pub const CAN_TDT0R_DLC: u32 = 15;
pub const CAN_TDT0R_TGT_Pos: u32 = 8;
pub const CAN_TDT0R_TGT_Msk: u32 = 256;
pub const CAN_TDT0R_TGT: u32 = 256;
pub const CAN_TDT0R_TIME_Pos: u32 = 16;
pub const CAN_TDT0R_TIME_Msk: u32 = 4294901760;
pub const CAN_TDT0R_TIME: u32 = 4294901760;
pub const CAN_TDL0R_DATA0_Pos: u32 = 0;
pub const CAN_TDL0R_DATA0_Msk: u32 = 255;
pub const CAN_TDL0R_DATA0: u32 = 255;
pub const CAN_TDL0R_DATA1_Pos: u32 = 8;
pub const CAN_TDL0R_DATA1_Msk: u32 = 65280;
pub const CAN_TDL0R_DATA1: u32 = 65280;
pub const CAN_TDL0R_DATA2_Pos: u32 = 16;
pub const CAN_TDL0R_DATA2_Msk: u32 = 16711680;
pub const CAN_TDL0R_DATA2: u32 = 16711680;
pub const CAN_TDL0R_DATA3_Pos: u32 = 24;
pub const CAN_TDL0R_DATA3_Msk: u32 = 4278190080;
pub const CAN_TDL0R_DATA3: u32 = 4278190080;
pub const CAN_TDH0R_DATA4_Pos: u32 = 0;
pub const CAN_TDH0R_DATA4_Msk: u32 = 255;
pub const CAN_TDH0R_DATA4: u32 = 255;
pub const CAN_TDH0R_DATA5_Pos: u32 = 8;
pub const CAN_TDH0R_DATA5_Msk: u32 = 65280;
pub const CAN_TDH0R_DATA5: u32 = 65280;
pub const CAN_TDH0R_DATA6_Pos: u32 = 16;
pub const CAN_TDH0R_DATA6_Msk: u32 = 16711680;
pub const CAN_TDH0R_DATA6: u32 = 16711680;
pub const CAN_TDH0R_DATA7_Pos: u32 = 24;
pub const CAN_TDH0R_DATA7_Msk: u32 = 4278190080;
pub const CAN_TDH0R_DATA7: u32 = 4278190080;
pub const CAN_TI1R_TXRQ_Pos: u32 = 0;
pub const CAN_TI1R_TXRQ_Msk: u32 = 1;
pub const CAN_TI1R_TXRQ: u32 = 1;
pub const CAN_TI1R_RTR_Pos: u32 = 1;
pub const CAN_TI1R_RTR_Msk: u32 = 2;
pub const CAN_TI1R_RTR: u32 = 2;
pub const CAN_TI1R_IDE_Pos: u32 = 2;
pub const CAN_TI1R_IDE_Msk: u32 = 4;
pub const CAN_TI1R_IDE: u32 = 4;
pub const CAN_TI1R_EXID_Pos: u32 = 3;
pub const CAN_TI1R_EXID_Msk: u32 = 2097144;
pub const CAN_TI1R_EXID: u32 = 2097144;
pub const CAN_TI1R_STID_Pos: u32 = 21;
pub const CAN_TI1R_STID_Msk: u32 = 4292870144;
pub const CAN_TI1R_STID: u32 = 4292870144;
pub const CAN_TDT1R_DLC_Pos: u32 = 0;
pub const CAN_TDT1R_DLC_Msk: u32 = 15;
pub const CAN_TDT1R_DLC: u32 = 15;
pub const CAN_TDT1R_TGT_Pos: u32 = 8;
pub const CAN_TDT1R_TGT_Msk: u32 = 256;
pub const CAN_TDT1R_TGT: u32 = 256;
pub const CAN_TDT1R_TIME_Pos: u32 = 16;
pub const CAN_TDT1R_TIME_Msk: u32 = 4294901760;
pub const CAN_TDT1R_TIME: u32 = 4294901760;
pub const CAN_TDL1R_DATA0_Pos: u32 = 0;
pub const CAN_TDL1R_DATA0_Msk: u32 = 255;
pub const CAN_TDL1R_DATA0: u32 = 255;
pub const CAN_TDL1R_DATA1_Pos: u32 = 8;
pub const CAN_TDL1R_DATA1_Msk: u32 = 65280;
pub const CAN_TDL1R_DATA1: u32 = 65280;
pub const CAN_TDL1R_DATA2_Pos: u32 = 16;
pub const CAN_TDL1R_DATA2_Msk: u32 = 16711680;
pub const CAN_TDL1R_DATA2: u32 = 16711680;
pub const CAN_TDL1R_DATA3_Pos: u32 = 24;
pub const CAN_TDL1R_DATA3_Msk: u32 = 4278190080;
pub const CAN_TDL1R_DATA3: u32 = 4278190080;
pub const CAN_TDH1R_DATA4_Pos: u32 = 0;
pub const CAN_TDH1R_DATA4_Msk: u32 = 255;
pub const CAN_TDH1R_DATA4: u32 = 255;
pub const CAN_TDH1R_DATA5_Pos: u32 = 8;
pub const CAN_TDH1R_DATA5_Msk: u32 = 65280;
pub const CAN_TDH1R_DATA5: u32 = 65280;
pub const CAN_TDH1R_DATA6_Pos: u32 = 16;
pub const CAN_TDH1R_DATA6_Msk: u32 = 16711680;
pub const CAN_TDH1R_DATA6: u32 = 16711680;
pub const CAN_TDH1R_DATA7_Pos: u32 = 24;
pub const CAN_TDH1R_DATA7_Msk: u32 = 4278190080;
pub const CAN_TDH1R_DATA7: u32 = 4278190080;
pub const CAN_TI2R_TXRQ_Pos: u32 = 0;
pub const CAN_TI2R_TXRQ_Msk: u32 = 1;
pub const CAN_TI2R_TXRQ: u32 = 1;
pub const CAN_TI2R_RTR_Pos: u32 = 1;
pub const CAN_TI2R_RTR_Msk: u32 = 2;
pub const CAN_TI2R_RTR: u32 = 2;
pub const CAN_TI2R_IDE_Pos: u32 = 2;
pub const CAN_TI2R_IDE_Msk: u32 = 4;
pub const CAN_TI2R_IDE: u32 = 4;
pub const CAN_TI2R_EXID_Pos: u32 = 3;
pub const CAN_TI2R_EXID_Msk: u32 = 2097144;
pub const CAN_TI2R_EXID: u32 = 2097144;
pub const CAN_TI2R_STID_Pos: u32 = 21;
pub const CAN_TI2R_STID_Msk: u32 = 4292870144;
pub const CAN_TI2R_STID: u32 = 4292870144;
pub const CAN_TDT2R_DLC_Pos: u32 = 0;
pub const CAN_TDT2R_DLC_Msk: u32 = 15;
pub const CAN_TDT2R_DLC: u32 = 15;
pub const CAN_TDT2R_TGT_Pos: u32 = 8;
pub const CAN_TDT2R_TGT_Msk: u32 = 256;
pub const CAN_TDT2R_TGT: u32 = 256;
pub const CAN_TDT2R_TIME_Pos: u32 = 16;
pub const CAN_TDT2R_TIME_Msk: u32 = 4294901760;
pub const CAN_TDT2R_TIME: u32 = 4294901760;
pub const CAN_TDL2R_DATA0_Pos: u32 = 0;
pub const CAN_TDL2R_DATA0_Msk: u32 = 255;
pub const CAN_TDL2R_DATA0: u32 = 255;
pub const CAN_TDL2R_DATA1_Pos: u32 = 8;
pub const CAN_TDL2R_DATA1_Msk: u32 = 65280;
pub const CAN_TDL2R_DATA1: u32 = 65280;
pub const CAN_TDL2R_DATA2_Pos: u32 = 16;
pub const CAN_TDL2R_DATA2_Msk: u32 = 16711680;
pub const CAN_TDL2R_DATA2: u32 = 16711680;
pub const CAN_TDL2R_DATA3_Pos: u32 = 24;
pub const CAN_TDL2R_DATA3_Msk: u32 = 4278190080;
pub const CAN_TDL2R_DATA3: u32 = 4278190080;
pub const CAN_TDH2R_DATA4_Pos: u32 = 0;
pub const CAN_TDH2R_DATA4_Msk: u32 = 255;
pub const CAN_TDH2R_DATA4: u32 = 255;
pub const CAN_TDH2R_DATA5_Pos: u32 = 8;
pub const CAN_TDH2R_DATA5_Msk: u32 = 65280;
pub const CAN_TDH2R_DATA5: u32 = 65280;
pub const CAN_TDH2R_DATA6_Pos: u32 = 16;
pub const CAN_TDH2R_DATA6_Msk: u32 = 16711680;
pub const CAN_TDH2R_DATA6: u32 = 16711680;
pub const CAN_TDH2R_DATA7_Pos: u32 = 24;
pub const CAN_TDH2R_DATA7_Msk: u32 = 4278190080;
pub const CAN_TDH2R_DATA7: u32 = 4278190080;
pub const CAN_RI0R_RTR_Pos: u32 = 1;
pub const CAN_RI0R_RTR_Msk: u32 = 2;
pub const CAN_RI0R_RTR: u32 = 2;
pub const CAN_RI0R_IDE_Pos: u32 = 2;
pub const CAN_RI0R_IDE_Msk: u32 = 4;
pub const CAN_RI0R_IDE: u32 = 4;
pub const CAN_RI0R_EXID_Pos: u32 = 3;
pub const CAN_RI0R_EXID_Msk: u32 = 2097144;
pub const CAN_RI0R_EXID: u32 = 2097144;
pub const CAN_RI0R_STID_Pos: u32 = 21;
pub const CAN_RI0R_STID_Msk: u32 = 4292870144;
pub const CAN_RI0R_STID: u32 = 4292870144;
pub const CAN_RDT0R_DLC_Pos: u32 = 0;
pub const CAN_RDT0R_DLC_Msk: u32 = 15;
pub const CAN_RDT0R_DLC: u32 = 15;
pub const CAN_RDT0R_FMI_Pos: u32 = 8;
pub const CAN_RDT0R_FMI_Msk: u32 = 65280;
pub const CAN_RDT0R_FMI: u32 = 65280;
pub const CAN_RDT0R_TIME_Pos: u32 = 16;
pub const CAN_RDT0R_TIME_Msk: u32 = 4294901760;
pub const CAN_RDT0R_TIME: u32 = 4294901760;
pub const CAN_RDL0R_DATA0_Pos: u32 = 0;
pub const CAN_RDL0R_DATA0_Msk: u32 = 255;
pub const CAN_RDL0R_DATA0: u32 = 255;
pub const CAN_RDL0R_DATA1_Pos: u32 = 8;
pub const CAN_RDL0R_DATA1_Msk: u32 = 65280;
pub const CAN_RDL0R_DATA1: u32 = 65280;
pub const CAN_RDL0R_DATA2_Pos: u32 = 16;
pub const CAN_RDL0R_DATA2_Msk: u32 = 16711680;
pub const CAN_RDL0R_DATA2: u32 = 16711680;
pub const CAN_RDL0R_DATA3_Pos: u32 = 24;
pub const CAN_RDL0R_DATA3_Msk: u32 = 4278190080;
pub const CAN_RDL0R_DATA3: u32 = 4278190080;
pub const CAN_RDH0R_DATA4_Pos: u32 = 0;
pub const CAN_RDH0R_DATA4_Msk: u32 = 255;
pub const CAN_RDH0R_DATA4: u32 = 255;
pub const CAN_RDH0R_DATA5_Pos: u32 = 8;
pub const CAN_RDH0R_DATA5_Msk: u32 = 65280;
pub const CAN_RDH0R_DATA5: u32 = 65280;
pub const CAN_RDH0R_DATA6_Pos: u32 = 16;
pub const CAN_RDH0R_DATA6_Msk: u32 = 16711680;
pub const CAN_RDH0R_DATA6: u32 = 16711680;
pub const CAN_RDH0R_DATA7_Pos: u32 = 24;
pub const CAN_RDH0R_DATA7_Msk: u32 = 4278190080;
pub const CAN_RDH0R_DATA7: u32 = 4278190080;
pub const CAN_RI1R_RTR_Pos: u32 = 1;
pub const CAN_RI1R_RTR_Msk: u32 = 2;
pub const CAN_RI1R_RTR: u32 = 2;
pub const CAN_RI1R_IDE_Pos: u32 = 2;
pub const CAN_RI1R_IDE_Msk: u32 = 4;
pub const CAN_RI1R_IDE: u32 = 4;
pub const CAN_RI1R_EXID_Pos: u32 = 3;
pub const CAN_RI1R_EXID_Msk: u32 = 2097144;
pub const CAN_RI1R_EXID: u32 = 2097144;
pub const CAN_RI1R_STID_Pos: u32 = 21;
pub const CAN_RI1R_STID_Msk: u32 = 4292870144;
pub const CAN_RI1R_STID: u32 = 4292870144;
pub const CAN_RDT1R_DLC_Pos: u32 = 0;
pub const CAN_RDT1R_DLC_Msk: u32 = 15;
pub const CAN_RDT1R_DLC: u32 = 15;
pub const CAN_RDT1R_FMI_Pos: u32 = 8;
pub const CAN_RDT1R_FMI_Msk: u32 = 65280;
pub const CAN_RDT1R_FMI: u32 = 65280;
pub const CAN_RDT1R_TIME_Pos: u32 = 16;
pub const CAN_RDT1R_TIME_Msk: u32 = 4294901760;
pub const CAN_RDT1R_TIME: u32 = 4294901760;
pub const CAN_RDL1R_DATA0_Pos: u32 = 0;
pub const CAN_RDL1R_DATA0_Msk: u32 = 255;
pub const CAN_RDL1R_DATA0: u32 = 255;
pub const CAN_RDL1R_DATA1_Pos: u32 = 8;
pub const CAN_RDL1R_DATA1_Msk: u32 = 65280;
pub const CAN_RDL1R_DATA1: u32 = 65280;
pub const CAN_RDL1R_DATA2_Pos: u32 = 16;
pub const CAN_RDL1R_DATA2_Msk: u32 = 16711680;
pub const CAN_RDL1R_DATA2: u32 = 16711680;
pub const CAN_RDL1R_DATA3_Pos: u32 = 24;
pub const CAN_RDL1R_DATA3_Msk: u32 = 4278190080;
pub const CAN_RDL1R_DATA3: u32 = 4278190080;
pub const CAN_RDH1R_DATA4_Pos: u32 = 0;
pub const CAN_RDH1R_DATA4_Msk: u32 = 255;
pub const CAN_RDH1R_DATA4: u32 = 255;
pub const CAN_RDH1R_DATA5_Pos: u32 = 8;
pub const CAN_RDH1R_DATA5_Msk: u32 = 65280;
pub const CAN_RDH1R_DATA5: u32 = 65280;
pub const CAN_RDH1R_DATA6_Pos: u32 = 16;
pub const CAN_RDH1R_DATA6_Msk: u32 = 16711680;
pub const CAN_RDH1R_DATA6: u32 = 16711680;
pub const CAN_RDH1R_DATA7_Pos: u32 = 24;
pub const CAN_RDH1R_DATA7_Msk: u32 = 4278190080;
pub const CAN_RDH1R_DATA7: u32 = 4278190080;
pub const CAN_FMR_FINIT_Pos: u32 = 0;
pub const CAN_FMR_FINIT_Msk: u32 = 1;
pub const CAN_FMR_FINIT: u32 = 1;
pub const CAN_FM1R_FBM_Pos: u32 = 0;
pub const CAN_FM1R_FBM_Msk: u32 = 16383;
pub const CAN_FM1R_FBM: u32 = 16383;
pub const CAN_FM1R_FBM0_Pos: u32 = 0;
pub const CAN_FM1R_FBM0_Msk: u32 = 1;
pub const CAN_FM1R_FBM0: u32 = 1;
pub const CAN_FM1R_FBM1_Pos: u32 = 1;
pub const CAN_FM1R_FBM1_Msk: u32 = 2;
pub const CAN_FM1R_FBM1: u32 = 2;
pub const CAN_FM1R_FBM2_Pos: u32 = 2;
pub const CAN_FM1R_FBM2_Msk: u32 = 4;
pub const CAN_FM1R_FBM2: u32 = 4;
pub const CAN_FM1R_FBM3_Pos: u32 = 3;
pub const CAN_FM1R_FBM3_Msk: u32 = 8;
pub const CAN_FM1R_FBM3: u32 = 8;
pub const CAN_FM1R_FBM4_Pos: u32 = 4;
pub const CAN_FM1R_FBM4_Msk: u32 = 16;
pub const CAN_FM1R_FBM4: u32 = 16;
pub const CAN_FM1R_FBM5_Pos: u32 = 5;
pub const CAN_FM1R_FBM5_Msk: u32 = 32;
pub const CAN_FM1R_FBM5: u32 = 32;
pub const CAN_FM1R_FBM6_Pos: u32 = 6;
pub const CAN_FM1R_FBM6_Msk: u32 = 64;
pub const CAN_FM1R_FBM6: u32 = 64;
pub const CAN_FM1R_FBM7_Pos: u32 = 7;
pub const CAN_FM1R_FBM7_Msk: u32 = 128;
pub const CAN_FM1R_FBM7: u32 = 128;
pub const CAN_FM1R_FBM8_Pos: u32 = 8;
pub const CAN_FM1R_FBM8_Msk: u32 = 256;
pub const CAN_FM1R_FBM8: u32 = 256;
pub const CAN_FM1R_FBM9_Pos: u32 = 9;
pub const CAN_FM1R_FBM9_Msk: u32 = 512;
pub const CAN_FM1R_FBM9: u32 = 512;
pub const CAN_FM1R_FBM10_Pos: u32 = 10;
pub const CAN_FM1R_FBM10_Msk: u32 = 1024;
pub const CAN_FM1R_FBM10: u32 = 1024;
pub const CAN_FM1R_FBM11_Pos: u32 = 11;
pub const CAN_FM1R_FBM11_Msk: u32 = 2048;
pub const CAN_FM1R_FBM11: u32 = 2048;
pub const CAN_FM1R_FBM12_Pos: u32 = 12;
pub const CAN_FM1R_FBM12_Msk: u32 = 4096;
pub const CAN_FM1R_FBM12: u32 = 4096;
pub const CAN_FM1R_FBM13_Pos: u32 = 13;
pub const CAN_FM1R_FBM13_Msk: u32 = 8192;
pub const CAN_FM1R_FBM13: u32 = 8192;
pub const CAN_FS1R_FSC_Pos: u32 = 0;
pub const CAN_FS1R_FSC_Msk: u32 = 16383;
pub const CAN_FS1R_FSC: u32 = 16383;
pub const CAN_FS1R_FSC0_Pos: u32 = 0;
pub const CAN_FS1R_FSC0_Msk: u32 = 1;
pub const CAN_FS1R_FSC0: u32 = 1;
pub const CAN_FS1R_FSC1_Pos: u32 = 1;
pub const CAN_FS1R_FSC1_Msk: u32 = 2;
pub const CAN_FS1R_FSC1: u32 = 2;
pub const CAN_FS1R_FSC2_Pos: u32 = 2;
pub const CAN_FS1R_FSC2_Msk: u32 = 4;
pub const CAN_FS1R_FSC2: u32 = 4;
pub const CAN_FS1R_FSC3_Pos: u32 = 3;
pub const CAN_FS1R_FSC3_Msk: u32 = 8;
pub const CAN_FS1R_FSC3: u32 = 8;
pub const CAN_FS1R_FSC4_Pos: u32 = 4;
pub const CAN_FS1R_FSC4_Msk: u32 = 16;
pub const CAN_FS1R_FSC4: u32 = 16;
pub const CAN_FS1R_FSC5_Pos: u32 = 5;
pub const CAN_FS1R_FSC5_Msk: u32 = 32;
pub const CAN_FS1R_FSC5: u32 = 32;
pub const CAN_FS1R_FSC6_Pos: u32 = 6;
pub const CAN_FS1R_FSC6_Msk: u32 = 64;
pub const CAN_FS1R_FSC6: u32 = 64;
pub const CAN_FS1R_FSC7_Pos: u32 = 7;
pub const CAN_FS1R_FSC7_Msk: u32 = 128;
pub const CAN_FS1R_FSC7: u32 = 128;
pub const CAN_FS1R_FSC8_Pos: u32 = 8;
pub const CAN_FS1R_FSC8_Msk: u32 = 256;
pub const CAN_FS1R_FSC8: u32 = 256;
pub const CAN_FS1R_FSC9_Pos: u32 = 9;
pub const CAN_FS1R_FSC9_Msk: u32 = 512;
pub const CAN_FS1R_FSC9: u32 = 512;
pub const CAN_FS1R_FSC10_Pos: u32 = 10;
pub const CAN_FS1R_FSC10_Msk: u32 = 1024;
pub const CAN_FS1R_FSC10: u32 = 1024;
pub const CAN_FS1R_FSC11_Pos: u32 = 11;
pub const CAN_FS1R_FSC11_Msk: u32 = 2048;
pub const CAN_FS1R_FSC11: u32 = 2048;
pub const CAN_FS1R_FSC12_Pos: u32 = 12;
pub const CAN_FS1R_FSC12_Msk: u32 = 4096;
pub const CAN_FS1R_FSC12: u32 = 4096;
pub const CAN_FS1R_FSC13_Pos: u32 = 13;
pub const CAN_FS1R_FSC13_Msk: u32 = 8192;
pub const CAN_FS1R_FSC13: u32 = 8192;
pub const CAN_FFA1R_FFA_Pos: u32 = 0;
pub const CAN_FFA1R_FFA_Msk: u32 = 16383;
pub const CAN_FFA1R_FFA: u32 = 16383;
pub const CAN_FFA1R_FFA0_Pos: u32 = 0;
pub const CAN_FFA1R_FFA0_Msk: u32 = 1;
pub const CAN_FFA1R_FFA0: u32 = 1;
pub const CAN_FFA1R_FFA1_Pos: u32 = 1;
pub const CAN_FFA1R_FFA1_Msk: u32 = 2;
pub const CAN_FFA1R_FFA1: u32 = 2;
pub const CAN_FFA1R_FFA2_Pos: u32 = 2;
pub const CAN_FFA1R_FFA2_Msk: u32 = 4;
pub const CAN_FFA1R_FFA2: u32 = 4;
pub const CAN_FFA1R_FFA3_Pos: u32 = 3;
pub const CAN_FFA1R_FFA3_Msk: u32 = 8;
pub const CAN_FFA1R_FFA3: u32 = 8;
pub const CAN_FFA1R_FFA4_Pos: u32 = 4;
pub const CAN_FFA1R_FFA4_Msk: u32 = 16;
pub const CAN_FFA1R_FFA4: u32 = 16;
pub const CAN_FFA1R_FFA5_Pos: u32 = 5;
pub const CAN_FFA1R_FFA5_Msk: u32 = 32;
pub const CAN_FFA1R_FFA5: u32 = 32;
pub const CAN_FFA1R_FFA6_Pos: u32 = 6;
pub const CAN_FFA1R_FFA6_Msk: u32 = 64;
pub const CAN_FFA1R_FFA6: u32 = 64;
pub const CAN_FFA1R_FFA7_Pos: u32 = 7;
pub const CAN_FFA1R_FFA7_Msk: u32 = 128;
pub const CAN_FFA1R_FFA7: u32 = 128;
pub const CAN_FFA1R_FFA8_Pos: u32 = 8;
pub const CAN_FFA1R_FFA8_Msk: u32 = 256;
pub const CAN_FFA1R_FFA8: u32 = 256;
pub const CAN_FFA1R_FFA9_Pos: u32 = 9;
pub const CAN_FFA1R_FFA9_Msk: u32 = 512;
pub const CAN_FFA1R_FFA9: u32 = 512;
pub const CAN_FFA1R_FFA10_Pos: u32 = 10;
pub const CAN_FFA1R_FFA10_Msk: u32 = 1024;
pub const CAN_FFA1R_FFA10: u32 = 1024;
pub const CAN_FFA1R_FFA11_Pos: u32 = 11;
pub const CAN_FFA1R_FFA11_Msk: u32 = 2048;
pub const CAN_FFA1R_FFA11: u32 = 2048;
pub const CAN_FFA1R_FFA12_Pos: u32 = 12;
pub const CAN_FFA1R_FFA12_Msk: u32 = 4096;
pub const CAN_FFA1R_FFA12: u32 = 4096;
pub const CAN_FFA1R_FFA13_Pos: u32 = 13;
pub const CAN_FFA1R_FFA13_Msk: u32 = 8192;
pub const CAN_FFA1R_FFA13: u32 = 8192;
pub const CAN_FA1R_FACT_Pos: u32 = 0;
pub const CAN_FA1R_FACT_Msk: u32 = 16383;
pub const CAN_FA1R_FACT: u32 = 16383;
pub const CAN_FA1R_FACT0_Pos: u32 = 0;
pub const CAN_FA1R_FACT0_Msk: u32 = 1;
pub const CAN_FA1R_FACT0: u32 = 1;
pub const CAN_FA1R_FACT1_Pos: u32 = 1;
pub const CAN_FA1R_FACT1_Msk: u32 = 2;
pub const CAN_FA1R_FACT1: u32 = 2;
pub const CAN_FA1R_FACT2_Pos: u32 = 2;
pub const CAN_FA1R_FACT2_Msk: u32 = 4;
pub const CAN_FA1R_FACT2: u32 = 4;
pub const CAN_FA1R_FACT3_Pos: u32 = 3;
pub const CAN_FA1R_FACT3_Msk: u32 = 8;
pub const CAN_FA1R_FACT3: u32 = 8;
pub const CAN_FA1R_FACT4_Pos: u32 = 4;
pub const CAN_FA1R_FACT4_Msk: u32 = 16;
pub const CAN_FA1R_FACT4: u32 = 16;
pub const CAN_FA1R_FACT5_Pos: u32 = 5;
pub const CAN_FA1R_FACT5_Msk: u32 = 32;
pub const CAN_FA1R_FACT5: u32 = 32;
pub const CAN_FA1R_FACT6_Pos: u32 = 6;
pub const CAN_FA1R_FACT6_Msk: u32 = 64;
pub const CAN_FA1R_FACT6: u32 = 64;
pub const CAN_FA1R_FACT7_Pos: u32 = 7;
pub const CAN_FA1R_FACT7_Msk: u32 = 128;
pub const CAN_FA1R_FACT7: u32 = 128;
pub const CAN_FA1R_FACT8_Pos: u32 = 8;
pub const CAN_FA1R_FACT8_Msk: u32 = 256;
pub const CAN_FA1R_FACT8: u32 = 256;
pub const CAN_FA1R_FACT9_Pos: u32 = 9;
pub const CAN_FA1R_FACT9_Msk: u32 = 512;
pub const CAN_FA1R_FACT9: u32 = 512;
pub const CAN_FA1R_FACT10_Pos: u32 = 10;
pub const CAN_FA1R_FACT10_Msk: u32 = 1024;
pub const CAN_FA1R_FACT10: u32 = 1024;
pub const CAN_FA1R_FACT11_Pos: u32 = 11;
pub const CAN_FA1R_FACT11_Msk: u32 = 2048;
pub const CAN_FA1R_FACT11: u32 = 2048;
pub const CAN_FA1R_FACT12_Pos: u32 = 12;
pub const CAN_FA1R_FACT12_Msk: u32 = 4096;
pub const CAN_FA1R_FACT12: u32 = 4096;
pub const CAN_FA1R_FACT13_Pos: u32 = 13;
pub const CAN_FA1R_FACT13_Msk: u32 = 8192;
pub const CAN_FA1R_FACT13: u32 = 8192;
pub const CAN_F0R1_FB0_Pos: u32 = 0;
pub const CAN_F0R1_FB0_Msk: u32 = 1;
pub const CAN_F0R1_FB0: u32 = 1;
pub const CAN_F0R1_FB1_Pos: u32 = 1;
pub const CAN_F0R1_FB1_Msk: u32 = 2;
pub const CAN_F0R1_FB1: u32 = 2;
pub const CAN_F0R1_FB2_Pos: u32 = 2;
pub const CAN_F0R1_FB2_Msk: u32 = 4;
pub const CAN_F0R1_FB2: u32 = 4;
pub const CAN_F0R1_FB3_Pos: u32 = 3;
pub const CAN_F0R1_FB3_Msk: u32 = 8;
pub const CAN_F0R1_FB3: u32 = 8;
pub const CAN_F0R1_FB4_Pos: u32 = 4;
pub const CAN_F0R1_FB4_Msk: u32 = 16;
pub const CAN_F0R1_FB4: u32 = 16;
pub const CAN_F0R1_FB5_Pos: u32 = 5;
pub const CAN_F0R1_FB5_Msk: u32 = 32;
pub const CAN_F0R1_FB5: u32 = 32;
pub const CAN_F0R1_FB6_Pos: u32 = 6;
pub const CAN_F0R1_FB6_Msk: u32 = 64;
pub const CAN_F0R1_FB6: u32 = 64;
pub const CAN_F0R1_FB7_Pos: u32 = 7;
pub const CAN_F0R1_FB7_Msk: u32 = 128;
pub const CAN_F0R1_FB7: u32 = 128;
pub const CAN_F0R1_FB8_Pos: u32 = 8;
pub const CAN_F0R1_FB8_Msk: u32 = 256;
pub const CAN_F0R1_FB8: u32 = 256;
pub const CAN_F0R1_FB9_Pos: u32 = 9;
pub const CAN_F0R1_FB9_Msk: u32 = 512;
pub const CAN_F0R1_FB9: u32 = 512;
pub const CAN_F0R1_FB10_Pos: u32 = 10;
pub const CAN_F0R1_FB10_Msk: u32 = 1024;
pub const CAN_F0R1_FB10: u32 = 1024;
pub const CAN_F0R1_FB11_Pos: u32 = 11;
pub const CAN_F0R1_FB11_Msk: u32 = 2048;
pub const CAN_F0R1_FB11: u32 = 2048;
pub const CAN_F0R1_FB12_Pos: u32 = 12;
pub const CAN_F0R1_FB12_Msk: u32 = 4096;
pub const CAN_F0R1_FB12: u32 = 4096;
pub const CAN_F0R1_FB13_Pos: u32 = 13;
pub const CAN_F0R1_FB13_Msk: u32 = 8192;
pub const CAN_F0R1_FB13: u32 = 8192;
pub const CAN_F0R1_FB14_Pos: u32 = 14;
pub const CAN_F0R1_FB14_Msk: u32 = 16384;
pub const CAN_F0R1_FB14: u32 = 16384;
pub const CAN_F0R1_FB15_Pos: u32 = 15;
pub const CAN_F0R1_FB15_Msk: u32 = 32768;
pub const CAN_F0R1_FB15: u32 = 32768;
pub const CAN_F0R1_FB16_Pos: u32 = 16;
pub const CAN_F0R1_FB16_Msk: u32 = 65536;
pub const CAN_F0R1_FB16: u32 = 65536;
pub const CAN_F0R1_FB17_Pos: u32 = 17;
pub const CAN_F0R1_FB17_Msk: u32 = 131072;
pub const CAN_F0R1_FB17: u32 = 131072;
pub const CAN_F0R1_FB18_Pos: u32 = 18;
pub const CAN_F0R1_FB18_Msk: u32 = 262144;
pub const CAN_F0R1_FB18: u32 = 262144;
pub const CAN_F0R1_FB19_Pos: u32 = 19;
pub const CAN_F0R1_FB19_Msk: u32 = 524288;
pub const CAN_F0R1_FB19: u32 = 524288;
pub const CAN_F0R1_FB20_Pos: u32 = 20;
pub const CAN_F0R1_FB20_Msk: u32 = 1048576;
pub const CAN_F0R1_FB20: u32 = 1048576;
pub const CAN_F0R1_FB21_Pos: u32 = 21;
pub const CAN_F0R1_FB21_Msk: u32 = 2097152;
pub const CAN_F0R1_FB21: u32 = 2097152;
pub const CAN_F0R1_FB22_Pos: u32 = 22;
pub const CAN_F0R1_FB22_Msk: u32 = 4194304;
pub const CAN_F0R1_FB22: u32 = 4194304;
pub const CAN_F0R1_FB23_Pos: u32 = 23;
pub const CAN_F0R1_FB23_Msk: u32 = 8388608;
pub const CAN_F0R1_FB23: u32 = 8388608;
pub const CAN_F0R1_FB24_Pos: u32 = 24;
pub const CAN_F0R1_FB24_Msk: u32 = 16777216;
pub const CAN_F0R1_FB24: u32 = 16777216;
pub const CAN_F0R1_FB25_Pos: u32 = 25;
pub const CAN_F0R1_FB25_Msk: u32 = 33554432;
pub const CAN_F0R1_FB25: u32 = 33554432;
pub const CAN_F0R1_FB26_Pos: u32 = 26;
pub const CAN_F0R1_FB26_Msk: u32 = 67108864;
pub const CAN_F0R1_FB26: u32 = 67108864;
pub const CAN_F0R1_FB27_Pos: u32 = 27;
pub const CAN_F0R1_FB27_Msk: u32 = 134217728;
pub const CAN_F0R1_FB27: u32 = 134217728;
pub const CAN_F0R1_FB28_Pos: u32 = 28;
pub const CAN_F0R1_FB28_Msk: u32 = 268435456;
pub const CAN_F0R1_FB28: u32 = 268435456;
pub const CAN_F0R1_FB29_Pos: u32 = 29;
pub const CAN_F0R1_FB29_Msk: u32 = 536870912;
pub const CAN_F0R1_FB29: u32 = 536870912;
pub const CAN_F0R1_FB30_Pos: u32 = 30;
pub const CAN_F0R1_FB30_Msk: u32 = 1073741824;
pub const CAN_F0R1_FB30: u32 = 1073741824;
pub const CAN_F0R1_FB31_Pos: u32 = 31;
pub const CAN_F0R1_FB31_Msk: u32 = 2147483648;
pub const CAN_F0R1_FB31: u32 = 2147483648;
pub const CAN_F1R1_FB0_Pos: u32 = 0;
pub const CAN_F1R1_FB0_Msk: u32 = 1;
pub const CAN_F1R1_FB0: u32 = 1;
pub const CAN_F1R1_FB1_Pos: u32 = 1;
pub const CAN_F1R1_FB1_Msk: u32 = 2;
pub const CAN_F1R1_FB1: u32 = 2;
pub const CAN_F1R1_FB2_Pos: u32 = 2;
pub const CAN_F1R1_FB2_Msk: u32 = 4;
pub const CAN_F1R1_FB2: u32 = 4;
pub const CAN_F1R1_FB3_Pos: u32 = 3;
pub const CAN_F1R1_FB3_Msk: u32 = 8;
pub const CAN_F1R1_FB3: u32 = 8;
pub const CAN_F1R1_FB4_Pos: u32 = 4;
pub const CAN_F1R1_FB4_Msk: u32 = 16;
pub const CAN_F1R1_FB4: u32 = 16;
pub const CAN_F1R1_FB5_Pos: u32 = 5;
pub const CAN_F1R1_FB5_Msk: u32 = 32;
pub const CAN_F1R1_FB5: u32 = 32;
pub const CAN_F1R1_FB6_Pos: u32 = 6;
pub const CAN_F1R1_FB6_Msk: u32 = 64;
pub const CAN_F1R1_FB6: u32 = 64;
pub const CAN_F1R1_FB7_Pos: u32 = 7;
pub const CAN_F1R1_FB7_Msk: u32 = 128;
pub const CAN_F1R1_FB7: u32 = 128;
pub const CAN_F1R1_FB8_Pos: u32 = 8;
pub const CAN_F1R1_FB8_Msk: u32 = 256;
pub const CAN_F1R1_FB8: u32 = 256;
pub const CAN_F1R1_FB9_Pos: u32 = 9;
pub const CAN_F1R1_FB9_Msk: u32 = 512;
pub const CAN_F1R1_FB9: u32 = 512;
pub const CAN_F1R1_FB10_Pos: u32 = 10;
pub const CAN_F1R1_FB10_Msk: u32 = 1024;
pub const CAN_F1R1_FB10: u32 = 1024;
pub const CAN_F1R1_FB11_Pos: u32 = 11;
pub const CAN_F1R1_FB11_Msk: u32 = 2048;
pub const CAN_F1R1_FB11: u32 = 2048;
pub const CAN_F1R1_FB12_Pos: u32 = 12;
pub const CAN_F1R1_FB12_Msk: u32 = 4096;
pub const CAN_F1R1_FB12: u32 = 4096;
pub const CAN_F1R1_FB13_Pos: u32 = 13;
pub const CAN_F1R1_FB13_Msk: u32 = 8192;
pub const CAN_F1R1_FB13: u32 = 8192;
pub const CAN_F1R1_FB14_Pos: u32 = 14;
pub const CAN_F1R1_FB14_Msk: u32 = 16384;
pub const CAN_F1R1_FB14: u32 = 16384;
pub const CAN_F1R1_FB15_Pos: u32 = 15;
pub const CAN_F1R1_FB15_Msk: u32 = 32768;
pub const CAN_F1R1_FB15: u32 = 32768;
pub const CAN_F1R1_FB16_Pos: u32 = 16;
pub const CAN_F1R1_FB16_Msk: u32 = 65536;
pub const CAN_F1R1_FB16: u32 = 65536;
pub const CAN_F1R1_FB17_Pos: u32 = 17;
pub const CAN_F1R1_FB17_Msk: u32 = 131072;
pub const CAN_F1R1_FB17: u32 = 131072;
pub const CAN_F1R1_FB18_Pos: u32 = 18;
pub const CAN_F1R1_FB18_Msk: u32 = 262144;
pub const CAN_F1R1_FB18: u32 = 262144;
pub const CAN_F1R1_FB19_Pos: u32 = 19;
pub const CAN_F1R1_FB19_Msk: u32 = 524288;
pub const CAN_F1R1_FB19: u32 = 524288;
pub const CAN_F1R1_FB20_Pos: u32 = 20;
pub const CAN_F1R1_FB20_Msk: u32 = 1048576;
pub const CAN_F1R1_FB20: u32 = 1048576;
pub const CAN_F1R1_FB21_Pos: u32 = 21;
pub const CAN_F1R1_FB21_Msk: u32 = 2097152;
pub const CAN_F1R1_FB21: u32 = 2097152;
pub const CAN_F1R1_FB22_Pos: u32 = 22;
pub const CAN_F1R1_FB22_Msk: u32 = 4194304;
pub const CAN_F1R1_FB22: u32 = 4194304;
pub const CAN_F1R1_FB23_Pos: u32 = 23;
pub const CAN_F1R1_FB23_Msk: u32 = 8388608;
pub const CAN_F1R1_FB23: u32 = 8388608;
pub const CAN_F1R1_FB24_Pos: u32 = 24;
pub const CAN_F1R1_FB24_Msk: u32 = 16777216;
pub const CAN_F1R1_FB24: u32 = 16777216;
pub const CAN_F1R1_FB25_Pos: u32 = 25;
pub const CAN_F1R1_FB25_Msk: u32 = 33554432;
pub const CAN_F1R1_FB25: u32 = 33554432;
pub const CAN_F1R1_FB26_Pos: u32 = 26;
pub const CAN_F1R1_FB26_Msk: u32 = 67108864;
pub const CAN_F1R1_FB26: u32 = 67108864;
pub const CAN_F1R1_FB27_Pos: u32 = 27;
pub const CAN_F1R1_FB27_Msk: u32 = 134217728;
pub const CAN_F1R1_FB27: u32 = 134217728;
pub const CAN_F1R1_FB28_Pos: u32 = 28;
pub const CAN_F1R1_FB28_Msk: u32 = 268435456;
pub const CAN_F1R1_FB28: u32 = 268435456;
pub const CAN_F1R1_FB29_Pos: u32 = 29;
pub const CAN_F1R1_FB29_Msk: u32 = 536870912;
pub const CAN_F1R1_FB29: u32 = 536870912;
pub const CAN_F1R1_FB30_Pos: u32 = 30;
pub const CAN_F1R1_FB30_Msk: u32 = 1073741824;
pub const CAN_F1R1_FB30: u32 = 1073741824;
pub const CAN_F1R1_FB31_Pos: u32 = 31;
pub const CAN_F1R1_FB31_Msk: u32 = 2147483648;
pub const CAN_F1R1_FB31: u32 = 2147483648;
pub const CAN_F2R1_FB0_Pos: u32 = 0;
pub const CAN_F2R1_FB0_Msk: u32 = 1;
pub const CAN_F2R1_FB0: u32 = 1;
pub const CAN_F2R1_FB1_Pos: u32 = 1;
pub const CAN_F2R1_FB1_Msk: u32 = 2;
pub const CAN_F2R1_FB1: u32 = 2;
pub const CAN_F2R1_FB2_Pos: u32 = 2;
pub const CAN_F2R1_FB2_Msk: u32 = 4;
pub const CAN_F2R1_FB2: u32 = 4;
pub const CAN_F2R1_FB3_Pos: u32 = 3;
pub const CAN_F2R1_FB3_Msk: u32 = 8;
pub const CAN_F2R1_FB3: u32 = 8;
pub const CAN_F2R1_FB4_Pos: u32 = 4;
pub const CAN_F2R1_FB4_Msk: u32 = 16;
pub const CAN_F2R1_FB4: u32 = 16;
pub const CAN_F2R1_FB5_Pos: u32 = 5;
pub const CAN_F2R1_FB5_Msk: u32 = 32;
pub const CAN_F2R1_FB5: u32 = 32;
pub const CAN_F2R1_FB6_Pos: u32 = 6;
pub const CAN_F2R1_FB6_Msk: u32 = 64;
pub const CAN_F2R1_FB6: u32 = 64;
pub const CAN_F2R1_FB7_Pos: u32 = 7;
pub const CAN_F2R1_FB7_Msk: u32 = 128;
pub const CAN_F2R1_FB7: u32 = 128;
pub const CAN_F2R1_FB8_Pos: u32 = 8;
pub const CAN_F2R1_FB8_Msk: u32 = 256;
pub const CAN_F2R1_FB8: u32 = 256;
pub const CAN_F2R1_FB9_Pos: u32 = 9;
pub const CAN_F2R1_FB9_Msk: u32 = 512;
pub const CAN_F2R1_FB9: u32 = 512;
pub const CAN_F2R1_FB10_Pos: u32 = 10;
pub const CAN_F2R1_FB10_Msk: u32 = 1024;
pub const CAN_F2R1_FB10: u32 = 1024;
pub const CAN_F2R1_FB11_Pos: u32 = 11;
pub const CAN_F2R1_FB11_Msk: u32 = 2048;
pub const CAN_F2R1_FB11: u32 = 2048;
pub const CAN_F2R1_FB12_Pos: u32 = 12;
pub const CAN_F2R1_FB12_Msk: u32 = 4096;
pub const CAN_F2R1_FB12: u32 = 4096;
pub const CAN_F2R1_FB13_Pos: u32 = 13;
pub const CAN_F2R1_FB13_Msk: u32 = 8192;
pub const CAN_F2R1_FB13: u32 = 8192;
pub const CAN_F2R1_FB14_Pos: u32 = 14;
pub const CAN_F2R1_FB14_Msk: u32 = 16384;
pub const CAN_F2R1_FB14: u32 = 16384;
pub const CAN_F2R1_FB15_Pos: u32 = 15;
pub const CAN_F2R1_FB15_Msk: u32 = 32768;
pub const CAN_F2R1_FB15: u32 = 32768;
pub const CAN_F2R1_FB16_Pos: u32 = 16;
pub const CAN_F2R1_FB16_Msk: u32 = 65536;
pub const CAN_F2R1_FB16: u32 = 65536;
pub const CAN_F2R1_FB17_Pos: u32 = 17;
pub const CAN_F2R1_FB17_Msk: u32 = 131072;
pub const CAN_F2R1_FB17: u32 = 131072;
pub const CAN_F2R1_FB18_Pos: u32 = 18;
pub const CAN_F2R1_FB18_Msk: u32 = 262144;
pub const CAN_F2R1_FB18: u32 = 262144;
pub const CAN_F2R1_FB19_Pos: u32 = 19;
pub const CAN_F2R1_FB19_Msk: u32 = 524288;
pub const CAN_F2R1_FB19: u32 = 524288;
pub const CAN_F2R1_FB20_Pos: u32 = 20;
pub const CAN_F2R1_FB20_Msk: u32 = 1048576;
pub const CAN_F2R1_FB20: u32 = 1048576;
pub const CAN_F2R1_FB21_Pos: u32 = 21;
pub const CAN_F2R1_FB21_Msk: u32 = 2097152;
pub const CAN_F2R1_FB21: u32 = 2097152;
pub const CAN_F2R1_FB22_Pos: u32 = 22;
pub const CAN_F2R1_FB22_Msk: u32 = 4194304;
pub const CAN_F2R1_FB22: u32 = 4194304;
pub const CAN_F2R1_FB23_Pos: u32 = 23;
pub const CAN_F2R1_FB23_Msk: u32 = 8388608;
pub const CAN_F2R1_FB23: u32 = 8388608;
pub const CAN_F2R1_FB24_Pos: u32 = 24;
pub const CAN_F2R1_FB24_Msk: u32 = 16777216;
pub const CAN_F2R1_FB24: u32 = 16777216;
pub const CAN_F2R1_FB25_Pos: u32 = 25;
pub const CAN_F2R1_FB25_Msk: u32 = 33554432;
pub const CAN_F2R1_FB25: u32 = 33554432;
pub const CAN_F2R1_FB26_Pos: u32 = 26;
pub const CAN_F2R1_FB26_Msk: u32 = 67108864;
pub const CAN_F2R1_FB26: u32 = 67108864;
pub const CAN_F2R1_FB27_Pos: u32 = 27;
pub const CAN_F2R1_FB27_Msk: u32 = 134217728;
pub const CAN_F2R1_FB27: u32 = 134217728;
pub const CAN_F2R1_FB28_Pos: u32 = 28;
pub const CAN_F2R1_FB28_Msk: u32 = 268435456;
pub const CAN_F2R1_FB28: u32 = 268435456;
pub const CAN_F2R1_FB29_Pos: u32 = 29;
pub const CAN_F2R1_FB29_Msk: u32 = 536870912;
pub const CAN_F2R1_FB29: u32 = 536870912;
pub const CAN_F2R1_FB30_Pos: u32 = 30;
pub const CAN_F2R1_FB30_Msk: u32 = 1073741824;
pub const CAN_F2R1_FB30: u32 = 1073741824;
pub const CAN_F2R1_FB31_Pos: u32 = 31;
pub const CAN_F2R1_FB31_Msk: u32 = 2147483648;
pub const CAN_F2R1_FB31: u32 = 2147483648;
pub const CAN_F3R1_FB0_Pos: u32 = 0;
pub const CAN_F3R1_FB0_Msk: u32 = 1;
pub const CAN_F3R1_FB0: u32 = 1;
pub const CAN_F3R1_FB1_Pos: u32 = 1;
pub const CAN_F3R1_FB1_Msk: u32 = 2;
pub const CAN_F3R1_FB1: u32 = 2;
pub const CAN_F3R1_FB2_Pos: u32 = 2;
pub const CAN_F3R1_FB2_Msk: u32 = 4;
pub const CAN_F3R1_FB2: u32 = 4;
pub const CAN_F3R1_FB3_Pos: u32 = 3;
pub const CAN_F3R1_FB3_Msk: u32 = 8;
pub const CAN_F3R1_FB3: u32 = 8;
pub const CAN_F3R1_FB4_Pos: u32 = 4;
pub const CAN_F3R1_FB4_Msk: u32 = 16;
pub const CAN_F3R1_FB4: u32 = 16;
pub const CAN_F3R1_FB5_Pos: u32 = 5;
pub const CAN_F3R1_FB5_Msk: u32 = 32;
pub const CAN_F3R1_FB5: u32 = 32;
pub const CAN_F3R1_FB6_Pos: u32 = 6;
pub const CAN_F3R1_FB6_Msk: u32 = 64;
pub const CAN_F3R1_FB6: u32 = 64;
pub const CAN_F3R1_FB7_Pos: u32 = 7;
pub const CAN_F3R1_FB7_Msk: u32 = 128;
pub const CAN_F3R1_FB7: u32 = 128;
pub const CAN_F3R1_FB8_Pos: u32 = 8;
pub const CAN_F3R1_FB8_Msk: u32 = 256;
pub const CAN_F3R1_FB8: u32 = 256;
pub const CAN_F3R1_FB9_Pos: u32 = 9;
pub const CAN_F3R1_FB9_Msk: u32 = 512;
pub const CAN_F3R1_FB9: u32 = 512;
pub const CAN_F3R1_FB10_Pos: u32 = 10;
pub const CAN_F3R1_FB10_Msk: u32 = 1024;
pub const CAN_F3R1_FB10: u32 = 1024;
pub const CAN_F3R1_FB11_Pos: u32 = 11;
pub const CAN_F3R1_FB11_Msk: u32 = 2048;
pub const CAN_F3R1_FB11: u32 = 2048;
pub const CAN_F3R1_FB12_Pos: u32 = 12;
pub const CAN_F3R1_FB12_Msk: u32 = 4096;
pub const CAN_F3R1_FB12: u32 = 4096;
pub const CAN_F3R1_FB13_Pos: u32 = 13;
pub const CAN_F3R1_FB13_Msk: u32 = 8192;
pub const CAN_F3R1_FB13: u32 = 8192;
pub const CAN_F3R1_FB14_Pos: u32 = 14;
pub const CAN_F3R1_FB14_Msk: u32 = 16384;
pub const CAN_F3R1_FB14: u32 = 16384;
pub const CAN_F3R1_FB15_Pos: u32 = 15;
pub const CAN_F3R1_FB15_Msk: u32 = 32768;
pub const CAN_F3R1_FB15: u32 = 32768;
pub const CAN_F3R1_FB16_Pos: u32 = 16;
pub const CAN_F3R1_FB16_Msk: u32 = 65536;
pub const CAN_F3R1_FB16: u32 = 65536;
pub const CAN_F3R1_FB17_Pos: u32 = 17;
pub const CAN_F3R1_FB17_Msk: u32 = 131072;
pub const CAN_F3R1_FB17: u32 = 131072;
pub const CAN_F3R1_FB18_Pos: u32 = 18;
pub const CAN_F3R1_FB18_Msk: u32 = 262144;
pub const CAN_F3R1_FB18: u32 = 262144;
pub const CAN_F3R1_FB19_Pos: u32 = 19;
pub const CAN_F3R1_FB19_Msk: u32 = 524288;
pub const CAN_F3R1_FB19: u32 = 524288;
pub const CAN_F3R1_FB20_Pos: u32 = 20;
pub const CAN_F3R1_FB20_Msk: u32 = 1048576;
pub const CAN_F3R1_FB20: u32 = 1048576;
pub const CAN_F3R1_FB21_Pos: u32 = 21;
pub const CAN_F3R1_FB21_Msk: u32 = 2097152;
pub const CAN_F3R1_FB21: u32 = 2097152;
pub const CAN_F3R1_FB22_Pos: u32 = 22;
pub const CAN_F3R1_FB22_Msk: u32 = 4194304;
pub const CAN_F3R1_FB22: u32 = 4194304;
pub const CAN_F3R1_FB23_Pos: u32 = 23;
pub const CAN_F3R1_FB23_Msk: u32 = 8388608;
pub const CAN_F3R1_FB23: u32 = 8388608;
pub const CAN_F3R1_FB24_Pos: u32 = 24;
pub const CAN_F3R1_FB24_Msk: u32 = 16777216;
pub const CAN_F3R1_FB24: u32 = 16777216;
pub const CAN_F3R1_FB25_Pos: u32 = 25;
pub const CAN_F3R1_FB25_Msk: u32 = 33554432;
pub const CAN_F3R1_FB25: u32 = 33554432;
pub const CAN_F3R1_FB26_Pos: u32 = 26;
pub const CAN_F3R1_FB26_Msk: u32 = 67108864;
pub const CAN_F3R1_FB26: u32 = 67108864;
pub const CAN_F3R1_FB27_Pos: u32 = 27;
pub const CAN_F3R1_FB27_Msk: u32 = 134217728;
pub const CAN_F3R1_FB27: u32 = 134217728;
pub const CAN_F3R1_FB28_Pos: u32 = 28;
pub const CAN_F3R1_FB28_Msk: u32 = 268435456;
pub const CAN_F3R1_FB28: u32 = 268435456;
pub const CAN_F3R1_FB29_Pos: u32 = 29;
pub const CAN_F3R1_FB29_Msk: u32 = 536870912;
pub const CAN_F3R1_FB29: u32 = 536870912;
pub const CAN_F3R1_FB30_Pos: u32 = 30;
pub const CAN_F3R1_FB30_Msk: u32 = 1073741824;
pub const CAN_F3R1_FB30: u32 = 1073741824;
pub const CAN_F3R1_FB31_Pos: u32 = 31;
pub const CAN_F3R1_FB31_Msk: u32 = 2147483648;
pub const CAN_F3R1_FB31: u32 = 2147483648;
pub const CAN_F4R1_FB0_Pos: u32 = 0;
pub const CAN_F4R1_FB0_Msk: u32 = 1;
pub const CAN_F4R1_FB0: u32 = 1;
pub const CAN_F4R1_FB1_Pos: u32 = 1;
pub const CAN_F4R1_FB1_Msk: u32 = 2;
pub const CAN_F4R1_FB1: u32 = 2;
pub const CAN_F4R1_FB2_Pos: u32 = 2;
pub const CAN_F4R1_FB2_Msk: u32 = 4;
pub const CAN_F4R1_FB2: u32 = 4;
pub const CAN_F4R1_FB3_Pos: u32 = 3;
pub const CAN_F4R1_FB3_Msk: u32 = 8;
pub const CAN_F4R1_FB3: u32 = 8;
pub const CAN_F4R1_FB4_Pos: u32 = 4;
pub const CAN_F4R1_FB4_Msk: u32 = 16;
pub const CAN_F4R1_FB4: u32 = 16;
pub const CAN_F4R1_FB5_Pos: u32 = 5;
pub const CAN_F4R1_FB5_Msk: u32 = 32;
pub const CAN_F4R1_FB5: u32 = 32;
pub const CAN_F4R1_FB6_Pos: u32 = 6;
pub const CAN_F4R1_FB6_Msk: u32 = 64;
pub const CAN_F4R1_FB6: u32 = 64;
pub const CAN_F4R1_FB7_Pos: u32 = 7;
pub const CAN_F4R1_FB7_Msk: u32 = 128;
pub const CAN_F4R1_FB7: u32 = 128;
pub const CAN_F4R1_FB8_Pos: u32 = 8;
pub const CAN_F4R1_FB8_Msk: u32 = 256;
pub const CAN_F4R1_FB8: u32 = 256;
pub const CAN_F4R1_FB9_Pos: u32 = 9;
pub const CAN_F4R1_FB9_Msk: u32 = 512;
pub const CAN_F4R1_FB9: u32 = 512;
pub const CAN_F4R1_FB10_Pos: u32 = 10;
pub const CAN_F4R1_FB10_Msk: u32 = 1024;
pub const CAN_F4R1_FB10: u32 = 1024;
pub const CAN_F4R1_FB11_Pos: u32 = 11;
pub const CAN_F4R1_FB11_Msk: u32 = 2048;
pub const CAN_F4R1_FB11: u32 = 2048;
pub const CAN_F4R1_FB12_Pos: u32 = 12;
pub const CAN_F4R1_FB12_Msk: u32 = 4096;
pub const CAN_F4R1_FB12: u32 = 4096;
pub const CAN_F4R1_FB13_Pos: u32 = 13;
pub const CAN_F4R1_FB13_Msk: u32 = 8192;
pub const CAN_F4R1_FB13: u32 = 8192;
pub const CAN_F4R1_FB14_Pos: u32 = 14;
pub const CAN_F4R1_FB14_Msk: u32 = 16384;
pub const CAN_F4R1_FB14: u32 = 16384;
pub const CAN_F4R1_FB15_Pos: u32 = 15;
pub const CAN_F4R1_FB15_Msk: u32 = 32768;
pub const CAN_F4R1_FB15: u32 = 32768;
pub const CAN_F4R1_FB16_Pos: u32 = 16;
pub const CAN_F4R1_FB16_Msk: u32 = 65536;
pub const CAN_F4R1_FB16: u32 = 65536;
pub const CAN_F4R1_FB17_Pos: u32 = 17;
pub const CAN_F4R1_FB17_Msk: u32 = 131072;
pub const CAN_F4R1_FB17: u32 = 131072;
pub const CAN_F4R1_FB18_Pos: u32 = 18;
pub const CAN_F4R1_FB18_Msk: u32 = 262144;
pub const CAN_F4R1_FB18: u32 = 262144;
pub const CAN_F4R1_FB19_Pos: u32 = 19;
pub const CAN_F4R1_FB19_Msk: u32 = 524288;
pub const CAN_F4R1_FB19: u32 = 524288;
pub const CAN_F4R1_FB20_Pos: u32 = 20;
pub const CAN_F4R1_FB20_Msk: u32 = 1048576;
pub const CAN_F4R1_FB20: u32 = 1048576;
pub const CAN_F4R1_FB21_Pos: u32 = 21;
pub const CAN_F4R1_FB21_Msk: u32 = 2097152;
pub const CAN_F4R1_FB21: u32 = 2097152;
pub const CAN_F4R1_FB22_Pos: u32 = 22;
pub const CAN_F4R1_FB22_Msk: u32 = 4194304;
pub const CAN_F4R1_FB22: u32 = 4194304;
pub const CAN_F4R1_FB23_Pos: u32 = 23;
pub const CAN_F4R1_FB23_Msk: u32 = 8388608;
pub const CAN_F4R1_FB23: u32 = 8388608;
pub const CAN_F4R1_FB24_Pos: u32 = 24;
pub const CAN_F4R1_FB24_Msk: u32 = 16777216;
pub const CAN_F4R1_FB24: u32 = 16777216;
pub const CAN_F4R1_FB25_Pos: u32 = 25;
pub const CAN_F4R1_FB25_Msk: u32 = 33554432;
pub const CAN_F4R1_FB25: u32 = 33554432;
pub const CAN_F4R1_FB26_Pos: u32 = 26;
pub const CAN_F4R1_FB26_Msk: u32 = 67108864;
pub const CAN_F4R1_FB26: u32 = 67108864;
pub const CAN_F4R1_FB27_Pos: u32 = 27;
pub const CAN_F4R1_FB27_Msk: u32 = 134217728;
pub const CAN_F4R1_FB27: u32 = 134217728;
pub const CAN_F4R1_FB28_Pos: u32 = 28;
pub const CAN_F4R1_FB28_Msk: u32 = 268435456;
pub const CAN_F4R1_FB28: u32 = 268435456;
pub const CAN_F4R1_FB29_Pos: u32 = 29;
pub const CAN_F4R1_FB29_Msk: u32 = 536870912;
pub const CAN_F4R1_FB29: u32 = 536870912;
pub const CAN_F4R1_FB30_Pos: u32 = 30;
pub const CAN_F4R1_FB30_Msk: u32 = 1073741824;
pub const CAN_F4R1_FB30: u32 = 1073741824;
pub const CAN_F4R1_FB31_Pos: u32 = 31;
pub const CAN_F4R1_FB31_Msk: u32 = 2147483648;
pub const CAN_F4R1_FB31: u32 = 2147483648;
pub const CAN_F5R1_FB0_Pos: u32 = 0;
pub const CAN_F5R1_FB0_Msk: u32 = 1;
pub const CAN_F5R1_FB0: u32 = 1;
pub const CAN_F5R1_FB1_Pos: u32 = 1;
pub const CAN_F5R1_FB1_Msk: u32 = 2;
pub const CAN_F5R1_FB1: u32 = 2;
pub const CAN_F5R1_FB2_Pos: u32 = 2;
pub const CAN_F5R1_FB2_Msk: u32 = 4;
pub const CAN_F5R1_FB2: u32 = 4;
pub const CAN_F5R1_FB3_Pos: u32 = 3;
pub const CAN_F5R1_FB3_Msk: u32 = 8;
pub const CAN_F5R1_FB3: u32 = 8;
pub const CAN_F5R1_FB4_Pos: u32 = 4;
pub const CAN_F5R1_FB4_Msk: u32 = 16;
pub const CAN_F5R1_FB4: u32 = 16;
pub const CAN_F5R1_FB5_Pos: u32 = 5;
pub const CAN_F5R1_FB5_Msk: u32 = 32;
pub const CAN_F5R1_FB5: u32 = 32;
pub const CAN_F5R1_FB6_Pos: u32 = 6;
pub const CAN_F5R1_FB6_Msk: u32 = 64;
pub const CAN_F5R1_FB6: u32 = 64;
pub const CAN_F5R1_FB7_Pos: u32 = 7;
pub const CAN_F5R1_FB7_Msk: u32 = 128;
pub const CAN_F5R1_FB7: u32 = 128;
pub const CAN_F5R1_FB8_Pos: u32 = 8;
pub const CAN_F5R1_FB8_Msk: u32 = 256;
pub const CAN_F5R1_FB8: u32 = 256;
pub const CAN_F5R1_FB9_Pos: u32 = 9;
pub const CAN_F5R1_FB9_Msk: u32 = 512;
pub const CAN_F5R1_FB9: u32 = 512;
pub const CAN_F5R1_FB10_Pos: u32 = 10;
pub const CAN_F5R1_FB10_Msk: u32 = 1024;
pub const CAN_F5R1_FB10: u32 = 1024;
pub const CAN_F5R1_FB11_Pos: u32 = 11;
pub const CAN_F5R1_FB11_Msk: u32 = 2048;
pub const CAN_F5R1_FB11: u32 = 2048;
pub const CAN_F5R1_FB12_Pos: u32 = 12;
pub const CAN_F5R1_FB12_Msk: u32 = 4096;
pub const CAN_F5R1_FB12: u32 = 4096;
pub const CAN_F5R1_FB13_Pos: u32 = 13;
pub const CAN_F5R1_FB13_Msk: u32 = 8192;
pub const CAN_F5R1_FB13: u32 = 8192;
pub const CAN_F5R1_FB14_Pos: u32 = 14;
pub const CAN_F5R1_FB14_Msk: u32 = 16384;
pub const CAN_F5R1_FB14: u32 = 16384;
pub const CAN_F5R1_FB15_Pos: u32 = 15;
pub const CAN_F5R1_FB15_Msk: u32 = 32768;
pub const CAN_F5R1_FB15: u32 = 32768;
pub const CAN_F5R1_FB16_Pos: u32 = 16;
pub const CAN_F5R1_FB16_Msk: u32 = 65536;
pub const CAN_F5R1_FB16: u32 = 65536;
pub const CAN_F5R1_FB17_Pos: u32 = 17;
pub const CAN_F5R1_FB17_Msk: u32 = 131072;
pub const CAN_F5R1_FB17: u32 = 131072;
pub const CAN_F5R1_FB18_Pos: u32 = 18;
pub const CAN_F5R1_FB18_Msk: u32 = 262144;
pub const CAN_F5R1_FB18: u32 = 262144;
pub const CAN_F5R1_FB19_Pos: u32 = 19;
pub const CAN_F5R1_FB19_Msk: u32 = 524288;
pub const CAN_F5R1_FB19: u32 = 524288;
pub const CAN_F5R1_FB20_Pos: u32 = 20;
pub const CAN_F5R1_FB20_Msk: u32 = 1048576;
pub const CAN_F5R1_FB20: u32 = 1048576;
pub const CAN_F5R1_FB21_Pos: u32 = 21;
pub const CAN_F5R1_FB21_Msk: u32 = 2097152;
pub const CAN_F5R1_FB21: u32 = 2097152;
pub const CAN_F5R1_FB22_Pos: u32 = 22;
pub const CAN_F5R1_FB22_Msk: u32 = 4194304;
pub const CAN_F5R1_FB22: u32 = 4194304;
pub const CAN_F5R1_FB23_Pos: u32 = 23;
pub const CAN_F5R1_FB23_Msk: u32 = 8388608;
pub const CAN_F5R1_FB23: u32 = 8388608;
pub const CAN_F5R1_FB24_Pos: u32 = 24;
pub const CAN_F5R1_FB24_Msk: u32 = 16777216;
pub const CAN_F5R1_FB24: u32 = 16777216;
pub const CAN_F5R1_FB25_Pos: u32 = 25;
pub const CAN_F5R1_FB25_Msk: u32 = 33554432;
pub const CAN_F5R1_FB25: u32 = 33554432;
pub const CAN_F5R1_FB26_Pos: u32 = 26;
pub const CAN_F5R1_FB26_Msk: u32 = 67108864;
pub const CAN_F5R1_FB26: u32 = 67108864;
pub const CAN_F5R1_FB27_Pos: u32 = 27;
pub const CAN_F5R1_FB27_Msk: u32 = 134217728;
pub const CAN_F5R1_FB27: u32 = 134217728;
pub const CAN_F5R1_FB28_Pos: u32 = 28;
pub const CAN_F5R1_FB28_Msk: u32 = 268435456;
pub const CAN_F5R1_FB28: u32 = 268435456;
pub const CAN_F5R1_FB29_Pos: u32 = 29;
pub const CAN_F5R1_FB29_Msk: u32 = 536870912;
pub const CAN_F5R1_FB29: u32 = 536870912;
pub const CAN_F5R1_FB30_Pos: u32 = 30;
pub const CAN_F5R1_FB30_Msk: u32 = 1073741824;
pub const CAN_F5R1_FB30: u32 = 1073741824;
pub const CAN_F5R1_FB31_Pos: u32 = 31;
pub const CAN_F5R1_FB31_Msk: u32 = 2147483648;
pub const CAN_F5R1_FB31: u32 = 2147483648;
pub const CAN_F6R1_FB0_Pos: u32 = 0;
pub const CAN_F6R1_FB0_Msk: u32 = 1;
pub const CAN_F6R1_FB0: u32 = 1;
pub const CAN_F6R1_FB1_Pos: u32 = 1;
pub const CAN_F6R1_FB1_Msk: u32 = 2;
pub const CAN_F6R1_FB1: u32 = 2;
pub const CAN_F6R1_FB2_Pos: u32 = 2;
pub const CAN_F6R1_FB2_Msk: u32 = 4;
pub const CAN_F6R1_FB2: u32 = 4;
pub const CAN_F6R1_FB3_Pos: u32 = 3;
pub const CAN_F6R1_FB3_Msk: u32 = 8;
pub const CAN_F6R1_FB3: u32 = 8;
pub const CAN_F6R1_FB4_Pos: u32 = 4;
pub const CAN_F6R1_FB4_Msk: u32 = 16;
pub const CAN_F6R1_FB4: u32 = 16;
pub const CAN_F6R1_FB5_Pos: u32 = 5;
pub const CAN_F6R1_FB5_Msk: u32 = 32;
pub const CAN_F6R1_FB5: u32 = 32;
pub const CAN_F6R1_FB6_Pos: u32 = 6;
pub const CAN_F6R1_FB6_Msk: u32 = 64;
pub const CAN_F6R1_FB6: u32 = 64;
pub const CAN_F6R1_FB7_Pos: u32 = 7;
pub const CAN_F6R1_FB7_Msk: u32 = 128;
pub const CAN_F6R1_FB7: u32 = 128;
pub const CAN_F6R1_FB8_Pos: u32 = 8;
pub const CAN_F6R1_FB8_Msk: u32 = 256;
pub const CAN_F6R1_FB8: u32 = 256;
pub const CAN_F6R1_FB9_Pos: u32 = 9;
pub const CAN_F6R1_FB9_Msk: u32 = 512;
pub const CAN_F6R1_FB9: u32 = 512;
pub const CAN_F6R1_FB10_Pos: u32 = 10;
pub const CAN_F6R1_FB10_Msk: u32 = 1024;
pub const CAN_F6R1_FB10: u32 = 1024;
pub const CAN_F6R1_FB11_Pos: u32 = 11;
pub const CAN_F6R1_FB11_Msk: u32 = 2048;
pub const CAN_F6R1_FB11: u32 = 2048;
pub const CAN_F6R1_FB12_Pos: u32 = 12;
pub const CAN_F6R1_FB12_Msk: u32 = 4096;
pub const CAN_F6R1_FB12: u32 = 4096;
pub const CAN_F6R1_FB13_Pos: u32 = 13;
pub const CAN_F6R1_FB13_Msk: u32 = 8192;
pub const CAN_F6R1_FB13: u32 = 8192;
pub const CAN_F6R1_FB14_Pos: u32 = 14;
pub const CAN_F6R1_FB14_Msk: u32 = 16384;
pub const CAN_F6R1_FB14: u32 = 16384;
pub const CAN_F6R1_FB15_Pos: u32 = 15;
pub const CAN_F6R1_FB15_Msk: u32 = 32768;
pub const CAN_F6R1_FB15: u32 = 32768;
pub const CAN_F6R1_FB16_Pos: u32 = 16;
pub const CAN_F6R1_FB16_Msk: u32 = 65536;
pub const CAN_F6R1_FB16: u32 = 65536;
pub const CAN_F6R1_FB17_Pos: u32 = 17;
pub const CAN_F6R1_FB17_Msk: u32 = 131072;
pub const CAN_F6R1_FB17: u32 = 131072;
pub const CAN_F6R1_FB18_Pos: u32 = 18;
pub const CAN_F6R1_FB18_Msk: u32 = 262144;
pub const CAN_F6R1_FB18: u32 = 262144;
pub const CAN_F6R1_FB19_Pos: u32 = 19;
pub const CAN_F6R1_FB19_Msk: u32 = 524288;
pub const CAN_F6R1_FB19: u32 = 524288;
pub const CAN_F6R1_FB20_Pos: u32 = 20;
pub const CAN_F6R1_FB20_Msk: u32 = 1048576;
pub const CAN_F6R1_FB20: u32 = 1048576;
pub const CAN_F6R1_FB21_Pos: u32 = 21;
pub const CAN_F6R1_FB21_Msk: u32 = 2097152;
pub const CAN_F6R1_FB21: u32 = 2097152;
pub const CAN_F6R1_FB22_Pos: u32 = 22;
pub const CAN_F6R1_FB22_Msk: u32 = 4194304;
pub const CAN_F6R1_FB22: u32 = 4194304;
pub const CAN_F6R1_FB23_Pos: u32 = 23;
pub const CAN_F6R1_FB23_Msk: u32 = 8388608;
pub const CAN_F6R1_FB23: u32 = 8388608;
pub const CAN_F6R1_FB24_Pos: u32 = 24;
pub const CAN_F6R1_FB24_Msk: u32 = 16777216;
pub const CAN_F6R1_FB24: u32 = 16777216;
pub const CAN_F6R1_FB25_Pos: u32 = 25;
pub const CAN_F6R1_FB25_Msk: u32 = 33554432;
pub const CAN_F6R1_FB25: u32 = 33554432;
pub const CAN_F6R1_FB26_Pos: u32 = 26;
pub const CAN_F6R1_FB26_Msk: u32 = 67108864;
pub const CAN_F6R1_FB26: u32 = 67108864;
pub const CAN_F6R1_FB27_Pos: u32 = 27;
pub const CAN_F6R1_FB27_Msk: u32 = 134217728;
pub const CAN_F6R1_FB27: u32 = 134217728;
pub const CAN_F6R1_FB28_Pos: u32 = 28;
pub const CAN_F6R1_FB28_Msk: u32 = 268435456;
pub const CAN_F6R1_FB28: u32 = 268435456;
pub const CAN_F6R1_FB29_Pos: u32 = 29;
pub const CAN_F6R1_FB29_Msk: u32 = 536870912;
pub const CAN_F6R1_FB29: u32 = 536870912;
pub const CAN_F6R1_FB30_Pos: u32 = 30;
pub const CAN_F6R1_FB30_Msk: u32 = 1073741824;
pub const CAN_F6R1_FB30: u32 = 1073741824;
pub const CAN_F6R1_FB31_Pos: u32 = 31;
pub const CAN_F6R1_FB31_Msk: u32 = 2147483648;
pub const CAN_F6R1_FB31: u32 = 2147483648;
pub const CAN_F7R1_FB0_Pos: u32 = 0;
pub const CAN_F7R1_FB0_Msk: u32 = 1;
pub const CAN_F7R1_FB0: u32 = 1;
pub const CAN_F7R1_FB1_Pos: u32 = 1;
pub const CAN_F7R1_FB1_Msk: u32 = 2;
pub const CAN_F7R1_FB1: u32 = 2;
pub const CAN_F7R1_FB2_Pos: u32 = 2;
pub const CAN_F7R1_FB2_Msk: u32 = 4;
pub const CAN_F7R1_FB2: u32 = 4;
pub const CAN_F7R1_FB3_Pos: u32 = 3;
pub const CAN_F7R1_FB3_Msk: u32 = 8;
pub const CAN_F7R1_FB3: u32 = 8;
pub const CAN_F7R1_FB4_Pos: u32 = 4;
pub const CAN_F7R1_FB4_Msk: u32 = 16;
pub const CAN_F7R1_FB4: u32 = 16;
pub const CAN_F7R1_FB5_Pos: u32 = 5;
pub const CAN_F7R1_FB5_Msk: u32 = 32;
pub const CAN_F7R1_FB5: u32 = 32;
pub const CAN_F7R1_FB6_Pos: u32 = 6;
pub const CAN_F7R1_FB6_Msk: u32 = 64;
pub const CAN_F7R1_FB6: u32 = 64;
pub const CAN_F7R1_FB7_Pos: u32 = 7;
pub const CAN_F7R1_FB7_Msk: u32 = 128;
pub const CAN_F7R1_FB7: u32 = 128;
pub const CAN_F7R1_FB8_Pos: u32 = 8;
pub const CAN_F7R1_FB8_Msk: u32 = 256;
pub const CAN_F7R1_FB8: u32 = 256;
pub const CAN_F7R1_FB9_Pos: u32 = 9;
pub const CAN_F7R1_FB9_Msk: u32 = 512;
pub const CAN_F7R1_FB9: u32 = 512;
pub const CAN_F7R1_FB10_Pos: u32 = 10;
pub const CAN_F7R1_FB10_Msk: u32 = 1024;
pub const CAN_F7R1_FB10: u32 = 1024;
pub const CAN_F7R1_FB11_Pos: u32 = 11;
pub const CAN_F7R1_FB11_Msk: u32 = 2048;
pub const CAN_F7R1_FB11: u32 = 2048;
pub const CAN_F7R1_FB12_Pos: u32 = 12;
pub const CAN_F7R1_FB12_Msk: u32 = 4096;
pub const CAN_F7R1_FB12: u32 = 4096;
pub const CAN_F7R1_FB13_Pos: u32 = 13;
pub const CAN_F7R1_FB13_Msk: u32 = 8192;
pub const CAN_F7R1_FB13: u32 = 8192;
pub const CAN_F7R1_FB14_Pos: u32 = 14;
pub const CAN_F7R1_FB14_Msk: u32 = 16384;
pub const CAN_F7R1_FB14: u32 = 16384;
pub const CAN_F7R1_FB15_Pos: u32 = 15;
pub const CAN_F7R1_FB15_Msk: u32 = 32768;
pub const CAN_F7R1_FB15: u32 = 32768;
pub const CAN_F7R1_FB16_Pos: u32 = 16;
pub const CAN_F7R1_FB16_Msk: u32 = 65536;
pub const CAN_F7R1_FB16: u32 = 65536;
pub const CAN_F7R1_FB17_Pos: u32 = 17;
pub const CAN_F7R1_FB17_Msk: u32 = 131072;
pub const CAN_F7R1_FB17: u32 = 131072;
pub const CAN_F7R1_FB18_Pos: u32 = 18;
pub const CAN_F7R1_FB18_Msk: u32 = 262144;
pub const CAN_F7R1_FB18: u32 = 262144;
pub const CAN_F7R1_FB19_Pos: u32 = 19;
pub const CAN_F7R1_FB19_Msk: u32 = 524288;
pub const CAN_F7R1_FB19: u32 = 524288;
pub const CAN_F7R1_FB20_Pos: u32 = 20;
pub const CAN_F7R1_FB20_Msk: u32 = 1048576;
pub const CAN_F7R1_FB20: u32 = 1048576;
pub const CAN_F7R1_FB21_Pos: u32 = 21;
pub const CAN_F7R1_FB21_Msk: u32 = 2097152;
pub const CAN_F7R1_FB21: u32 = 2097152;
pub const CAN_F7R1_FB22_Pos: u32 = 22;
pub const CAN_F7R1_FB22_Msk: u32 = 4194304;
pub const CAN_F7R1_FB22: u32 = 4194304;
pub const CAN_F7R1_FB23_Pos: u32 = 23;
pub const CAN_F7R1_FB23_Msk: u32 = 8388608;
pub const CAN_F7R1_FB23: u32 = 8388608;
pub const CAN_F7R1_FB24_Pos: u32 = 24;
pub const CAN_F7R1_FB24_Msk: u32 = 16777216;
pub const CAN_F7R1_FB24: u32 = 16777216;
pub const CAN_F7R1_FB25_Pos: u32 = 25;
pub const CAN_F7R1_FB25_Msk: u32 = 33554432;
pub const CAN_F7R1_FB25: u32 = 33554432;
pub const CAN_F7R1_FB26_Pos: u32 = 26;
pub const CAN_F7R1_FB26_Msk: u32 = 67108864;
pub const CAN_F7R1_FB26: u32 = 67108864;
pub const CAN_F7R1_FB27_Pos: u32 = 27;
pub const CAN_F7R1_FB27_Msk: u32 = 134217728;
pub const CAN_F7R1_FB27: u32 = 134217728;
pub const CAN_F7R1_FB28_Pos: u32 = 28;
pub const CAN_F7R1_FB28_Msk: u32 = 268435456;
pub const CAN_F7R1_FB28: u32 = 268435456;
pub const CAN_F7R1_FB29_Pos: u32 = 29;
pub const CAN_F7R1_FB29_Msk: u32 = 536870912;
pub const CAN_F7R1_FB29: u32 = 536870912;
pub const CAN_F7R1_FB30_Pos: u32 = 30;
pub const CAN_F7R1_FB30_Msk: u32 = 1073741824;
pub const CAN_F7R1_FB30: u32 = 1073741824;
pub const CAN_F7R1_FB31_Pos: u32 = 31;
pub const CAN_F7R1_FB31_Msk: u32 = 2147483648;
pub const CAN_F7R1_FB31: u32 = 2147483648;
pub const CAN_F8R1_FB0_Pos: u32 = 0;
pub const CAN_F8R1_FB0_Msk: u32 = 1;
pub const CAN_F8R1_FB0: u32 = 1;
pub const CAN_F8R1_FB1_Pos: u32 = 1;
pub const CAN_F8R1_FB1_Msk: u32 = 2;
pub const CAN_F8R1_FB1: u32 = 2;
pub const CAN_F8R1_FB2_Pos: u32 = 2;
pub const CAN_F8R1_FB2_Msk: u32 = 4;
pub const CAN_F8R1_FB2: u32 = 4;
pub const CAN_F8R1_FB3_Pos: u32 = 3;
pub const CAN_F8R1_FB3_Msk: u32 = 8;
pub const CAN_F8R1_FB3: u32 = 8;
pub const CAN_F8R1_FB4_Pos: u32 = 4;
pub const CAN_F8R1_FB4_Msk: u32 = 16;
pub const CAN_F8R1_FB4: u32 = 16;
pub const CAN_F8R1_FB5_Pos: u32 = 5;
pub const CAN_F8R1_FB5_Msk: u32 = 32;
pub const CAN_F8R1_FB5: u32 = 32;
pub const CAN_F8R1_FB6_Pos: u32 = 6;
pub const CAN_F8R1_FB6_Msk: u32 = 64;
pub const CAN_F8R1_FB6: u32 = 64;
pub const CAN_F8R1_FB7_Pos: u32 = 7;
pub const CAN_F8R1_FB7_Msk: u32 = 128;
pub const CAN_F8R1_FB7: u32 = 128;
pub const CAN_F8R1_FB8_Pos: u32 = 8;
pub const CAN_F8R1_FB8_Msk: u32 = 256;
pub const CAN_F8R1_FB8: u32 = 256;
pub const CAN_F8R1_FB9_Pos: u32 = 9;
pub const CAN_F8R1_FB9_Msk: u32 = 512;
pub const CAN_F8R1_FB9: u32 = 512;
pub const CAN_F8R1_FB10_Pos: u32 = 10;
pub const CAN_F8R1_FB10_Msk: u32 = 1024;
pub const CAN_F8R1_FB10: u32 = 1024;
pub const CAN_F8R1_FB11_Pos: u32 = 11;
pub const CAN_F8R1_FB11_Msk: u32 = 2048;
pub const CAN_F8R1_FB11: u32 = 2048;
pub const CAN_F8R1_FB12_Pos: u32 = 12;
pub const CAN_F8R1_FB12_Msk: u32 = 4096;
pub const CAN_F8R1_FB12: u32 = 4096;
pub const CAN_F8R1_FB13_Pos: u32 = 13;
pub const CAN_F8R1_FB13_Msk: u32 = 8192;
pub const CAN_F8R1_FB13: u32 = 8192;
pub const CAN_F8R1_FB14_Pos: u32 = 14;
pub const CAN_F8R1_FB14_Msk: u32 = 16384;
pub const CAN_F8R1_FB14: u32 = 16384;
pub const CAN_F8R1_FB15_Pos: u32 = 15;
pub const CAN_F8R1_FB15_Msk: u32 = 32768;
pub const CAN_F8R1_FB15: u32 = 32768;
pub const CAN_F8R1_FB16_Pos: u32 = 16;
pub const CAN_F8R1_FB16_Msk: u32 = 65536;
pub const CAN_F8R1_FB16: u32 = 65536;
pub const CAN_F8R1_FB17_Pos: u32 = 17;
pub const CAN_F8R1_FB17_Msk: u32 = 131072;
pub const CAN_F8R1_FB17: u32 = 131072;
pub const CAN_F8R1_FB18_Pos: u32 = 18;
pub const CAN_F8R1_FB18_Msk: u32 = 262144;
pub const CAN_F8R1_FB18: u32 = 262144;
pub const CAN_F8R1_FB19_Pos: u32 = 19;
pub const CAN_F8R1_FB19_Msk: u32 = 524288;
pub const CAN_F8R1_FB19: u32 = 524288;
pub const CAN_F8R1_FB20_Pos: u32 = 20;
pub const CAN_F8R1_FB20_Msk: u32 = 1048576;
pub const CAN_F8R1_FB20: u32 = 1048576;
pub const CAN_F8R1_FB21_Pos: u32 = 21;
pub const CAN_F8R1_FB21_Msk: u32 = 2097152;
pub const CAN_F8R1_FB21: u32 = 2097152;
pub const CAN_F8R1_FB22_Pos: u32 = 22;
pub const CAN_F8R1_FB22_Msk: u32 = 4194304;
pub const CAN_F8R1_FB22: u32 = 4194304;
pub const CAN_F8R1_FB23_Pos: u32 = 23;
pub const CAN_F8R1_FB23_Msk: u32 = 8388608;
pub const CAN_F8R1_FB23: u32 = 8388608;
pub const CAN_F8R1_FB24_Pos: u32 = 24;
pub const CAN_F8R1_FB24_Msk: u32 = 16777216;
pub const CAN_F8R1_FB24: u32 = 16777216;
pub const CAN_F8R1_FB25_Pos: u32 = 25;
pub const CAN_F8R1_FB25_Msk: u32 = 33554432;
pub const CAN_F8R1_FB25: u32 = 33554432;
pub const CAN_F8R1_FB26_Pos: u32 = 26;
pub const CAN_F8R1_FB26_Msk: u32 = 67108864;
pub const CAN_F8R1_FB26: u32 = 67108864;
pub const CAN_F8R1_FB27_Pos: u32 = 27;
pub const CAN_F8R1_FB27_Msk: u32 = 134217728;
pub const CAN_F8R1_FB27: u32 = 134217728;
pub const CAN_F8R1_FB28_Pos: u32 = 28;
pub const CAN_F8R1_FB28_Msk: u32 = 268435456;
pub const CAN_F8R1_FB28: u32 = 268435456;
pub const CAN_F8R1_FB29_Pos: u32 = 29;
pub const CAN_F8R1_FB29_Msk: u32 = 536870912;
pub const CAN_F8R1_FB29: u32 = 536870912;
pub const CAN_F8R1_FB30_Pos: u32 = 30;
pub const CAN_F8R1_FB30_Msk: u32 = 1073741824;
pub const CAN_F8R1_FB30: u32 = 1073741824;
pub const CAN_F8R1_FB31_Pos: u32 = 31;
pub const CAN_F8R1_FB31_Msk: u32 = 2147483648;
pub const CAN_F8R1_FB31: u32 = 2147483648;
pub const CAN_F9R1_FB0_Pos: u32 = 0;
pub const CAN_F9R1_FB0_Msk: u32 = 1;
pub const CAN_F9R1_FB0: u32 = 1;
pub const CAN_F9R1_FB1_Pos: u32 = 1;
pub const CAN_F9R1_FB1_Msk: u32 = 2;
pub const CAN_F9R1_FB1: u32 = 2;
pub const CAN_F9R1_FB2_Pos: u32 = 2;
pub const CAN_F9R1_FB2_Msk: u32 = 4;
pub const CAN_F9R1_FB2: u32 = 4;
pub const CAN_F9R1_FB3_Pos: u32 = 3;
pub const CAN_F9R1_FB3_Msk: u32 = 8;
pub const CAN_F9R1_FB3: u32 = 8;
pub const CAN_F9R1_FB4_Pos: u32 = 4;
pub const CAN_F9R1_FB4_Msk: u32 = 16;
pub const CAN_F9R1_FB4: u32 = 16;
pub const CAN_F9R1_FB5_Pos: u32 = 5;
pub const CAN_F9R1_FB5_Msk: u32 = 32;
pub const CAN_F9R1_FB5: u32 = 32;
pub const CAN_F9R1_FB6_Pos: u32 = 6;
pub const CAN_F9R1_FB6_Msk: u32 = 64;
pub const CAN_F9R1_FB6: u32 = 64;
pub const CAN_F9R1_FB7_Pos: u32 = 7;
pub const CAN_F9R1_FB7_Msk: u32 = 128;
pub const CAN_F9R1_FB7: u32 = 128;
pub const CAN_F9R1_FB8_Pos: u32 = 8;
pub const CAN_F9R1_FB8_Msk: u32 = 256;
pub const CAN_F9R1_FB8: u32 = 256;
pub const CAN_F9R1_FB9_Pos: u32 = 9;
pub const CAN_F9R1_FB9_Msk: u32 = 512;
pub const CAN_F9R1_FB9: u32 = 512;
pub const CAN_F9R1_FB10_Pos: u32 = 10;
pub const CAN_F9R1_FB10_Msk: u32 = 1024;
pub const CAN_F9R1_FB10: u32 = 1024;
pub const CAN_F9R1_FB11_Pos: u32 = 11;
pub const CAN_F9R1_FB11_Msk: u32 = 2048;
pub const CAN_F9R1_FB11: u32 = 2048;
pub const CAN_F9R1_FB12_Pos: u32 = 12;
pub const CAN_F9R1_FB12_Msk: u32 = 4096;
pub const CAN_F9R1_FB12: u32 = 4096;
pub const CAN_F9R1_FB13_Pos: u32 = 13;
pub const CAN_F9R1_FB13_Msk: u32 = 8192;
pub const CAN_F9R1_FB13: u32 = 8192;
pub const CAN_F9R1_FB14_Pos: u32 = 14;
pub const CAN_F9R1_FB14_Msk: u32 = 16384;
pub const CAN_F9R1_FB14: u32 = 16384;
pub const CAN_F9R1_FB15_Pos: u32 = 15;
pub const CAN_F9R1_FB15_Msk: u32 = 32768;
pub const CAN_F9R1_FB15: u32 = 32768;
pub const CAN_F9R1_FB16_Pos: u32 = 16;
pub const CAN_F9R1_FB16_Msk: u32 = 65536;
pub const CAN_F9R1_FB16: u32 = 65536;
pub const CAN_F9R1_FB17_Pos: u32 = 17;
pub const CAN_F9R1_FB17_Msk: u32 = 131072;
pub const CAN_F9R1_FB17: u32 = 131072;
pub const CAN_F9R1_FB18_Pos: u32 = 18;
pub const CAN_F9R1_FB18_Msk: u32 = 262144;
pub const CAN_F9R1_FB18: u32 = 262144;
pub const CAN_F9R1_FB19_Pos: u32 = 19;
pub const CAN_F9R1_FB19_Msk: u32 = 524288;
pub const CAN_F9R1_FB19: u32 = 524288;
pub const CAN_F9R1_FB20_Pos: u32 = 20;
pub const CAN_F9R1_FB20_Msk: u32 = 1048576;
pub const CAN_F9R1_FB20: u32 = 1048576;
pub const CAN_F9R1_FB21_Pos: u32 = 21;
pub const CAN_F9R1_FB21_Msk: u32 = 2097152;
pub const CAN_F9R1_FB21: u32 = 2097152;
pub const CAN_F9R1_FB22_Pos: u32 = 22;
pub const CAN_F9R1_FB22_Msk: u32 = 4194304;
pub const CAN_F9R1_FB22: u32 = 4194304;
pub const CAN_F9R1_FB23_Pos: u32 = 23;
pub const CAN_F9R1_FB23_Msk: u32 = 8388608;
pub const CAN_F9R1_FB23: u32 = 8388608;
pub const CAN_F9R1_FB24_Pos: u32 = 24;
pub const CAN_F9R1_FB24_Msk: u32 = 16777216;
pub const CAN_F9R1_FB24: u32 = 16777216;
pub const CAN_F9R1_FB25_Pos: u32 = 25;
pub const CAN_F9R1_FB25_Msk: u32 = 33554432;
pub const CAN_F9R1_FB25: u32 = 33554432;
pub const CAN_F9R1_FB26_Pos: u32 = 26;
pub const CAN_F9R1_FB26_Msk: u32 = 67108864;
pub const CAN_F9R1_FB26: u32 = 67108864;
pub const CAN_F9R1_FB27_Pos: u32 = 27;
pub const CAN_F9R1_FB27_Msk: u32 = 134217728;
pub const CAN_F9R1_FB27: u32 = 134217728;
pub const CAN_F9R1_FB28_Pos: u32 = 28;
pub const CAN_F9R1_FB28_Msk: u32 = 268435456;
pub const CAN_F9R1_FB28: u32 = 268435456;
pub const CAN_F9R1_FB29_Pos: u32 = 29;
pub const CAN_F9R1_FB29_Msk: u32 = 536870912;
pub const CAN_F9R1_FB29: u32 = 536870912;
pub const CAN_F9R1_FB30_Pos: u32 = 30;
pub const CAN_F9R1_FB30_Msk: u32 = 1073741824;
pub const CAN_F9R1_FB30: u32 = 1073741824;
pub const CAN_F9R1_FB31_Pos: u32 = 31;
pub const CAN_F9R1_FB31_Msk: u32 = 2147483648;
pub const CAN_F9R1_FB31: u32 = 2147483648;
pub const CAN_F10R1_FB0_Pos: u32 = 0;
pub const CAN_F10R1_FB0_Msk: u32 = 1;
pub const CAN_F10R1_FB0: u32 = 1;
pub const CAN_F10R1_FB1_Pos: u32 = 1;
pub const CAN_F10R1_FB1_Msk: u32 = 2;
pub const CAN_F10R1_FB1: u32 = 2;
pub const CAN_F10R1_FB2_Pos: u32 = 2;
pub const CAN_F10R1_FB2_Msk: u32 = 4;
pub const CAN_F10R1_FB2: u32 = 4;
pub const CAN_F10R1_FB3_Pos: u32 = 3;
pub const CAN_F10R1_FB3_Msk: u32 = 8;
pub const CAN_F10R1_FB3: u32 = 8;
pub const CAN_F10R1_FB4_Pos: u32 = 4;
pub const CAN_F10R1_FB4_Msk: u32 = 16;
pub const CAN_F10R1_FB4: u32 = 16;
pub const CAN_F10R1_FB5_Pos: u32 = 5;
pub const CAN_F10R1_FB5_Msk: u32 = 32;
pub const CAN_F10R1_FB5: u32 = 32;
pub const CAN_F10R1_FB6_Pos: u32 = 6;
pub const CAN_F10R1_FB6_Msk: u32 = 64;
pub const CAN_F10R1_FB6: u32 = 64;
pub const CAN_F10R1_FB7_Pos: u32 = 7;
pub const CAN_F10R1_FB7_Msk: u32 = 128;
pub const CAN_F10R1_FB7: u32 = 128;
pub const CAN_F10R1_FB8_Pos: u32 = 8;
pub const CAN_F10R1_FB8_Msk: u32 = 256;
pub const CAN_F10R1_FB8: u32 = 256;
pub const CAN_F10R1_FB9_Pos: u32 = 9;
pub const CAN_F10R1_FB9_Msk: u32 = 512;
pub const CAN_F10R1_FB9: u32 = 512;
pub const CAN_F10R1_FB10_Pos: u32 = 10;
pub const CAN_F10R1_FB10_Msk: u32 = 1024;
pub const CAN_F10R1_FB10: u32 = 1024;
pub const CAN_F10R1_FB11_Pos: u32 = 11;
pub const CAN_F10R1_FB11_Msk: u32 = 2048;
pub const CAN_F10R1_FB11: u32 = 2048;
pub const CAN_F10R1_FB12_Pos: u32 = 12;
pub const CAN_F10R1_FB12_Msk: u32 = 4096;
pub const CAN_F10R1_FB12: u32 = 4096;
pub const CAN_F10R1_FB13_Pos: u32 = 13;
pub const CAN_F10R1_FB13_Msk: u32 = 8192;
pub const CAN_F10R1_FB13: u32 = 8192;
pub const CAN_F10R1_FB14_Pos: u32 = 14;
pub const CAN_F10R1_FB14_Msk: u32 = 16384;
pub const CAN_F10R1_FB14: u32 = 16384;
pub const CAN_F10R1_FB15_Pos: u32 = 15;
pub const CAN_F10R1_FB15_Msk: u32 = 32768;
pub const CAN_F10R1_FB15: u32 = 32768;
pub const CAN_F10R1_FB16_Pos: u32 = 16;
pub const CAN_F10R1_FB16_Msk: u32 = 65536;
pub const CAN_F10R1_FB16: u32 = 65536;
pub const CAN_F10R1_FB17_Pos: u32 = 17;
pub const CAN_F10R1_FB17_Msk: u32 = 131072;
pub const CAN_F10R1_FB17: u32 = 131072;
pub const CAN_F10R1_FB18_Pos: u32 = 18;
pub const CAN_F10R1_FB18_Msk: u32 = 262144;
pub const CAN_F10R1_FB18: u32 = 262144;
pub const CAN_F10R1_FB19_Pos: u32 = 19;
pub const CAN_F10R1_FB19_Msk: u32 = 524288;
pub const CAN_F10R1_FB19: u32 = 524288;
pub const CAN_F10R1_FB20_Pos: u32 = 20;
pub const CAN_F10R1_FB20_Msk: u32 = 1048576;
pub const CAN_F10R1_FB20: u32 = 1048576;
pub const CAN_F10R1_FB21_Pos: u32 = 21;
pub const CAN_F10R1_FB21_Msk: u32 = 2097152;
pub const CAN_F10R1_FB21: u32 = 2097152;
pub const CAN_F10R1_FB22_Pos: u32 = 22;
pub const CAN_F10R1_FB22_Msk: u32 = 4194304;
pub const CAN_F10R1_FB22: u32 = 4194304;
pub const CAN_F10R1_FB23_Pos: u32 = 23;
pub const CAN_F10R1_FB23_Msk: u32 = 8388608;
pub const CAN_F10R1_FB23: u32 = 8388608;
pub const CAN_F10R1_FB24_Pos: u32 = 24;
pub const CAN_F10R1_FB24_Msk: u32 = 16777216;
pub const CAN_F10R1_FB24: u32 = 16777216;
pub const CAN_F10R1_FB25_Pos: u32 = 25;
pub const CAN_F10R1_FB25_Msk: u32 = 33554432;
pub const CAN_F10R1_FB25: u32 = 33554432;
pub const CAN_F10R1_FB26_Pos: u32 = 26;
pub const CAN_F10R1_FB26_Msk: u32 = 67108864;
pub const CAN_F10R1_FB26: u32 = 67108864;
pub const CAN_F10R1_FB27_Pos: u32 = 27;
pub const CAN_F10R1_FB27_Msk: u32 = 134217728;
pub const CAN_F10R1_FB27: u32 = 134217728;
pub const CAN_F10R1_FB28_Pos: u32 = 28;
pub const CAN_F10R1_FB28_Msk: u32 = 268435456;
pub const CAN_F10R1_FB28: u32 = 268435456;
pub const CAN_F10R1_FB29_Pos: u32 = 29;
pub const CAN_F10R1_FB29_Msk: u32 = 536870912;
pub const CAN_F10R1_FB29: u32 = 536870912;
pub const CAN_F10R1_FB30_Pos: u32 = 30;
pub const CAN_F10R1_FB30_Msk: u32 = 1073741824;
pub const CAN_F10R1_FB30: u32 = 1073741824;
pub const CAN_F10R1_FB31_Pos: u32 = 31;
pub const CAN_F10R1_FB31_Msk: u32 = 2147483648;
pub const CAN_F10R1_FB31: u32 = 2147483648;
pub const CAN_F11R1_FB0_Pos: u32 = 0;
pub const CAN_F11R1_FB0_Msk: u32 = 1;
pub const CAN_F11R1_FB0: u32 = 1;
pub const CAN_F11R1_FB1_Pos: u32 = 1;
pub const CAN_F11R1_FB1_Msk: u32 = 2;
pub const CAN_F11R1_FB1: u32 = 2;
pub const CAN_F11R1_FB2_Pos: u32 = 2;
pub const CAN_F11R1_FB2_Msk: u32 = 4;
pub const CAN_F11R1_FB2: u32 = 4;
pub const CAN_F11R1_FB3_Pos: u32 = 3;
pub const CAN_F11R1_FB3_Msk: u32 = 8;
pub const CAN_F11R1_FB3: u32 = 8;
pub const CAN_F11R1_FB4_Pos: u32 = 4;
pub const CAN_F11R1_FB4_Msk: u32 = 16;
pub const CAN_F11R1_FB4: u32 = 16;
pub const CAN_F11R1_FB5_Pos: u32 = 5;
pub const CAN_F11R1_FB5_Msk: u32 = 32;
pub const CAN_F11R1_FB5: u32 = 32;
pub const CAN_F11R1_FB6_Pos: u32 = 6;
pub const CAN_F11R1_FB6_Msk: u32 = 64;
pub const CAN_F11R1_FB6: u32 = 64;
pub const CAN_F11R1_FB7_Pos: u32 = 7;
pub const CAN_F11R1_FB7_Msk: u32 = 128;
pub const CAN_F11R1_FB7: u32 = 128;
pub const CAN_F11R1_FB8_Pos: u32 = 8;
pub const CAN_F11R1_FB8_Msk: u32 = 256;
pub const CAN_F11R1_FB8: u32 = 256;
pub const CAN_F11R1_FB9_Pos: u32 = 9;
pub const CAN_F11R1_FB9_Msk: u32 = 512;
pub const CAN_F11R1_FB9: u32 = 512;
pub const CAN_F11R1_FB10_Pos: u32 = 10;
pub const CAN_F11R1_FB10_Msk: u32 = 1024;
pub const CAN_F11R1_FB10: u32 = 1024;
pub const CAN_F11R1_FB11_Pos: u32 = 11;
pub const CAN_F11R1_FB11_Msk: u32 = 2048;
pub const CAN_F11R1_FB11: u32 = 2048;
pub const CAN_F11R1_FB12_Pos: u32 = 12;
pub const CAN_F11R1_FB12_Msk: u32 = 4096;
pub const CAN_F11R1_FB12: u32 = 4096;
pub const CAN_F11R1_FB13_Pos: u32 = 13;
pub const CAN_F11R1_FB13_Msk: u32 = 8192;
pub const CAN_F11R1_FB13: u32 = 8192;
pub const CAN_F11R1_FB14_Pos: u32 = 14;
pub const CAN_F11R1_FB14_Msk: u32 = 16384;
pub const CAN_F11R1_FB14: u32 = 16384;
pub const CAN_F11R1_FB15_Pos: u32 = 15;
pub const CAN_F11R1_FB15_Msk: u32 = 32768;
pub const CAN_F11R1_FB15: u32 = 32768;
pub const CAN_F11R1_FB16_Pos: u32 = 16;
pub const CAN_F11R1_FB16_Msk: u32 = 65536;
pub const CAN_F11R1_FB16: u32 = 65536;
pub const CAN_F11R1_FB17_Pos: u32 = 17;
pub const CAN_F11R1_FB17_Msk: u32 = 131072;
pub const CAN_F11R1_FB17: u32 = 131072;
pub const CAN_F11R1_FB18_Pos: u32 = 18;
pub const CAN_F11R1_FB18_Msk: u32 = 262144;
pub const CAN_F11R1_FB18: u32 = 262144;
pub const CAN_F11R1_FB19_Pos: u32 = 19;
pub const CAN_F11R1_FB19_Msk: u32 = 524288;
pub const CAN_F11R1_FB19: u32 = 524288;
pub const CAN_F11R1_FB20_Pos: u32 = 20;
pub const CAN_F11R1_FB20_Msk: u32 = 1048576;
pub const CAN_F11R1_FB20: u32 = 1048576;
pub const CAN_F11R1_FB21_Pos: u32 = 21;
pub const CAN_F11R1_FB21_Msk: u32 = 2097152;
pub const CAN_F11R1_FB21: u32 = 2097152;
pub const CAN_F11R1_FB22_Pos: u32 = 22;
pub const CAN_F11R1_FB22_Msk: u32 = 4194304;
pub const CAN_F11R1_FB22: u32 = 4194304;
pub const CAN_F11R1_FB23_Pos: u32 = 23;
pub const CAN_F11R1_FB23_Msk: u32 = 8388608;
pub const CAN_F11R1_FB23: u32 = 8388608;
pub const CAN_F11R1_FB24_Pos: u32 = 24;
pub const CAN_F11R1_FB24_Msk: u32 = 16777216;
pub const CAN_F11R1_FB24: u32 = 16777216;
pub const CAN_F11R1_FB25_Pos: u32 = 25;
pub const CAN_F11R1_FB25_Msk: u32 = 33554432;
pub const CAN_F11R1_FB25: u32 = 33554432;
pub const CAN_F11R1_FB26_Pos: u32 = 26;
pub const CAN_F11R1_FB26_Msk: u32 = 67108864;
pub const CAN_F11R1_FB26: u32 = 67108864;
pub const CAN_F11R1_FB27_Pos: u32 = 27;
pub const CAN_F11R1_FB27_Msk: u32 = 134217728;
pub const CAN_F11R1_FB27: u32 = 134217728;
pub const CAN_F11R1_FB28_Pos: u32 = 28;
pub const CAN_F11R1_FB28_Msk: u32 = 268435456;
pub const CAN_F11R1_FB28: u32 = 268435456;
pub const CAN_F11R1_FB29_Pos: u32 = 29;
pub const CAN_F11R1_FB29_Msk: u32 = 536870912;
pub const CAN_F11R1_FB29: u32 = 536870912;
pub const CAN_F11R1_FB30_Pos: u32 = 30;
pub const CAN_F11R1_FB30_Msk: u32 = 1073741824;
pub const CAN_F11R1_FB30: u32 = 1073741824;
pub const CAN_F11R1_FB31_Pos: u32 = 31;
pub const CAN_F11R1_FB31_Msk: u32 = 2147483648;
pub const CAN_F11R1_FB31: u32 = 2147483648;
pub const CAN_F12R1_FB0_Pos: u32 = 0;
pub const CAN_F12R1_FB0_Msk: u32 = 1;
pub const CAN_F12R1_FB0: u32 = 1;
pub const CAN_F12R1_FB1_Pos: u32 = 1;
pub const CAN_F12R1_FB1_Msk: u32 = 2;
pub const CAN_F12R1_FB1: u32 = 2;
pub const CAN_F12R1_FB2_Pos: u32 = 2;
pub const CAN_F12R1_FB2_Msk: u32 = 4;
pub const CAN_F12R1_FB2: u32 = 4;
pub const CAN_F12R1_FB3_Pos: u32 = 3;
pub const CAN_F12R1_FB3_Msk: u32 = 8;
pub const CAN_F12R1_FB3: u32 = 8;
pub const CAN_F12R1_FB4_Pos: u32 = 4;
pub const CAN_F12R1_FB4_Msk: u32 = 16;
pub const CAN_F12R1_FB4: u32 = 16;
pub const CAN_F12R1_FB5_Pos: u32 = 5;
pub const CAN_F12R1_FB5_Msk: u32 = 32;
pub const CAN_F12R1_FB5: u32 = 32;
pub const CAN_F12R1_FB6_Pos: u32 = 6;
pub const CAN_F12R1_FB6_Msk: u32 = 64;
pub const CAN_F12R1_FB6: u32 = 64;
pub const CAN_F12R1_FB7_Pos: u32 = 7;
pub const CAN_F12R1_FB7_Msk: u32 = 128;
pub const CAN_F12R1_FB7: u32 = 128;
pub const CAN_F12R1_FB8_Pos: u32 = 8;
pub const CAN_F12R1_FB8_Msk: u32 = 256;
pub const CAN_F12R1_FB8: u32 = 256;
pub const CAN_F12R1_FB9_Pos: u32 = 9;
pub const CAN_F12R1_FB9_Msk: u32 = 512;
pub const CAN_F12R1_FB9: u32 = 512;
pub const CAN_F12R1_FB10_Pos: u32 = 10;
pub const CAN_F12R1_FB10_Msk: u32 = 1024;
pub const CAN_F12R1_FB10: u32 = 1024;
pub const CAN_F12R1_FB11_Pos: u32 = 11;
pub const CAN_F12R1_FB11_Msk: u32 = 2048;
pub const CAN_F12R1_FB11: u32 = 2048;
pub const CAN_F12R1_FB12_Pos: u32 = 12;
pub const CAN_F12R1_FB12_Msk: u32 = 4096;
pub const CAN_F12R1_FB12: u32 = 4096;
pub const CAN_F12R1_FB13_Pos: u32 = 13;
pub const CAN_F12R1_FB13_Msk: u32 = 8192;
pub const CAN_F12R1_FB13: u32 = 8192;
pub const CAN_F12R1_FB14_Pos: u32 = 14;
pub const CAN_F12R1_FB14_Msk: u32 = 16384;
pub const CAN_F12R1_FB14: u32 = 16384;
pub const CAN_F12R1_FB15_Pos: u32 = 15;
pub const CAN_F12R1_FB15_Msk: u32 = 32768;
pub const CAN_F12R1_FB15: u32 = 32768;
pub const CAN_F12R1_FB16_Pos: u32 = 16;
pub const CAN_F12R1_FB16_Msk: u32 = 65536;
pub const CAN_F12R1_FB16: u32 = 65536;
pub const CAN_F12R1_FB17_Pos: u32 = 17;
pub const CAN_F12R1_FB17_Msk: u32 = 131072;
pub const CAN_F12R1_FB17: u32 = 131072;
pub const CAN_F12R1_FB18_Pos: u32 = 18;
pub const CAN_F12R1_FB18_Msk: u32 = 262144;
pub const CAN_F12R1_FB18: u32 = 262144;
pub const CAN_F12R1_FB19_Pos: u32 = 19;
pub const CAN_F12R1_FB19_Msk: u32 = 524288;
pub const CAN_F12R1_FB19: u32 = 524288;
pub const CAN_F12R1_FB20_Pos: u32 = 20;
pub const CAN_F12R1_FB20_Msk: u32 = 1048576;
pub const CAN_F12R1_FB20: u32 = 1048576;
pub const CAN_F12R1_FB21_Pos: u32 = 21;
pub const CAN_F12R1_FB21_Msk: u32 = 2097152;
pub const CAN_F12R1_FB21: u32 = 2097152;
pub const CAN_F12R1_FB22_Pos: u32 = 22;
pub const CAN_F12R1_FB22_Msk: u32 = 4194304;
pub const CAN_F12R1_FB22: u32 = 4194304;
pub const CAN_F12R1_FB23_Pos: u32 = 23;
pub const CAN_F12R1_FB23_Msk: u32 = 8388608;
pub const CAN_F12R1_FB23: u32 = 8388608;
pub const CAN_F12R1_FB24_Pos: u32 = 24;
pub const CAN_F12R1_FB24_Msk: u32 = 16777216;
pub const CAN_F12R1_FB24: u32 = 16777216;
pub const CAN_F12R1_FB25_Pos: u32 = 25;
pub const CAN_F12R1_FB25_Msk: u32 = 33554432;
pub const CAN_F12R1_FB25: u32 = 33554432;
pub const CAN_F12R1_FB26_Pos: u32 = 26;
pub const CAN_F12R1_FB26_Msk: u32 = 67108864;
pub const CAN_F12R1_FB26: u32 = 67108864;
pub const CAN_F12R1_FB27_Pos: u32 = 27;
pub const CAN_F12R1_FB27_Msk: u32 = 134217728;
pub const CAN_F12R1_FB27: u32 = 134217728;
pub const CAN_F12R1_FB28_Pos: u32 = 28;
pub const CAN_F12R1_FB28_Msk: u32 = 268435456;
pub const CAN_F12R1_FB28: u32 = 268435456;
pub const CAN_F12R1_FB29_Pos: u32 = 29;
pub const CAN_F12R1_FB29_Msk: u32 = 536870912;
pub const CAN_F12R1_FB29: u32 = 536870912;
pub const CAN_F12R1_FB30_Pos: u32 = 30;
pub const CAN_F12R1_FB30_Msk: u32 = 1073741824;
pub const CAN_F12R1_FB30: u32 = 1073741824;
pub const CAN_F12R1_FB31_Pos: u32 = 31;
pub const CAN_F12R1_FB31_Msk: u32 = 2147483648;
pub const CAN_F12R1_FB31: u32 = 2147483648;
pub const CAN_F13R1_FB0_Pos: u32 = 0;
pub const CAN_F13R1_FB0_Msk: u32 = 1;
pub const CAN_F13R1_FB0: u32 = 1;
pub const CAN_F13R1_FB1_Pos: u32 = 1;
pub const CAN_F13R1_FB1_Msk: u32 = 2;
pub const CAN_F13R1_FB1: u32 = 2;
pub const CAN_F13R1_FB2_Pos: u32 = 2;
pub const CAN_F13R1_FB2_Msk: u32 = 4;
pub const CAN_F13R1_FB2: u32 = 4;
pub const CAN_F13R1_FB3_Pos: u32 = 3;
pub const CAN_F13R1_FB3_Msk: u32 = 8;
pub const CAN_F13R1_FB3: u32 = 8;
pub const CAN_F13R1_FB4_Pos: u32 = 4;
pub const CAN_F13R1_FB4_Msk: u32 = 16;
pub const CAN_F13R1_FB4: u32 = 16;
pub const CAN_F13R1_FB5_Pos: u32 = 5;
pub const CAN_F13R1_FB5_Msk: u32 = 32;
pub const CAN_F13R1_FB5: u32 = 32;
pub const CAN_F13R1_FB6_Pos: u32 = 6;
pub const CAN_F13R1_FB6_Msk: u32 = 64;
pub const CAN_F13R1_FB6: u32 = 64;
pub const CAN_F13R1_FB7_Pos: u32 = 7;
pub const CAN_F13R1_FB7_Msk: u32 = 128;
pub const CAN_F13R1_FB7: u32 = 128;
pub const CAN_F13R1_FB8_Pos: u32 = 8;
pub const CAN_F13R1_FB8_Msk: u32 = 256;
pub const CAN_F13R1_FB8: u32 = 256;
pub const CAN_F13R1_FB9_Pos: u32 = 9;
pub const CAN_F13R1_FB9_Msk: u32 = 512;
pub const CAN_F13R1_FB9: u32 = 512;
pub const CAN_F13R1_FB10_Pos: u32 = 10;
pub const CAN_F13R1_FB10_Msk: u32 = 1024;
pub const CAN_F13R1_FB10: u32 = 1024;
pub const CAN_F13R1_FB11_Pos: u32 = 11;
pub const CAN_F13R1_FB11_Msk: u32 = 2048;
pub const CAN_F13R1_FB11: u32 = 2048;
pub const CAN_F13R1_FB12_Pos: u32 = 12;
pub const CAN_F13R1_FB12_Msk: u32 = 4096;
pub const CAN_F13R1_FB12: u32 = 4096;
pub const CAN_F13R1_FB13_Pos: u32 = 13;
pub const CAN_F13R1_FB13_Msk: u32 = 8192;
pub const CAN_F13R1_FB13: u32 = 8192;
pub const CAN_F13R1_FB14_Pos: u32 = 14;
pub const CAN_F13R1_FB14_Msk: u32 = 16384;
pub const CAN_F13R1_FB14: u32 = 16384;
pub const CAN_F13R1_FB15_Pos: u32 = 15;
pub const CAN_F13R1_FB15_Msk: u32 = 32768;
pub const CAN_F13R1_FB15: u32 = 32768;
pub const CAN_F13R1_FB16_Pos: u32 = 16;
pub const CAN_F13R1_FB16_Msk: u32 = 65536;
pub const CAN_F13R1_FB16: u32 = 65536;
pub const CAN_F13R1_FB17_Pos: u32 = 17;
pub const CAN_F13R1_FB17_Msk: u32 = 131072;
pub const CAN_F13R1_FB17: u32 = 131072;
pub const CAN_F13R1_FB18_Pos: u32 = 18;
pub const CAN_F13R1_FB18_Msk: u32 = 262144;
pub const CAN_F13R1_FB18: u32 = 262144;
pub const CAN_F13R1_FB19_Pos: u32 = 19;
pub const CAN_F13R1_FB19_Msk: u32 = 524288;
pub const CAN_F13R1_FB19: u32 = 524288;
pub const CAN_F13R1_FB20_Pos: u32 = 20;
pub const CAN_F13R1_FB20_Msk: u32 = 1048576;
pub const CAN_F13R1_FB20: u32 = 1048576;
pub const CAN_F13R1_FB21_Pos: u32 = 21;
pub const CAN_F13R1_FB21_Msk: u32 = 2097152;
pub const CAN_F13R1_FB21: u32 = 2097152;
pub const CAN_F13R1_FB22_Pos: u32 = 22;
pub const CAN_F13R1_FB22_Msk: u32 = 4194304;
pub const CAN_F13R1_FB22: u32 = 4194304;
pub const CAN_F13R1_FB23_Pos: u32 = 23;
pub const CAN_F13R1_FB23_Msk: u32 = 8388608;
pub const CAN_F13R1_FB23: u32 = 8388608;
pub const CAN_F13R1_FB24_Pos: u32 = 24;
pub const CAN_F13R1_FB24_Msk: u32 = 16777216;
pub const CAN_F13R1_FB24: u32 = 16777216;
pub const CAN_F13R1_FB25_Pos: u32 = 25;
pub const CAN_F13R1_FB25_Msk: u32 = 33554432;
pub const CAN_F13R1_FB25: u32 = 33554432;
pub const CAN_F13R1_FB26_Pos: u32 = 26;
pub const CAN_F13R1_FB26_Msk: u32 = 67108864;
pub const CAN_F13R1_FB26: u32 = 67108864;
pub const CAN_F13R1_FB27_Pos: u32 = 27;
pub const CAN_F13R1_FB27_Msk: u32 = 134217728;
pub const CAN_F13R1_FB27: u32 = 134217728;
pub const CAN_F13R1_FB28_Pos: u32 = 28;
pub const CAN_F13R1_FB28_Msk: u32 = 268435456;
pub const CAN_F13R1_FB28: u32 = 268435456;
pub const CAN_F13R1_FB29_Pos: u32 = 29;
pub const CAN_F13R1_FB29_Msk: u32 = 536870912;
pub const CAN_F13R1_FB29: u32 = 536870912;
pub const CAN_F13R1_FB30_Pos: u32 = 30;
pub const CAN_F13R1_FB30_Msk: u32 = 1073741824;
pub const CAN_F13R1_FB30: u32 = 1073741824;
pub const CAN_F13R1_FB31_Pos: u32 = 31;
pub const CAN_F13R1_FB31_Msk: u32 = 2147483648;
pub const CAN_F13R1_FB31: u32 = 2147483648;
pub const CAN_F0R2_FB0_Pos: u32 = 0;
pub const CAN_F0R2_FB0_Msk: u32 = 1;
pub const CAN_F0R2_FB0: u32 = 1;
pub const CAN_F0R2_FB1_Pos: u32 = 1;
pub const CAN_F0R2_FB1_Msk: u32 = 2;
pub const CAN_F0R2_FB1: u32 = 2;
pub const CAN_F0R2_FB2_Pos: u32 = 2;
pub const CAN_F0R2_FB2_Msk: u32 = 4;
pub const CAN_F0R2_FB2: u32 = 4;
pub const CAN_F0R2_FB3_Pos: u32 = 3;
pub const CAN_F0R2_FB3_Msk: u32 = 8;
pub const CAN_F0R2_FB3: u32 = 8;
pub const CAN_F0R2_FB4_Pos: u32 = 4;
pub const CAN_F0R2_FB4_Msk: u32 = 16;
pub const CAN_F0R2_FB4: u32 = 16;
pub const CAN_F0R2_FB5_Pos: u32 = 5;
pub const CAN_F0R2_FB5_Msk: u32 = 32;
pub const CAN_F0R2_FB5: u32 = 32;
pub const CAN_F0R2_FB6_Pos: u32 = 6;
pub const CAN_F0R2_FB6_Msk: u32 = 64;
pub const CAN_F0R2_FB6: u32 = 64;
pub const CAN_F0R2_FB7_Pos: u32 = 7;
pub const CAN_F0R2_FB7_Msk: u32 = 128;
pub const CAN_F0R2_FB7: u32 = 128;
pub const CAN_F0R2_FB8_Pos: u32 = 8;
pub const CAN_F0R2_FB8_Msk: u32 = 256;
pub const CAN_F0R2_FB8: u32 = 256;
pub const CAN_F0R2_FB9_Pos: u32 = 9;
pub const CAN_F0R2_FB9_Msk: u32 = 512;
pub const CAN_F0R2_FB9: u32 = 512;
pub const CAN_F0R2_FB10_Pos: u32 = 10;
pub const CAN_F0R2_FB10_Msk: u32 = 1024;
pub const CAN_F0R2_FB10: u32 = 1024;
pub const CAN_F0R2_FB11_Pos: u32 = 11;
pub const CAN_F0R2_FB11_Msk: u32 = 2048;
pub const CAN_F0R2_FB11: u32 = 2048;
pub const CAN_F0R2_FB12_Pos: u32 = 12;
pub const CAN_F0R2_FB12_Msk: u32 = 4096;
pub const CAN_F0R2_FB12: u32 = 4096;
pub const CAN_F0R2_FB13_Pos: u32 = 13;
pub const CAN_F0R2_FB13_Msk: u32 = 8192;
pub const CAN_F0R2_FB13: u32 = 8192;
pub const CAN_F0R2_FB14_Pos: u32 = 14;
pub const CAN_F0R2_FB14_Msk: u32 = 16384;
pub const CAN_F0R2_FB14: u32 = 16384;
pub const CAN_F0R2_FB15_Pos: u32 = 15;
pub const CAN_F0R2_FB15_Msk: u32 = 32768;
pub const CAN_F0R2_FB15: u32 = 32768;
pub const CAN_F0R2_FB16_Pos: u32 = 16;
pub const CAN_F0R2_FB16_Msk: u32 = 65536;
pub const CAN_F0R2_FB16: u32 = 65536;
pub const CAN_F0R2_FB17_Pos: u32 = 17;
pub const CAN_F0R2_FB17_Msk: u32 = 131072;
pub const CAN_F0R2_FB17: u32 = 131072;
pub const CAN_F0R2_FB18_Pos: u32 = 18;
pub const CAN_F0R2_FB18_Msk: u32 = 262144;
pub const CAN_F0R2_FB18: u32 = 262144;
pub const CAN_F0R2_FB19_Pos: u32 = 19;
pub const CAN_F0R2_FB19_Msk: u32 = 524288;
pub const CAN_F0R2_FB19: u32 = 524288;
pub const CAN_F0R2_FB20_Pos: u32 = 20;
pub const CAN_F0R2_FB20_Msk: u32 = 1048576;
pub const CAN_F0R2_FB20: u32 = 1048576;
pub const CAN_F0R2_FB21_Pos: u32 = 21;
pub const CAN_F0R2_FB21_Msk: u32 = 2097152;
pub const CAN_F0R2_FB21: u32 = 2097152;
pub const CAN_F0R2_FB22_Pos: u32 = 22;
pub const CAN_F0R2_FB22_Msk: u32 = 4194304;
pub const CAN_F0R2_FB22: u32 = 4194304;
pub const CAN_F0R2_FB23_Pos: u32 = 23;
pub const CAN_F0R2_FB23_Msk: u32 = 8388608;
pub const CAN_F0R2_FB23: u32 = 8388608;
pub const CAN_F0R2_FB24_Pos: u32 = 24;
pub const CAN_F0R2_FB24_Msk: u32 = 16777216;
pub const CAN_F0R2_FB24: u32 = 16777216;
pub const CAN_F0R2_FB25_Pos: u32 = 25;
pub const CAN_F0R2_FB25_Msk: u32 = 33554432;
pub const CAN_F0R2_FB25: u32 = 33554432;
pub const CAN_F0R2_FB26_Pos: u32 = 26;
pub const CAN_F0R2_FB26_Msk: u32 = 67108864;
pub const CAN_F0R2_FB26: u32 = 67108864;
pub const CAN_F0R2_FB27_Pos: u32 = 27;
pub const CAN_F0R2_FB27_Msk: u32 = 134217728;
pub const CAN_F0R2_FB27: u32 = 134217728;
pub const CAN_F0R2_FB28_Pos: u32 = 28;
pub const CAN_F0R2_FB28_Msk: u32 = 268435456;
pub const CAN_F0R2_FB28: u32 = 268435456;
pub const CAN_F0R2_FB29_Pos: u32 = 29;
pub const CAN_F0R2_FB29_Msk: u32 = 536870912;
pub const CAN_F0R2_FB29: u32 = 536870912;
pub const CAN_F0R2_FB30_Pos: u32 = 30;
pub const CAN_F0R2_FB30_Msk: u32 = 1073741824;
pub const CAN_F0R2_FB30: u32 = 1073741824;
pub const CAN_F0R2_FB31_Pos: u32 = 31;
pub const CAN_F0R2_FB31_Msk: u32 = 2147483648;
pub const CAN_F0R2_FB31: u32 = 2147483648;
pub const CAN_F1R2_FB0_Pos: u32 = 0;
pub const CAN_F1R2_FB0_Msk: u32 = 1;
pub const CAN_F1R2_FB0: u32 = 1;
pub const CAN_F1R2_FB1_Pos: u32 = 1;
pub const CAN_F1R2_FB1_Msk: u32 = 2;
pub const CAN_F1R2_FB1: u32 = 2;
pub const CAN_F1R2_FB2_Pos: u32 = 2;
pub const CAN_F1R2_FB2_Msk: u32 = 4;
pub const CAN_F1R2_FB2: u32 = 4;
pub const CAN_F1R2_FB3_Pos: u32 = 3;
pub const CAN_F1R2_FB3_Msk: u32 = 8;
pub const CAN_F1R2_FB3: u32 = 8;
pub const CAN_F1R2_FB4_Pos: u32 = 4;
pub const CAN_F1R2_FB4_Msk: u32 = 16;
pub const CAN_F1R2_FB4: u32 = 16;
pub const CAN_F1R2_FB5_Pos: u32 = 5;
pub const CAN_F1R2_FB5_Msk: u32 = 32;
pub const CAN_F1R2_FB5: u32 = 32;
pub const CAN_F1R2_FB6_Pos: u32 = 6;
pub const CAN_F1R2_FB6_Msk: u32 = 64;
pub const CAN_F1R2_FB6: u32 = 64;
pub const CAN_F1R2_FB7_Pos: u32 = 7;
pub const CAN_F1R2_FB7_Msk: u32 = 128;
pub const CAN_F1R2_FB7: u32 = 128;
pub const CAN_F1R2_FB8_Pos: u32 = 8;
pub const CAN_F1R2_FB8_Msk: u32 = 256;
pub const CAN_F1R2_FB8: u32 = 256;
pub const CAN_F1R2_FB9_Pos: u32 = 9;
pub const CAN_F1R2_FB9_Msk: u32 = 512;
pub const CAN_F1R2_FB9: u32 = 512;
pub const CAN_F1R2_FB10_Pos: u32 = 10;
pub const CAN_F1R2_FB10_Msk: u32 = 1024;
pub const CAN_F1R2_FB10: u32 = 1024;
pub const CAN_F1R2_FB11_Pos: u32 = 11;
pub const CAN_F1R2_FB11_Msk: u32 = 2048;
pub const CAN_F1R2_FB11: u32 = 2048;
pub const CAN_F1R2_FB12_Pos: u32 = 12;
pub const CAN_F1R2_FB12_Msk: u32 = 4096;
pub const CAN_F1R2_FB12: u32 = 4096;
pub const CAN_F1R2_FB13_Pos: u32 = 13;
pub const CAN_F1R2_FB13_Msk: u32 = 8192;
pub const CAN_F1R2_FB13: u32 = 8192;
pub const CAN_F1R2_FB14_Pos: u32 = 14;
pub const CAN_F1R2_FB14_Msk: u32 = 16384;
pub const CAN_F1R2_FB14: u32 = 16384;
pub const CAN_F1R2_FB15_Pos: u32 = 15;
pub const CAN_F1R2_FB15_Msk: u32 = 32768;
pub const CAN_F1R2_FB15: u32 = 32768;
pub const CAN_F1R2_FB16_Pos: u32 = 16;
pub const CAN_F1R2_FB16_Msk: u32 = 65536;
pub const CAN_F1R2_FB16: u32 = 65536;
pub const CAN_F1R2_FB17_Pos: u32 = 17;
pub const CAN_F1R2_FB17_Msk: u32 = 131072;
pub const CAN_F1R2_FB17: u32 = 131072;
pub const CAN_F1R2_FB18_Pos: u32 = 18;
pub const CAN_F1R2_FB18_Msk: u32 = 262144;
pub const CAN_F1R2_FB18: u32 = 262144;
pub const CAN_F1R2_FB19_Pos: u32 = 19;
pub const CAN_F1R2_FB19_Msk: u32 = 524288;
pub const CAN_F1R2_FB19: u32 = 524288;
pub const CAN_F1R2_FB20_Pos: u32 = 20;
pub const CAN_F1R2_FB20_Msk: u32 = 1048576;
pub const CAN_F1R2_FB20: u32 = 1048576;
pub const CAN_F1R2_FB21_Pos: u32 = 21;
pub const CAN_F1R2_FB21_Msk: u32 = 2097152;
pub const CAN_F1R2_FB21: u32 = 2097152;
pub const CAN_F1R2_FB22_Pos: u32 = 22;
pub const CAN_F1R2_FB22_Msk: u32 = 4194304;
pub const CAN_F1R2_FB22: u32 = 4194304;
pub const CAN_F1R2_FB23_Pos: u32 = 23;
pub const CAN_F1R2_FB23_Msk: u32 = 8388608;
pub const CAN_F1R2_FB23: u32 = 8388608;
pub const CAN_F1R2_FB24_Pos: u32 = 24;
pub const CAN_F1R2_FB24_Msk: u32 = 16777216;
pub const CAN_F1R2_FB24: u32 = 16777216;
pub const CAN_F1R2_FB25_Pos: u32 = 25;
pub const CAN_F1R2_FB25_Msk: u32 = 33554432;
pub const CAN_F1R2_FB25: u32 = 33554432;
pub const CAN_F1R2_FB26_Pos: u32 = 26;
pub const CAN_F1R2_FB26_Msk: u32 = 67108864;
pub const CAN_F1R2_FB26: u32 = 67108864;
pub const CAN_F1R2_FB27_Pos: u32 = 27;
pub const CAN_F1R2_FB27_Msk: u32 = 134217728;
pub const CAN_F1R2_FB27: u32 = 134217728;
pub const CAN_F1R2_FB28_Pos: u32 = 28;
pub const CAN_F1R2_FB28_Msk: u32 = 268435456;
pub const CAN_F1R2_FB28: u32 = 268435456;
pub const CAN_F1R2_FB29_Pos: u32 = 29;
pub const CAN_F1R2_FB29_Msk: u32 = 536870912;
pub const CAN_F1R2_FB29: u32 = 536870912;
pub const CAN_F1R2_FB30_Pos: u32 = 30;
pub const CAN_F1R2_FB30_Msk: u32 = 1073741824;
pub const CAN_F1R2_FB30: u32 = 1073741824;
pub const CAN_F1R2_FB31_Pos: u32 = 31;
pub const CAN_F1R2_FB31_Msk: u32 = 2147483648;
pub const CAN_F1R2_FB31: u32 = 2147483648;
pub const CAN_F2R2_FB0_Pos: u32 = 0;
pub const CAN_F2R2_FB0_Msk: u32 = 1;
pub const CAN_F2R2_FB0: u32 = 1;
pub const CAN_F2R2_FB1_Pos: u32 = 1;
pub const CAN_F2R2_FB1_Msk: u32 = 2;
pub const CAN_F2R2_FB1: u32 = 2;
pub const CAN_F2R2_FB2_Pos: u32 = 2;
pub const CAN_F2R2_FB2_Msk: u32 = 4;
pub const CAN_F2R2_FB2: u32 = 4;
pub const CAN_F2R2_FB3_Pos: u32 = 3;
pub const CAN_F2R2_FB3_Msk: u32 = 8;
pub const CAN_F2R2_FB3: u32 = 8;
pub const CAN_F2R2_FB4_Pos: u32 = 4;
pub const CAN_F2R2_FB4_Msk: u32 = 16;
pub const CAN_F2R2_FB4: u32 = 16;
pub const CAN_F2R2_FB5_Pos: u32 = 5;
pub const CAN_F2R2_FB5_Msk: u32 = 32;
pub const CAN_F2R2_FB5: u32 = 32;
pub const CAN_F2R2_FB6_Pos: u32 = 6;
pub const CAN_F2R2_FB6_Msk: u32 = 64;
pub const CAN_F2R2_FB6: u32 = 64;
pub const CAN_F2R2_FB7_Pos: u32 = 7;
pub const CAN_F2R2_FB7_Msk: u32 = 128;
pub const CAN_F2R2_FB7: u32 = 128;
pub const CAN_F2R2_FB8_Pos: u32 = 8;
pub const CAN_F2R2_FB8_Msk: u32 = 256;
pub const CAN_F2R2_FB8: u32 = 256;
pub const CAN_F2R2_FB9_Pos: u32 = 9;
pub const CAN_F2R2_FB9_Msk: u32 = 512;
pub const CAN_F2R2_FB9: u32 = 512;
pub const CAN_F2R2_FB10_Pos: u32 = 10;
pub const CAN_F2R2_FB10_Msk: u32 = 1024;
pub const CAN_F2R2_FB10: u32 = 1024;
pub const CAN_F2R2_FB11_Pos: u32 = 11;
pub const CAN_F2R2_FB11_Msk: u32 = 2048;
pub const CAN_F2R2_FB11: u32 = 2048;
pub const CAN_F2R2_FB12_Pos: u32 = 12;
pub const CAN_F2R2_FB12_Msk: u32 = 4096;
pub const CAN_F2R2_FB12: u32 = 4096;
pub const CAN_F2R2_FB13_Pos: u32 = 13;
pub const CAN_F2R2_FB13_Msk: u32 = 8192;
pub const CAN_F2R2_FB13: u32 = 8192;
pub const CAN_F2R2_FB14_Pos: u32 = 14;
pub const CAN_F2R2_FB14_Msk: u32 = 16384;
pub const CAN_F2R2_FB14: u32 = 16384;
pub const CAN_F2R2_FB15_Pos: u32 = 15;
pub const CAN_F2R2_FB15_Msk: u32 = 32768;
pub const CAN_F2R2_FB15: u32 = 32768;
pub const CAN_F2R2_FB16_Pos: u32 = 16;
pub const CAN_F2R2_FB16_Msk: u32 = 65536;
pub const CAN_F2R2_FB16: u32 = 65536;
pub const CAN_F2R2_FB17_Pos: u32 = 17;
pub const CAN_F2R2_FB17_Msk: u32 = 131072;
pub const CAN_F2R2_FB17: u32 = 131072;
pub const CAN_F2R2_FB18_Pos: u32 = 18;
pub const CAN_F2R2_FB18_Msk: u32 = 262144;
pub const CAN_F2R2_FB18: u32 = 262144;
pub const CAN_F2R2_FB19_Pos: u32 = 19;
pub const CAN_F2R2_FB19_Msk: u32 = 524288;
pub const CAN_F2R2_FB19: u32 = 524288;
pub const CAN_F2R2_FB20_Pos: u32 = 20;
pub const CAN_F2R2_FB20_Msk: u32 = 1048576;
pub const CAN_F2R2_FB20: u32 = 1048576;
pub const CAN_F2R2_FB21_Pos: u32 = 21;
pub const CAN_F2R2_FB21_Msk: u32 = 2097152;
pub const CAN_F2R2_FB21: u32 = 2097152;
pub const CAN_F2R2_FB22_Pos: u32 = 22;
pub const CAN_F2R2_FB22_Msk: u32 = 4194304;
pub const CAN_F2R2_FB22: u32 = 4194304;
pub const CAN_F2R2_FB23_Pos: u32 = 23;
pub const CAN_F2R2_FB23_Msk: u32 = 8388608;
pub const CAN_F2R2_FB23: u32 = 8388608;
pub const CAN_F2R2_FB24_Pos: u32 = 24;
pub const CAN_F2R2_FB24_Msk: u32 = 16777216;
pub const CAN_F2R2_FB24: u32 = 16777216;
pub const CAN_F2R2_FB25_Pos: u32 = 25;
pub const CAN_F2R2_FB25_Msk: u32 = 33554432;
pub const CAN_F2R2_FB25: u32 = 33554432;
pub const CAN_F2R2_FB26_Pos: u32 = 26;
pub const CAN_F2R2_FB26_Msk: u32 = 67108864;
pub const CAN_F2R2_FB26: u32 = 67108864;
pub const CAN_F2R2_FB27_Pos: u32 = 27;
pub const CAN_F2R2_FB27_Msk: u32 = 134217728;
pub const CAN_F2R2_FB27: u32 = 134217728;
pub const CAN_F2R2_FB28_Pos: u32 = 28;
pub const CAN_F2R2_FB28_Msk: u32 = 268435456;
pub const CAN_F2R2_FB28: u32 = 268435456;
pub const CAN_F2R2_FB29_Pos: u32 = 29;
pub const CAN_F2R2_FB29_Msk: u32 = 536870912;
pub const CAN_F2R2_FB29: u32 = 536870912;
pub const CAN_F2R2_FB30_Pos: u32 = 30;
pub const CAN_F2R2_FB30_Msk: u32 = 1073741824;
pub const CAN_F2R2_FB30: u32 = 1073741824;
pub const CAN_F2R2_FB31_Pos: u32 = 31;
pub const CAN_F2R2_FB31_Msk: u32 = 2147483648;
pub const CAN_F2R2_FB31: u32 = 2147483648;
pub const CAN_F3R2_FB0_Pos: u32 = 0;
pub const CAN_F3R2_FB0_Msk: u32 = 1;
pub const CAN_F3R2_FB0: u32 = 1;
pub const CAN_F3R2_FB1_Pos: u32 = 1;
pub const CAN_F3R2_FB1_Msk: u32 = 2;
pub const CAN_F3R2_FB1: u32 = 2;
pub const CAN_F3R2_FB2_Pos: u32 = 2;
pub const CAN_F3R2_FB2_Msk: u32 = 4;
pub const CAN_F3R2_FB2: u32 = 4;
pub const CAN_F3R2_FB3_Pos: u32 = 3;
pub const CAN_F3R2_FB3_Msk: u32 = 8;
pub const CAN_F3R2_FB3: u32 = 8;
pub const CAN_F3R2_FB4_Pos: u32 = 4;
pub const CAN_F3R2_FB4_Msk: u32 = 16;
pub const CAN_F3R2_FB4: u32 = 16;
pub const CAN_F3R2_FB5_Pos: u32 = 5;
pub const CAN_F3R2_FB5_Msk: u32 = 32;
pub const CAN_F3R2_FB5: u32 = 32;
pub const CAN_F3R2_FB6_Pos: u32 = 6;
pub const CAN_F3R2_FB6_Msk: u32 = 64;
pub const CAN_F3R2_FB6: u32 = 64;
pub const CAN_F3R2_FB7_Pos: u32 = 7;
pub const CAN_F3R2_FB7_Msk: u32 = 128;
pub const CAN_F3R2_FB7: u32 = 128;
pub const CAN_F3R2_FB8_Pos: u32 = 8;
pub const CAN_F3R2_FB8_Msk: u32 = 256;
pub const CAN_F3R2_FB8: u32 = 256;
pub const CAN_F3R2_FB9_Pos: u32 = 9;
pub const CAN_F3R2_FB9_Msk: u32 = 512;
pub const CAN_F3R2_FB9: u32 = 512;
pub const CAN_F3R2_FB10_Pos: u32 = 10;
pub const CAN_F3R2_FB10_Msk: u32 = 1024;
pub const CAN_F3R2_FB10: u32 = 1024;
pub const CAN_F3R2_FB11_Pos: u32 = 11;
pub const CAN_F3R2_FB11_Msk: u32 = 2048;
pub const CAN_F3R2_FB11: u32 = 2048;
pub const CAN_F3R2_FB12_Pos: u32 = 12;
pub const CAN_F3R2_FB12_Msk: u32 = 4096;
pub const CAN_F3R2_FB12: u32 = 4096;
pub const CAN_F3R2_FB13_Pos: u32 = 13;
pub const CAN_F3R2_FB13_Msk: u32 = 8192;
pub const CAN_F3R2_FB13: u32 = 8192;
pub const CAN_F3R2_FB14_Pos: u32 = 14;
pub const CAN_F3R2_FB14_Msk: u32 = 16384;
pub const CAN_F3R2_FB14: u32 = 16384;
pub const CAN_F3R2_FB15_Pos: u32 = 15;
pub const CAN_F3R2_FB15_Msk: u32 = 32768;
pub const CAN_F3R2_FB15: u32 = 32768;
pub const CAN_F3R2_FB16_Pos: u32 = 16;
pub const CAN_F3R2_FB16_Msk: u32 = 65536;
pub const CAN_F3R2_FB16: u32 = 65536;
pub const CAN_F3R2_FB17_Pos: u32 = 17;
pub const CAN_F3R2_FB17_Msk: u32 = 131072;
pub const CAN_F3R2_FB17: u32 = 131072;
pub const CAN_F3R2_FB18_Pos: u32 = 18;
pub const CAN_F3R2_FB18_Msk: u32 = 262144;
pub const CAN_F3R2_FB18: u32 = 262144;
pub const CAN_F3R2_FB19_Pos: u32 = 19;
pub const CAN_F3R2_FB19_Msk: u32 = 524288;
pub const CAN_F3R2_FB19: u32 = 524288;
pub const CAN_F3R2_FB20_Pos: u32 = 20;
pub const CAN_F3R2_FB20_Msk: u32 = 1048576;
pub const CAN_F3R2_FB20: u32 = 1048576;
pub const CAN_F3R2_FB21_Pos: u32 = 21;
pub const CAN_F3R2_FB21_Msk: u32 = 2097152;
pub const CAN_F3R2_FB21: u32 = 2097152;
pub const CAN_F3R2_FB22_Pos: u32 = 22;
pub const CAN_F3R2_FB22_Msk: u32 = 4194304;
pub const CAN_F3R2_FB22: u32 = 4194304;
pub const CAN_F3R2_FB23_Pos: u32 = 23;
pub const CAN_F3R2_FB23_Msk: u32 = 8388608;
pub const CAN_F3R2_FB23: u32 = 8388608;
pub const CAN_F3R2_FB24_Pos: u32 = 24;
pub const CAN_F3R2_FB24_Msk: u32 = 16777216;
pub const CAN_F3R2_FB24: u32 = 16777216;
pub const CAN_F3R2_FB25_Pos: u32 = 25;
pub const CAN_F3R2_FB25_Msk: u32 = 33554432;
pub const CAN_F3R2_FB25: u32 = 33554432;
pub const CAN_F3R2_FB26_Pos: u32 = 26;
pub const CAN_F3R2_FB26_Msk: u32 = 67108864;
pub const CAN_F3R2_FB26: u32 = 67108864;
pub const CAN_F3R2_FB27_Pos: u32 = 27;
pub const CAN_F3R2_FB27_Msk: u32 = 134217728;
pub const CAN_F3R2_FB27: u32 = 134217728;
pub const CAN_F3R2_FB28_Pos: u32 = 28;
pub const CAN_F3R2_FB28_Msk: u32 = 268435456;
pub const CAN_F3R2_FB28: u32 = 268435456;
pub const CAN_F3R2_FB29_Pos: u32 = 29;
pub const CAN_F3R2_FB29_Msk: u32 = 536870912;
pub const CAN_F3R2_FB29: u32 = 536870912;
pub const CAN_F3R2_FB30_Pos: u32 = 30;
pub const CAN_F3R2_FB30_Msk: u32 = 1073741824;
pub const CAN_F3R2_FB30: u32 = 1073741824;
pub const CAN_F3R2_FB31_Pos: u32 = 31;
pub const CAN_F3R2_FB31_Msk: u32 = 2147483648;
pub const CAN_F3R2_FB31: u32 = 2147483648;
pub const CAN_F4R2_FB0_Pos: u32 = 0;
pub const CAN_F4R2_FB0_Msk: u32 = 1;
pub const CAN_F4R2_FB0: u32 = 1;
pub const CAN_F4R2_FB1_Pos: u32 = 1;
pub const CAN_F4R2_FB1_Msk: u32 = 2;
pub const CAN_F4R2_FB1: u32 = 2;
pub const CAN_F4R2_FB2_Pos: u32 = 2;
pub const CAN_F4R2_FB2_Msk: u32 = 4;
pub const CAN_F4R2_FB2: u32 = 4;
pub const CAN_F4R2_FB3_Pos: u32 = 3;
pub const CAN_F4R2_FB3_Msk: u32 = 8;
pub const CAN_F4R2_FB3: u32 = 8;
pub const CAN_F4R2_FB4_Pos: u32 = 4;
pub const CAN_F4R2_FB4_Msk: u32 = 16;
pub const CAN_F4R2_FB4: u32 = 16;
pub const CAN_F4R2_FB5_Pos: u32 = 5;
pub const CAN_F4R2_FB5_Msk: u32 = 32;
pub const CAN_F4R2_FB5: u32 = 32;
pub const CAN_F4R2_FB6_Pos: u32 = 6;
pub const CAN_F4R2_FB6_Msk: u32 = 64;
pub const CAN_F4R2_FB6: u32 = 64;
pub const CAN_F4R2_FB7_Pos: u32 = 7;
pub const CAN_F4R2_FB7_Msk: u32 = 128;
pub const CAN_F4R2_FB7: u32 = 128;
pub const CAN_F4R2_FB8_Pos: u32 = 8;
pub const CAN_F4R2_FB8_Msk: u32 = 256;
pub const CAN_F4R2_FB8: u32 = 256;
pub const CAN_F4R2_FB9_Pos: u32 = 9;
pub const CAN_F4R2_FB9_Msk: u32 = 512;
pub const CAN_F4R2_FB9: u32 = 512;
pub const CAN_F4R2_FB10_Pos: u32 = 10;
pub const CAN_F4R2_FB10_Msk: u32 = 1024;
pub const CAN_F4R2_FB10: u32 = 1024;
pub const CAN_F4R2_FB11_Pos: u32 = 11;
pub const CAN_F4R2_FB11_Msk: u32 = 2048;
pub const CAN_F4R2_FB11: u32 = 2048;
pub const CAN_F4R2_FB12_Pos: u32 = 12;
pub const CAN_F4R2_FB12_Msk: u32 = 4096;
pub const CAN_F4R2_FB12: u32 = 4096;
pub const CAN_F4R2_FB13_Pos: u32 = 13;
pub const CAN_F4R2_FB13_Msk: u32 = 8192;
pub const CAN_F4R2_FB13: u32 = 8192;
pub const CAN_F4R2_FB14_Pos: u32 = 14;
pub const CAN_F4R2_FB14_Msk: u32 = 16384;
pub const CAN_F4R2_FB14: u32 = 16384;
pub const CAN_F4R2_FB15_Pos: u32 = 15;
pub const CAN_F4R2_FB15_Msk: u32 = 32768;
pub const CAN_F4R2_FB15: u32 = 32768;
pub const CAN_F4R2_FB16_Pos: u32 = 16;
pub const CAN_F4R2_FB16_Msk: u32 = 65536;
pub const CAN_F4R2_FB16: u32 = 65536;
pub const CAN_F4R2_FB17_Pos: u32 = 17;
pub const CAN_F4R2_FB17_Msk: u32 = 131072;
pub const CAN_F4R2_FB17: u32 = 131072;
pub const CAN_F4R2_FB18_Pos: u32 = 18;
pub const CAN_F4R2_FB18_Msk: u32 = 262144;
pub const CAN_F4R2_FB18: u32 = 262144;
pub const CAN_F4R2_FB19_Pos: u32 = 19;
pub const CAN_F4R2_FB19_Msk: u32 = 524288;
pub const CAN_F4R2_FB19: u32 = 524288;
pub const CAN_F4R2_FB20_Pos: u32 = 20;
pub const CAN_F4R2_FB20_Msk: u32 = 1048576;
pub const CAN_F4R2_FB20: u32 = 1048576;
pub const CAN_F4R2_FB21_Pos: u32 = 21;
pub const CAN_F4R2_FB21_Msk: u32 = 2097152;
pub const CAN_F4R2_FB21: u32 = 2097152;
pub const CAN_F4R2_FB22_Pos: u32 = 22;
pub const CAN_F4R2_FB22_Msk: u32 = 4194304;
pub const CAN_F4R2_FB22: u32 = 4194304;
pub const CAN_F4R2_FB23_Pos: u32 = 23;
pub const CAN_F4R2_FB23_Msk: u32 = 8388608;
pub const CAN_F4R2_FB23: u32 = 8388608;
pub const CAN_F4R2_FB24_Pos: u32 = 24;
pub const CAN_F4R2_FB24_Msk: u32 = 16777216;
pub const CAN_F4R2_FB24: u32 = 16777216;
pub const CAN_F4R2_FB25_Pos: u32 = 25;
pub const CAN_F4R2_FB25_Msk: u32 = 33554432;
pub const CAN_F4R2_FB25: u32 = 33554432;
pub const CAN_F4R2_FB26_Pos: u32 = 26;
pub const CAN_F4R2_FB26_Msk: u32 = 67108864;
pub const CAN_F4R2_FB26: u32 = 67108864;
pub const CAN_F4R2_FB27_Pos: u32 = 27;
pub const CAN_F4R2_FB27_Msk: u32 = 134217728;
pub const CAN_F4R2_FB27: u32 = 134217728;
pub const CAN_F4R2_FB28_Pos: u32 = 28;
pub const CAN_F4R2_FB28_Msk: u32 = 268435456;
pub const CAN_F4R2_FB28: u32 = 268435456;
pub const CAN_F4R2_FB29_Pos: u32 = 29;
pub const CAN_F4R2_FB29_Msk: u32 = 536870912;
pub const CAN_F4R2_FB29: u32 = 536870912;
pub const CAN_F4R2_FB30_Pos: u32 = 30;
pub const CAN_F4R2_FB30_Msk: u32 = 1073741824;
pub const CAN_F4R2_FB30: u32 = 1073741824;
pub const CAN_F4R2_FB31_Pos: u32 = 31;
pub const CAN_F4R2_FB31_Msk: u32 = 2147483648;
pub const CAN_F4R2_FB31: u32 = 2147483648;
pub const CAN_F5R2_FB0_Pos: u32 = 0;
pub const CAN_F5R2_FB0_Msk: u32 = 1;
pub const CAN_F5R2_FB0: u32 = 1;
pub const CAN_F5R2_FB1_Pos: u32 = 1;
pub const CAN_F5R2_FB1_Msk: u32 = 2;
pub const CAN_F5R2_FB1: u32 = 2;
pub const CAN_F5R2_FB2_Pos: u32 = 2;
pub const CAN_F5R2_FB2_Msk: u32 = 4;
pub const CAN_F5R2_FB2: u32 = 4;
pub const CAN_F5R2_FB3_Pos: u32 = 3;
pub const CAN_F5R2_FB3_Msk: u32 = 8;
pub const CAN_F5R2_FB3: u32 = 8;
pub const CAN_F5R2_FB4_Pos: u32 = 4;
pub const CAN_F5R2_FB4_Msk: u32 = 16;
pub const CAN_F5R2_FB4: u32 = 16;
pub const CAN_F5R2_FB5_Pos: u32 = 5;
pub const CAN_F5R2_FB5_Msk: u32 = 32;
pub const CAN_F5R2_FB5: u32 = 32;
pub const CAN_F5R2_FB6_Pos: u32 = 6;
pub const CAN_F5R2_FB6_Msk: u32 = 64;
pub const CAN_F5R2_FB6: u32 = 64;
pub const CAN_F5R2_FB7_Pos: u32 = 7;
pub const CAN_F5R2_FB7_Msk: u32 = 128;
pub const CAN_F5R2_FB7: u32 = 128;
pub const CAN_F5R2_FB8_Pos: u32 = 8;
pub const CAN_F5R2_FB8_Msk: u32 = 256;
pub const CAN_F5R2_FB8: u32 = 256;
pub const CAN_F5R2_FB9_Pos: u32 = 9;
pub const CAN_F5R2_FB9_Msk: u32 = 512;
pub const CAN_F5R2_FB9: u32 = 512;
pub const CAN_F5R2_FB10_Pos: u32 = 10;
pub const CAN_F5R2_FB10_Msk: u32 = 1024;
pub const CAN_F5R2_FB10: u32 = 1024;
pub const CAN_F5R2_FB11_Pos: u32 = 11;
pub const CAN_F5R2_FB11_Msk: u32 = 2048;
pub const CAN_F5R2_FB11: u32 = 2048;
pub const CAN_F5R2_FB12_Pos: u32 = 12;
pub const CAN_F5R2_FB12_Msk: u32 = 4096;
pub const CAN_F5R2_FB12: u32 = 4096;
pub const CAN_F5R2_FB13_Pos: u32 = 13;
pub const CAN_F5R2_FB13_Msk: u32 = 8192;
pub const CAN_F5R2_FB13: u32 = 8192;
pub const CAN_F5R2_FB14_Pos: u32 = 14;
pub const CAN_F5R2_FB14_Msk: u32 = 16384;
pub const CAN_F5R2_FB14: u32 = 16384;
pub const CAN_F5R2_FB15_Pos: u32 = 15;
pub const CAN_F5R2_FB15_Msk: u32 = 32768;
pub const CAN_F5R2_FB15: u32 = 32768;
pub const CAN_F5R2_FB16_Pos: u32 = 16;
pub const CAN_F5R2_FB16_Msk: u32 = 65536;
pub const CAN_F5R2_FB16: u32 = 65536;
pub const CAN_F5R2_FB17_Pos: u32 = 17;
pub const CAN_F5R2_FB17_Msk: u32 = 131072;
pub const CAN_F5R2_FB17: u32 = 131072;
pub const CAN_F5R2_FB18_Pos: u32 = 18;
pub const CAN_F5R2_FB18_Msk: u32 = 262144;
pub const CAN_F5R2_FB18: u32 = 262144;
pub const CAN_F5R2_FB19_Pos: u32 = 19;
pub const CAN_F5R2_FB19_Msk: u32 = 524288;
pub const CAN_F5R2_FB19: u32 = 524288;
pub const CAN_F5R2_FB20_Pos: u32 = 20;
pub const CAN_F5R2_FB20_Msk: u32 = 1048576;
pub const CAN_F5R2_FB20: u32 = 1048576;
pub const CAN_F5R2_FB21_Pos: u32 = 21;
pub const CAN_F5R2_FB21_Msk: u32 = 2097152;
pub const CAN_F5R2_FB21: u32 = 2097152;
pub const CAN_F5R2_FB22_Pos: u32 = 22;
pub const CAN_F5R2_FB22_Msk: u32 = 4194304;
pub const CAN_F5R2_FB22: u32 = 4194304;
pub const CAN_F5R2_FB23_Pos: u32 = 23;
pub const CAN_F5R2_FB23_Msk: u32 = 8388608;
pub const CAN_F5R2_FB23: u32 = 8388608;
pub const CAN_F5R2_FB24_Pos: u32 = 24;
pub const CAN_F5R2_FB24_Msk: u32 = 16777216;
pub const CAN_F5R2_FB24: u32 = 16777216;
pub const CAN_F5R2_FB25_Pos: u32 = 25;
pub const CAN_F5R2_FB25_Msk: u32 = 33554432;
pub const CAN_F5R2_FB25: u32 = 33554432;
pub const CAN_F5R2_FB26_Pos: u32 = 26;
pub const CAN_F5R2_FB26_Msk: u32 = 67108864;
pub const CAN_F5R2_FB26: u32 = 67108864;
pub const CAN_F5R2_FB27_Pos: u32 = 27;
pub const CAN_F5R2_FB27_Msk: u32 = 134217728;
pub const CAN_F5R2_FB27: u32 = 134217728;
pub const CAN_F5R2_FB28_Pos: u32 = 28;
pub const CAN_F5R2_FB28_Msk: u32 = 268435456;
pub const CAN_F5R2_FB28: u32 = 268435456;
pub const CAN_F5R2_FB29_Pos: u32 = 29;
pub const CAN_F5R2_FB29_Msk: u32 = 536870912;
pub const CAN_F5R2_FB29: u32 = 536870912;
pub const CAN_F5R2_FB30_Pos: u32 = 30;
pub const CAN_F5R2_FB30_Msk: u32 = 1073741824;
pub const CAN_F5R2_FB30: u32 = 1073741824;
pub const CAN_F5R2_FB31_Pos: u32 = 31;
pub const CAN_F5R2_FB31_Msk: u32 = 2147483648;
pub const CAN_F5R2_FB31: u32 = 2147483648;
pub const CAN_F6R2_FB0_Pos: u32 = 0;
pub const CAN_F6R2_FB0_Msk: u32 = 1;
pub const CAN_F6R2_FB0: u32 = 1;
pub const CAN_F6R2_FB1_Pos: u32 = 1;
pub const CAN_F6R2_FB1_Msk: u32 = 2;
pub const CAN_F6R2_FB1: u32 = 2;
pub const CAN_F6R2_FB2_Pos: u32 = 2;
pub const CAN_F6R2_FB2_Msk: u32 = 4;
pub const CAN_F6R2_FB2: u32 = 4;
pub const CAN_F6R2_FB3_Pos: u32 = 3;
pub const CAN_F6R2_FB3_Msk: u32 = 8;
pub const CAN_F6R2_FB3: u32 = 8;
pub const CAN_F6R2_FB4_Pos: u32 = 4;
pub const CAN_F6R2_FB4_Msk: u32 = 16;
pub const CAN_F6R2_FB4: u32 = 16;
pub const CAN_F6R2_FB5_Pos: u32 = 5;
pub const CAN_F6R2_FB5_Msk: u32 = 32;
pub const CAN_F6R2_FB5: u32 = 32;
pub const CAN_F6R2_FB6_Pos: u32 = 6;
pub const CAN_F6R2_FB6_Msk: u32 = 64;
pub const CAN_F6R2_FB6: u32 = 64;
pub const CAN_F6R2_FB7_Pos: u32 = 7;
pub const CAN_F6R2_FB7_Msk: u32 = 128;
pub const CAN_F6R2_FB7: u32 = 128;
pub const CAN_F6R2_FB8_Pos: u32 = 8;
pub const CAN_F6R2_FB8_Msk: u32 = 256;
pub const CAN_F6R2_FB8: u32 = 256;
pub const CAN_F6R2_FB9_Pos: u32 = 9;
pub const CAN_F6R2_FB9_Msk: u32 = 512;
pub const CAN_F6R2_FB9: u32 = 512;
pub const CAN_F6R2_FB10_Pos: u32 = 10;
pub const CAN_F6R2_FB10_Msk: u32 = 1024;
pub const CAN_F6R2_FB10: u32 = 1024;
pub const CAN_F6R2_FB11_Pos: u32 = 11;
pub const CAN_F6R2_FB11_Msk: u32 = 2048;
pub const CAN_F6R2_FB11: u32 = 2048;
pub const CAN_F6R2_FB12_Pos: u32 = 12;
pub const CAN_F6R2_FB12_Msk: u32 = 4096;
pub const CAN_F6R2_FB12: u32 = 4096;
pub const CAN_F6R2_FB13_Pos: u32 = 13;
pub const CAN_F6R2_FB13_Msk: u32 = 8192;
pub const CAN_F6R2_FB13: u32 = 8192;
pub const CAN_F6R2_FB14_Pos: u32 = 14;
pub const CAN_F6R2_FB14_Msk: u32 = 16384;
pub const CAN_F6R2_FB14: u32 = 16384;
pub const CAN_F6R2_FB15_Pos: u32 = 15;
pub const CAN_F6R2_FB15_Msk: u32 = 32768;
pub const CAN_F6R2_FB15: u32 = 32768;
pub const CAN_F6R2_FB16_Pos: u32 = 16;
pub const CAN_F6R2_FB16_Msk: u32 = 65536;
pub const CAN_F6R2_FB16: u32 = 65536;
pub const CAN_F6R2_FB17_Pos: u32 = 17;
pub const CAN_F6R2_FB17_Msk: u32 = 131072;
pub const CAN_F6R2_FB17: u32 = 131072;
pub const CAN_F6R2_FB18_Pos: u32 = 18;
pub const CAN_F6R2_FB18_Msk: u32 = 262144;
pub const CAN_F6R2_FB18: u32 = 262144;
pub const CAN_F6R2_FB19_Pos: u32 = 19;
pub const CAN_F6R2_FB19_Msk: u32 = 524288;
pub const CAN_F6R2_FB19: u32 = 524288;
pub const CAN_F6R2_FB20_Pos: u32 = 20;
pub const CAN_F6R2_FB20_Msk: u32 = 1048576;
pub const CAN_F6R2_FB20: u32 = 1048576;
pub const CAN_F6R2_FB21_Pos: u32 = 21;
pub const CAN_F6R2_FB21_Msk: u32 = 2097152;
pub const CAN_F6R2_FB21: u32 = 2097152;
pub const CAN_F6R2_FB22_Pos: u32 = 22;
pub const CAN_F6R2_FB22_Msk: u32 = 4194304;
pub const CAN_F6R2_FB22: u32 = 4194304;
pub const CAN_F6R2_FB23_Pos: u32 = 23;
pub const CAN_F6R2_FB23_Msk: u32 = 8388608;
pub const CAN_F6R2_FB23: u32 = 8388608;
pub const CAN_F6R2_FB24_Pos: u32 = 24;
pub const CAN_F6R2_FB24_Msk: u32 = 16777216;
pub const CAN_F6R2_FB24: u32 = 16777216;
pub const CAN_F6R2_FB25_Pos: u32 = 25;
pub const CAN_F6R2_FB25_Msk: u32 = 33554432;
pub const CAN_F6R2_FB25: u32 = 33554432;
pub const CAN_F6R2_FB26_Pos: u32 = 26;
pub const CAN_F6R2_FB26_Msk: u32 = 67108864;
pub const CAN_F6R2_FB26: u32 = 67108864;
pub const CAN_F6R2_FB27_Pos: u32 = 27;
pub const CAN_F6R2_FB27_Msk: u32 = 134217728;
pub const CAN_F6R2_FB27: u32 = 134217728;
pub const CAN_F6R2_FB28_Pos: u32 = 28;
pub const CAN_F6R2_FB28_Msk: u32 = 268435456;
pub const CAN_F6R2_FB28: u32 = 268435456;
pub const CAN_F6R2_FB29_Pos: u32 = 29;
pub const CAN_F6R2_FB29_Msk: u32 = 536870912;
pub const CAN_F6R2_FB29: u32 = 536870912;
pub const CAN_F6R2_FB30_Pos: u32 = 30;
pub const CAN_F6R2_FB30_Msk: u32 = 1073741824;
pub const CAN_F6R2_FB30: u32 = 1073741824;
pub const CAN_F6R2_FB31_Pos: u32 = 31;
pub const CAN_F6R2_FB31_Msk: u32 = 2147483648;
pub const CAN_F6R2_FB31: u32 = 2147483648;
pub const CAN_F7R2_FB0_Pos: u32 = 0;
pub const CAN_F7R2_FB0_Msk: u32 = 1;
pub const CAN_F7R2_FB0: u32 = 1;
pub const CAN_F7R2_FB1_Pos: u32 = 1;
pub const CAN_F7R2_FB1_Msk: u32 = 2;
pub const CAN_F7R2_FB1: u32 = 2;
pub const CAN_F7R2_FB2_Pos: u32 = 2;
pub const CAN_F7R2_FB2_Msk: u32 = 4;
pub const CAN_F7R2_FB2: u32 = 4;
pub const CAN_F7R2_FB3_Pos: u32 = 3;
pub const CAN_F7R2_FB3_Msk: u32 = 8;
pub const CAN_F7R2_FB3: u32 = 8;
pub const CAN_F7R2_FB4_Pos: u32 = 4;
pub const CAN_F7R2_FB4_Msk: u32 = 16;
pub const CAN_F7R2_FB4: u32 = 16;
pub const CAN_F7R2_FB5_Pos: u32 = 5;
pub const CAN_F7R2_FB5_Msk: u32 = 32;
pub const CAN_F7R2_FB5: u32 = 32;
pub const CAN_F7R2_FB6_Pos: u32 = 6;
pub const CAN_F7R2_FB6_Msk: u32 = 64;
pub const CAN_F7R2_FB6: u32 = 64;
pub const CAN_F7R2_FB7_Pos: u32 = 7;
pub const CAN_F7R2_FB7_Msk: u32 = 128;
pub const CAN_F7R2_FB7: u32 = 128;
pub const CAN_F7R2_FB8_Pos: u32 = 8;
pub const CAN_F7R2_FB8_Msk: u32 = 256;
pub const CAN_F7R2_FB8: u32 = 256;
pub const CAN_F7R2_FB9_Pos: u32 = 9;
pub const CAN_F7R2_FB9_Msk: u32 = 512;
pub const CAN_F7R2_FB9: u32 = 512;
pub const CAN_F7R2_FB10_Pos: u32 = 10;
pub const CAN_F7R2_FB10_Msk: u32 = 1024;
pub const CAN_F7R2_FB10: u32 = 1024;
pub const CAN_F7R2_FB11_Pos: u32 = 11;
pub const CAN_F7R2_FB11_Msk: u32 = 2048;
pub const CAN_F7R2_FB11: u32 = 2048;
pub const CAN_F7R2_FB12_Pos: u32 = 12;
pub const CAN_F7R2_FB12_Msk: u32 = 4096;
pub const CAN_F7R2_FB12: u32 = 4096;
pub const CAN_F7R2_FB13_Pos: u32 = 13;
pub const CAN_F7R2_FB13_Msk: u32 = 8192;
pub const CAN_F7R2_FB13: u32 = 8192;
pub const CAN_F7R2_FB14_Pos: u32 = 14;
pub const CAN_F7R2_FB14_Msk: u32 = 16384;
pub const CAN_F7R2_FB14: u32 = 16384;
pub const CAN_F7R2_FB15_Pos: u32 = 15;
pub const CAN_F7R2_FB15_Msk: u32 = 32768;
pub const CAN_F7R2_FB15: u32 = 32768;
pub const CAN_F7R2_FB16_Pos: u32 = 16;
pub const CAN_F7R2_FB16_Msk: u32 = 65536;
pub const CAN_F7R2_FB16: u32 = 65536;
pub const CAN_F7R2_FB17_Pos: u32 = 17;
pub const CAN_F7R2_FB17_Msk: u32 = 131072;
pub const CAN_F7R2_FB17: u32 = 131072;
pub const CAN_F7R2_FB18_Pos: u32 = 18;
pub const CAN_F7R2_FB18_Msk: u32 = 262144;
pub const CAN_F7R2_FB18: u32 = 262144;
pub const CAN_F7R2_FB19_Pos: u32 = 19;
pub const CAN_F7R2_FB19_Msk: u32 = 524288;
pub const CAN_F7R2_FB19: u32 = 524288;
pub const CAN_F7R2_FB20_Pos: u32 = 20;
pub const CAN_F7R2_FB20_Msk: u32 = 1048576;
pub const CAN_F7R2_FB20: u32 = 1048576;
pub const CAN_F7R2_FB21_Pos: u32 = 21;
pub const CAN_F7R2_FB21_Msk: u32 = 2097152;
pub const CAN_F7R2_FB21: u32 = 2097152;
pub const CAN_F7R2_FB22_Pos: u32 = 22;
pub const CAN_F7R2_FB22_Msk: u32 = 4194304;
pub const CAN_F7R2_FB22: u32 = 4194304;
pub const CAN_F7R2_FB23_Pos: u32 = 23;
pub const CAN_F7R2_FB23_Msk: u32 = 8388608;
pub const CAN_F7R2_FB23: u32 = 8388608;
pub const CAN_F7R2_FB24_Pos: u32 = 24;
pub const CAN_F7R2_FB24_Msk: u32 = 16777216;
pub const CAN_F7R2_FB24: u32 = 16777216;
pub const CAN_F7R2_FB25_Pos: u32 = 25;
pub const CAN_F7R2_FB25_Msk: u32 = 33554432;
pub const CAN_F7R2_FB25: u32 = 33554432;
pub const CAN_F7R2_FB26_Pos: u32 = 26;
pub const CAN_F7R2_FB26_Msk: u32 = 67108864;
pub const CAN_F7R2_FB26: u32 = 67108864;
pub const CAN_F7R2_FB27_Pos: u32 = 27;
pub const CAN_F7R2_FB27_Msk: u32 = 134217728;
pub const CAN_F7R2_FB27: u32 = 134217728;
pub const CAN_F7R2_FB28_Pos: u32 = 28;
pub const CAN_F7R2_FB28_Msk: u32 = 268435456;
pub const CAN_F7R2_FB28: u32 = 268435456;
pub const CAN_F7R2_FB29_Pos: u32 = 29;
pub const CAN_F7R2_FB29_Msk: u32 = 536870912;
pub const CAN_F7R2_FB29: u32 = 536870912;
pub const CAN_F7R2_FB30_Pos: u32 = 30;
pub const CAN_F7R2_FB30_Msk: u32 = 1073741824;
pub const CAN_F7R2_FB30: u32 = 1073741824;
pub const CAN_F7R2_FB31_Pos: u32 = 31;
pub const CAN_F7R2_FB31_Msk: u32 = 2147483648;
pub const CAN_F7R2_FB31: u32 = 2147483648;
pub const CAN_F8R2_FB0_Pos: u32 = 0;
pub const CAN_F8R2_FB0_Msk: u32 = 1;
pub const CAN_F8R2_FB0: u32 = 1;
pub const CAN_F8R2_FB1_Pos: u32 = 1;
pub const CAN_F8R2_FB1_Msk: u32 = 2;
pub const CAN_F8R2_FB1: u32 = 2;
pub const CAN_F8R2_FB2_Pos: u32 = 2;
pub const CAN_F8R2_FB2_Msk: u32 = 4;
pub const CAN_F8R2_FB2: u32 = 4;
pub const CAN_F8R2_FB3_Pos: u32 = 3;
pub const CAN_F8R2_FB3_Msk: u32 = 8;
pub const CAN_F8R2_FB3: u32 = 8;
pub const CAN_F8R2_FB4_Pos: u32 = 4;
pub const CAN_F8R2_FB4_Msk: u32 = 16;
pub const CAN_F8R2_FB4: u32 = 16;
pub const CAN_F8R2_FB5_Pos: u32 = 5;
pub const CAN_F8R2_FB5_Msk: u32 = 32;
pub const CAN_F8R2_FB5: u32 = 32;
pub const CAN_F8R2_FB6_Pos: u32 = 6;
pub const CAN_F8R2_FB6_Msk: u32 = 64;
pub const CAN_F8R2_FB6: u32 = 64;
pub const CAN_F8R2_FB7_Pos: u32 = 7;
pub const CAN_F8R2_FB7_Msk: u32 = 128;
pub const CAN_F8R2_FB7: u32 = 128;
pub const CAN_F8R2_FB8_Pos: u32 = 8;
pub const CAN_F8R2_FB8_Msk: u32 = 256;
pub const CAN_F8R2_FB8: u32 = 256;
pub const CAN_F8R2_FB9_Pos: u32 = 9;
pub const CAN_F8R2_FB9_Msk: u32 = 512;
pub const CAN_F8R2_FB9: u32 = 512;
pub const CAN_F8R2_FB10_Pos: u32 = 10;
pub const CAN_F8R2_FB10_Msk: u32 = 1024;
pub const CAN_F8R2_FB10: u32 = 1024;
pub const CAN_F8R2_FB11_Pos: u32 = 11;
pub const CAN_F8R2_FB11_Msk: u32 = 2048;
pub const CAN_F8R2_FB11: u32 = 2048;
pub const CAN_F8R2_FB12_Pos: u32 = 12;
pub const CAN_F8R2_FB12_Msk: u32 = 4096;
pub const CAN_F8R2_FB12: u32 = 4096;
pub const CAN_F8R2_FB13_Pos: u32 = 13;
pub const CAN_F8R2_FB13_Msk: u32 = 8192;
pub const CAN_F8R2_FB13: u32 = 8192;
pub const CAN_F8R2_FB14_Pos: u32 = 14;
pub const CAN_F8R2_FB14_Msk: u32 = 16384;
pub const CAN_F8R2_FB14: u32 = 16384;
pub const CAN_F8R2_FB15_Pos: u32 = 15;
pub const CAN_F8R2_FB15_Msk: u32 = 32768;
pub const CAN_F8R2_FB15: u32 = 32768;
pub const CAN_F8R2_FB16_Pos: u32 = 16;
pub const CAN_F8R2_FB16_Msk: u32 = 65536;
pub const CAN_F8R2_FB16: u32 = 65536;
pub const CAN_F8R2_FB17_Pos: u32 = 17;
pub const CAN_F8R2_FB17_Msk: u32 = 131072;
pub const CAN_F8R2_FB17: u32 = 131072;
pub const CAN_F8R2_FB18_Pos: u32 = 18;
pub const CAN_F8R2_FB18_Msk: u32 = 262144;
pub const CAN_F8R2_FB18: u32 = 262144;
pub const CAN_F8R2_FB19_Pos: u32 = 19;
pub const CAN_F8R2_FB19_Msk: u32 = 524288;
pub const CAN_F8R2_FB19: u32 = 524288;
pub const CAN_F8R2_FB20_Pos: u32 = 20;
pub const CAN_F8R2_FB20_Msk: u32 = 1048576;
pub const CAN_F8R2_FB20: u32 = 1048576;
pub const CAN_F8R2_FB21_Pos: u32 = 21;
pub const CAN_F8R2_FB21_Msk: u32 = 2097152;
pub const CAN_F8R2_FB21: u32 = 2097152;
pub const CAN_F8R2_FB22_Pos: u32 = 22;
pub const CAN_F8R2_FB22_Msk: u32 = 4194304;
pub const CAN_F8R2_FB22: u32 = 4194304;
pub const CAN_F8R2_FB23_Pos: u32 = 23;
pub const CAN_F8R2_FB23_Msk: u32 = 8388608;
pub const CAN_F8R2_FB23: u32 = 8388608;
pub const CAN_F8R2_FB24_Pos: u32 = 24;
pub const CAN_F8R2_FB24_Msk: u32 = 16777216;
pub const CAN_F8R2_FB24: u32 = 16777216;
pub const CAN_F8R2_FB25_Pos: u32 = 25;
pub const CAN_F8R2_FB25_Msk: u32 = 33554432;
pub const CAN_F8R2_FB25: u32 = 33554432;
pub const CAN_F8R2_FB26_Pos: u32 = 26;
pub const CAN_F8R2_FB26_Msk: u32 = 67108864;
pub const CAN_F8R2_FB26: u32 = 67108864;
pub const CAN_F8R2_FB27_Pos: u32 = 27;
pub const CAN_F8R2_FB27_Msk: u32 = 134217728;
pub const CAN_F8R2_FB27: u32 = 134217728;
pub const CAN_F8R2_FB28_Pos: u32 = 28;
pub const CAN_F8R2_FB28_Msk: u32 = 268435456;
pub const CAN_F8R2_FB28: u32 = 268435456;
pub const CAN_F8R2_FB29_Pos: u32 = 29;
pub const CAN_F8R2_FB29_Msk: u32 = 536870912;
pub const CAN_F8R2_FB29: u32 = 536870912;
pub const CAN_F8R2_FB30_Pos: u32 = 30;
pub const CAN_F8R2_FB30_Msk: u32 = 1073741824;
pub const CAN_F8R2_FB30: u32 = 1073741824;
pub const CAN_F8R2_FB31_Pos: u32 = 31;
pub const CAN_F8R2_FB31_Msk: u32 = 2147483648;
pub const CAN_F8R2_FB31: u32 = 2147483648;
pub const CAN_F9R2_FB0_Pos: u32 = 0;
pub const CAN_F9R2_FB0_Msk: u32 = 1;
pub const CAN_F9R2_FB0: u32 = 1;
pub const CAN_F9R2_FB1_Pos: u32 = 1;
pub const CAN_F9R2_FB1_Msk: u32 = 2;
pub const CAN_F9R2_FB1: u32 = 2;
pub const CAN_F9R2_FB2_Pos: u32 = 2;
pub const CAN_F9R2_FB2_Msk: u32 = 4;
pub const CAN_F9R2_FB2: u32 = 4;
pub const CAN_F9R2_FB3_Pos: u32 = 3;
pub const CAN_F9R2_FB3_Msk: u32 = 8;
pub const CAN_F9R2_FB3: u32 = 8;
pub const CAN_F9R2_FB4_Pos: u32 = 4;
pub const CAN_F9R2_FB4_Msk: u32 = 16;
pub const CAN_F9R2_FB4: u32 = 16;
pub const CAN_F9R2_FB5_Pos: u32 = 5;
pub const CAN_F9R2_FB5_Msk: u32 = 32;
pub const CAN_F9R2_FB5: u32 = 32;
pub const CAN_F9R2_FB6_Pos: u32 = 6;
pub const CAN_F9R2_FB6_Msk: u32 = 64;
pub const CAN_F9R2_FB6: u32 = 64;
pub const CAN_F9R2_FB7_Pos: u32 = 7;
pub const CAN_F9R2_FB7_Msk: u32 = 128;
pub const CAN_F9R2_FB7: u32 = 128;
pub const CAN_F9R2_FB8_Pos: u32 = 8;
pub const CAN_F9R2_FB8_Msk: u32 = 256;
pub const CAN_F9R2_FB8: u32 = 256;
pub const CAN_F9R2_FB9_Pos: u32 = 9;
pub const CAN_F9R2_FB9_Msk: u32 = 512;
pub const CAN_F9R2_FB9: u32 = 512;
pub const CAN_F9R2_FB10_Pos: u32 = 10;
pub const CAN_F9R2_FB10_Msk: u32 = 1024;
pub const CAN_F9R2_FB10: u32 = 1024;
pub const CAN_F9R2_FB11_Pos: u32 = 11;
pub const CAN_F9R2_FB11_Msk: u32 = 2048;
pub const CAN_F9R2_FB11: u32 = 2048;
pub const CAN_F9R2_FB12_Pos: u32 = 12;
pub const CAN_F9R2_FB12_Msk: u32 = 4096;
pub const CAN_F9R2_FB12: u32 = 4096;
pub const CAN_F9R2_FB13_Pos: u32 = 13;
pub const CAN_F9R2_FB13_Msk: u32 = 8192;
pub const CAN_F9R2_FB13: u32 = 8192;
pub const CAN_F9R2_FB14_Pos: u32 = 14;
pub const CAN_F9R2_FB14_Msk: u32 = 16384;
pub const CAN_F9R2_FB14: u32 = 16384;
pub const CAN_F9R2_FB15_Pos: u32 = 15;
pub const CAN_F9R2_FB15_Msk: u32 = 32768;
pub const CAN_F9R2_FB15: u32 = 32768;
pub const CAN_F9R2_FB16_Pos: u32 = 16;
pub const CAN_F9R2_FB16_Msk: u32 = 65536;
pub const CAN_F9R2_FB16: u32 = 65536;
pub const CAN_F9R2_FB17_Pos: u32 = 17;
pub const CAN_F9R2_FB17_Msk: u32 = 131072;
pub const CAN_F9R2_FB17: u32 = 131072;
pub const CAN_F9R2_FB18_Pos: u32 = 18;
pub const CAN_F9R2_FB18_Msk: u32 = 262144;
pub const CAN_F9R2_FB18: u32 = 262144;
pub const CAN_F9R2_FB19_Pos: u32 = 19;
pub const CAN_F9R2_FB19_Msk: u32 = 524288;
pub const CAN_F9R2_FB19: u32 = 524288;
pub const CAN_F9R2_FB20_Pos: u32 = 20;
pub const CAN_F9R2_FB20_Msk: u32 = 1048576;
pub const CAN_F9R2_FB20: u32 = 1048576;
pub const CAN_F9R2_FB21_Pos: u32 = 21;
pub const CAN_F9R2_FB21_Msk: u32 = 2097152;
pub const CAN_F9R2_FB21: u32 = 2097152;
pub const CAN_F9R2_FB22_Pos: u32 = 22;
pub const CAN_F9R2_FB22_Msk: u32 = 4194304;
pub const CAN_F9R2_FB22: u32 = 4194304;
pub const CAN_F9R2_FB23_Pos: u32 = 23;
pub const CAN_F9R2_FB23_Msk: u32 = 8388608;
pub const CAN_F9R2_FB23: u32 = 8388608;
pub const CAN_F9R2_FB24_Pos: u32 = 24;
pub const CAN_F9R2_FB24_Msk: u32 = 16777216;
pub const CAN_F9R2_FB24: u32 = 16777216;
pub const CAN_F9R2_FB25_Pos: u32 = 25;
pub const CAN_F9R2_FB25_Msk: u32 = 33554432;
pub const CAN_F9R2_FB25: u32 = 33554432;
pub const CAN_F9R2_FB26_Pos: u32 = 26;
pub const CAN_F9R2_FB26_Msk: u32 = 67108864;
pub const CAN_F9R2_FB26: u32 = 67108864;
pub const CAN_F9R2_FB27_Pos: u32 = 27;
pub const CAN_F9R2_FB27_Msk: u32 = 134217728;
pub const CAN_F9R2_FB27: u32 = 134217728;
pub const CAN_F9R2_FB28_Pos: u32 = 28;
pub const CAN_F9R2_FB28_Msk: u32 = 268435456;
pub const CAN_F9R2_FB28: u32 = 268435456;
pub const CAN_F9R2_FB29_Pos: u32 = 29;
pub const CAN_F9R2_FB29_Msk: u32 = 536870912;
pub const CAN_F9R2_FB29: u32 = 536870912;
pub const CAN_F9R2_FB30_Pos: u32 = 30;
pub const CAN_F9R2_FB30_Msk: u32 = 1073741824;
pub const CAN_F9R2_FB30: u32 = 1073741824;
pub const CAN_F9R2_FB31_Pos: u32 = 31;
pub const CAN_F9R2_FB31_Msk: u32 = 2147483648;
pub const CAN_F9R2_FB31: u32 = 2147483648;
pub const CAN_F10R2_FB0_Pos: u32 = 0;
pub const CAN_F10R2_FB0_Msk: u32 = 1;
pub const CAN_F10R2_FB0: u32 = 1;
pub const CAN_F10R2_FB1_Pos: u32 = 1;
pub const CAN_F10R2_FB1_Msk: u32 = 2;
pub const CAN_F10R2_FB1: u32 = 2;
pub const CAN_F10R2_FB2_Pos: u32 = 2;
pub const CAN_F10R2_FB2_Msk: u32 = 4;
pub const CAN_F10R2_FB2: u32 = 4;
pub const CAN_F10R2_FB3_Pos: u32 = 3;
pub const CAN_F10R2_FB3_Msk: u32 = 8;
pub const CAN_F10R2_FB3: u32 = 8;
pub const CAN_F10R2_FB4_Pos: u32 = 4;
pub const CAN_F10R2_FB4_Msk: u32 = 16;
pub const CAN_F10R2_FB4: u32 = 16;
pub const CAN_F10R2_FB5_Pos: u32 = 5;
pub const CAN_F10R2_FB5_Msk: u32 = 32;
pub const CAN_F10R2_FB5: u32 = 32;
pub const CAN_F10R2_FB6_Pos: u32 = 6;
pub const CAN_F10R2_FB6_Msk: u32 = 64;
pub const CAN_F10R2_FB6: u32 = 64;
pub const CAN_F10R2_FB7_Pos: u32 = 7;
pub const CAN_F10R2_FB7_Msk: u32 = 128;
pub const CAN_F10R2_FB7: u32 = 128;
pub const CAN_F10R2_FB8_Pos: u32 = 8;
pub const CAN_F10R2_FB8_Msk: u32 = 256;
pub const CAN_F10R2_FB8: u32 = 256;
pub const CAN_F10R2_FB9_Pos: u32 = 9;
pub const CAN_F10R2_FB9_Msk: u32 = 512;
pub const CAN_F10R2_FB9: u32 = 512;
pub const CAN_F10R2_FB10_Pos: u32 = 10;
pub const CAN_F10R2_FB10_Msk: u32 = 1024;
pub const CAN_F10R2_FB10: u32 = 1024;
pub const CAN_F10R2_FB11_Pos: u32 = 11;
pub const CAN_F10R2_FB11_Msk: u32 = 2048;
pub const CAN_F10R2_FB11: u32 = 2048;
pub const CAN_F10R2_FB12_Pos: u32 = 12;
pub const CAN_F10R2_FB12_Msk: u32 = 4096;
pub const CAN_F10R2_FB12: u32 = 4096;
pub const CAN_F10R2_FB13_Pos: u32 = 13;
pub const CAN_F10R2_FB13_Msk: u32 = 8192;
pub const CAN_F10R2_FB13: u32 = 8192;
pub const CAN_F10R2_FB14_Pos: u32 = 14;
pub const CAN_F10R2_FB14_Msk: u32 = 16384;
pub const CAN_F10R2_FB14: u32 = 16384;
pub const CAN_F10R2_FB15_Pos: u32 = 15;
pub const CAN_F10R2_FB15_Msk: u32 = 32768;
pub const CAN_F10R2_FB15: u32 = 32768;
pub const CAN_F10R2_FB16_Pos: u32 = 16;
pub const CAN_F10R2_FB16_Msk: u32 = 65536;
pub const CAN_F10R2_FB16: u32 = 65536;
pub const CAN_F10R2_FB17_Pos: u32 = 17;
pub const CAN_F10R2_FB17_Msk: u32 = 131072;
pub const CAN_F10R2_FB17: u32 = 131072;
pub const CAN_F10R2_FB18_Pos: u32 = 18;
pub const CAN_F10R2_FB18_Msk: u32 = 262144;
pub const CAN_F10R2_FB18: u32 = 262144;
pub const CAN_F10R2_FB19_Pos: u32 = 19;
pub const CAN_F10R2_FB19_Msk: u32 = 524288;
pub const CAN_F10R2_FB19: u32 = 524288;
pub const CAN_F10R2_FB20_Pos: u32 = 20;
pub const CAN_F10R2_FB20_Msk: u32 = 1048576;
pub const CAN_F10R2_FB20: u32 = 1048576;
pub const CAN_F10R2_FB21_Pos: u32 = 21;
pub const CAN_F10R2_FB21_Msk: u32 = 2097152;
pub const CAN_F10R2_FB21: u32 = 2097152;
pub const CAN_F10R2_FB22_Pos: u32 = 22;
pub const CAN_F10R2_FB22_Msk: u32 = 4194304;
pub const CAN_F10R2_FB22: u32 = 4194304;
pub const CAN_F10R2_FB23_Pos: u32 = 23;
pub const CAN_F10R2_FB23_Msk: u32 = 8388608;
pub const CAN_F10R2_FB23: u32 = 8388608;
pub const CAN_F10R2_FB24_Pos: u32 = 24;
pub const CAN_F10R2_FB24_Msk: u32 = 16777216;
pub const CAN_F10R2_FB24: u32 = 16777216;
pub const CAN_F10R2_FB25_Pos: u32 = 25;
pub const CAN_F10R2_FB25_Msk: u32 = 33554432;
pub const CAN_F10R2_FB25: u32 = 33554432;
pub const CAN_F10R2_FB26_Pos: u32 = 26;
pub const CAN_F10R2_FB26_Msk: u32 = 67108864;
pub const CAN_F10R2_FB26: u32 = 67108864;
pub const CAN_F10R2_FB27_Pos: u32 = 27;
pub const CAN_F10R2_FB27_Msk: u32 = 134217728;
pub const CAN_F10R2_FB27: u32 = 134217728;
pub const CAN_F10R2_FB28_Pos: u32 = 28;
pub const CAN_F10R2_FB28_Msk: u32 = 268435456;
pub const CAN_F10R2_FB28: u32 = 268435456;
pub const CAN_F10R2_FB29_Pos: u32 = 29;
pub const CAN_F10R2_FB29_Msk: u32 = 536870912;
pub const CAN_F10R2_FB29: u32 = 536870912;
pub const CAN_F10R2_FB30_Pos: u32 = 30;
pub const CAN_F10R2_FB30_Msk: u32 = 1073741824;
pub const CAN_F10R2_FB30: u32 = 1073741824;
pub const CAN_F10R2_FB31_Pos: u32 = 31;
pub const CAN_F10R2_FB31_Msk: u32 = 2147483648;
pub const CAN_F10R2_FB31: u32 = 2147483648;
pub const CAN_F11R2_FB0_Pos: u32 = 0;
pub const CAN_F11R2_FB0_Msk: u32 = 1;
pub const CAN_F11R2_FB0: u32 = 1;
pub const CAN_F11R2_FB1_Pos: u32 = 1;
pub const CAN_F11R2_FB1_Msk: u32 = 2;
pub const CAN_F11R2_FB1: u32 = 2;
pub const CAN_F11R2_FB2_Pos: u32 = 2;
pub const CAN_F11R2_FB2_Msk: u32 = 4;
pub const CAN_F11R2_FB2: u32 = 4;
pub const CAN_F11R2_FB3_Pos: u32 = 3;
pub const CAN_F11R2_FB3_Msk: u32 = 8;
pub const CAN_F11R2_FB3: u32 = 8;
pub const CAN_F11R2_FB4_Pos: u32 = 4;
pub const CAN_F11R2_FB4_Msk: u32 = 16;
pub const CAN_F11R2_FB4: u32 = 16;
pub const CAN_F11R2_FB5_Pos: u32 = 5;
pub const CAN_F11R2_FB5_Msk: u32 = 32;
pub const CAN_F11R2_FB5: u32 = 32;
pub const CAN_F11R2_FB6_Pos: u32 = 6;
pub const CAN_F11R2_FB6_Msk: u32 = 64;
pub const CAN_F11R2_FB6: u32 = 64;
pub const CAN_F11R2_FB7_Pos: u32 = 7;
pub const CAN_F11R2_FB7_Msk: u32 = 128;
pub const CAN_F11R2_FB7: u32 = 128;
pub const CAN_F11R2_FB8_Pos: u32 = 8;
pub const CAN_F11R2_FB8_Msk: u32 = 256;
pub const CAN_F11R2_FB8: u32 = 256;
pub const CAN_F11R2_FB9_Pos: u32 = 9;
pub const CAN_F11R2_FB9_Msk: u32 = 512;
pub const CAN_F11R2_FB9: u32 = 512;
pub const CAN_F11R2_FB10_Pos: u32 = 10;
pub const CAN_F11R2_FB10_Msk: u32 = 1024;
pub const CAN_F11R2_FB10: u32 = 1024;
pub const CAN_F11R2_FB11_Pos: u32 = 11;
pub const CAN_F11R2_FB11_Msk: u32 = 2048;
pub const CAN_F11R2_FB11: u32 = 2048;
pub const CAN_F11R2_FB12_Pos: u32 = 12;
pub const CAN_F11R2_FB12_Msk: u32 = 4096;
pub const CAN_F11R2_FB12: u32 = 4096;
pub const CAN_F11R2_FB13_Pos: u32 = 13;
pub const CAN_F11R2_FB13_Msk: u32 = 8192;
pub const CAN_F11R2_FB13: u32 = 8192;
pub const CAN_F11R2_FB14_Pos: u32 = 14;
pub const CAN_F11R2_FB14_Msk: u32 = 16384;
pub const CAN_F11R2_FB14: u32 = 16384;
pub const CAN_F11R2_FB15_Pos: u32 = 15;
pub const CAN_F11R2_FB15_Msk: u32 = 32768;
pub const CAN_F11R2_FB15: u32 = 32768;
pub const CAN_F11R2_FB16_Pos: u32 = 16;
pub const CAN_F11R2_FB16_Msk: u32 = 65536;
pub const CAN_F11R2_FB16: u32 = 65536;
pub const CAN_F11R2_FB17_Pos: u32 = 17;
pub const CAN_F11R2_FB17_Msk: u32 = 131072;
pub const CAN_F11R2_FB17: u32 = 131072;
pub const CAN_F11R2_FB18_Pos: u32 = 18;
pub const CAN_F11R2_FB18_Msk: u32 = 262144;
pub const CAN_F11R2_FB18: u32 = 262144;
pub const CAN_F11R2_FB19_Pos: u32 = 19;
pub const CAN_F11R2_FB19_Msk: u32 = 524288;
pub const CAN_F11R2_FB19: u32 = 524288;
pub const CAN_F11R2_FB20_Pos: u32 = 20;
pub const CAN_F11R2_FB20_Msk: u32 = 1048576;
pub const CAN_F11R2_FB20: u32 = 1048576;
pub const CAN_F11R2_FB21_Pos: u32 = 21;
pub const CAN_F11R2_FB21_Msk: u32 = 2097152;
pub const CAN_F11R2_FB21: u32 = 2097152;
pub const CAN_F11R2_FB22_Pos: u32 = 22;
pub const CAN_F11R2_FB22_Msk: u32 = 4194304;
pub const CAN_F11R2_FB22: u32 = 4194304;
pub const CAN_F11R2_FB23_Pos: u32 = 23;
pub const CAN_F11R2_FB23_Msk: u32 = 8388608;
pub const CAN_F11R2_FB23: u32 = 8388608;
pub const CAN_F11R2_FB24_Pos: u32 = 24;
pub const CAN_F11R2_FB24_Msk: u32 = 16777216;
pub const CAN_F11R2_FB24: u32 = 16777216;
pub const CAN_F11R2_FB25_Pos: u32 = 25;
pub const CAN_F11R2_FB25_Msk: u32 = 33554432;
pub const CAN_F11R2_FB25: u32 = 33554432;
pub const CAN_F11R2_FB26_Pos: u32 = 26;
pub const CAN_F11R2_FB26_Msk: u32 = 67108864;
pub const CAN_F11R2_FB26: u32 = 67108864;
pub const CAN_F11R2_FB27_Pos: u32 = 27;
pub const CAN_F11R2_FB27_Msk: u32 = 134217728;
pub const CAN_F11R2_FB27: u32 = 134217728;
pub const CAN_F11R2_FB28_Pos: u32 = 28;
pub const CAN_F11R2_FB28_Msk: u32 = 268435456;
pub const CAN_F11R2_FB28: u32 = 268435456;
pub const CAN_F11R2_FB29_Pos: u32 = 29;
pub const CAN_F11R2_FB29_Msk: u32 = 536870912;
pub const CAN_F11R2_FB29: u32 = 536870912;
pub const CAN_F11R2_FB30_Pos: u32 = 30;
pub const CAN_F11R2_FB30_Msk: u32 = 1073741824;
pub const CAN_F11R2_FB30: u32 = 1073741824;
pub const CAN_F11R2_FB31_Pos: u32 = 31;
pub const CAN_F11R2_FB31_Msk: u32 = 2147483648;
pub const CAN_F11R2_FB31: u32 = 2147483648;
pub const CAN_F12R2_FB0_Pos: u32 = 0;
pub const CAN_F12R2_FB0_Msk: u32 = 1;
pub const CAN_F12R2_FB0: u32 = 1;
pub const CAN_F12R2_FB1_Pos: u32 = 1;
pub const CAN_F12R2_FB1_Msk: u32 = 2;
pub const CAN_F12R2_FB1: u32 = 2;
pub const CAN_F12R2_FB2_Pos: u32 = 2;
pub const CAN_F12R2_FB2_Msk: u32 = 4;
pub const CAN_F12R2_FB2: u32 = 4;
pub const CAN_F12R2_FB3_Pos: u32 = 3;
pub const CAN_F12R2_FB3_Msk: u32 = 8;
pub const CAN_F12R2_FB3: u32 = 8;
pub const CAN_F12R2_FB4_Pos: u32 = 4;
pub const CAN_F12R2_FB4_Msk: u32 = 16;
pub const CAN_F12R2_FB4: u32 = 16;
pub const CAN_F12R2_FB5_Pos: u32 = 5;
pub const CAN_F12R2_FB5_Msk: u32 = 32;
pub const CAN_F12R2_FB5: u32 = 32;
pub const CAN_F12R2_FB6_Pos: u32 = 6;
pub const CAN_F12R2_FB6_Msk: u32 = 64;
pub const CAN_F12R2_FB6: u32 = 64;
pub const CAN_F12R2_FB7_Pos: u32 = 7;
pub const CAN_F12R2_FB7_Msk: u32 = 128;
pub const CAN_F12R2_FB7: u32 = 128;
pub const CAN_F12R2_FB8_Pos: u32 = 8;
pub const CAN_F12R2_FB8_Msk: u32 = 256;
pub const CAN_F12R2_FB8: u32 = 256;
pub const CAN_F12R2_FB9_Pos: u32 = 9;
pub const CAN_F12R2_FB9_Msk: u32 = 512;
pub const CAN_F12R2_FB9: u32 = 512;
pub const CAN_F12R2_FB10_Pos: u32 = 10;
pub const CAN_F12R2_FB10_Msk: u32 = 1024;
pub const CAN_F12R2_FB10: u32 = 1024;
pub const CAN_F12R2_FB11_Pos: u32 = 11;
pub const CAN_F12R2_FB11_Msk: u32 = 2048;
pub const CAN_F12R2_FB11: u32 = 2048;
pub const CAN_F12R2_FB12_Pos: u32 = 12;
pub const CAN_F12R2_FB12_Msk: u32 = 4096;
pub const CAN_F12R2_FB12: u32 = 4096;
pub const CAN_F12R2_FB13_Pos: u32 = 13;
pub const CAN_F12R2_FB13_Msk: u32 = 8192;
pub const CAN_F12R2_FB13: u32 = 8192;
pub const CAN_F12R2_FB14_Pos: u32 = 14;
pub const CAN_F12R2_FB14_Msk: u32 = 16384;
pub const CAN_F12R2_FB14: u32 = 16384;
pub const CAN_F12R2_FB15_Pos: u32 = 15;
pub const CAN_F12R2_FB15_Msk: u32 = 32768;
pub const CAN_F12R2_FB15: u32 = 32768;
pub const CAN_F12R2_FB16_Pos: u32 = 16;
pub const CAN_F12R2_FB16_Msk: u32 = 65536;
pub const CAN_F12R2_FB16: u32 = 65536;
pub const CAN_F12R2_FB17_Pos: u32 = 17;
pub const CAN_F12R2_FB17_Msk: u32 = 131072;
pub const CAN_F12R2_FB17: u32 = 131072;
pub const CAN_F12R2_FB18_Pos: u32 = 18;
pub const CAN_F12R2_FB18_Msk: u32 = 262144;
pub const CAN_F12R2_FB18: u32 = 262144;
pub const CAN_F12R2_FB19_Pos: u32 = 19;
pub const CAN_F12R2_FB19_Msk: u32 = 524288;
pub const CAN_F12R2_FB19: u32 = 524288;
pub const CAN_F12R2_FB20_Pos: u32 = 20;
pub const CAN_F12R2_FB20_Msk: u32 = 1048576;
pub const CAN_F12R2_FB20: u32 = 1048576;
pub const CAN_F12R2_FB21_Pos: u32 = 21;
pub const CAN_F12R2_FB21_Msk: u32 = 2097152;
pub const CAN_F12R2_FB21: u32 = 2097152;
pub const CAN_F12R2_FB22_Pos: u32 = 22;
pub const CAN_F12R2_FB22_Msk: u32 = 4194304;
pub const CAN_F12R2_FB22: u32 = 4194304;
pub const CAN_F12R2_FB23_Pos: u32 = 23;
pub const CAN_F12R2_FB23_Msk: u32 = 8388608;
pub const CAN_F12R2_FB23: u32 = 8388608;
pub const CAN_F12R2_FB24_Pos: u32 = 24;
pub const CAN_F12R2_FB24_Msk: u32 = 16777216;
pub const CAN_F12R2_FB24: u32 = 16777216;
pub const CAN_F12R2_FB25_Pos: u32 = 25;
pub const CAN_F12R2_FB25_Msk: u32 = 33554432;
pub const CAN_F12R2_FB25: u32 = 33554432;
pub const CAN_F12R2_FB26_Pos: u32 = 26;
pub const CAN_F12R2_FB26_Msk: u32 = 67108864;
pub const CAN_F12R2_FB26: u32 = 67108864;
pub const CAN_F12R2_FB27_Pos: u32 = 27;
pub const CAN_F12R2_FB27_Msk: u32 = 134217728;
pub const CAN_F12R2_FB27: u32 = 134217728;
pub const CAN_F12R2_FB28_Pos: u32 = 28;
pub const CAN_F12R2_FB28_Msk: u32 = 268435456;
pub const CAN_F12R2_FB28: u32 = 268435456;
pub const CAN_F12R2_FB29_Pos: u32 = 29;
pub const CAN_F12R2_FB29_Msk: u32 = 536870912;
pub const CAN_F12R2_FB29: u32 = 536870912;
pub const CAN_F12R2_FB30_Pos: u32 = 30;
pub const CAN_F12R2_FB30_Msk: u32 = 1073741824;
pub const CAN_F12R2_FB30: u32 = 1073741824;
pub const CAN_F12R2_FB31_Pos: u32 = 31;
pub const CAN_F12R2_FB31_Msk: u32 = 2147483648;
pub const CAN_F12R2_FB31: u32 = 2147483648;
pub const CAN_F13R2_FB0_Pos: u32 = 0;
pub const CAN_F13R2_FB0_Msk: u32 = 1;
pub const CAN_F13R2_FB0: u32 = 1;
pub const CAN_F13R2_FB1_Pos: u32 = 1;
pub const CAN_F13R2_FB1_Msk: u32 = 2;
pub const CAN_F13R2_FB1: u32 = 2;
pub const CAN_F13R2_FB2_Pos: u32 = 2;
pub const CAN_F13R2_FB2_Msk: u32 = 4;
pub const CAN_F13R2_FB2: u32 = 4;
pub const CAN_F13R2_FB3_Pos: u32 = 3;
pub const CAN_F13R2_FB3_Msk: u32 = 8;
pub const CAN_F13R2_FB3: u32 = 8;
pub const CAN_F13R2_FB4_Pos: u32 = 4;
pub const CAN_F13R2_FB4_Msk: u32 = 16;
pub const CAN_F13R2_FB4: u32 = 16;
pub const CAN_F13R2_FB5_Pos: u32 = 5;
pub const CAN_F13R2_FB5_Msk: u32 = 32;
pub const CAN_F13R2_FB5: u32 = 32;
pub const CAN_F13R2_FB6_Pos: u32 = 6;
pub const CAN_F13R2_FB6_Msk: u32 = 64;
pub const CAN_F13R2_FB6: u32 = 64;
pub const CAN_F13R2_FB7_Pos: u32 = 7;
pub const CAN_F13R2_FB7_Msk: u32 = 128;
pub const CAN_F13R2_FB7: u32 = 128;
pub const CAN_F13R2_FB8_Pos: u32 = 8;
pub const CAN_F13R2_FB8_Msk: u32 = 256;
pub const CAN_F13R2_FB8: u32 = 256;
pub const CAN_F13R2_FB9_Pos: u32 = 9;
pub const CAN_F13R2_FB9_Msk: u32 = 512;
pub const CAN_F13R2_FB9: u32 = 512;
pub const CAN_F13R2_FB10_Pos: u32 = 10;
pub const CAN_F13R2_FB10_Msk: u32 = 1024;
pub const CAN_F13R2_FB10: u32 = 1024;
pub const CAN_F13R2_FB11_Pos: u32 = 11;
pub const CAN_F13R2_FB11_Msk: u32 = 2048;
pub const CAN_F13R2_FB11: u32 = 2048;
pub const CAN_F13R2_FB12_Pos: u32 = 12;
pub const CAN_F13R2_FB12_Msk: u32 = 4096;
pub const CAN_F13R2_FB12: u32 = 4096;
pub const CAN_F13R2_FB13_Pos: u32 = 13;
pub const CAN_F13R2_FB13_Msk: u32 = 8192;
pub const CAN_F13R2_FB13: u32 = 8192;
pub const CAN_F13R2_FB14_Pos: u32 = 14;
pub const CAN_F13R2_FB14_Msk: u32 = 16384;
pub const CAN_F13R2_FB14: u32 = 16384;
pub const CAN_F13R2_FB15_Pos: u32 = 15;
pub const CAN_F13R2_FB15_Msk: u32 = 32768;
pub const CAN_F13R2_FB15: u32 = 32768;
pub const CAN_F13R2_FB16_Pos: u32 = 16;
pub const CAN_F13R2_FB16_Msk: u32 = 65536;
pub const CAN_F13R2_FB16: u32 = 65536;
pub const CAN_F13R2_FB17_Pos: u32 = 17;
pub const CAN_F13R2_FB17_Msk: u32 = 131072;
pub const CAN_F13R2_FB17: u32 = 131072;
pub const CAN_F13R2_FB18_Pos: u32 = 18;
pub const CAN_F13R2_FB18_Msk: u32 = 262144;
pub const CAN_F13R2_FB18: u32 = 262144;
pub const CAN_F13R2_FB19_Pos: u32 = 19;
pub const CAN_F13R2_FB19_Msk: u32 = 524288;
pub const CAN_F13R2_FB19: u32 = 524288;
pub const CAN_F13R2_FB20_Pos: u32 = 20;
pub const CAN_F13R2_FB20_Msk: u32 = 1048576;
pub const CAN_F13R2_FB20: u32 = 1048576;
pub const CAN_F13R2_FB21_Pos: u32 = 21;
pub const CAN_F13R2_FB21_Msk: u32 = 2097152;
pub const CAN_F13R2_FB21: u32 = 2097152;
pub const CAN_F13R2_FB22_Pos: u32 = 22;
pub const CAN_F13R2_FB22_Msk: u32 = 4194304;
pub const CAN_F13R2_FB22: u32 = 4194304;
pub const CAN_F13R2_FB23_Pos: u32 = 23;
pub const CAN_F13R2_FB23_Msk: u32 = 8388608;
pub const CAN_F13R2_FB23: u32 = 8388608;
pub const CAN_F13R2_FB24_Pos: u32 = 24;
pub const CAN_F13R2_FB24_Msk: u32 = 16777216;
pub const CAN_F13R2_FB24: u32 = 16777216;
pub const CAN_F13R2_FB25_Pos: u32 = 25;
pub const CAN_F13R2_FB25_Msk: u32 = 33554432;
pub const CAN_F13R2_FB25: u32 = 33554432;
pub const CAN_F13R2_FB26_Pos: u32 = 26;
pub const CAN_F13R2_FB26_Msk: u32 = 67108864;
pub const CAN_F13R2_FB26: u32 = 67108864;
pub const CAN_F13R2_FB27_Pos: u32 = 27;
pub const CAN_F13R2_FB27_Msk: u32 = 134217728;
pub const CAN_F13R2_FB27: u32 = 134217728;
pub const CAN_F13R2_FB28_Pos: u32 = 28;
pub const CAN_F13R2_FB28_Msk: u32 = 268435456;
pub const CAN_F13R2_FB28: u32 = 268435456;
pub const CAN_F13R2_FB29_Pos: u32 = 29;
pub const CAN_F13R2_FB29_Msk: u32 = 536870912;
pub const CAN_F13R2_FB29: u32 = 536870912;
pub const CAN_F13R2_FB30_Pos: u32 = 30;
pub const CAN_F13R2_FB30_Msk: u32 = 1073741824;
pub const CAN_F13R2_FB30: u32 = 1073741824;
pub const CAN_F13R2_FB31_Pos: u32 = 31;
pub const CAN_F13R2_FB31_Msk: u32 = 2147483648;
pub const CAN_F13R2_FB31: u32 = 2147483648;
pub const CRC_DR_DR_Pos: u32 = 0;
pub const CRC_DR_DR_Msk: u32 = 4294967295;
pub const CRC_DR_DR: u32 = 4294967295;
pub const CRC_IDR_IDR_Pos: u32 = 0;
pub const CRC_IDR_IDR_Msk: u32 = 255;
pub const CRC_IDR_IDR: u32 = 255;
pub const CRC_CR_RESET_Pos: u32 = 0;
pub const CRC_CR_RESET_Msk: u32 = 1;
pub const CRC_CR_RESET: u32 = 1;
pub const CRC_CR_POLYSIZE_Pos: u32 = 3;
pub const CRC_CR_POLYSIZE_Msk: u32 = 24;
pub const CRC_CR_POLYSIZE: u32 = 24;
pub const CRC_CR_POLYSIZE_0: u32 = 8;
pub const CRC_CR_POLYSIZE_1: u32 = 16;
pub const CRC_CR_REV_IN_Pos: u32 = 5;
pub const CRC_CR_REV_IN_Msk: u32 = 96;
pub const CRC_CR_REV_IN: u32 = 96;
pub const CRC_CR_REV_IN_0: u32 = 32;
pub const CRC_CR_REV_IN_1: u32 = 64;
pub const CRC_CR_REV_OUT_Pos: u32 = 7;
pub const CRC_CR_REV_OUT_Msk: u32 = 128;
pub const CRC_CR_REV_OUT: u32 = 128;
pub const CRC_INIT_INIT_Pos: u32 = 0;
pub const CRC_INIT_INIT_Msk: u32 = 4294967295;
pub const CRC_INIT_INIT: u32 = 4294967295;
pub const CRC_POL_POL_Pos: u32 = 0;
pub const CRC_POL_POL_Msk: u32 = 4294967295;
pub const CRC_POL_POL: u32 = 4294967295;
pub const DAC_CR_EN1_Pos: u32 = 0;
pub const DAC_CR_EN1_Msk: u32 = 1;
pub const DAC_CR_EN1: u32 = 1;
pub const DAC_CR_TEN1_Pos: u32 = 2;
pub const DAC_CR_TEN1_Msk: u32 = 4;
pub const DAC_CR_TEN1: u32 = 4;
pub const DAC_CR_TSEL1_Pos: u32 = 3;
pub const DAC_CR_TSEL1_Msk: u32 = 56;
pub const DAC_CR_TSEL1: u32 = 56;
pub const DAC_CR_TSEL1_0: u32 = 8;
pub const DAC_CR_TSEL1_1: u32 = 16;
pub const DAC_CR_TSEL1_2: u32 = 32;
pub const DAC_CR_WAVE1_Pos: u32 = 6;
pub const DAC_CR_WAVE1_Msk: u32 = 192;
pub const DAC_CR_WAVE1: u32 = 192;
pub const DAC_CR_WAVE1_0: u32 = 64;
pub const DAC_CR_WAVE1_1: u32 = 128;
pub const DAC_CR_MAMP1_Pos: u32 = 8;
pub const DAC_CR_MAMP1_Msk: u32 = 3840;
pub const DAC_CR_MAMP1: u32 = 3840;
pub const DAC_CR_MAMP1_0: u32 = 256;
pub const DAC_CR_MAMP1_1: u32 = 512;
pub const DAC_CR_MAMP1_2: u32 = 1024;
pub const DAC_CR_MAMP1_3: u32 = 2048;
pub const DAC_CR_DMAEN1_Pos: u32 = 12;
pub const DAC_CR_DMAEN1_Msk: u32 = 4096;
pub const DAC_CR_DMAEN1: u32 = 4096;
pub const DAC_CR_DMAUDRIE1_Pos: u32 = 13;
pub const DAC_CR_DMAUDRIE1_Msk: u32 = 8192;
pub const DAC_CR_DMAUDRIE1: u32 = 8192;
pub const DAC_CR_CEN1_Pos: u32 = 14;
pub const DAC_CR_CEN1_Msk: u32 = 16384;
pub const DAC_CR_CEN1: u32 = 16384;
pub const DAC_CR_EN2_Pos: u32 = 16;
pub const DAC_CR_EN2_Msk: u32 = 65536;
pub const DAC_CR_EN2: u32 = 65536;
pub const DAC_CR_TEN2_Pos: u32 = 18;
pub const DAC_CR_TEN2_Msk: u32 = 262144;
pub const DAC_CR_TEN2: u32 = 262144;
pub const DAC_CR_TSEL2_Pos: u32 = 19;
pub const DAC_CR_TSEL2_Msk: u32 = 3670016;
pub const DAC_CR_TSEL2: u32 = 3670016;
pub const DAC_CR_TSEL2_0: u32 = 524288;
pub const DAC_CR_TSEL2_1: u32 = 1048576;
pub const DAC_CR_TSEL2_2: u32 = 2097152;
pub const DAC_CR_WAVE2_Pos: u32 = 22;
pub const DAC_CR_WAVE2_Msk: u32 = 12582912;
pub const DAC_CR_WAVE2: u32 = 12582912;
pub const DAC_CR_WAVE2_0: u32 = 4194304;
pub const DAC_CR_WAVE2_1: u32 = 8388608;
pub const DAC_CR_MAMP2_Pos: u32 = 24;
pub const DAC_CR_MAMP2_Msk: u32 = 251658240;
pub const DAC_CR_MAMP2: u32 = 251658240;
pub const DAC_CR_MAMP2_0: u32 = 16777216;
pub const DAC_CR_MAMP2_1: u32 = 33554432;
pub const DAC_CR_MAMP2_2: u32 = 67108864;
pub const DAC_CR_MAMP2_3: u32 = 134217728;
pub const DAC_CR_DMAEN2_Pos: u32 = 28;
pub const DAC_CR_DMAEN2_Msk: u32 = 268435456;
pub const DAC_CR_DMAEN2: u32 = 268435456;
pub const DAC_CR_DMAUDRIE2_Pos: u32 = 29;
pub const DAC_CR_DMAUDRIE2_Msk: u32 = 536870912;
pub const DAC_CR_DMAUDRIE2: u32 = 536870912;
pub const DAC_CR_CEN2_Pos: u32 = 30;
pub const DAC_CR_CEN2_Msk: u32 = 1073741824;
pub const DAC_CR_CEN2: u32 = 1073741824;
pub const DAC_SWTRIGR_SWTRIG1_Pos: u32 = 0;
pub const DAC_SWTRIGR_SWTRIG1_Msk: u32 = 1;
pub const DAC_SWTRIGR_SWTRIG1: u32 = 1;
pub const DAC_SWTRIGR_SWTRIG2_Pos: u32 = 1;
pub const DAC_SWTRIGR_SWTRIG2_Msk: u32 = 2;
pub const DAC_SWTRIGR_SWTRIG2: u32 = 2;
pub const DAC_DHR12R1_DACC1DHR_Pos: u32 = 0;
pub const DAC_DHR12R1_DACC1DHR_Msk: u32 = 4095;
pub const DAC_DHR12R1_DACC1DHR: u32 = 4095;
pub const DAC_DHR12L1_DACC1DHR_Pos: u32 = 4;
pub const DAC_DHR12L1_DACC1DHR_Msk: u32 = 65520;
pub const DAC_DHR12L1_DACC1DHR: u32 = 65520;
pub const DAC_DHR8R1_DACC1DHR_Pos: u32 = 0;
pub const DAC_DHR8R1_DACC1DHR_Msk: u32 = 255;
pub const DAC_DHR8R1_DACC1DHR: u32 = 255;
pub const DAC_DHR12R2_DACC2DHR_Pos: u32 = 0;
pub const DAC_DHR12R2_DACC2DHR_Msk: u32 = 4095;
pub const DAC_DHR12R2_DACC2DHR: u32 = 4095;
pub const DAC_DHR12L2_DACC2DHR_Pos: u32 = 4;
pub const DAC_DHR12L2_DACC2DHR_Msk: u32 = 65520;
pub const DAC_DHR12L2_DACC2DHR: u32 = 65520;
pub const DAC_DHR8R2_DACC2DHR_Pos: u32 = 0;
pub const DAC_DHR8R2_DACC2DHR_Msk: u32 = 255;
pub const DAC_DHR8R2_DACC2DHR: u32 = 255;
pub const DAC_DHR12RD_DACC1DHR_Pos: u32 = 0;
pub const DAC_DHR12RD_DACC1DHR_Msk: u32 = 4095;
pub const DAC_DHR12RD_DACC1DHR: u32 = 4095;
pub const DAC_DHR12RD_DACC2DHR_Pos: u32 = 16;
pub const DAC_DHR12RD_DACC2DHR_Msk: u32 = 268369920;
pub const DAC_DHR12RD_DACC2DHR: u32 = 268369920;
pub const DAC_DHR12LD_DACC1DHR_Pos: u32 = 4;
pub const DAC_DHR12LD_DACC1DHR_Msk: u32 = 65520;
pub const DAC_DHR12LD_DACC1DHR: u32 = 65520;
pub const DAC_DHR12LD_DACC2DHR_Pos: u32 = 20;
pub const DAC_DHR12LD_DACC2DHR_Msk: u32 = 4293918720;
pub const DAC_DHR12LD_DACC2DHR: u32 = 4293918720;
pub const DAC_DHR8RD_DACC1DHR_Pos: u32 = 0;
pub const DAC_DHR8RD_DACC1DHR_Msk: u32 = 255;
pub const DAC_DHR8RD_DACC1DHR: u32 = 255;
pub const DAC_DHR8RD_DACC2DHR_Pos: u32 = 8;
pub const DAC_DHR8RD_DACC2DHR_Msk: u32 = 65280;
pub const DAC_DHR8RD_DACC2DHR: u32 = 65280;
pub const DAC_DOR1_DACC1DOR_Pos: u32 = 0;
pub const DAC_DOR1_DACC1DOR_Msk: u32 = 4095;
pub const DAC_DOR1_DACC1DOR: u32 = 4095;
pub const DAC_DOR2_DACC2DOR_Pos: u32 = 0;
pub const DAC_DOR2_DACC2DOR_Msk: u32 = 4095;
pub const DAC_DOR2_DACC2DOR: u32 = 4095;
pub const DAC_SR_DMAUDR1_Pos: u32 = 13;
pub const DAC_SR_DMAUDR1_Msk: u32 = 8192;
pub const DAC_SR_DMAUDR1: u32 = 8192;
pub const DAC_SR_CAL_FLAG1_Pos: u32 = 14;
pub const DAC_SR_CAL_FLAG1_Msk: u32 = 16384;
pub const DAC_SR_CAL_FLAG1: u32 = 16384;
pub const DAC_SR_BWST1_Pos: u32 = 15;
pub const DAC_SR_BWST1_Msk: u32 = 32768;
pub const DAC_SR_BWST1: u32 = 32768;
pub const DAC_SR_DMAUDR2_Pos: u32 = 29;
pub const DAC_SR_DMAUDR2_Msk: u32 = 536870912;
pub const DAC_SR_DMAUDR2: u32 = 536870912;
pub const DAC_SR_CAL_FLAG2_Pos: u32 = 30;
pub const DAC_SR_CAL_FLAG2_Msk: u32 = 1073741824;
pub const DAC_SR_CAL_FLAG2: u32 = 1073741824;
pub const DAC_SR_BWST2_Pos: u32 = 31;
pub const DAC_SR_BWST2_Msk: u32 = 2147483648;
pub const DAC_SR_BWST2: u32 = 2147483648;
pub const DAC_CCR_OTRIM1_Pos: u32 = 0;
pub const DAC_CCR_OTRIM1_Msk: u32 = 31;
pub const DAC_CCR_OTRIM1: u32 = 31;
pub const DAC_CCR_OTRIM2_Pos: u32 = 16;
pub const DAC_CCR_OTRIM2_Msk: u32 = 2031616;
pub const DAC_CCR_OTRIM2: u32 = 2031616;
pub const DAC_MCR_MODE1_Pos: u32 = 0;
pub const DAC_MCR_MODE1_Msk: u32 = 7;
pub const DAC_MCR_MODE1: u32 = 7;
pub const DAC_MCR_MODE1_0: u32 = 1;
pub const DAC_MCR_MODE1_1: u32 = 2;
pub const DAC_MCR_MODE1_2: u32 = 4;
pub const DAC_MCR_MODE2_Pos: u32 = 16;
pub const DAC_MCR_MODE2_Msk: u32 = 458752;
pub const DAC_MCR_MODE2: u32 = 458752;
pub const DAC_MCR_MODE2_0: u32 = 65536;
pub const DAC_MCR_MODE2_1: u32 = 131072;
pub const DAC_MCR_MODE2_2: u32 = 262144;
pub const DAC_SHSR1_TSAMPLE1_Pos: u32 = 0;
pub const DAC_SHSR1_TSAMPLE1_Msk: u32 = 1023;
pub const DAC_SHSR1_TSAMPLE1: u32 = 1023;
pub const DAC_SHSR2_TSAMPLE2_Pos: u32 = 0;
pub const DAC_SHSR2_TSAMPLE2_Msk: u32 = 1023;
pub const DAC_SHSR2_TSAMPLE2: u32 = 1023;
pub const DAC_SHHR_THOLD1_Pos: u32 = 0;
pub const DAC_SHHR_THOLD1_Msk: u32 = 1023;
pub const DAC_SHHR_THOLD1: u32 = 1023;
pub const DAC_SHHR_THOLD2_Pos: u32 = 16;
pub const DAC_SHHR_THOLD2_Msk: u32 = 67043328;
pub const DAC_SHHR_THOLD2: u32 = 67043328;
pub const DAC_SHRR_TREFRESH1_Pos: u32 = 0;
pub const DAC_SHRR_TREFRESH1_Msk: u32 = 255;
pub const DAC_SHRR_TREFRESH1: u32 = 255;
pub const DAC_SHRR_TREFRESH2_Pos: u32 = 16;
pub const DAC_SHRR_TREFRESH2_Msk: u32 = 16711680;
pub const DAC_SHRR_TREFRESH2: u32 = 16711680;
pub const DFSDM_CHCFGR1_DFSDMEN_Pos: u32 = 31;
pub const DFSDM_CHCFGR1_DFSDMEN_Msk: u32 = 2147483648;
pub const DFSDM_CHCFGR1_DFSDMEN: u32 = 2147483648;
pub const DFSDM_CHCFGR1_CKOUTSRC_Pos: u32 = 30;
pub const DFSDM_CHCFGR1_CKOUTSRC_Msk: u32 = 1073741824;
pub const DFSDM_CHCFGR1_CKOUTSRC: u32 = 1073741824;
pub const DFSDM_CHCFGR1_CKOUTDIV_Pos: u32 = 16;
pub const DFSDM_CHCFGR1_CKOUTDIV_Msk: u32 = 16711680;
pub const DFSDM_CHCFGR1_CKOUTDIV: u32 = 16711680;
pub const DFSDM_CHCFGR1_DATPACK_Pos: u32 = 14;
pub const DFSDM_CHCFGR1_DATPACK_Msk: u32 = 49152;
pub const DFSDM_CHCFGR1_DATPACK: u32 = 49152;
pub const DFSDM_CHCFGR1_DATPACK_1: u32 = 32768;
pub const DFSDM_CHCFGR1_DATPACK_0: u32 = 16384;
pub const DFSDM_CHCFGR1_DATMPX_Pos: u32 = 12;
pub const DFSDM_CHCFGR1_DATMPX_Msk: u32 = 12288;
pub const DFSDM_CHCFGR1_DATMPX: u32 = 12288;
pub const DFSDM_CHCFGR1_DATMPX_1: u32 = 8192;
pub const DFSDM_CHCFGR1_DATMPX_0: u32 = 4096;
pub const DFSDM_CHCFGR1_CHINSEL_Pos: u32 = 8;
pub const DFSDM_CHCFGR1_CHINSEL_Msk: u32 = 256;
pub const DFSDM_CHCFGR1_CHINSEL: u32 = 256;
pub const DFSDM_CHCFGR1_CHEN_Pos: u32 = 7;
pub const DFSDM_CHCFGR1_CHEN_Msk: u32 = 128;
pub const DFSDM_CHCFGR1_CHEN: u32 = 128;
pub const DFSDM_CHCFGR1_CKABEN_Pos: u32 = 6;
pub const DFSDM_CHCFGR1_CKABEN_Msk: u32 = 64;
pub const DFSDM_CHCFGR1_CKABEN: u32 = 64;
pub const DFSDM_CHCFGR1_SCDEN_Pos: u32 = 5;
pub const DFSDM_CHCFGR1_SCDEN_Msk: u32 = 32;
pub const DFSDM_CHCFGR1_SCDEN: u32 = 32;
pub const DFSDM_CHCFGR1_SPICKSEL_Pos: u32 = 2;
pub const DFSDM_CHCFGR1_SPICKSEL_Msk: u32 = 12;
pub const DFSDM_CHCFGR1_SPICKSEL: u32 = 12;
pub const DFSDM_CHCFGR1_SPICKSEL_1: u32 = 8;
pub const DFSDM_CHCFGR1_SPICKSEL_0: u32 = 4;
pub const DFSDM_CHCFGR1_SITP_Pos: u32 = 0;
pub const DFSDM_CHCFGR1_SITP_Msk: u32 = 3;
pub const DFSDM_CHCFGR1_SITP: u32 = 3;
pub const DFSDM_CHCFGR1_SITP_1: u32 = 2;
pub const DFSDM_CHCFGR1_SITP_0: u32 = 1;
pub const DFSDM_CHCFGR2_OFFSET_Pos: u32 = 8;
pub const DFSDM_CHCFGR2_OFFSET_Msk: u32 = 4294967040;
pub const DFSDM_CHCFGR2_OFFSET: u32 = 4294967040;
pub const DFSDM_CHCFGR2_DTRBS_Pos: u32 = 3;
pub const DFSDM_CHCFGR2_DTRBS_Msk: u32 = 248;
pub const DFSDM_CHCFGR2_DTRBS: u32 = 248;
pub const DFSDM_CHAWSCDR_AWFORD_Pos: u32 = 22;
pub const DFSDM_CHAWSCDR_AWFORD_Msk: u32 = 12582912;
pub const DFSDM_CHAWSCDR_AWFORD: u32 = 12582912;
pub const DFSDM_CHAWSCDR_AWFORD_1: u32 = 8388608;
pub const DFSDM_CHAWSCDR_AWFORD_0: u32 = 4194304;
pub const DFSDM_CHAWSCDR_AWFOSR_Pos: u32 = 16;
pub const DFSDM_CHAWSCDR_AWFOSR_Msk: u32 = 2031616;
pub const DFSDM_CHAWSCDR_AWFOSR: u32 = 2031616;
pub const DFSDM_CHAWSCDR_BKSCD_Pos: u32 = 12;
pub const DFSDM_CHAWSCDR_BKSCD_Msk: u32 = 61440;
pub const DFSDM_CHAWSCDR_BKSCD: u32 = 61440;
pub const DFSDM_CHAWSCDR_SCDT_Pos: u32 = 0;
pub const DFSDM_CHAWSCDR_SCDT_Msk: u32 = 255;
pub const DFSDM_CHAWSCDR_SCDT: u32 = 255;
pub const DFSDM_CHWDATR_WDATA_Pos: u32 = 0;
pub const DFSDM_CHWDATR_WDATA_Msk: u32 = 65535;
pub const DFSDM_CHWDATR_WDATA: u32 = 65535;
pub const DFSDM_CHDATINR_INDAT0_Pos: u32 = 0;
pub const DFSDM_CHDATINR_INDAT0_Msk: u32 = 65535;
pub const DFSDM_CHDATINR_INDAT0: u32 = 65535;
pub const DFSDM_CHDATINR_INDAT1_Pos: u32 = 16;
pub const DFSDM_CHDATINR_INDAT1_Msk: u32 = 4294901760;
pub const DFSDM_CHDATINR_INDAT1: u32 = 4294901760;
pub const DFSDM_FLTCR1_AWFSEL_Pos: u32 = 30;
pub const DFSDM_FLTCR1_AWFSEL_Msk: u32 = 1073741824;
pub const DFSDM_FLTCR1_AWFSEL: u32 = 1073741824;
pub const DFSDM_FLTCR1_FAST_Pos: u32 = 29;
pub const DFSDM_FLTCR1_FAST_Msk: u32 = 536870912;
pub const DFSDM_FLTCR1_FAST: u32 = 536870912;
pub const DFSDM_FLTCR1_RCH_Pos: u32 = 24;
pub const DFSDM_FLTCR1_RCH_Msk: u32 = 117440512;
pub const DFSDM_FLTCR1_RCH: u32 = 117440512;
pub const DFSDM_FLTCR1_RDMAEN_Pos: u32 = 21;
pub const DFSDM_FLTCR1_RDMAEN_Msk: u32 = 2097152;
pub const DFSDM_FLTCR1_RDMAEN: u32 = 2097152;
pub const DFSDM_FLTCR1_RSYNC_Pos: u32 = 19;
pub const DFSDM_FLTCR1_RSYNC_Msk: u32 = 524288;
pub const DFSDM_FLTCR1_RSYNC: u32 = 524288;
pub const DFSDM_FLTCR1_RCONT_Pos: u32 = 18;
pub const DFSDM_FLTCR1_RCONT_Msk: u32 = 262144;
pub const DFSDM_FLTCR1_RCONT: u32 = 262144;
pub const DFSDM_FLTCR1_RSWSTART_Pos: u32 = 17;
pub const DFSDM_FLTCR1_RSWSTART_Msk: u32 = 131072;
pub const DFSDM_FLTCR1_RSWSTART: u32 = 131072;
pub const DFSDM_FLTCR1_JEXTEN_Pos: u32 = 13;
pub const DFSDM_FLTCR1_JEXTEN_Msk: u32 = 24576;
pub const DFSDM_FLTCR1_JEXTEN: u32 = 24576;
pub const DFSDM_FLTCR1_JEXTEN_1: u32 = 16384;
pub const DFSDM_FLTCR1_JEXTEN_0: u32 = 8192;
pub const DFSDM_FLTCR1_JEXTSEL_Pos: u32 = 8;
pub const DFSDM_FLTCR1_JEXTSEL_Msk: u32 = 1792;
pub const DFSDM_FLTCR1_JEXTSEL: u32 = 1792;
pub const DFSDM_FLTCR1_JEXTSEL_2: u32 = 1024;
pub const DFSDM_FLTCR1_JEXTSEL_1: u32 = 512;
pub const DFSDM_FLTCR1_JEXTSEL_0: u32 = 256;
pub const DFSDM_FLTCR1_JDMAEN_Pos: u32 = 5;
pub const DFSDM_FLTCR1_JDMAEN_Msk: u32 = 32;
pub const DFSDM_FLTCR1_JDMAEN: u32 = 32;
pub const DFSDM_FLTCR1_JSCAN_Pos: u32 = 4;
pub const DFSDM_FLTCR1_JSCAN_Msk: u32 = 16;
pub const DFSDM_FLTCR1_JSCAN: u32 = 16;
pub const DFSDM_FLTCR1_JSYNC_Pos: u32 = 3;
pub const DFSDM_FLTCR1_JSYNC_Msk: u32 = 8;
pub const DFSDM_FLTCR1_JSYNC: u32 = 8;
pub const DFSDM_FLTCR1_JSWSTART_Pos: u32 = 1;
pub const DFSDM_FLTCR1_JSWSTART_Msk: u32 = 2;
pub const DFSDM_FLTCR1_JSWSTART: u32 = 2;
pub const DFSDM_FLTCR1_DFEN_Pos: u32 = 0;
pub const DFSDM_FLTCR1_DFEN_Msk: u32 = 1;
pub const DFSDM_FLTCR1_DFEN: u32 = 1;
pub const DFSDM_FLTCR2_AWDCH_Pos: u32 = 16;
pub const DFSDM_FLTCR2_AWDCH_Msk: u32 = 16711680;
pub const DFSDM_FLTCR2_AWDCH: u32 = 16711680;
pub const DFSDM_FLTCR2_EXCH_Pos: u32 = 8;
pub const DFSDM_FLTCR2_EXCH_Msk: u32 = 65280;
pub const DFSDM_FLTCR2_EXCH: u32 = 65280;
pub const DFSDM_FLTCR2_CKABIE_Pos: u32 = 6;
pub const DFSDM_FLTCR2_CKABIE_Msk: u32 = 64;
pub const DFSDM_FLTCR2_CKABIE: u32 = 64;
pub const DFSDM_FLTCR2_SCDIE_Pos: u32 = 5;
pub const DFSDM_FLTCR2_SCDIE_Msk: u32 = 32;
pub const DFSDM_FLTCR2_SCDIE: u32 = 32;
pub const DFSDM_FLTCR2_AWDIE_Pos: u32 = 4;
pub const DFSDM_FLTCR2_AWDIE_Msk: u32 = 16;
pub const DFSDM_FLTCR2_AWDIE: u32 = 16;
pub const DFSDM_FLTCR2_ROVRIE_Pos: u32 = 3;
pub const DFSDM_FLTCR2_ROVRIE_Msk: u32 = 8;
pub const DFSDM_FLTCR2_ROVRIE: u32 = 8;
pub const DFSDM_FLTCR2_JOVRIE_Pos: u32 = 2;
pub const DFSDM_FLTCR2_JOVRIE_Msk: u32 = 4;
pub const DFSDM_FLTCR2_JOVRIE: u32 = 4;
pub const DFSDM_FLTCR2_REOCIE_Pos: u32 = 1;
pub const DFSDM_FLTCR2_REOCIE_Msk: u32 = 2;
pub const DFSDM_FLTCR2_REOCIE: u32 = 2;
pub const DFSDM_FLTCR2_JEOCIE_Pos: u32 = 0;
pub const DFSDM_FLTCR2_JEOCIE_Msk: u32 = 1;
pub const DFSDM_FLTCR2_JEOCIE: u32 = 1;
pub const DFSDM_FLTISR_SCDF_Pos: u32 = 24;
pub const DFSDM_FLTISR_SCDF_Msk: u32 = 4278190080;
pub const DFSDM_FLTISR_SCDF: u32 = 4278190080;
pub const DFSDM_FLTISR_CKABF_Pos: u32 = 16;
pub const DFSDM_FLTISR_CKABF_Msk: u32 = 16711680;
pub const DFSDM_FLTISR_CKABF: u32 = 16711680;
pub const DFSDM_FLTISR_RCIP_Pos: u32 = 14;
pub const DFSDM_FLTISR_RCIP_Msk: u32 = 16384;
pub const DFSDM_FLTISR_RCIP: u32 = 16384;
pub const DFSDM_FLTISR_JCIP_Pos: u32 = 13;
pub const DFSDM_FLTISR_JCIP_Msk: u32 = 8192;
pub const DFSDM_FLTISR_JCIP: u32 = 8192;
pub const DFSDM_FLTISR_AWDF_Pos: u32 = 4;
pub const DFSDM_FLTISR_AWDF_Msk: u32 = 16;
pub const DFSDM_FLTISR_AWDF: u32 = 16;
pub const DFSDM_FLTISR_ROVRF_Pos: u32 = 3;
pub const DFSDM_FLTISR_ROVRF_Msk: u32 = 8;
pub const DFSDM_FLTISR_ROVRF: u32 = 8;
pub const DFSDM_FLTISR_JOVRF_Pos: u32 = 2;
pub const DFSDM_FLTISR_JOVRF_Msk: u32 = 4;
pub const DFSDM_FLTISR_JOVRF: u32 = 4;
pub const DFSDM_FLTISR_REOCF_Pos: u32 = 1;
pub const DFSDM_FLTISR_REOCF_Msk: u32 = 2;
pub const DFSDM_FLTISR_REOCF: u32 = 2;
pub const DFSDM_FLTISR_JEOCF_Pos: u32 = 0;
pub const DFSDM_FLTISR_JEOCF_Msk: u32 = 1;
pub const DFSDM_FLTISR_JEOCF: u32 = 1;
pub const DFSDM_FLTICR_CLRSCDF_Pos: u32 = 24;
pub const DFSDM_FLTICR_CLRSCDF_Msk: u32 = 4278190080;
pub const DFSDM_FLTICR_CLRSCDF: u32 = 4278190080;
pub const DFSDM_FLTICR_CLRCKABF_Pos: u32 = 16;
pub const DFSDM_FLTICR_CLRCKABF_Msk: u32 = 16711680;
pub const DFSDM_FLTICR_CLRCKABF: u32 = 16711680;
pub const DFSDM_FLTICR_CLRROVRF_Pos: u32 = 3;
pub const DFSDM_FLTICR_CLRROVRF_Msk: u32 = 8;
pub const DFSDM_FLTICR_CLRROVRF: u32 = 8;
pub const DFSDM_FLTICR_CLRJOVRF_Pos: u32 = 2;
pub const DFSDM_FLTICR_CLRJOVRF_Msk: u32 = 4;
pub const DFSDM_FLTICR_CLRJOVRF: u32 = 4;
pub const DFSDM_FLTJCHGR_JCHG_Pos: u32 = 0;
pub const DFSDM_FLTJCHGR_JCHG_Msk: u32 = 255;
pub const DFSDM_FLTJCHGR_JCHG: u32 = 255;
pub const DFSDM_FLTFCR_FORD_Pos: u32 = 29;
pub const DFSDM_FLTFCR_FORD_Msk: u32 = 3758096384;
pub const DFSDM_FLTFCR_FORD: u32 = 3758096384;
pub const DFSDM_FLTFCR_FORD_2: u32 = 2147483648;
pub const DFSDM_FLTFCR_FORD_1: u32 = 1073741824;
pub const DFSDM_FLTFCR_FORD_0: u32 = 536870912;
pub const DFSDM_FLTFCR_FOSR_Pos: u32 = 16;
pub const DFSDM_FLTFCR_FOSR_Msk: u32 = 67043328;
pub const DFSDM_FLTFCR_FOSR: u32 = 67043328;
pub const DFSDM_FLTFCR_IOSR_Pos: u32 = 0;
pub const DFSDM_FLTFCR_IOSR_Msk: u32 = 255;
pub const DFSDM_FLTFCR_IOSR: u32 = 255;
pub const DFSDM_FLTJDATAR_JDATA_Pos: u32 = 8;
pub const DFSDM_FLTJDATAR_JDATA_Msk: u32 = 4294967040;
pub const DFSDM_FLTJDATAR_JDATA: u32 = 4294967040;
pub const DFSDM_FLTJDATAR_JDATACH_Pos: u32 = 0;
pub const DFSDM_FLTJDATAR_JDATACH_Msk: u32 = 7;
pub const DFSDM_FLTJDATAR_JDATACH: u32 = 7;
pub const DFSDM_FLTRDATAR_RDATA_Pos: u32 = 8;
pub const DFSDM_FLTRDATAR_RDATA_Msk: u32 = 4294967040;
pub const DFSDM_FLTRDATAR_RDATA: u32 = 4294967040;
pub const DFSDM_FLTRDATAR_RPEND_Pos: u32 = 4;
pub const DFSDM_FLTRDATAR_RPEND_Msk: u32 = 16;
pub const DFSDM_FLTRDATAR_RPEND: u32 = 16;
pub const DFSDM_FLTRDATAR_RDATACH_Pos: u32 = 0;
pub const DFSDM_FLTRDATAR_RDATACH_Msk: u32 = 7;
pub const DFSDM_FLTRDATAR_RDATACH: u32 = 7;
pub const DFSDM_FLTAWHTR_AWHT_Pos: u32 = 8;
pub const DFSDM_FLTAWHTR_AWHT_Msk: u32 = 4294967040;
pub const DFSDM_FLTAWHTR_AWHT: u32 = 4294967040;
pub const DFSDM_FLTAWHTR_BKAWH_Pos: u32 = 0;
pub const DFSDM_FLTAWHTR_BKAWH_Msk: u32 = 15;
pub const DFSDM_FLTAWHTR_BKAWH: u32 = 15;
pub const DFSDM_FLTAWLTR_AWLT_Pos: u32 = 8;
pub const DFSDM_FLTAWLTR_AWLT_Msk: u32 = 4294967040;
pub const DFSDM_FLTAWLTR_AWLT: u32 = 4294967040;
pub const DFSDM_FLTAWLTR_BKAWL_Pos: u32 = 0;
pub const DFSDM_FLTAWLTR_BKAWL_Msk: u32 = 15;
pub const DFSDM_FLTAWLTR_BKAWL: u32 = 15;
pub const DFSDM_FLTAWSR_AWHTF_Pos: u32 = 8;
pub const DFSDM_FLTAWSR_AWHTF_Msk: u32 = 65280;
pub const DFSDM_FLTAWSR_AWHTF: u32 = 65280;
pub const DFSDM_FLTAWSR_AWLTF_Pos: u32 = 0;
pub const DFSDM_FLTAWSR_AWLTF_Msk: u32 = 255;
pub const DFSDM_FLTAWSR_AWLTF: u32 = 255;
pub const DFSDM_FLTAWCFR_CLRAWHTF_Pos: u32 = 8;
pub const DFSDM_FLTAWCFR_CLRAWHTF_Msk: u32 = 65280;
pub const DFSDM_FLTAWCFR_CLRAWHTF: u32 = 65280;
pub const DFSDM_FLTAWCFR_CLRAWLTF_Pos: u32 = 0;
pub const DFSDM_FLTAWCFR_CLRAWLTF_Msk: u32 = 255;
pub const DFSDM_FLTAWCFR_CLRAWLTF: u32 = 255;
pub const DFSDM_FLTEXMAX_EXMAX_Pos: u32 = 8;
pub const DFSDM_FLTEXMAX_EXMAX_Msk: u32 = 4294967040;
pub const DFSDM_FLTEXMAX_EXMAX: u32 = 4294967040;
pub const DFSDM_FLTEXMAX_EXMAXCH_Pos: u32 = 0;
pub const DFSDM_FLTEXMAX_EXMAXCH_Msk: u32 = 7;
pub const DFSDM_FLTEXMAX_EXMAXCH: u32 = 7;
pub const DFSDM_FLTEXMIN_EXMIN_Pos: u32 = 8;
pub const DFSDM_FLTEXMIN_EXMIN_Msk: u32 = 4294967040;
pub const DFSDM_FLTEXMIN_EXMIN: u32 = 4294967040;
pub const DFSDM_FLTEXMIN_EXMINCH_Pos: u32 = 0;
pub const DFSDM_FLTEXMIN_EXMINCH_Msk: u32 = 7;
pub const DFSDM_FLTEXMIN_EXMINCH: u32 = 7;
pub const DFSDM_FLTCNVTIMR_CNVCNT_Pos: u32 = 4;
pub const DFSDM_FLTCNVTIMR_CNVCNT_Msk: u32 = 4294967280;
pub const DFSDM_FLTCNVTIMR_CNVCNT: u32 = 4294967280;
pub const DMA_ISR_GIF1_Pos: u32 = 0;
pub const DMA_ISR_GIF1_Msk: u32 = 1;
pub const DMA_ISR_GIF1: u32 = 1;
pub const DMA_ISR_TCIF1_Pos: u32 = 1;
pub const DMA_ISR_TCIF1_Msk: u32 = 2;
pub const DMA_ISR_TCIF1: u32 = 2;
pub const DMA_ISR_HTIF1_Pos: u32 = 2;
pub const DMA_ISR_HTIF1_Msk: u32 = 4;
pub const DMA_ISR_HTIF1: u32 = 4;
pub const DMA_ISR_TEIF1_Pos: u32 = 3;
pub const DMA_ISR_TEIF1_Msk: u32 = 8;
pub const DMA_ISR_TEIF1: u32 = 8;
pub const DMA_ISR_GIF2_Pos: u32 = 4;
pub const DMA_ISR_GIF2_Msk: u32 = 16;
pub const DMA_ISR_GIF2: u32 = 16;
pub const DMA_ISR_TCIF2_Pos: u32 = 5;
pub const DMA_ISR_TCIF2_Msk: u32 = 32;
pub const DMA_ISR_TCIF2: u32 = 32;
pub const DMA_ISR_HTIF2_Pos: u32 = 6;
pub const DMA_ISR_HTIF2_Msk: u32 = 64;
pub const DMA_ISR_HTIF2: u32 = 64;
pub const DMA_ISR_TEIF2_Pos: u32 = 7;
pub const DMA_ISR_TEIF2_Msk: u32 = 128;
pub const DMA_ISR_TEIF2: u32 = 128;
pub const DMA_ISR_GIF3_Pos: u32 = 8;
pub const DMA_ISR_GIF3_Msk: u32 = 256;
pub const DMA_ISR_GIF3: u32 = 256;
pub const DMA_ISR_TCIF3_Pos: u32 = 9;
pub const DMA_ISR_TCIF3_Msk: u32 = 512;
pub const DMA_ISR_TCIF3: u32 = 512;
pub const DMA_ISR_HTIF3_Pos: u32 = 10;
pub const DMA_ISR_HTIF3_Msk: u32 = 1024;
pub const DMA_ISR_HTIF3: u32 = 1024;
pub const DMA_ISR_TEIF3_Pos: u32 = 11;
pub const DMA_ISR_TEIF3_Msk: u32 = 2048;
pub const DMA_ISR_TEIF3: u32 = 2048;
pub const DMA_ISR_GIF4_Pos: u32 = 12;
pub const DMA_ISR_GIF4_Msk: u32 = 4096;
pub const DMA_ISR_GIF4: u32 = 4096;
pub const DMA_ISR_TCIF4_Pos: u32 = 13;
pub const DMA_ISR_TCIF4_Msk: u32 = 8192;
pub const DMA_ISR_TCIF4: u32 = 8192;
pub const DMA_ISR_HTIF4_Pos: u32 = 14;
pub const DMA_ISR_HTIF4_Msk: u32 = 16384;
pub const DMA_ISR_HTIF4: u32 = 16384;
pub const DMA_ISR_TEIF4_Pos: u32 = 15;
pub const DMA_ISR_TEIF4_Msk: u32 = 32768;
pub const DMA_ISR_TEIF4: u32 = 32768;
pub const DMA_ISR_GIF5_Pos: u32 = 16;
pub const DMA_ISR_GIF5_Msk: u32 = 65536;
pub const DMA_ISR_GIF5: u32 = 65536;
pub const DMA_ISR_TCIF5_Pos: u32 = 17;
pub const DMA_ISR_TCIF5_Msk: u32 = 131072;
pub const DMA_ISR_TCIF5: u32 = 131072;
pub const DMA_ISR_HTIF5_Pos: u32 = 18;
pub const DMA_ISR_HTIF5_Msk: u32 = 262144;
pub const DMA_ISR_HTIF5: u32 = 262144;
pub const DMA_ISR_TEIF5_Pos: u32 = 19;
pub const DMA_ISR_TEIF5_Msk: u32 = 524288;
pub const DMA_ISR_TEIF5: u32 = 524288;
pub const DMA_ISR_GIF6_Pos: u32 = 20;
pub const DMA_ISR_GIF6_Msk: u32 = 1048576;
pub const DMA_ISR_GIF6: u32 = 1048576;
pub const DMA_ISR_TCIF6_Pos: u32 = 21;
pub const DMA_ISR_TCIF6_Msk: u32 = 2097152;
pub const DMA_ISR_TCIF6: u32 = 2097152;
pub const DMA_ISR_HTIF6_Pos: u32 = 22;
pub const DMA_ISR_HTIF6_Msk: u32 = 4194304;
pub const DMA_ISR_HTIF6: u32 = 4194304;
pub const DMA_ISR_TEIF6_Pos: u32 = 23;
pub const DMA_ISR_TEIF6_Msk: u32 = 8388608;
pub const DMA_ISR_TEIF6: u32 = 8388608;
pub const DMA_ISR_GIF7_Pos: u32 = 24;
pub const DMA_ISR_GIF7_Msk: u32 = 16777216;
pub const DMA_ISR_GIF7: u32 = 16777216;
pub const DMA_ISR_TCIF7_Pos: u32 = 25;
pub const DMA_ISR_TCIF7_Msk: u32 = 33554432;
pub const DMA_ISR_TCIF7: u32 = 33554432;
pub const DMA_ISR_HTIF7_Pos: u32 = 26;
pub const DMA_ISR_HTIF7_Msk: u32 = 67108864;
pub const DMA_ISR_HTIF7: u32 = 67108864;
pub const DMA_ISR_TEIF7_Pos: u32 = 27;
pub const DMA_ISR_TEIF7_Msk: u32 = 134217728;
pub const DMA_ISR_TEIF7: u32 = 134217728;
pub const DMA_IFCR_CGIF1_Pos: u32 = 0;
pub const DMA_IFCR_CGIF1_Msk: u32 = 1;
pub const DMA_IFCR_CGIF1: u32 = 1;
pub const DMA_IFCR_CTCIF1_Pos: u32 = 1;
pub const DMA_IFCR_CTCIF1_Msk: u32 = 2;
pub const DMA_IFCR_CTCIF1: u32 = 2;
pub const DMA_IFCR_CHTIF1_Pos: u32 = 2;
pub const DMA_IFCR_CHTIF1_Msk: u32 = 4;
pub const DMA_IFCR_CHTIF1: u32 = 4;
pub const DMA_IFCR_CTEIF1_Pos: u32 = 3;
pub const DMA_IFCR_CTEIF1_Msk: u32 = 8;
pub const DMA_IFCR_CTEIF1: u32 = 8;
pub const DMA_IFCR_CGIF2_Pos: u32 = 4;
pub const DMA_IFCR_CGIF2_Msk: u32 = 16;
pub const DMA_IFCR_CGIF2: u32 = 16;
pub const DMA_IFCR_CTCIF2_Pos: u32 = 5;
pub const DMA_IFCR_CTCIF2_Msk: u32 = 32;
pub const DMA_IFCR_CTCIF2: u32 = 32;
pub const DMA_IFCR_CHTIF2_Pos: u32 = 6;
pub const DMA_IFCR_CHTIF2_Msk: u32 = 64;
pub const DMA_IFCR_CHTIF2: u32 = 64;
pub const DMA_IFCR_CTEIF2_Pos: u32 = 7;
pub const DMA_IFCR_CTEIF2_Msk: u32 = 128;
pub const DMA_IFCR_CTEIF2: u32 = 128;
pub const DMA_IFCR_CGIF3_Pos: u32 = 8;
pub const DMA_IFCR_CGIF3_Msk: u32 = 256;
pub const DMA_IFCR_CGIF3: u32 = 256;
pub const DMA_IFCR_CTCIF3_Pos: u32 = 9;
pub const DMA_IFCR_CTCIF3_Msk: u32 = 512;
pub const DMA_IFCR_CTCIF3: u32 = 512;
pub const DMA_IFCR_CHTIF3_Pos: u32 = 10;
pub const DMA_IFCR_CHTIF3_Msk: u32 = 1024;
pub const DMA_IFCR_CHTIF3: u32 = 1024;
pub const DMA_IFCR_CTEIF3_Pos: u32 = 11;
pub const DMA_IFCR_CTEIF3_Msk: u32 = 2048;
pub const DMA_IFCR_CTEIF3: u32 = 2048;
pub const DMA_IFCR_CGIF4_Pos: u32 = 12;
pub const DMA_IFCR_CGIF4_Msk: u32 = 4096;
pub const DMA_IFCR_CGIF4: u32 = 4096;
pub const DMA_IFCR_CTCIF4_Pos: u32 = 13;
pub const DMA_IFCR_CTCIF4_Msk: u32 = 8192;
pub const DMA_IFCR_CTCIF4: u32 = 8192;
pub const DMA_IFCR_CHTIF4_Pos: u32 = 14;
pub const DMA_IFCR_CHTIF4_Msk: u32 = 16384;
pub const DMA_IFCR_CHTIF4: u32 = 16384;
pub const DMA_IFCR_CTEIF4_Pos: u32 = 15;
pub const DMA_IFCR_CTEIF4_Msk: u32 = 32768;
pub const DMA_IFCR_CTEIF4: u32 = 32768;
pub const DMA_IFCR_CGIF5_Pos: u32 = 16;
pub const DMA_IFCR_CGIF5_Msk: u32 = 65536;
pub const DMA_IFCR_CGIF5: u32 = 65536;
pub const DMA_IFCR_CTCIF5_Pos: u32 = 17;
pub const DMA_IFCR_CTCIF5_Msk: u32 = 131072;
pub const DMA_IFCR_CTCIF5: u32 = 131072;
pub const DMA_IFCR_CHTIF5_Pos: u32 = 18;
pub const DMA_IFCR_CHTIF5_Msk: u32 = 262144;
pub const DMA_IFCR_CHTIF5: u32 = 262144;
pub const DMA_IFCR_CTEIF5_Pos: u32 = 19;
pub const DMA_IFCR_CTEIF5_Msk: u32 = 524288;
pub const DMA_IFCR_CTEIF5: u32 = 524288;
pub const DMA_IFCR_CGIF6_Pos: u32 = 20;
pub const DMA_IFCR_CGIF6_Msk: u32 = 1048576;
pub const DMA_IFCR_CGIF6: u32 = 1048576;
pub const DMA_IFCR_CTCIF6_Pos: u32 = 21;
pub const DMA_IFCR_CTCIF6_Msk: u32 = 2097152;
pub const DMA_IFCR_CTCIF6: u32 = 2097152;
pub const DMA_IFCR_CHTIF6_Pos: u32 = 22;
pub const DMA_IFCR_CHTIF6_Msk: u32 = 4194304;
pub const DMA_IFCR_CHTIF6: u32 = 4194304;
pub const DMA_IFCR_CTEIF6_Pos: u32 = 23;
pub const DMA_IFCR_CTEIF6_Msk: u32 = 8388608;
pub const DMA_IFCR_CTEIF6: u32 = 8388608;
pub const DMA_IFCR_CGIF7_Pos: u32 = 24;
pub const DMA_IFCR_CGIF7_Msk: u32 = 16777216;
pub const DMA_IFCR_CGIF7: u32 = 16777216;
pub const DMA_IFCR_CTCIF7_Pos: u32 = 25;
pub const DMA_IFCR_CTCIF7_Msk: u32 = 33554432;
pub const DMA_IFCR_CTCIF7: u32 = 33554432;
pub const DMA_IFCR_CHTIF7_Pos: u32 = 26;
pub const DMA_IFCR_CHTIF7_Msk: u32 = 67108864;
pub const DMA_IFCR_CHTIF7: u32 = 67108864;
pub const DMA_IFCR_CTEIF7_Pos: u32 = 27;
pub const DMA_IFCR_CTEIF7_Msk: u32 = 134217728;
pub const DMA_IFCR_CTEIF7: u32 = 134217728;
pub const DMA_CCR_EN_Pos: u32 = 0;
pub const DMA_CCR_EN_Msk: u32 = 1;
pub const DMA_CCR_EN: u32 = 1;
pub const DMA_CCR_TCIE_Pos: u32 = 1;
pub const DMA_CCR_TCIE_Msk: u32 = 2;
pub const DMA_CCR_TCIE: u32 = 2;
pub const DMA_CCR_HTIE_Pos: u32 = 2;
pub const DMA_CCR_HTIE_Msk: u32 = 4;
pub const DMA_CCR_HTIE: u32 = 4;
pub const DMA_CCR_TEIE_Pos: u32 = 3;
pub const DMA_CCR_TEIE_Msk: u32 = 8;
pub const DMA_CCR_TEIE: u32 = 8;
pub const DMA_CCR_DIR_Pos: u32 = 4;
pub const DMA_CCR_DIR_Msk: u32 = 16;
pub const DMA_CCR_DIR: u32 = 16;
pub const DMA_CCR_CIRC_Pos: u32 = 5;
pub const DMA_CCR_CIRC_Msk: u32 = 32;
pub const DMA_CCR_CIRC: u32 = 32;
pub const DMA_CCR_PINC_Pos: u32 = 6;
pub const DMA_CCR_PINC_Msk: u32 = 64;
pub const DMA_CCR_PINC: u32 = 64;
pub const DMA_CCR_MINC_Pos: u32 = 7;
pub const DMA_CCR_MINC_Msk: u32 = 128;
pub const DMA_CCR_MINC: u32 = 128;
pub const DMA_CCR_PSIZE_Pos: u32 = 8;
pub const DMA_CCR_PSIZE_Msk: u32 = 768;
pub const DMA_CCR_PSIZE: u32 = 768;
pub const DMA_CCR_PSIZE_0: u32 = 256;
pub const DMA_CCR_PSIZE_1: u32 = 512;
pub const DMA_CCR_MSIZE_Pos: u32 = 10;
pub const DMA_CCR_MSIZE_Msk: u32 = 3072;
pub const DMA_CCR_MSIZE: u32 = 3072;
pub const DMA_CCR_MSIZE_0: u32 = 1024;
pub const DMA_CCR_MSIZE_1: u32 = 2048;
pub const DMA_CCR_PL_Pos: u32 = 12;
pub const DMA_CCR_PL_Msk: u32 = 12288;
pub const DMA_CCR_PL: u32 = 12288;
pub const DMA_CCR_PL_0: u32 = 4096;
pub const DMA_CCR_PL_1: u32 = 8192;
pub const DMA_CCR_MEM2MEM_Pos: u32 = 14;
pub const DMA_CCR_MEM2MEM_Msk: u32 = 16384;
pub const DMA_CCR_MEM2MEM: u32 = 16384;
pub const DMA_CNDTR_NDT_Pos: u32 = 0;
pub const DMA_CNDTR_NDT_Msk: u32 = 65535;
pub const DMA_CNDTR_NDT: u32 = 65535;
pub const DMA_CPAR_PA_Pos: u32 = 0;
pub const DMA_CPAR_PA_Msk: u32 = 4294967295;
pub const DMA_CPAR_PA: u32 = 4294967295;
pub const DMA_CMAR_MA_Pos: u32 = 0;
pub const DMA_CMAR_MA_Msk: u32 = 4294967295;
pub const DMA_CMAR_MA: u32 = 4294967295;
pub const DMA_CSELR_C1S_Pos: u32 = 0;
pub const DMA_CSELR_C1S_Msk: u32 = 15;
pub const DMA_CSELR_C1S: u32 = 15;
pub const DMA_CSELR_C2S_Pos: u32 = 4;
pub const DMA_CSELR_C2S_Msk: u32 = 240;
pub const DMA_CSELR_C2S: u32 = 240;
pub const DMA_CSELR_C3S_Pos: u32 = 8;
pub const DMA_CSELR_C3S_Msk: u32 = 3840;
pub const DMA_CSELR_C3S: u32 = 3840;
pub const DMA_CSELR_C4S_Pos: u32 = 12;
pub const DMA_CSELR_C4S_Msk: u32 = 61440;
pub const DMA_CSELR_C4S: u32 = 61440;
pub const DMA_CSELR_C5S_Pos: u32 = 16;
pub const DMA_CSELR_C5S_Msk: u32 = 983040;
pub const DMA_CSELR_C5S: u32 = 983040;
pub const DMA_CSELR_C6S_Pos: u32 = 20;
pub const DMA_CSELR_C6S_Msk: u32 = 15728640;
pub const DMA_CSELR_C6S: u32 = 15728640;
pub const DMA_CSELR_C7S_Pos: u32 = 24;
pub const DMA_CSELR_C7S_Msk: u32 = 251658240;
pub const DMA_CSELR_C7S: u32 = 251658240;
pub const EXTI_IMR1_IM0_Pos: u32 = 0;
pub const EXTI_IMR1_IM0_Msk: u32 = 1;
pub const EXTI_IMR1_IM0: u32 = 1;
pub const EXTI_IMR1_IM1_Pos: u32 = 1;
pub const EXTI_IMR1_IM1_Msk: u32 = 2;
pub const EXTI_IMR1_IM1: u32 = 2;
pub const EXTI_IMR1_IM2_Pos: u32 = 2;
pub const EXTI_IMR1_IM2_Msk: u32 = 4;
pub const EXTI_IMR1_IM2: u32 = 4;
pub const EXTI_IMR1_IM3_Pos: u32 = 3;
pub const EXTI_IMR1_IM3_Msk: u32 = 8;
pub const EXTI_IMR1_IM3: u32 = 8;
pub const EXTI_IMR1_IM4_Pos: u32 = 4;
pub const EXTI_IMR1_IM4_Msk: u32 = 16;
pub const EXTI_IMR1_IM4: u32 = 16;
pub const EXTI_IMR1_IM5_Pos: u32 = 5;
pub const EXTI_IMR1_IM5_Msk: u32 = 32;
pub const EXTI_IMR1_IM5: u32 = 32;
pub const EXTI_IMR1_IM6_Pos: u32 = 6;
pub const EXTI_IMR1_IM6_Msk: u32 = 64;
pub const EXTI_IMR1_IM6: u32 = 64;
pub const EXTI_IMR1_IM7_Pos: u32 = 7;
pub const EXTI_IMR1_IM7_Msk: u32 = 128;
pub const EXTI_IMR1_IM7: u32 = 128;
pub const EXTI_IMR1_IM8_Pos: u32 = 8;
pub const EXTI_IMR1_IM8_Msk: u32 = 256;
pub const EXTI_IMR1_IM8: u32 = 256;
pub const EXTI_IMR1_IM9_Pos: u32 = 9;
pub const EXTI_IMR1_IM9_Msk: u32 = 512;
pub const EXTI_IMR1_IM9: u32 = 512;
pub const EXTI_IMR1_IM10_Pos: u32 = 10;
pub const EXTI_IMR1_IM10_Msk: u32 = 1024;
pub const EXTI_IMR1_IM10: u32 = 1024;
pub const EXTI_IMR1_IM11_Pos: u32 = 11;
pub const EXTI_IMR1_IM11_Msk: u32 = 2048;
pub const EXTI_IMR1_IM11: u32 = 2048;
pub const EXTI_IMR1_IM12_Pos: u32 = 12;
pub const EXTI_IMR1_IM12_Msk: u32 = 4096;
pub const EXTI_IMR1_IM12: u32 = 4096;
pub const EXTI_IMR1_IM13_Pos: u32 = 13;
pub const EXTI_IMR1_IM13_Msk: u32 = 8192;
pub const EXTI_IMR1_IM13: u32 = 8192;
pub const EXTI_IMR1_IM14_Pos: u32 = 14;
pub const EXTI_IMR1_IM14_Msk: u32 = 16384;
pub const EXTI_IMR1_IM14: u32 = 16384;
pub const EXTI_IMR1_IM15_Pos: u32 = 15;
pub const EXTI_IMR1_IM15_Msk: u32 = 32768;
pub const EXTI_IMR1_IM15: u32 = 32768;
pub const EXTI_IMR1_IM16_Pos: u32 = 16;
pub const EXTI_IMR1_IM16_Msk: u32 = 65536;
pub const EXTI_IMR1_IM16: u32 = 65536;
pub const EXTI_IMR1_IM17_Pos: u32 = 17;
pub const EXTI_IMR1_IM17_Msk: u32 = 131072;
pub const EXTI_IMR1_IM17: u32 = 131072;
pub const EXTI_IMR1_IM18_Pos: u32 = 18;
pub const EXTI_IMR1_IM18_Msk: u32 = 262144;
pub const EXTI_IMR1_IM18: u32 = 262144;
pub const EXTI_IMR1_IM19_Pos: u32 = 19;
pub const EXTI_IMR1_IM19_Msk: u32 = 524288;
pub const EXTI_IMR1_IM19: u32 = 524288;
pub const EXTI_IMR1_IM20_Pos: u32 = 20;
pub const EXTI_IMR1_IM20_Msk: u32 = 1048576;
pub const EXTI_IMR1_IM20: u32 = 1048576;
pub const EXTI_IMR1_IM21_Pos: u32 = 21;
pub const EXTI_IMR1_IM21_Msk: u32 = 2097152;
pub const EXTI_IMR1_IM21: u32 = 2097152;
pub const EXTI_IMR1_IM22_Pos: u32 = 22;
pub const EXTI_IMR1_IM22_Msk: u32 = 4194304;
pub const EXTI_IMR1_IM22: u32 = 4194304;
pub const EXTI_IMR1_IM23_Pos: u32 = 23;
pub const EXTI_IMR1_IM23_Msk: u32 = 8388608;
pub const EXTI_IMR1_IM23: u32 = 8388608;
pub const EXTI_IMR1_IM24_Pos: u32 = 24;
pub const EXTI_IMR1_IM24_Msk: u32 = 16777216;
pub const EXTI_IMR1_IM24: u32 = 16777216;
pub const EXTI_IMR1_IM25_Pos: u32 = 25;
pub const EXTI_IMR1_IM25_Msk: u32 = 33554432;
pub const EXTI_IMR1_IM25: u32 = 33554432;
pub const EXTI_IMR1_IM26_Pos: u32 = 26;
pub const EXTI_IMR1_IM26_Msk: u32 = 67108864;
pub const EXTI_IMR1_IM26: u32 = 67108864;
pub const EXTI_IMR1_IM27_Pos: u32 = 27;
pub const EXTI_IMR1_IM27_Msk: u32 = 134217728;
pub const EXTI_IMR1_IM27: u32 = 134217728;
pub const EXTI_IMR1_IM28_Pos: u32 = 28;
pub const EXTI_IMR1_IM28_Msk: u32 = 268435456;
pub const EXTI_IMR1_IM28: u32 = 268435456;
pub const EXTI_IMR1_IM29_Pos: u32 = 29;
pub const EXTI_IMR1_IM29_Msk: u32 = 536870912;
pub const EXTI_IMR1_IM29: u32 = 536870912;
pub const EXTI_IMR1_IM30_Pos: u32 = 30;
pub const EXTI_IMR1_IM30_Msk: u32 = 1073741824;
pub const EXTI_IMR1_IM30: u32 = 1073741824;
pub const EXTI_IMR1_IM31_Pos: u32 = 31;
pub const EXTI_IMR1_IM31_Msk: u32 = 2147483648;
pub const EXTI_IMR1_IM31: u32 = 2147483648;
pub const EXTI_IMR1_IM_Pos: u32 = 0;
pub const EXTI_IMR1_IM_Msk: u32 = 4294967295;
pub const EXTI_IMR1_IM: u32 = 4294967295;
pub const EXTI_EMR1_EM0_Pos: u32 = 0;
pub const EXTI_EMR1_EM0_Msk: u32 = 1;
pub const EXTI_EMR1_EM0: u32 = 1;
pub const EXTI_EMR1_EM1_Pos: u32 = 1;
pub const EXTI_EMR1_EM1_Msk: u32 = 2;
pub const EXTI_EMR1_EM1: u32 = 2;
pub const EXTI_EMR1_EM2_Pos: u32 = 2;
pub const EXTI_EMR1_EM2_Msk: u32 = 4;
pub const EXTI_EMR1_EM2: u32 = 4;
pub const EXTI_EMR1_EM3_Pos: u32 = 3;
pub const EXTI_EMR1_EM3_Msk: u32 = 8;
pub const EXTI_EMR1_EM3: u32 = 8;
pub const EXTI_EMR1_EM4_Pos: u32 = 4;
pub const EXTI_EMR1_EM4_Msk: u32 = 16;
pub const EXTI_EMR1_EM4: u32 = 16;
pub const EXTI_EMR1_EM5_Pos: u32 = 5;
pub const EXTI_EMR1_EM5_Msk: u32 = 32;
pub const EXTI_EMR1_EM5: u32 = 32;
pub const EXTI_EMR1_EM6_Pos: u32 = 6;
pub const EXTI_EMR1_EM6_Msk: u32 = 64;
pub const EXTI_EMR1_EM6: u32 = 64;
pub const EXTI_EMR1_EM7_Pos: u32 = 7;
pub const EXTI_EMR1_EM7_Msk: u32 = 128;
pub const EXTI_EMR1_EM7: u32 = 128;
pub const EXTI_EMR1_EM8_Pos: u32 = 8;
pub const EXTI_EMR1_EM8_Msk: u32 = 256;
pub const EXTI_EMR1_EM8: u32 = 256;
pub const EXTI_EMR1_EM9_Pos: u32 = 9;
pub const EXTI_EMR1_EM9_Msk: u32 = 512;
pub const EXTI_EMR1_EM9: u32 = 512;
pub const EXTI_EMR1_EM10_Pos: u32 = 10;
pub const EXTI_EMR1_EM10_Msk: u32 = 1024;
pub const EXTI_EMR1_EM10: u32 = 1024;
pub const EXTI_EMR1_EM11_Pos: u32 = 11;
pub const EXTI_EMR1_EM11_Msk: u32 = 2048;
pub const EXTI_EMR1_EM11: u32 = 2048;
pub const EXTI_EMR1_EM12_Pos: u32 = 12;
pub const EXTI_EMR1_EM12_Msk: u32 = 4096;
pub const EXTI_EMR1_EM12: u32 = 4096;
pub const EXTI_EMR1_EM13_Pos: u32 = 13;
pub const EXTI_EMR1_EM13_Msk: u32 = 8192;
pub const EXTI_EMR1_EM13: u32 = 8192;
pub const EXTI_EMR1_EM14_Pos: u32 = 14;
pub const EXTI_EMR1_EM14_Msk: u32 = 16384;
pub const EXTI_EMR1_EM14: u32 = 16384;
pub const EXTI_EMR1_EM15_Pos: u32 = 15;
pub const EXTI_EMR1_EM15_Msk: u32 = 32768;
pub const EXTI_EMR1_EM15: u32 = 32768;
pub const EXTI_EMR1_EM16_Pos: u32 = 16;
pub const EXTI_EMR1_EM16_Msk: u32 = 65536;
pub const EXTI_EMR1_EM16: u32 = 65536;
pub const EXTI_EMR1_EM17_Pos: u32 = 17;
pub const EXTI_EMR1_EM17_Msk: u32 = 131072;
pub const EXTI_EMR1_EM17: u32 = 131072;
pub const EXTI_EMR1_EM18_Pos: u32 = 18;
pub const EXTI_EMR1_EM18_Msk: u32 = 262144;
pub const EXTI_EMR1_EM18: u32 = 262144;
pub const EXTI_EMR1_EM19_Pos: u32 = 19;
pub const EXTI_EMR1_EM19_Msk: u32 = 524288;
pub const EXTI_EMR1_EM19: u32 = 524288;
pub const EXTI_EMR1_EM20_Pos: u32 = 20;
pub const EXTI_EMR1_EM20_Msk: u32 = 1048576;
pub const EXTI_EMR1_EM20: u32 = 1048576;
pub const EXTI_EMR1_EM21_Pos: u32 = 21;
pub const EXTI_EMR1_EM21_Msk: u32 = 2097152;
pub const EXTI_EMR1_EM21: u32 = 2097152;
pub const EXTI_EMR1_EM22_Pos: u32 = 22;
pub const EXTI_EMR1_EM22_Msk: u32 = 4194304;
pub const EXTI_EMR1_EM22: u32 = 4194304;
pub const EXTI_EMR1_EM23_Pos: u32 = 23;
pub const EXTI_EMR1_EM23_Msk: u32 = 8388608;
pub const EXTI_EMR1_EM23: u32 = 8388608;
pub const EXTI_EMR1_EM24_Pos: u32 = 24;
pub const EXTI_EMR1_EM24_Msk: u32 = 16777216;
pub const EXTI_EMR1_EM24: u32 = 16777216;
pub const EXTI_EMR1_EM25_Pos: u32 = 25;
pub const EXTI_EMR1_EM25_Msk: u32 = 33554432;
pub const EXTI_EMR1_EM25: u32 = 33554432;
pub const EXTI_EMR1_EM26_Pos: u32 = 26;
pub const EXTI_EMR1_EM26_Msk: u32 = 67108864;
pub const EXTI_EMR1_EM26: u32 = 67108864;
pub const EXTI_EMR1_EM27_Pos: u32 = 27;
pub const EXTI_EMR1_EM27_Msk: u32 = 134217728;
pub const EXTI_EMR1_EM27: u32 = 134217728;
pub const EXTI_EMR1_EM28_Pos: u32 = 28;
pub const EXTI_EMR1_EM28_Msk: u32 = 268435456;
pub const EXTI_EMR1_EM28: u32 = 268435456;
pub const EXTI_EMR1_EM29_Pos: u32 = 29;
pub const EXTI_EMR1_EM29_Msk: u32 = 536870912;
pub const EXTI_EMR1_EM29: u32 = 536870912;
pub const EXTI_EMR1_EM30_Pos: u32 = 30;
pub const EXTI_EMR1_EM30_Msk: u32 = 1073741824;
pub const EXTI_EMR1_EM30: u32 = 1073741824;
pub const EXTI_EMR1_EM31_Pos: u32 = 31;
pub const EXTI_EMR1_EM31_Msk: u32 = 2147483648;
pub const EXTI_EMR1_EM31: u32 = 2147483648;
pub const EXTI_RTSR1_RT0_Pos: u32 = 0;
pub const EXTI_RTSR1_RT0_Msk: u32 = 1;
pub const EXTI_RTSR1_RT0: u32 = 1;
pub const EXTI_RTSR1_RT1_Pos: u32 = 1;
pub const EXTI_RTSR1_RT1_Msk: u32 = 2;
pub const EXTI_RTSR1_RT1: u32 = 2;
pub const EXTI_RTSR1_RT2_Pos: u32 = 2;
pub const EXTI_RTSR1_RT2_Msk: u32 = 4;
pub const EXTI_RTSR1_RT2: u32 = 4;
pub const EXTI_RTSR1_RT3_Pos: u32 = 3;
pub const EXTI_RTSR1_RT3_Msk: u32 = 8;
pub const EXTI_RTSR1_RT3: u32 = 8;
pub const EXTI_RTSR1_RT4_Pos: u32 = 4;
pub const EXTI_RTSR1_RT4_Msk: u32 = 16;
pub const EXTI_RTSR1_RT4: u32 = 16;
pub const EXTI_RTSR1_RT5_Pos: u32 = 5;
pub const EXTI_RTSR1_RT5_Msk: u32 = 32;
pub const EXTI_RTSR1_RT5: u32 = 32;
pub const EXTI_RTSR1_RT6_Pos: u32 = 6;
pub const EXTI_RTSR1_RT6_Msk: u32 = 64;
pub const EXTI_RTSR1_RT6: u32 = 64;
pub const EXTI_RTSR1_RT7_Pos: u32 = 7;
pub const EXTI_RTSR1_RT7_Msk: u32 = 128;
pub const EXTI_RTSR1_RT7: u32 = 128;
pub const EXTI_RTSR1_RT8_Pos: u32 = 8;
pub const EXTI_RTSR1_RT8_Msk: u32 = 256;
pub const EXTI_RTSR1_RT8: u32 = 256;
pub const EXTI_RTSR1_RT9_Pos: u32 = 9;
pub const EXTI_RTSR1_RT9_Msk: u32 = 512;
pub const EXTI_RTSR1_RT9: u32 = 512;
pub const EXTI_RTSR1_RT10_Pos: u32 = 10;
pub const EXTI_RTSR1_RT10_Msk: u32 = 1024;
pub const EXTI_RTSR1_RT10: u32 = 1024;
pub const EXTI_RTSR1_RT11_Pos: u32 = 11;
pub const EXTI_RTSR1_RT11_Msk: u32 = 2048;
pub const EXTI_RTSR1_RT11: u32 = 2048;
pub const EXTI_RTSR1_RT12_Pos: u32 = 12;
pub const EXTI_RTSR1_RT12_Msk: u32 = 4096;
pub const EXTI_RTSR1_RT12: u32 = 4096;
pub const EXTI_RTSR1_RT13_Pos: u32 = 13;
pub const EXTI_RTSR1_RT13_Msk: u32 = 8192;
pub const EXTI_RTSR1_RT13: u32 = 8192;
pub const EXTI_RTSR1_RT14_Pos: u32 = 14;
pub const EXTI_RTSR1_RT14_Msk: u32 = 16384;
pub const EXTI_RTSR1_RT14: u32 = 16384;
pub const EXTI_RTSR1_RT15_Pos: u32 = 15;
pub const EXTI_RTSR1_RT15_Msk: u32 = 32768;
pub const EXTI_RTSR1_RT15: u32 = 32768;
pub const EXTI_RTSR1_RT16_Pos: u32 = 16;
pub const EXTI_RTSR1_RT16_Msk: u32 = 65536;
pub const EXTI_RTSR1_RT16: u32 = 65536;
pub const EXTI_RTSR1_RT18_Pos: u32 = 18;
pub const EXTI_RTSR1_RT18_Msk: u32 = 262144;
pub const EXTI_RTSR1_RT18: u32 = 262144;
pub const EXTI_RTSR1_RT19_Pos: u32 = 19;
pub const EXTI_RTSR1_RT19_Msk: u32 = 524288;
pub const EXTI_RTSR1_RT19: u32 = 524288;
pub const EXTI_RTSR1_RT20_Pos: u32 = 20;
pub const EXTI_RTSR1_RT20_Msk: u32 = 1048576;
pub const EXTI_RTSR1_RT20: u32 = 1048576;
pub const EXTI_RTSR1_RT21_Pos: u32 = 21;
pub const EXTI_RTSR1_RT21_Msk: u32 = 2097152;
pub const EXTI_RTSR1_RT21: u32 = 2097152;
pub const EXTI_RTSR1_RT22_Pos: u32 = 22;
pub const EXTI_RTSR1_RT22_Msk: u32 = 4194304;
pub const EXTI_RTSR1_RT22: u32 = 4194304;
pub const EXTI_FTSR1_FT0_Pos: u32 = 0;
pub const EXTI_FTSR1_FT0_Msk: u32 = 1;
pub const EXTI_FTSR1_FT0: u32 = 1;
pub const EXTI_FTSR1_FT1_Pos: u32 = 1;
pub const EXTI_FTSR1_FT1_Msk: u32 = 2;
pub const EXTI_FTSR1_FT1: u32 = 2;
pub const EXTI_FTSR1_FT2_Pos: u32 = 2;
pub const EXTI_FTSR1_FT2_Msk: u32 = 4;
pub const EXTI_FTSR1_FT2: u32 = 4;
pub const EXTI_FTSR1_FT3_Pos: u32 = 3;
pub const EXTI_FTSR1_FT3_Msk: u32 = 8;
pub const EXTI_FTSR1_FT3: u32 = 8;
pub const EXTI_FTSR1_FT4_Pos: u32 = 4;
pub const EXTI_FTSR1_FT4_Msk: u32 = 16;
pub const EXTI_FTSR1_FT4: u32 = 16;
pub const EXTI_FTSR1_FT5_Pos: u32 = 5;
pub const EXTI_FTSR1_FT5_Msk: u32 = 32;
pub const EXTI_FTSR1_FT5: u32 = 32;
pub const EXTI_FTSR1_FT6_Pos: u32 = 6;
pub const EXTI_FTSR1_FT6_Msk: u32 = 64;
pub const EXTI_FTSR1_FT6: u32 = 64;
pub const EXTI_FTSR1_FT7_Pos: u32 = 7;
pub const EXTI_FTSR1_FT7_Msk: u32 = 128;
pub const EXTI_FTSR1_FT7: u32 = 128;
pub const EXTI_FTSR1_FT8_Pos: u32 = 8;
pub const EXTI_FTSR1_FT8_Msk: u32 = 256;
pub const EXTI_FTSR1_FT8: u32 = 256;
pub const EXTI_FTSR1_FT9_Pos: u32 = 9;
pub const EXTI_FTSR1_FT9_Msk: u32 = 512;
pub const EXTI_FTSR1_FT9: u32 = 512;
pub const EXTI_FTSR1_FT10_Pos: u32 = 10;
pub const EXTI_FTSR1_FT10_Msk: u32 = 1024;
pub const EXTI_FTSR1_FT10: u32 = 1024;
pub const EXTI_FTSR1_FT11_Pos: u32 = 11;
pub const EXTI_FTSR1_FT11_Msk: u32 = 2048;
pub const EXTI_FTSR1_FT11: u32 = 2048;
pub const EXTI_FTSR1_FT12_Pos: u32 = 12;
pub const EXTI_FTSR1_FT12_Msk: u32 = 4096;
pub const EXTI_FTSR1_FT12: u32 = 4096;
pub const EXTI_FTSR1_FT13_Pos: u32 = 13;
pub const EXTI_FTSR1_FT13_Msk: u32 = 8192;
pub const EXTI_FTSR1_FT13: u32 = 8192;
pub const EXTI_FTSR1_FT14_Pos: u32 = 14;
pub const EXTI_FTSR1_FT14_Msk: u32 = 16384;
pub const EXTI_FTSR1_FT14: u32 = 16384;
pub const EXTI_FTSR1_FT15_Pos: u32 = 15;
pub const EXTI_FTSR1_FT15_Msk: u32 = 32768;
pub const EXTI_FTSR1_FT15: u32 = 32768;
pub const EXTI_FTSR1_FT16_Pos: u32 = 16;
pub const EXTI_FTSR1_FT16_Msk: u32 = 65536;
pub const EXTI_FTSR1_FT16: u32 = 65536;
pub const EXTI_FTSR1_FT18_Pos: u32 = 18;
pub const EXTI_FTSR1_FT18_Msk: u32 = 262144;
pub const EXTI_FTSR1_FT18: u32 = 262144;
pub const EXTI_FTSR1_FT19_Pos: u32 = 19;
pub const EXTI_FTSR1_FT19_Msk: u32 = 524288;
pub const EXTI_FTSR1_FT19: u32 = 524288;
pub const EXTI_FTSR1_FT20_Pos: u32 = 20;
pub const EXTI_FTSR1_FT20_Msk: u32 = 1048576;
pub const EXTI_FTSR1_FT20: u32 = 1048576;
pub const EXTI_FTSR1_FT21_Pos: u32 = 21;
pub const EXTI_FTSR1_FT21_Msk: u32 = 2097152;
pub const EXTI_FTSR1_FT21: u32 = 2097152;
pub const EXTI_FTSR1_FT22_Pos: u32 = 22;
pub const EXTI_FTSR1_FT22_Msk: u32 = 4194304;
pub const EXTI_FTSR1_FT22: u32 = 4194304;
pub const EXTI_SWIER1_SWI0_Pos: u32 = 0;
pub const EXTI_SWIER1_SWI0_Msk: u32 = 1;
pub const EXTI_SWIER1_SWI0: u32 = 1;
pub const EXTI_SWIER1_SWI1_Pos: u32 = 1;
pub const EXTI_SWIER1_SWI1_Msk: u32 = 2;
pub const EXTI_SWIER1_SWI1: u32 = 2;
pub const EXTI_SWIER1_SWI2_Pos: u32 = 2;
pub const EXTI_SWIER1_SWI2_Msk: u32 = 4;
pub const EXTI_SWIER1_SWI2: u32 = 4;
pub const EXTI_SWIER1_SWI3_Pos: u32 = 3;
pub const EXTI_SWIER1_SWI3_Msk: u32 = 8;
pub const EXTI_SWIER1_SWI3: u32 = 8;
pub const EXTI_SWIER1_SWI4_Pos: u32 = 4;
pub const EXTI_SWIER1_SWI4_Msk: u32 = 16;
pub const EXTI_SWIER1_SWI4: u32 = 16;
pub const EXTI_SWIER1_SWI5_Pos: u32 = 5;
pub const EXTI_SWIER1_SWI5_Msk: u32 = 32;
pub const EXTI_SWIER1_SWI5: u32 = 32;
pub const EXTI_SWIER1_SWI6_Pos: u32 = 6;
pub const EXTI_SWIER1_SWI6_Msk: u32 = 64;
pub const EXTI_SWIER1_SWI6: u32 = 64;
pub const EXTI_SWIER1_SWI7_Pos: u32 = 7;
pub const EXTI_SWIER1_SWI7_Msk: u32 = 128;
pub const EXTI_SWIER1_SWI7: u32 = 128;
pub const EXTI_SWIER1_SWI8_Pos: u32 = 8;
pub const EXTI_SWIER1_SWI8_Msk: u32 = 256;
pub const EXTI_SWIER1_SWI8: u32 = 256;
pub const EXTI_SWIER1_SWI9_Pos: u32 = 9;
pub const EXTI_SWIER1_SWI9_Msk: u32 = 512;
pub const EXTI_SWIER1_SWI9: u32 = 512;
pub const EXTI_SWIER1_SWI10_Pos: u32 = 10;
pub const EXTI_SWIER1_SWI10_Msk: u32 = 1024;
pub const EXTI_SWIER1_SWI10: u32 = 1024;
pub const EXTI_SWIER1_SWI11_Pos: u32 = 11;
pub const EXTI_SWIER1_SWI11_Msk: u32 = 2048;
pub const EXTI_SWIER1_SWI11: u32 = 2048;
pub const EXTI_SWIER1_SWI12_Pos: u32 = 12;
pub const EXTI_SWIER1_SWI12_Msk: u32 = 4096;
pub const EXTI_SWIER1_SWI12: u32 = 4096;
pub const EXTI_SWIER1_SWI13_Pos: u32 = 13;
pub const EXTI_SWIER1_SWI13_Msk: u32 = 8192;
pub const EXTI_SWIER1_SWI13: u32 = 8192;
pub const EXTI_SWIER1_SWI14_Pos: u32 = 14;
pub const EXTI_SWIER1_SWI14_Msk: u32 = 16384;
pub const EXTI_SWIER1_SWI14: u32 = 16384;
pub const EXTI_SWIER1_SWI15_Pos: u32 = 15;
pub const EXTI_SWIER1_SWI15_Msk: u32 = 32768;
pub const EXTI_SWIER1_SWI15: u32 = 32768;
pub const EXTI_SWIER1_SWI16_Pos: u32 = 16;
pub const EXTI_SWIER1_SWI16_Msk: u32 = 65536;
pub const EXTI_SWIER1_SWI16: u32 = 65536;
pub const EXTI_SWIER1_SWI18_Pos: u32 = 18;
pub const EXTI_SWIER1_SWI18_Msk: u32 = 262144;
pub const EXTI_SWIER1_SWI18: u32 = 262144;
pub const EXTI_SWIER1_SWI19_Pos: u32 = 19;
pub const EXTI_SWIER1_SWI19_Msk: u32 = 524288;
pub const EXTI_SWIER1_SWI19: u32 = 524288;
pub const EXTI_SWIER1_SWI20_Pos: u32 = 20;
pub const EXTI_SWIER1_SWI20_Msk: u32 = 1048576;
pub const EXTI_SWIER1_SWI20: u32 = 1048576;
pub const EXTI_SWIER1_SWI21_Pos: u32 = 21;
pub const EXTI_SWIER1_SWI21_Msk: u32 = 2097152;
pub const EXTI_SWIER1_SWI21: u32 = 2097152;
pub const EXTI_SWIER1_SWI22_Pos: u32 = 22;
pub const EXTI_SWIER1_SWI22_Msk: u32 = 4194304;
pub const EXTI_SWIER1_SWI22: u32 = 4194304;
pub const EXTI_PR1_PIF0_Pos: u32 = 0;
pub const EXTI_PR1_PIF0_Msk: u32 = 1;
pub const EXTI_PR1_PIF0: u32 = 1;
pub const EXTI_PR1_PIF1_Pos: u32 = 1;
pub const EXTI_PR1_PIF1_Msk: u32 = 2;
pub const EXTI_PR1_PIF1: u32 = 2;
pub const EXTI_PR1_PIF2_Pos: u32 = 2;
pub const EXTI_PR1_PIF2_Msk: u32 = 4;
pub const EXTI_PR1_PIF2: u32 = 4;
pub const EXTI_PR1_PIF3_Pos: u32 = 3;
pub const EXTI_PR1_PIF3_Msk: u32 = 8;
pub const EXTI_PR1_PIF3: u32 = 8;
pub const EXTI_PR1_PIF4_Pos: u32 = 4;
pub const EXTI_PR1_PIF4_Msk: u32 = 16;
pub const EXTI_PR1_PIF4: u32 = 16;
pub const EXTI_PR1_PIF5_Pos: u32 = 5;
pub const EXTI_PR1_PIF5_Msk: u32 = 32;
pub const EXTI_PR1_PIF5: u32 = 32;
pub const EXTI_PR1_PIF6_Pos: u32 = 6;
pub const EXTI_PR1_PIF6_Msk: u32 = 64;
pub const EXTI_PR1_PIF6: u32 = 64;
pub const EXTI_PR1_PIF7_Pos: u32 = 7;
pub const EXTI_PR1_PIF7_Msk: u32 = 128;
pub const EXTI_PR1_PIF7: u32 = 128;
pub const EXTI_PR1_PIF8_Pos: u32 = 8;
pub const EXTI_PR1_PIF8_Msk: u32 = 256;
pub const EXTI_PR1_PIF8: u32 = 256;
pub const EXTI_PR1_PIF9_Pos: u32 = 9;
pub const EXTI_PR1_PIF9_Msk: u32 = 512;
pub const EXTI_PR1_PIF9: u32 = 512;
pub const EXTI_PR1_PIF10_Pos: u32 = 10;
pub const EXTI_PR1_PIF10_Msk: u32 = 1024;
pub const EXTI_PR1_PIF10: u32 = 1024;
pub const EXTI_PR1_PIF11_Pos: u32 = 11;
pub const EXTI_PR1_PIF11_Msk: u32 = 2048;
pub const EXTI_PR1_PIF11: u32 = 2048;
pub const EXTI_PR1_PIF12_Pos: u32 = 12;
pub const EXTI_PR1_PIF12_Msk: u32 = 4096;
pub const EXTI_PR1_PIF12: u32 = 4096;
pub const EXTI_PR1_PIF13_Pos: u32 = 13;
pub const EXTI_PR1_PIF13_Msk: u32 = 8192;
pub const EXTI_PR1_PIF13: u32 = 8192;
pub const EXTI_PR1_PIF14_Pos: u32 = 14;
pub const EXTI_PR1_PIF14_Msk: u32 = 16384;
pub const EXTI_PR1_PIF14: u32 = 16384;
pub const EXTI_PR1_PIF15_Pos: u32 = 15;
pub const EXTI_PR1_PIF15_Msk: u32 = 32768;
pub const EXTI_PR1_PIF15: u32 = 32768;
pub const EXTI_PR1_PIF16_Pos: u32 = 16;
pub const EXTI_PR1_PIF16_Msk: u32 = 65536;
pub const EXTI_PR1_PIF16: u32 = 65536;
pub const EXTI_PR1_PIF18_Pos: u32 = 18;
pub const EXTI_PR1_PIF18_Msk: u32 = 262144;
pub const EXTI_PR1_PIF18: u32 = 262144;
pub const EXTI_PR1_PIF19_Pos: u32 = 19;
pub const EXTI_PR1_PIF19_Msk: u32 = 524288;
pub const EXTI_PR1_PIF19: u32 = 524288;
pub const EXTI_PR1_PIF20_Pos: u32 = 20;
pub const EXTI_PR1_PIF20_Msk: u32 = 1048576;
pub const EXTI_PR1_PIF20: u32 = 1048576;
pub const EXTI_PR1_PIF21_Pos: u32 = 21;
pub const EXTI_PR1_PIF21_Msk: u32 = 2097152;
pub const EXTI_PR1_PIF21: u32 = 2097152;
pub const EXTI_PR1_PIF22_Pos: u32 = 22;
pub const EXTI_PR1_PIF22_Msk: u32 = 4194304;
pub const EXTI_PR1_PIF22: u32 = 4194304;
pub const EXTI_IMR2_IM32_Pos: u32 = 0;
pub const EXTI_IMR2_IM32_Msk: u32 = 1;
pub const EXTI_IMR2_IM32: u32 = 1;
pub const EXTI_IMR2_IM33_Pos: u32 = 1;
pub const EXTI_IMR2_IM33_Msk: u32 = 2;
pub const EXTI_IMR2_IM33: u32 = 2;
pub const EXTI_IMR2_IM34_Pos: u32 = 2;
pub const EXTI_IMR2_IM34_Msk: u32 = 4;
pub const EXTI_IMR2_IM34: u32 = 4;
pub const EXTI_IMR2_IM35_Pos: u32 = 3;
pub const EXTI_IMR2_IM35_Msk: u32 = 8;
pub const EXTI_IMR2_IM35: u32 = 8;
pub const EXTI_IMR2_IM36_Pos: u32 = 4;
pub const EXTI_IMR2_IM36_Msk: u32 = 16;
pub const EXTI_IMR2_IM36: u32 = 16;
pub const EXTI_IMR2_IM37_Pos: u32 = 5;
pub const EXTI_IMR2_IM37_Msk: u32 = 32;
pub const EXTI_IMR2_IM37: u32 = 32;
pub const EXTI_IMR2_IM38_Pos: u32 = 6;
pub const EXTI_IMR2_IM38_Msk: u32 = 64;
pub const EXTI_IMR2_IM38: u32 = 64;
pub const EXTI_IMR2_IM_Pos: u32 = 0;
pub const EXTI_IMR2_IM_Msk: u32 = 127;
pub const EXTI_IMR2_IM: u32 = 127;
pub const EXTI_EMR2_EM32_Pos: u32 = 0;
pub const EXTI_EMR2_EM32_Msk: u32 = 1;
pub const EXTI_EMR2_EM32: u32 = 1;
pub const EXTI_EMR2_EM33_Pos: u32 = 1;
pub const EXTI_EMR2_EM33_Msk: u32 = 2;
pub const EXTI_EMR2_EM33: u32 = 2;
pub const EXTI_EMR2_EM34_Pos: u32 = 2;
pub const EXTI_EMR2_EM34_Msk: u32 = 4;
pub const EXTI_EMR2_EM34: u32 = 4;
pub const EXTI_EMR2_EM35_Pos: u32 = 3;
pub const EXTI_EMR2_EM35_Msk: u32 = 8;
pub const EXTI_EMR2_EM35: u32 = 8;
pub const EXTI_EMR2_EM36_Pos: u32 = 4;
pub const EXTI_EMR2_EM36_Msk: u32 = 16;
pub const EXTI_EMR2_EM36: u32 = 16;
pub const EXTI_EMR2_EM37_Pos: u32 = 5;
pub const EXTI_EMR2_EM37_Msk: u32 = 32;
pub const EXTI_EMR2_EM37: u32 = 32;
pub const EXTI_EMR2_EM38_Pos: u32 = 6;
pub const EXTI_EMR2_EM38_Msk: u32 = 64;
pub const EXTI_EMR2_EM38: u32 = 64;
pub const EXTI_EMR2_EM_Pos: u32 = 0;
pub const EXTI_EMR2_EM_Msk: u32 = 127;
pub const EXTI_EMR2_EM: u32 = 127;
pub const EXTI_RTSR2_RT35_Pos: u32 = 3;
pub const EXTI_RTSR2_RT35_Msk: u32 = 8;
pub const EXTI_RTSR2_RT35: u32 = 8;
pub const EXTI_RTSR2_RT36_Pos: u32 = 4;
pub const EXTI_RTSR2_RT36_Msk: u32 = 16;
pub const EXTI_RTSR2_RT36: u32 = 16;
pub const EXTI_RTSR2_RT37_Pos: u32 = 5;
pub const EXTI_RTSR2_RT37_Msk: u32 = 32;
pub const EXTI_RTSR2_RT37: u32 = 32;
pub const EXTI_RTSR2_RT38_Pos: u32 = 6;
pub const EXTI_RTSR2_RT38_Msk: u32 = 64;
pub const EXTI_RTSR2_RT38: u32 = 64;
pub const EXTI_FTSR2_FT35_Pos: u32 = 3;
pub const EXTI_FTSR2_FT35_Msk: u32 = 8;
pub const EXTI_FTSR2_FT35: u32 = 8;
pub const EXTI_FTSR2_FT36_Pos: u32 = 4;
pub const EXTI_FTSR2_FT36_Msk: u32 = 16;
pub const EXTI_FTSR2_FT36: u32 = 16;
pub const EXTI_FTSR2_FT37_Pos: u32 = 5;
pub const EXTI_FTSR2_FT37_Msk: u32 = 32;
pub const EXTI_FTSR2_FT37: u32 = 32;
pub const EXTI_FTSR2_FT38_Pos: u32 = 6;
pub const EXTI_FTSR2_FT38_Msk: u32 = 64;
pub const EXTI_FTSR2_FT38: u32 = 64;
pub const EXTI_SWIER2_SWI35_Pos: u32 = 3;
pub const EXTI_SWIER2_SWI35_Msk: u32 = 8;
pub const EXTI_SWIER2_SWI35: u32 = 8;
pub const EXTI_SWIER2_SWI36_Pos: u32 = 4;
pub const EXTI_SWIER2_SWI36_Msk: u32 = 16;
pub const EXTI_SWIER2_SWI36: u32 = 16;
pub const EXTI_SWIER2_SWI37_Pos: u32 = 5;
pub const EXTI_SWIER2_SWI37_Msk: u32 = 32;
pub const EXTI_SWIER2_SWI37: u32 = 32;
pub const EXTI_SWIER2_SWI38_Pos: u32 = 6;
pub const EXTI_SWIER2_SWI38_Msk: u32 = 64;
pub const EXTI_SWIER2_SWI38: u32 = 64;
pub const EXTI_PR2_PIF35_Pos: u32 = 3;
pub const EXTI_PR2_PIF35_Msk: u32 = 8;
pub const EXTI_PR2_PIF35: u32 = 8;
pub const EXTI_PR2_PIF36_Pos: u32 = 4;
pub const EXTI_PR2_PIF36_Msk: u32 = 16;
pub const EXTI_PR2_PIF36: u32 = 16;
pub const EXTI_PR2_PIF37_Pos: u32 = 5;
pub const EXTI_PR2_PIF37_Msk: u32 = 32;
pub const EXTI_PR2_PIF37: u32 = 32;
pub const EXTI_PR2_PIF38_Pos: u32 = 6;
pub const EXTI_PR2_PIF38_Msk: u32 = 64;
pub const EXTI_PR2_PIF38: u32 = 64;
pub const FLASH_ACR_LATENCY_Pos: u32 = 0;
pub const FLASH_ACR_LATENCY_Msk: u32 = 7;
pub const FLASH_ACR_LATENCY: u32 = 7;
pub const FLASH_ACR_LATENCY_0WS: u32 = 0;
pub const FLASH_ACR_LATENCY_1WS: u32 = 1;
pub const FLASH_ACR_LATENCY_2WS: u32 = 2;
pub const FLASH_ACR_LATENCY_3WS: u32 = 3;
pub const FLASH_ACR_LATENCY_4WS: u32 = 4;
pub const FLASH_ACR_PRFTEN_Pos: u32 = 8;
pub const FLASH_ACR_PRFTEN_Msk: u32 = 256;
pub const FLASH_ACR_PRFTEN: u32 = 256;
pub const FLASH_ACR_ICEN_Pos: u32 = 9;
pub const FLASH_ACR_ICEN_Msk: u32 = 512;
pub const FLASH_ACR_ICEN: u32 = 512;
pub const FLASH_ACR_DCEN_Pos: u32 = 10;
pub const FLASH_ACR_DCEN_Msk: u32 = 1024;
pub const FLASH_ACR_DCEN: u32 = 1024;
pub const FLASH_ACR_ICRST_Pos: u32 = 11;
pub const FLASH_ACR_ICRST_Msk: u32 = 2048;
pub const FLASH_ACR_ICRST: u32 = 2048;
pub const FLASH_ACR_DCRST_Pos: u32 = 12;
pub const FLASH_ACR_DCRST_Msk: u32 = 4096;
pub const FLASH_ACR_DCRST: u32 = 4096;
pub const FLASH_ACR_RUN_PD_Pos: u32 = 13;
pub const FLASH_ACR_RUN_PD_Msk: u32 = 8192;
pub const FLASH_ACR_RUN_PD: u32 = 8192;
pub const FLASH_ACR_SLEEP_PD_Pos: u32 = 14;
pub const FLASH_ACR_SLEEP_PD_Msk: u32 = 16384;
pub const FLASH_ACR_SLEEP_PD: u32 = 16384;
pub const FLASH_SR_EOP_Pos: u32 = 0;
pub const FLASH_SR_EOP_Msk: u32 = 1;
pub const FLASH_SR_EOP: u32 = 1;
pub const FLASH_SR_OPERR_Pos: u32 = 1;
pub const FLASH_SR_OPERR_Msk: u32 = 2;
pub const FLASH_SR_OPERR: u32 = 2;
pub const FLASH_SR_PROGERR_Pos: u32 = 3;
pub const FLASH_SR_PROGERR_Msk: u32 = 8;
pub const FLASH_SR_PROGERR: u32 = 8;
pub const FLASH_SR_WRPERR_Pos: u32 = 4;
pub const FLASH_SR_WRPERR_Msk: u32 = 16;
pub const FLASH_SR_WRPERR: u32 = 16;
pub const FLASH_SR_PGAERR_Pos: u32 = 5;
pub const FLASH_SR_PGAERR_Msk: u32 = 32;
pub const FLASH_SR_PGAERR: u32 = 32;
pub const FLASH_SR_SIZERR_Pos: u32 = 6;
pub const FLASH_SR_SIZERR_Msk: u32 = 64;
pub const FLASH_SR_SIZERR: u32 = 64;
pub const FLASH_SR_PGSERR_Pos: u32 = 7;
pub const FLASH_SR_PGSERR_Msk: u32 = 128;
pub const FLASH_SR_PGSERR: u32 = 128;
pub const FLASH_SR_MISERR_Pos: u32 = 8;
pub const FLASH_SR_MISERR_Msk: u32 = 256;
pub const FLASH_SR_MISERR: u32 = 256;
pub const FLASH_SR_FASTERR_Pos: u32 = 9;
pub const FLASH_SR_FASTERR_Msk: u32 = 512;
pub const FLASH_SR_FASTERR: u32 = 512;
pub const FLASH_SR_RDERR_Pos: u32 = 14;
pub const FLASH_SR_RDERR_Msk: u32 = 16384;
pub const FLASH_SR_RDERR: u32 = 16384;
pub const FLASH_SR_OPTVERR_Pos: u32 = 15;
pub const FLASH_SR_OPTVERR_Msk: u32 = 32768;
pub const FLASH_SR_OPTVERR: u32 = 32768;
pub const FLASH_SR_BSY_Pos: u32 = 16;
pub const FLASH_SR_BSY_Msk: u32 = 65536;
pub const FLASH_SR_BSY: u32 = 65536;
pub const FLASH_CR_PG_Pos: u32 = 0;
pub const FLASH_CR_PG_Msk: u32 = 1;
pub const FLASH_CR_PG: u32 = 1;
pub const FLASH_CR_PER_Pos: u32 = 1;
pub const FLASH_CR_PER_Msk: u32 = 2;
pub const FLASH_CR_PER: u32 = 2;
pub const FLASH_CR_MER1_Pos: u32 = 2;
pub const FLASH_CR_MER1_Msk: u32 = 4;
pub const FLASH_CR_MER1: u32 = 4;
pub const FLASH_CR_PNB_Pos: u32 = 3;
pub const FLASH_CR_PNB_Msk: u32 = 2040;
pub const FLASH_CR_PNB: u32 = 2040;
pub const FLASH_CR_BKER_Pos: u32 = 11;
pub const FLASH_CR_BKER_Msk: u32 = 2048;
pub const FLASH_CR_BKER: u32 = 2048;
pub const FLASH_CR_MER2_Pos: u32 = 15;
pub const FLASH_CR_MER2_Msk: u32 = 32768;
pub const FLASH_CR_MER2: u32 = 32768;
pub const FLASH_CR_STRT_Pos: u32 = 16;
pub const FLASH_CR_STRT_Msk: u32 = 65536;
pub const FLASH_CR_STRT: u32 = 65536;
pub const FLASH_CR_OPTSTRT_Pos: u32 = 17;
pub const FLASH_CR_OPTSTRT_Msk: u32 = 131072;
pub const FLASH_CR_OPTSTRT: u32 = 131072;
pub const FLASH_CR_FSTPG_Pos: u32 = 18;
pub const FLASH_CR_FSTPG_Msk: u32 = 262144;
pub const FLASH_CR_FSTPG: u32 = 262144;
pub const FLASH_CR_EOPIE_Pos: u32 = 24;
pub const FLASH_CR_EOPIE_Msk: u32 = 16777216;
pub const FLASH_CR_EOPIE: u32 = 16777216;
pub const FLASH_CR_ERRIE_Pos: u32 = 25;
pub const FLASH_CR_ERRIE_Msk: u32 = 33554432;
pub const FLASH_CR_ERRIE: u32 = 33554432;
pub const FLASH_CR_RDERRIE_Pos: u32 = 26;
pub const FLASH_CR_RDERRIE_Msk: u32 = 67108864;
pub const FLASH_CR_RDERRIE: u32 = 67108864;
pub const FLASH_CR_OBL_LAUNCH_Pos: u32 = 27;
pub const FLASH_CR_OBL_LAUNCH_Msk: u32 = 134217728;
pub const FLASH_CR_OBL_LAUNCH: u32 = 134217728;
pub const FLASH_CR_OPTLOCK_Pos: u32 = 30;
pub const FLASH_CR_OPTLOCK_Msk: u32 = 1073741824;
pub const FLASH_CR_OPTLOCK: u32 = 1073741824;
pub const FLASH_CR_LOCK_Pos: u32 = 31;
pub const FLASH_CR_LOCK_Msk: u32 = 2147483648;
pub const FLASH_CR_LOCK: u32 = 2147483648;
pub const FLASH_ECCR_ADDR_ECC_Pos: u32 = 0;
pub const FLASH_ECCR_ADDR_ECC_Msk: u32 = 524287;
pub const FLASH_ECCR_ADDR_ECC: u32 = 524287;
pub const FLASH_ECCR_BK_ECC_Pos: u32 = 19;
pub const FLASH_ECCR_BK_ECC_Msk: u32 = 524288;
pub const FLASH_ECCR_BK_ECC: u32 = 524288;
pub const FLASH_ECCR_SYSF_ECC_Pos: u32 = 20;
pub const FLASH_ECCR_SYSF_ECC_Msk: u32 = 1048576;
pub const FLASH_ECCR_SYSF_ECC: u32 = 1048576;
pub const FLASH_ECCR_ECCIE_Pos: u32 = 24;
pub const FLASH_ECCR_ECCIE_Msk: u32 = 16777216;
pub const FLASH_ECCR_ECCIE: u32 = 16777216;
pub const FLASH_ECCR_ECCC_Pos: u32 = 30;
pub const FLASH_ECCR_ECCC_Msk: u32 = 1073741824;
pub const FLASH_ECCR_ECCC: u32 = 1073741824;
pub const FLASH_ECCR_ECCD_Pos: u32 = 31;
pub const FLASH_ECCR_ECCD_Msk: u32 = 2147483648;
pub const FLASH_ECCR_ECCD: u32 = 2147483648;
pub const FLASH_OPTR_RDP_Pos: u32 = 0;
pub const FLASH_OPTR_RDP_Msk: u32 = 255;
pub const FLASH_OPTR_RDP: u32 = 255;
pub const FLASH_OPTR_BOR_LEV_Pos: u32 = 8;
pub const FLASH_OPTR_BOR_LEV_Msk: u32 = 1792;
pub const FLASH_OPTR_BOR_LEV: u32 = 1792;
pub const FLASH_OPTR_BOR_LEV_0: u32 = 0;
pub const FLASH_OPTR_BOR_LEV_1: u32 = 256;
pub const FLASH_OPTR_BOR_LEV_2: u32 = 512;
pub const FLASH_OPTR_BOR_LEV_3: u32 = 768;
pub const FLASH_OPTR_BOR_LEV_4: u32 = 1024;
pub const FLASH_OPTR_nRST_STOP_Pos: u32 = 12;
pub const FLASH_OPTR_nRST_STOP_Msk: u32 = 4096;
pub const FLASH_OPTR_nRST_STOP: u32 = 4096;
pub const FLASH_OPTR_nRST_STDBY_Pos: u32 = 13;
pub const FLASH_OPTR_nRST_STDBY_Msk: u32 = 8192;
pub const FLASH_OPTR_nRST_STDBY: u32 = 8192;
pub const FLASH_OPTR_nRST_SHDW_Pos: u32 = 14;
pub const FLASH_OPTR_nRST_SHDW_Msk: u32 = 16384;
pub const FLASH_OPTR_nRST_SHDW: u32 = 16384;
pub const FLASH_OPTR_IWDG_SW_Pos: u32 = 16;
pub const FLASH_OPTR_IWDG_SW_Msk: u32 = 65536;
pub const FLASH_OPTR_IWDG_SW: u32 = 65536;
pub const FLASH_OPTR_IWDG_STOP_Pos: u32 = 17;
pub const FLASH_OPTR_IWDG_STOP_Msk: u32 = 131072;
pub const FLASH_OPTR_IWDG_STOP: u32 = 131072;
pub const FLASH_OPTR_IWDG_STDBY_Pos: u32 = 18;
pub const FLASH_OPTR_IWDG_STDBY_Msk: u32 = 262144;
pub const FLASH_OPTR_IWDG_STDBY: u32 = 262144;
pub const FLASH_OPTR_WWDG_SW_Pos: u32 = 19;
pub const FLASH_OPTR_WWDG_SW_Msk: u32 = 524288;
pub const FLASH_OPTR_WWDG_SW: u32 = 524288;
pub const FLASH_OPTR_BFB2_Pos: u32 = 20;
pub const FLASH_OPTR_BFB2_Msk: u32 = 1048576;
pub const FLASH_OPTR_BFB2: u32 = 1048576;
pub const FLASH_OPTR_DUALBANK_Pos: u32 = 21;
pub const FLASH_OPTR_DUALBANK_Msk: u32 = 2097152;
pub const FLASH_OPTR_DUALBANK: u32 = 2097152;
pub const FLASH_OPTR_nBOOT1_Pos: u32 = 23;
pub const FLASH_OPTR_nBOOT1_Msk: u32 = 8388608;
pub const FLASH_OPTR_nBOOT1: u32 = 8388608;
pub const FLASH_OPTR_SRAM2_PE_Pos: u32 = 24;
pub const FLASH_OPTR_SRAM2_PE_Msk: u32 = 16777216;
pub const FLASH_OPTR_SRAM2_PE: u32 = 16777216;
pub const FLASH_OPTR_SRAM2_RST_Pos: u32 = 25;
pub const FLASH_OPTR_SRAM2_RST_Msk: u32 = 33554432;
pub const FLASH_OPTR_SRAM2_RST: u32 = 33554432;
pub const FLASH_PCROP1SR_PCROP1_STRT_Pos: u32 = 0;
pub const FLASH_PCROP1SR_PCROP1_STRT_Msk: u32 = 65535;
pub const FLASH_PCROP1SR_PCROP1_STRT: u32 = 65535;
pub const FLASH_PCROP1ER_PCROP1_END_Pos: u32 = 0;
pub const FLASH_PCROP1ER_PCROP1_END_Msk: u32 = 65535;
pub const FLASH_PCROP1ER_PCROP1_END: u32 = 65535;
pub const FLASH_PCROP1ER_PCROP_RDP_Pos: u32 = 31;
pub const FLASH_PCROP1ER_PCROP_RDP_Msk: u32 = 2147483648;
pub const FLASH_PCROP1ER_PCROP_RDP: u32 = 2147483648;
pub const FLASH_WRP1AR_WRP1A_STRT_Pos: u32 = 0;
pub const FLASH_WRP1AR_WRP1A_STRT_Msk: u32 = 255;
pub const FLASH_WRP1AR_WRP1A_STRT: u32 = 255;
pub const FLASH_WRP1AR_WRP1A_END_Pos: u32 = 16;
pub const FLASH_WRP1AR_WRP1A_END_Msk: u32 = 16711680;
pub const FLASH_WRP1AR_WRP1A_END: u32 = 16711680;
pub const FLASH_WRP1BR_WRP1B_STRT_Pos: u32 = 0;
pub const FLASH_WRP1BR_WRP1B_STRT_Msk: u32 = 255;
pub const FLASH_WRP1BR_WRP1B_STRT: u32 = 255;
pub const FLASH_WRP1BR_WRP1B_END_Pos: u32 = 16;
pub const FLASH_WRP1BR_WRP1B_END_Msk: u32 = 16711680;
pub const FLASH_WRP1BR_WRP1B_END: u32 = 16711680;
pub const FLASH_PCROP2SR_PCROP2_STRT_Pos: u32 = 0;
pub const FLASH_PCROP2SR_PCROP2_STRT_Msk: u32 = 65535;
pub const FLASH_PCROP2SR_PCROP2_STRT: u32 = 65535;
pub const FLASH_PCROP2ER_PCROP2_END_Pos: u32 = 0;
pub const FLASH_PCROP2ER_PCROP2_END_Msk: u32 = 65535;
pub const FLASH_PCROP2ER_PCROP2_END: u32 = 65535;
pub const FLASH_WRP2AR_WRP2A_STRT_Pos: u32 = 0;
pub const FLASH_WRP2AR_WRP2A_STRT_Msk: u32 = 255;
pub const FLASH_WRP2AR_WRP2A_STRT: u32 = 255;
pub const FLASH_WRP2AR_WRP2A_END_Pos: u32 = 16;
pub const FLASH_WRP2AR_WRP2A_END_Msk: u32 = 16711680;
pub const FLASH_WRP2AR_WRP2A_END: u32 = 16711680;
pub const FLASH_WRP2BR_WRP2B_STRT_Pos: u32 = 0;
pub const FLASH_WRP2BR_WRP2B_STRT_Msk: u32 = 255;
pub const FLASH_WRP2BR_WRP2B_STRT: u32 = 255;
pub const FLASH_WRP2BR_WRP2B_END_Pos: u32 = 16;
pub const FLASH_WRP2BR_WRP2B_END_Msk: u32 = 16711680;
pub const FLASH_WRP2BR_WRP2B_END: u32 = 16711680;
pub const FMC_BCR1_CCLKEN_Pos: u32 = 20;
pub const FMC_BCR1_CCLKEN_Msk: u32 = 1048576;
pub const FMC_BCR1_CCLKEN: u32 = 1048576;
pub const FMC_BCRx_MBKEN_Pos: u32 = 0;
pub const FMC_BCRx_MBKEN_Msk: u32 = 1;
pub const FMC_BCRx_MBKEN: u32 = 1;
pub const FMC_BCRx_MUXEN_Pos: u32 = 1;
pub const FMC_BCRx_MUXEN_Msk: u32 = 2;
pub const FMC_BCRx_MUXEN: u32 = 2;
pub const FMC_BCRx_MTYP_Pos: u32 = 2;
pub const FMC_BCRx_MTYP_Msk: u32 = 12;
pub const FMC_BCRx_MTYP: u32 = 12;
pub const FMC_BCRx_MTYP_0: u32 = 4;
pub const FMC_BCRx_MTYP_1: u32 = 8;
pub const FMC_BCRx_MWID_Pos: u32 = 4;
pub const FMC_BCRx_MWID_Msk: u32 = 48;
pub const FMC_BCRx_MWID: u32 = 48;
pub const FMC_BCRx_MWID_0: u32 = 16;
pub const FMC_BCRx_MWID_1: u32 = 32;
pub const FMC_BCRx_FACCEN_Pos: u32 = 6;
pub const FMC_BCRx_FACCEN_Msk: u32 = 64;
pub const FMC_BCRx_FACCEN: u32 = 64;
pub const FMC_BCRx_BURSTEN_Pos: u32 = 8;
pub const FMC_BCRx_BURSTEN_Msk: u32 = 256;
pub const FMC_BCRx_BURSTEN: u32 = 256;
pub const FMC_BCRx_WAITPOL_Pos: u32 = 9;
pub const FMC_BCRx_WAITPOL_Msk: u32 = 512;
pub const FMC_BCRx_WAITPOL: u32 = 512;
pub const FMC_BCRx_WAITCFG_Pos: u32 = 11;
pub const FMC_BCRx_WAITCFG_Msk: u32 = 2048;
pub const FMC_BCRx_WAITCFG: u32 = 2048;
pub const FMC_BCRx_WREN_Pos: u32 = 12;
pub const FMC_BCRx_WREN_Msk: u32 = 4096;
pub const FMC_BCRx_WREN: u32 = 4096;
pub const FMC_BCRx_WAITEN_Pos: u32 = 13;
pub const FMC_BCRx_WAITEN_Msk: u32 = 8192;
pub const FMC_BCRx_WAITEN: u32 = 8192;
pub const FMC_BCRx_EXTMOD_Pos: u32 = 14;
pub const FMC_BCRx_EXTMOD_Msk: u32 = 16384;
pub const FMC_BCRx_EXTMOD: u32 = 16384;
pub const FMC_BCRx_ASYNCWAIT_Pos: u32 = 15;
pub const FMC_BCRx_ASYNCWAIT_Msk: u32 = 32768;
pub const FMC_BCRx_ASYNCWAIT: u32 = 32768;
pub const FMC_BCRx_CPSIZE_Pos: u32 = 16;
pub const FMC_BCRx_CPSIZE_Msk: u32 = 458752;
pub const FMC_BCRx_CPSIZE: u32 = 458752;
pub const FMC_BCRx_CPSIZE_0: u32 = 65536;
pub const FMC_BCRx_CPSIZE_1: u32 = 131072;
pub const FMC_BCRx_CPSIZE_2: u32 = 262144;
pub const FMC_BCRx_CBURSTRW_Pos: u32 = 19;
pub const FMC_BCRx_CBURSTRW_Msk: u32 = 524288;
pub const FMC_BCRx_CBURSTRW: u32 = 524288;
pub const FMC_BTRx_ADDSET_Pos: u32 = 0;
pub const FMC_BTRx_ADDSET_Msk: u32 = 15;
pub const FMC_BTRx_ADDSET: u32 = 15;
pub const FMC_BTRx_ADDSET_0: u32 = 1;
pub const FMC_BTRx_ADDSET_1: u32 = 2;
pub const FMC_BTRx_ADDSET_2: u32 = 4;
pub const FMC_BTRx_ADDSET_3: u32 = 8;
pub const FMC_BTRx_ADDHLD_Pos: u32 = 4;
pub const FMC_BTRx_ADDHLD_Msk: u32 = 240;
pub const FMC_BTRx_ADDHLD: u32 = 240;
pub const FMC_BTRx_ADDHLD_0: u32 = 16;
pub const FMC_BTRx_ADDHLD_1: u32 = 32;
pub const FMC_BTRx_ADDHLD_2: u32 = 64;
pub const FMC_BTRx_ADDHLD_3: u32 = 128;
pub const FMC_BTRx_DATAST_Pos: u32 = 8;
pub const FMC_BTRx_DATAST_Msk: u32 = 65280;
pub const FMC_BTRx_DATAST: u32 = 65280;
pub const FMC_BTRx_DATAST_0: u32 = 256;
pub const FMC_BTRx_DATAST_1: u32 = 512;
pub const FMC_BTRx_DATAST_2: u32 = 1024;
pub const FMC_BTRx_DATAST_3: u32 = 2048;
pub const FMC_BTRx_DATAST_4: u32 = 4096;
pub const FMC_BTRx_DATAST_5: u32 = 8192;
pub const FMC_BTRx_DATAST_6: u32 = 16384;
pub const FMC_BTRx_DATAST_7: u32 = 32768;
pub const FMC_BTRx_BUSTURN_Pos: u32 = 16;
pub const FMC_BTRx_BUSTURN_Msk: u32 = 983040;
pub const FMC_BTRx_BUSTURN: u32 = 983040;
pub const FMC_BTRx_BUSTURN_0: u32 = 65536;
pub const FMC_BTRx_BUSTURN_1: u32 = 131072;
pub const FMC_BTRx_BUSTURN_2: u32 = 262144;
pub const FMC_BTRx_BUSTURN_3: u32 = 524288;
pub const FMC_BTRx_CLKDIV_Pos: u32 = 20;
pub const FMC_BTRx_CLKDIV_Msk: u32 = 15728640;
pub const FMC_BTRx_CLKDIV: u32 = 15728640;
pub const FMC_BTRx_CLKDIV_0: u32 = 1048576;
pub const FMC_BTRx_CLKDIV_1: u32 = 2097152;
pub const FMC_BTRx_CLKDIV_2: u32 = 4194304;
pub const FMC_BTRx_CLKDIV_3: u32 = 8388608;
pub const FMC_BTRx_DATLAT_Pos: u32 = 24;
pub const FMC_BTRx_DATLAT_Msk: u32 = 251658240;
pub const FMC_BTRx_DATLAT: u32 = 251658240;
pub const FMC_BTRx_DATLAT_0: u32 = 16777216;
pub const FMC_BTRx_DATLAT_1: u32 = 33554432;
pub const FMC_BTRx_DATLAT_2: u32 = 67108864;
pub const FMC_BTRx_DATLAT_3: u32 = 134217728;
pub const FMC_BTRx_ACCMOD_Pos: u32 = 28;
pub const FMC_BTRx_ACCMOD_Msk: u32 = 805306368;
pub const FMC_BTRx_ACCMOD: u32 = 805306368;
pub const FMC_BTRx_ACCMOD_0: u32 = 268435456;
pub const FMC_BTRx_ACCMOD_1: u32 = 536870912;
pub const FMC_BWTRx_ADDSET_Pos: u32 = 0;
pub const FMC_BWTRx_ADDSET_Msk: u32 = 15;
pub const FMC_BWTRx_ADDSET: u32 = 15;
pub const FMC_BWTRx_ADDSET_0: u32 = 1;
pub const FMC_BWTRx_ADDSET_1: u32 = 2;
pub const FMC_BWTRx_ADDSET_2: u32 = 4;
pub const FMC_BWTRx_ADDSET_3: u32 = 8;
pub const FMC_BWTRx_ADDHLD_Pos: u32 = 4;
pub const FMC_BWTRx_ADDHLD_Msk: u32 = 240;
pub const FMC_BWTRx_ADDHLD: u32 = 240;
pub const FMC_BWTRx_ADDHLD_0: u32 = 16;
pub const FMC_BWTRx_ADDHLD_1: u32 = 32;
pub const FMC_BWTRx_ADDHLD_2: u32 = 64;
pub const FMC_BWTRx_ADDHLD_3: u32 = 128;
pub const FMC_BWTRx_DATAST_Pos: u32 = 8;
pub const FMC_BWTRx_DATAST_Msk: u32 = 65280;
pub const FMC_BWTRx_DATAST: u32 = 65280;
pub const FMC_BWTRx_DATAST_0: u32 = 256;
pub const FMC_BWTRx_DATAST_1: u32 = 512;
pub const FMC_BWTRx_DATAST_2: u32 = 1024;
pub const FMC_BWTRx_DATAST_3: u32 = 2048;
pub const FMC_BWTRx_DATAST_4: u32 = 4096;
pub const FMC_BWTRx_DATAST_5: u32 = 8192;
pub const FMC_BWTRx_DATAST_6: u32 = 16384;
pub const FMC_BWTRx_DATAST_7: u32 = 32768;
pub const FMC_BWTRx_BUSTURN_Pos: u32 = 16;
pub const FMC_BWTRx_BUSTURN_Msk: u32 = 983040;
pub const FMC_BWTRx_BUSTURN: u32 = 983040;
pub const FMC_BWTRx_BUSTURN_0: u32 = 65536;
pub const FMC_BWTRx_BUSTURN_1: u32 = 131072;
pub const FMC_BWTRx_BUSTURN_2: u32 = 262144;
pub const FMC_BWTRx_BUSTURN_3: u32 = 524288;
pub const FMC_BWTRx_ACCMOD_Pos: u32 = 28;
pub const FMC_BWTRx_ACCMOD_Msk: u32 = 805306368;
pub const FMC_BWTRx_ACCMOD: u32 = 805306368;
pub const FMC_BWTRx_ACCMOD_0: u32 = 268435456;
pub const FMC_BWTRx_ACCMOD_1: u32 = 536870912;
pub const FMC_PCR_PWAITEN_Pos: u32 = 1;
pub const FMC_PCR_PWAITEN_Msk: u32 = 2;
pub const FMC_PCR_PWAITEN: u32 = 2;
pub const FMC_PCR_PBKEN_Pos: u32 = 2;
pub const FMC_PCR_PBKEN_Msk: u32 = 4;
pub const FMC_PCR_PBKEN: u32 = 4;
pub const FMC_PCR_PTYP_Pos: u32 = 3;
pub const FMC_PCR_PTYP_Msk: u32 = 8;
pub const FMC_PCR_PTYP: u32 = 8;
pub const FMC_PCR_PWID_Pos: u32 = 4;
pub const FMC_PCR_PWID_Msk: u32 = 48;
pub const FMC_PCR_PWID: u32 = 48;
pub const FMC_PCR_PWID_0: u32 = 16;
pub const FMC_PCR_PWID_1: u32 = 32;
pub const FMC_PCR_ECCEN_Pos: u32 = 6;
pub const FMC_PCR_ECCEN_Msk: u32 = 64;
pub const FMC_PCR_ECCEN: u32 = 64;
pub const FMC_PCR_TCLR_Pos: u32 = 9;
pub const FMC_PCR_TCLR_Msk: u32 = 7680;
pub const FMC_PCR_TCLR: u32 = 7680;
pub const FMC_PCR_TCLR_0: u32 = 512;
pub const FMC_PCR_TCLR_1: u32 = 1024;
pub const FMC_PCR_TCLR_2: u32 = 2048;
pub const FMC_PCR_TCLR_3: u32 = 4096;
pub const FMC_PCR_TAR_Pos: u32 = 13;
pub const FMC_PCR_TAR_Msk: u32 = 122880;
pub const FMC_PCR_TAR: u32 = 122880;
pub const FMC_PCR_TAR_0: u32 = 8192;
pub const FMC_PCR_TAR_1: u32 = 16384;
pub const FMC_PCR_TAR_2: u32 = 32768;
pub const FMC_PCR_TAR_3: u32 = 65536;
pub const FMC_PCR_ECCPS_Pos: u32 = 17;
pub const FMC_PCR_ECCPS_Msk: u32 = 917504;
pub const FMC_PCR_ECCPS: u32 = 917504;
pub const FMC_PCR_ECCPS_0: u32 = 131072;
pub const FMC_PCR_ECCPS_1: u32 = 262144;
pub const FMC_PCR_ECCPS_2: u32 = 524288;
pub const FMC_SR_IRS_Pos: u32 = 0;
pub const FMC_SR_IRS_Msk: u32 = 1;
pub const FMC_SR_IRS: u32 = 1;
pub const FMC_SR_ILS_Pos: u32 = 1;
pub const FMC_SR_ILS_Msk: u32 = 2;
pub const FMC_SR_ILS: u32 = 2;
pub const FMC_SR_IFS_Pos: u32 = 2;
pub const FMC_SR_IFS_Msk: u32 = 4;
pub const FMC_SR_IFS: u32 = 4;
pub const FMC_SR_IREN_Pos: u32 = 3;
pub const FMC_SR_IREN_Msk: u32 = 8;
pub const FMC_SR_IREN: u32 = 8;
pub const FMC_SR_ILEN_Pos: u32 = 4;
pub const FMC_SR_ILEN_Msk: u32 = 16;
pub const FMC_SR_ILEN: u32 = 16;
pub const FMC_SR_IFEN_Pos: u32 = 5;
pub const FMC_SR_IFEN_Msk: u32 = 32;
pub const FMC_SR_IFEN: u32 = 32;
pub const FMC_SR_FEMPT_Pos: u32 = 6;
pub const FMC_SR_FEMPT_Msk: u32 = 64;
pub const FMC_SR_FEMPT: u32 = 64;
pub const FMC_PMEM_MEMSET_Pos: u32 = 0;
pub const FMC_PMEM_MEMSET_Msk: u32 = 255;
pub const FMC_PMEM_MEMSET: u32 = 255;
pub const FMC_PMEM_MEMSET_0: u32 = 1;
pub const FMC_PMEM_MEMSET_1: u32 = 2;
pub const FMC_PMEM_MEMSET_2: u32 = 4;
pub const FMC_PMEM_MEMSET_3: u32 = 8;
pub const FMC_PMEM_MEMSET_4: u32 = 16;
pub const FMC_PMEM_MEMSET_5: u32 = 32;
pub const FMC_PMEM_MEMSET_6: u32 = 64;
pub const FMC_PMEM_MEMSET_7: u32 = 128;
pub const FMC_PMEM_MEMWAIT_Pos: u32 = 8;
pub const FMC_PMEM_MEMWAIT_Msk: u32 = 65280;
pub const FMC_PMEM_MEMWAIT: u32 = 65280;
pub const FMC_PMEM_MEMWAIT_0: u32 = 256;
pub const FMC_PMEM_MEMWAIT_1: u32 = 512;
pub const FMC_PMEM_MEMWAIT_2: u32 = 1024;
pub const FMC_PMEM_MEMWAIT_3: u32 = 2048;
pub const FMC_PMEM_MEMWAIT_4: u32 = 4096;
pub const FMC_PMEM_MEMWAIT_5: u32 = 8192;
pub const FMC_PMEM_MEMWAIT_6: u32 = 16384;
pub const FMC_PMEM_MEMWAIT_7: u32 = 32768;
pub const FMC_PMEM_MEMHOLD_Pos: u32 = 16;
pub const FMC_PMEM_MEMHOLD_Msk: u32 = 16711680;
pub const FMC_PMEM_MEMHOLD: u32 = 16711680;
pub const FMC_PMEM_MEMHOLD_0: u32 = 65536;
pub const FMC_PMEM_MEMHOLD_1: u32 = 131072;
pub const FMC_PMEM_MEMHOLD_2: u32 = 262144;
pub const FMC_PMEM_MEMHOLD_3: u32 = 524288;
pub const FMC_PMEM_MEMHOLD_4: u32 = 1048576;
pub const FMC_PMEM_MEMHOLD_5: u32 = 2097152;
pub const FMC_PMEM_MEMHOLD_6: u32 = 4194304;
pub const FMC_PMEM_MEMHOLD_7: u32 = 8388608;
pub const FMC_PMEM_MEMHIZ_Pos: u32 = 24;
pub const FMC_PMEM_MEMHIZ_Msk: u32 = 4278190080;
pub const FMC_PMEM_MEMHIZ: u32 = 4278190080;
pub const FMC_PMEM_MEMHIZ_0: u32 = 16777216;
pub const FMC_PMEM_MEMHIZ_1: u32 = 33554432;
pub const FMC_PMEM_MEMHIZ_2: u32 = 67108864;
pub const FMC_PMEM_MEMHIZ_3: u32 = 134217728;
pub const FMC_PMEM_MEMHIZ_4: u32 = 268435456;
pub const FMC_PMEM_MEMHIZ_5: u32 = 536870912;
pub const FMC_PMEM_MEMHIZ_6: u32 = 1073741824;
pub const FMC_PMEM_MEMHIZ_7: u32 = 2147483648;
pub const FMC_PATT_ATTSET_Pos: u32 = 0;
pub const FMC_PATT_ATTSET_Msk: u32 = 255;
pub const FMC_PATT_ATTSET: u32 = 255;
pub const FMC_PATT_ATTSET_0: u32 = 1;
pub const FMC_PATT_ATTSET_1: u32 = 2;
pub const FMC_PATT_ATTSET_2: u32 = 4;
pub const FMC_PATT_ATTSET_3: u32 = 8;
pub const FMC_PATT_ATTSET_4: u32 = 16;
pub const FMC_PATT_ATTSET_5: u32 = 32;
pub const FMC_PATT_ATTSET_6: u32 = 64;
pub const FMC_PATT_ATTSET_7: u32 = 128;
pub const FMC_PATT_ATTWAIT_Pos: u32 = 8;
pub const FMC_PATT_ATTWAIT_Msk: u32 = 65280;
pub const FMC_PATT_ATTWAIT: u32 = 65280;
pub const FMC_PATT_ATTWAIT_0: u32 = 256;
pub const FMC_PATT_ATTWAIT_1: u32 = 512;
pub const FMC_PATT_ATTWAIT_2: u32 = 1024;
pub const FMC_PATT_ATTWAIT_3: u32 = 2048;
pub const FMC_PATT_ATTWAIT_4: u32 = 4096;
pub const FMC_PATT_ATTWAIT_5: u32 = 8192;
pub const FMC_PATT_ATTWAIT_6: u32 = 16384;
pub const FMC_PATT_ATTWAIT_7: u32 = 32768;
pub const FMC_PATT_ATTHOLD_Pos: u32 = 16;
pub const FMC_PATT_ATTHOLD_Msk: u32 = 16711680;
pub const FMC_PATT_ATTHOLD: u32 = 16711680;
pub const FMC_PATT_ATTHOLD_0: u32 = 65536;
pub const FMC_PATT_ATTHOLD_1: u32 = 131072;
pub const FMC_PATT_ATTHOLD_2: u32 = 262144;
pub const FMC_PATT_ATTHOLD_3: u32 = 524288;
pub const FMC_PATT_ATTHOLD_4: u32 = 1048576;
pub const FMC_PATT_ATTHOLD_5: u32 = 2097152;
pub const FMC_PATT_ATTHOLD_6: u32 = 4194304;
pub const FMC_PATT_ATTHOLD_7: u32 = 8388608;
pub const FMC_PATT_ATTHIZ_Pos: u32 = 24;
pub const FMC_PATT_ATTHIZ_Msk: u32 = 4278190080;
pub const FMC_PATT_ATTHIZ: u32 = 4278190080;
pub const FMC_PATT_ATTHIZ_0: u32 = 16777216;
pub const FMC_PATT_ATTHIZ_1: u32 = 33554432;
pub const FMC_PATT_ATTHIZ_2: u32 = 67108864;
pub const FMC_PATT_ATTHIZ_3: u32 = 134217728;
pub const FMC_PATT_ATTHIZ_4: u32 = 268435456;
pub const FMC_PATT_ATTHIZ_5: u32 = 536870912;
pub const FMC_PATT_ATTHIZ_6: u32 = 1073741824;
pub const FMC_PATT_ATTHIZ_7: u32 = 2147483648;
pub const FMC_ECCR_ECC_Pos: u32 = 0;
pub const FMC_ECCR_ECC_Msk: u32 = 4294967295;
pub const FMC_ECCR_ECC: u32 = 4294967295;
pub const GPIO_MODER_MODE0_Pos: u32 = 0;
pub const GPIO_MODER_MODE0_Msk: u32 = 3;
pub const GPIO_MODER_MODE0: u32 = 3;
pub const GPIO_MODER_MODE0_0: u32 = 1;
pub const GPIO_MODER_MODE0_1: u32 = 2;
pub const GPIO_MODER_MODE1_Pos: u32 = 2;
pub const GPIO_MODER_MODE1_Msk: u32 = 12;
pub const GPIO_MODER_MODE1: u32 = 12;
pub const GPIO_MODER_MODE1_0: u32 = 4;
pub const GPIO_MODER_MODE1_1: u32 = 8;
pub const GPIO_MODER_MODE2_Pos: u32 = 4;
pub const GPIO_MODER_MODE2_Msk: u32 = 48;
pub const GPIO_MODER_MODE2: u32 = 48;
pub const GPIO_MODER_MODE2_0: u32 = 16;
pub const GPIO_MODER_MODE2_1: u32 = 32;
pub const GPIO_MODER_MODE3_Pos: u32 = 6;
pub const GPIO_MODER_MODE3_Msk: u32 = 192;
pub const GPIO_MODER_MODE3: u32 = 192;
pub const GPIO_MODER_MODE3_0: u32 = 64;
pub const GPIO_MODER_MODE3_1: u32 = 128;
pub const GPIO_MODER_MODE4_Pos: u32 = 8;
pub const GPIO_MODER_MODE4_Msk: u32 = 768;
pub const GPIO_MODER_MODE4: u32 = 768;
pub const GPIO_MODER_MODE4_0: u32 = 256;
pub const GPIO_MODER_MODE4_1: u32 = 512;
pub const GPIO_MODER_MODE5_Pos: u32 = 10;
pub const GPIO_MODER_MODE5_Msk: u32 = 3072;
pub const GPIO_MODER_MODE5: u32 = 3072;
pub const GPIO_MODER_MODE5_0: u32 = 1024;
pub const GPIO_MODER_MODE5_1: u32 = 2048;
pub const GPIO_MODER_MODE6_Pos: u32 = 12;
pub const GPIO_MODER_MODE6_Msk: u32 = 12288;
pub const GPIO_MODER_MODE6: u32 = 12288;
pub const GPIO_MODER_MODE6_0: u32 = 4096;
pub const GPIO_MODER_MODE6_1: u32 = 8192;
pub const GPIO_MODER_MODE7_Pos: u32 = 14;
pub const GPIO_MODER_MODE7_Msk: u32 = 49152;
pub const GPIO_MODER_MODE7: u32 = 49152;
pub const GPIO_MODER_MODE7_0: u32 = 16384;
pub const GPIO_MODER_MODE7_1: u32 = 32768;
pub const GPIO_MODER_MODE8_Pos: u32 = 16;
pub const GPIO_MODER_MODE8_Msk: u32 = 196608;
pub const GPIO_MODER_MODE8: u32 = 196608;
pub const GPIO_MODER_MODE8_0: u32 = 65536;
pub const GPIO_MODER_MODE8_1: u32 = 131072;
pub const GPIO_MODER_MODE9_Pos: u32 = 18;
pub const GPIO_MODER_MODE9_Msk: u32 = 786432;
pub const GPIO_MODER_MODE9: u32 = 786432;
pub const GPIO_MODER_MODE9_0: u32 = 262144;
pub const GPIO_MODER_MODE9_1: u32 = 524288;
pub const GPIO_MODER_MODE10_Pos: u32 = 20;
pub const GPIO_MODER_MODE10_Msk: u32 = 3145728;
pub const GPIO_MODER_MODE10: u32 = 3145728;
pub const GPIO_MODER_MODE10_0: u32 = 1048576;
pub const GPIO_MODER_MODE10_1: u32 = 2097152;
pub const GPIO_MODER_MODE11_Pos: u32 = 22;
pub const GPIO_MODER_MODE11_Msk: u32 = 12582912;
pub const GPIO_MODER_MODE11: u32 = 12582912;
pub const GPIO_MODER_MODE11_0: u32 = 4194304;
pub const GPIO_MODER_MODE11_1: u32 = 8388608;
pub const GPIO_MODER_MODE12_Pos: u32 = 24;
pub const GPIO_MODER_MODE12_Msk: u32 = 50331648;
pub const GPIO_MODER_MODE12: u32 = 50331648;
pub const GPIO_MODER_MODE12_0: u32 = 16777216;
pub const GPIO_MODER_MODE12_1: u32 = 33554432;
pub const GPIO_MODER_MODE13_Pos: u32 = 26;
pub const GPIO_MODER_MODE13_Msk: u32 = 201326592;
pub const GPIO_MODER_MODE13: u32 = 201326592;
pub const GPIO_MODER_MODE13_0: u32 = 67108864;
pub const GPIO_MODER_MODE13_1: u32 = 134217728;
pub const GPIO_MODER_MODE14_Pos: u32 = 28;
pub const GPIO_MODER_MODE14_Msk: u32 = 805306368;
pub const GPIO_MODER_MODE14: u32 = 805306368;
pub const GPIO_MODER_MODE14_0: u32 = 268435456;
pub const GPIO_MODER_MODE14_1: u32 = 536870912;
pub const GPIO_MODER_MODE15_Pos: u32 = 30;
pub const GPIO_MODER_MODE15_Msk: u32 = 3221225472;
pub const GPIO_MODER_MODE15: u32 = 3221225472;
pub const GPIO_MODER_MODE15_0: u32 = 1073741824;
pub const GPIO_MODER_MODE15_1: u32 = 2147483648;
pub const GPIO_MODER_MODER0: u32 = 3;
pub const GPIO_MODER_MODER0_0: u32 = 1;
pub const GPIO_MODER_MODER0_1: u32 = 2;
pub const GPIO_MODER_MODER1: u32 = 12;
pub const GPIO_MODER_MODER1_0: u32 = 4;
pub const GPIO_MODER_MODER1_1: u32 = 8;
pub const GPIO_MODER_MODER2: u32 = 48;
pub const GPIO_MODER_MODER2_0: u32 = 16;
pub const GPIO_MODER_MODER2_1: u32 = 32;
pub const GPIO_MODER_MODER3: u32 = 192;
pub const GPIO_MODER_MODER3_0: u32 = 64;
pub const GPIO_MODER_MODER3_1: u32 = 128;
pub const GPIO_MODER_MODER4: u32 = 768;
pub const GPIO_MODER_MODER4_0: u32 = 256;
pub const GPIO_MODER_MODER4_1: u32 = 512;
pub const GPIO_MODER_MODER5: u32 = 3072;
pub const GPIO_MODER_MODER5_0: u32 = 1024;
pub const GPIO_MODER_MODER5_1: u32 = 2048;
pub const GPIO_MODER_MODER6: u32 = 12288;
pub const GPIO_MODER_MODER6_0: u32 = 4096;
pub const GPIO_MODER_MODER6_1: u32 = 8192;
pub const GPIO_MODER_MODER7: u32 = 49152;
pub const GPIO_MODER_MODER7_0: u32 = 16384;
pub const GPIO_MODER_MODER7_1: u32 = 32768;
pub const GPIO_MODER_MODER8: u32 = 196608;
pub const GPIO_MODER_MODER8_0: u32 = 65536;
pub const GPIO_MODER_MODER8_1: u32 = 131072;
pub const GPIO_MODER_MODER9: u32 = 786432;
pub const GPIO_MODER_MODER9_0: u32 = 262144;
pub const GPIO_MODER_MODER9_1: u32 = 524288;
pub const GPIO_MODER_MODER10: u32 = 3145728;
pub const GPIO_MODER_MODER10_0: u32 = 1048576;
pub const GPIO_MODER_MODER10_1: u32 = 2097152;
pub const GPIO_MODER_MODER11: u32 = 12582912;
pub const GPIO_MODER_MODER11_0: u32 = 4194304;
pub const GPIO_MODER_MODER11_1: u32 = 8388608;
pub const GPIO_MODER_MODER12: u32 = 50331648;
pub const GPIO_MODER_MODER12_0: u32 = 16777216;
pub const GPIO_MODER_MODER12_1: u32 = 33554432;
pub const GPIO_MODER_MODER13: u32 = 201326592;
pub const GPIO_MODER_MODER13_0: u32 = 67108864;
pub const GPIO_MODER_MODER13_1: u32 = 134217728;
pub const GPIO_MODER_MODER14: u32 = 805306368;
pub const GPIO_MODER_MODER14_0: u32 = 268435456;
pub const GPIO_MODER_MODER14_1: u32 = 536870912;
pub const GPIO_MODER_MODER15: u32 = 3221225472;
pub const GPIO_MODER_MODER15_0: u32 = 1073741824;
pub const GPIO_MODER_MODER15_1: u32 = 2147483648;
pub const GPIO_OTYPER_OT0_Pos: u32 = 0;
pub const GPIO_OTYPER_OT0_Msk: u32 = 1;
pub const GPIO_OTYPER_OT0: u32 = 1;
pub const GPIO_OTYPER_OT1_Pos: u32 = 1;
pub const GPIO_OTYPER_OT1_Msk: u32 = 2;
pub const GPIO_OTYPER_OT1: u32 = 2;
pub const GPIO_OTYPER_OT2_Pos: u32 = 2;
pub const GPIO_OTYPER_OT2_Msk: u32 = 4;
pub const GPIO_OTYPER_OT2: u32 = 4;
pub const GPIO_OTYPER_OT3_Pos: u32 = 3;
pub const GPIO_OTYPER_OT3_Msk: u32 = 8;
pub const GPIO_OTYPER_OT3: u32 = 8;
pub const GPIO_OTYPER_OT4_Pos: u32 = 4;
pub const GPIO_OTYPER_OT4_Msk: u32 = 16;
pub const GPIO_OTYPER_OT4: u32 = 16;
pub const GPIO_OTYPER_OT5_Pos: u32 = 5;
pub const GPIO_OTYPER_OT5_Msk: u32 = 32;
pub const GPIO_OTYPER_OT5: u32 = 32;
pub const GPIO_OTYPER_OT6_Pos: u32 = 6;
pub const GPIO_OTYPER_OT6_Msk: u32 = 64;
pub const GPIO_OTYPER_OT6: u32 = 64;
pub const GPIO_OTYPER_OT7_Pos: u32 = 7;
pub const GPIO_OTYPER_OT7_Msk: u32 = 128;
pub const GPIO_OTYPER_OT7: u32 = 128;
pub const GPIO_OTYPER_OT8_Pos: u32 = 8;
pub const GPIO_OTYPER_OT8_Msk: u32 = 256;
pub const GPIO_OTYPER_OT8: u32 = 256;
pub const GPIO_OTYPER_OT9_Pos: u32 = 9;
pub const GPIO_OTYPER_OT9_Msk: u32 = 512;
pub const GPIO_OTYPER_OT9: u32 = 512;
pub const GPIO_OTYPER_OT10_Pos: u32 = 10;
pub const GPIO_OTYPER_OT10_Msk: u32 = 1024;
pub const GPIO_OTYPER_OT10: u32 = 1024;
pub const GPIO_OTYPER_OT11_Pos: u32 = 11;
pub const GPIO_OTYPER_OT11_Msk: u32 = 2048;
pub const GPIO_OTYPER_OT11: u32 = 2048;
pub const GPIO_OTYPER_OT12_Pos: u32 = 12;
pub const GPIO_OTYPER_OT12_Msk: u32 = 4096;
pub const GPIO_OTYPER_OT12: u32 = 4096;
pub const GPIO_OTYPER_OT13_Pos: u32 = 13;
pub const GPIO_OTYPER_OT13_Msk: u32 = 8192;
pub const GPIO_OTYPER_OT13: u32 = 8192;
pub const GPIO_OTYPER_OT14_Pos: u32 = 14;
pub const GPIO_OTYPER_OT14_Msk: u32 = 16384;
pub const GPIO_OTYPER_OT14: u32 = 16384;
pub const GPIO_OTYPER_OT15_Pos: u32 = 15;
pub const GPIO_OTYPER_OT15_Msk: u32 = 32768;
pub const GPIO_OTYPER_OT15: u32 = 32768;
pub const GPIO_OTYPER_OT_0: u32 = 1;
pub const GPIO_OTYPER_OT_1: u32 = 2;
pub const GPIO_OTYPER_OT_2: u32 = 4;
pub const GPIO_OTYPER_OT_3: u32 = 8;
pub const GPIO_OTYPER_OT_4: u32 = 16;
pub const GPIO_OTYPER_OT_5: u32 = 32;
pub const GPIO_OTYPER_OT_6: u32 = 64;
pub const GPIO_OTYPER_OT_7: u32 = 128;
pub const GPIO_OTYPER_OT_8: u32 = 256;
pub const GPIO_OTYPER_OT_9: u32 = 512;
pub const GPIO_OTYPER_OT_10: u32 = 1024;
pub const GPIO_OTYPER_OT_11: u32 = 2048;
pub const GPIO_OTYPER_OT_12: u32 = 4096;
pub const GPIO_OTYPER_OT_13: u32 = 8192;
pub const GPIO_OTYPER_OT_14: u32 = 16384;
pub const GPIO_OTYPER_OT_15: u32 = 32768;
pub const GPIO_OSPEEDR_OSPEED0_Pos: u32 = 0;
pub const GPIO_OSPEEDR_OSPEED0_Msk: u32 = 3;
pub const GPIO_OSPEEDR_OSPEED0: u32 = 3;
pub const GPIO_OSPEEDR_OSPEED0_0: u32 = 1;
pub const GPIO_OSPEEDR_OSPEED0_1: u32 = 2;
pub const GPIO_OSPEEDR_OSPEED1_Pos: u32 = 2;
pub const GPIO_OSPEEDR_OSPEED1_Msk: u32 = 12;
pub const GPIO_OSPEEDR_OSPEED1: u32 = 12;
pub const GPIO_OSPEEDR_OSPEED1_0: u32 = 4;
pub const GPIO_OSPEEDR_OSPEED1_1: u32 = 8;
pub const GPIO_OSPEEDR_OSPEED2_Pos: u32 = 4;
pub const GPIO_OSPEEDR_OSPEED2_Msk: u32 = 48;
pub const GPIO_OSPEEDR_OSPEED2: u32 = 48;
pub const GPIO_OSPEEDR_OSPEED2_0: u32 = 16;
pub const GPIO_OSPEEDR_OSPEED2_1: u32 = 32;
pub const GPIO_OSPEEDR_OSPEED3_Pos: u32 = 6;
pub const GPIO_OSPEEDR_OSPEED3_Msk: u32 = 192;
pub const GPIO_OSPEEDR_OSPEED3: u32 = 192;
pub const GPIO_OSPEEDR_OSPEED3_0: u32 = 64;
pub const GPIO_OSPEEDR_OSPEED3_1: u32 = 128;
pub const GPIO_OSPEEDR_OSPEED4_Pos: u32 = 8;
pub const GPIO_OSPEEDR_OSPEED4_Msk: u32 = 768;
pub const GPIO_OSPEEDR_OSPEED4: u32 = 768;
pub const GPIO_OSPEEDR_OSPEED4_0: u32 = 256;
pub const GPIO_OSPEEDR_OSPEED4_1: u32 = 512;
pub const GPIO_OSPEEDR_OSPEED5_Pos: u32 = 10;
pub const GPIO_OSPEEDR_OSPEED5_Msk: u32 = 3072;
pub const GPIO_OSPEEDR_OSPEED5: u32 = 3072;
pub const GPIO_OSPEEDR_OSPEED5_0: u32 = 1024;
pub const GPIO_OSPEEDR_OSPEED5_1: u32 = 2048;
pub const GPIO_OSPEEDR_OSPEED6_Pos: u32 = 12;
pub const GPIO_OSPEEDR_OSPEED6_Msk: u32 = 12288;
pub const GPIO_OSPEEDR_OSPEED6: u32 = 12288;
pub const GPIO_OSPEEDR_OSPEED6_0: u32 = 4096;
pub const GPIO_OSPEEDR_OSPEED6_1: u32 = 8192;
pub const GPIO_OSPEEDR_OSPEED7_Pos: u32 = 14;
pub const GPIO_OSPEEDR_OSPEED7_Msk: u32 = 49152;
pub const GPIO_OSPEEDR_OSPEED7: u32 = 49152;
pub const GPIO_OSPEEDR_OSPEED7_0: u32 = 16384;
pub const GPIO_OSPEEDR_OSPEED7_1: u32 = 32768;
pub const GPIO_OSPEEDR_OSPEED8_Pos: u32 = 16;
pub const GPIO_OSPEEDR_OSPEED8_Msk: u32 = 196608;
pub const GPIO_OSPEEDR_OSPEED8: u32 = 196608;
pub const GPIO_OSPEEDR_OSPEED8_0: u32 = 65536;
pub const GPIO_OSPEEDR_OSPEED8_1: u32 = 131072;
pub const GPIO_OSPEEDR_OSPEED9_Pos: u32 = 18;
pub const GPIO_OSPEEDR_OSPEED9_Msk: u32 = 786432;
pub const GPIO_OSPEEDR_OSPEED9: u32 = 786432;
pub const GPIO_OSPEEDR_OSPEED9_0: u32 = 262144;
pub const GPIO_OSPEEDR_OSPEED9_1: u32 = 524288;
pub const GPIO_OSPEEDR_OSPEED10_Pos: u32 = 20;
pub const GPIO_OSPEEDR_OSPEED10_Msk: u32 = 3145728;
pub const GPIO_OSPEEDR_OSPEED10: u32 = 3145728;
pub const GPIO_OSPEEDR_OSPEED10_0: u32 = 1048576;
pub const GPIO_OSPEEDR_OSPEED10_1: u32 = 2097152;
pub const GPIO_OSPEEDR_OSPEED11_Pos: u32 = 22;
pub const GPIO_OSPEEDR_OSPEED11_Msk: u32 = 12582912;
pub const GPIO_OSPEEDR_OSPEED11: u32 = 12582912;
pub const GPIO_OSPEEDR_OSPEED11_0: u32 = 4194304;
pub const GPIO_OSPEEDR_OSPEED11_1: u32 = 8388608;
pub const GPIO_OSPEEDR_OSPEED12_Pos: u32 = 24;
pub const GPIO_OSPEEDR_OSPEED12_Msk: u32 = 50331648;
pub const GPIO_OSPEEDR_OSPEED12: u32 = 50331648;
pub const GPIO_OSPEEDR_OSPEED12_0: u32 = 16777216;
pub const GPIO_OSPEEDR_OSPEED12_1: u32 = 33554432;
pub const GPIO_OSPEEDR_OSPEED13_Pos: u32 = 26;
pub const GPIO_OSPEEDR_OSPEED13_Msk: u32 = 201326592;
pub const GPIO_OSPEEDR_OSPEED13: u32 = 201326592;
pub const GPIO_OSPEEDR_OSPEED13_0: u32 = 67108864;
pub const GPIO_OSPEEDR_OSPEED13_1: u32 = 134217728;
pub const GPIO_OSPEEDR_OSPEED14_Pos: u32 = 28;
pub const GPIO_OSPEEDR_OSPEED14_Msk: u32 = 805306368;
pub const GPIO_OSPEEDR_OSPEED14: u32 = 805306368;
pub const GPIO_OSPEEDR_OSPEED14_0: u32 = 268435456;
pub const GPIO_OSPEEDR_OSPEED14_1: u32 = 536870912;
pub const GPIO_OSPEEDR_OSPEED15_Pos: u32 = 30;
pub const GPIO_OSPEEDR_OSPEED15_Msk: u32 = 3221225472;
pub const GPIO_OSPEEDR_OSPEED15: u32 = 3221225472;
pub const GPIO_OSPEEDR_OSPEED15_0: u32 = 1073741824;
pub const GPIO_OSPEEDR_OSPEED15_1: u32 = 2147483648;
pub const GPIO_OSPEEDER_OSPEEDR0: u32 = 3;
pub const GPIO_OSPEEDER_OSPEEDR0_0: u32 = 1;
pub const GPIO_OSPEEDER_OSPEEDR0_1: u32 = 2;
pub const GPIO_OSPEEDER_OSPEEDR1: u32 = 12;
pub const GPIO_OSPEEDER_OSPEEDR1_0: u32 = 4;
pub const GPIO_OSPEEDER_OSPEEDR1_1: u32 = 8;
pub const GPIO_OSPEEDER_OSPEEDR2: u32 = 48;
pub const GPIO_OSPEEDER_OSPEEDR2_0: u32 = 16;
pub const GPIO_OSPEEDER_OSPEEDR2_1: u32 = 32;
pub const GPIO_OSPEEDER_OSPEEDR3: u32 = 192;
pub const GPIO_OSPEEDER_OSPEEDR3_0: u32 = 64;
pub const GPIO_OSPEEDER_OSPEEDR3_1: u32 = 128;
pub const GPIO_OSPEEDER_OSPEEDR4: u32 = 768;
pub const GPIO_OSPEEDER_OSPEEDR4_0: u32 = 256;
pub const GPIO_OSPEEDER_OSPEEDR4_1: u32 = 512;
pub const GPIO_OSPEEDER_OSPEEDR5: u32 = 3072;
pub const GPIO_OSPEEDER_OSPEEDR5_0: u32 = 1024;
pub const GPIO_OSPEEDER_OSPEEDR5_1: u32 = 2048;
pub const GPIO_OSPEEDER_OSPEEDR6: u32 = 12288;
pub const GPIO_OSPEEDER_OSPEEDR6_0: u32 = 4096;
pub const GPIO_OSPEEDER_OSPEEDR6_1: u32 = 8192;
pub const GPIO_OSPEEDER_OSPEEDR7: u32 = 49152;
pub const GPIO_OSPEEDER_OSPEEDR7_0: u32 = 16384;
pub const GPIO_OSPEEDER_OSPEEDR7_1: u32 = 32768;
pub const GPIO_OSPEEDER_OSPEEDR8: u32 = 196608;
pub const GPIO_OSPEEDER_OSPEEDR8_0: u32 = 65536;
pub const GPIO_OSPEEDER_OSPEEDR8_1: u32 = 131072;
pub const GPIO_OSPEEDER_OSPEEDR9: u32 = 786432;
pub const GPIO_OSPEEDER_OSPEEDR9_0: u32 = 262144;
pub const GPIO_OSPEEDER_OSPEEDR9_1: u32 = 524288;
pub const GPIO_OSPEEDER_OSPEEDR10: u32 = 3145728;
pub const GPIO_OSPEEDER_OSPEEDR10_0: u32 = 1048576;
pub const GPIO_OSPEEDER_OSPEEDR10_1: u32 = 2097152;
pub const GPIO_OSPEEDER_OSPEEDR11: u32 = 12582912;
pub const GPIO_OSPEEDER_OSPEEDR11_0: u32 = 4194304;
pub const GPIO_OSPEEDER_OSPEEDR11_1: u32 = 8388608;
pub const GPIO_OSPEEDER_OSPEEDR12: u32 = 50331648;
pub const GPIO_OSPEEDER_OSPEEDR12_0: u32 = 16777216;
pub const GPIO_OSPEEDER_OSPEEDR12_1: u32 = 33554432;
pub const GPIO_OSPEEDER_OSPEEDR13: u32 = 201326592;
pub const GPIO_OSPEEDER_OSPEEDR13_0: u32 = 67108864;
pub const GPIO_OSPEEDER_OSPEEDR13_1: u32 = 134217728;
pub const GPIO_OSPEEDER_OSPEEDR14: u32 = 805306368;
pub const GPIO_OSPEEDER_OSPEEDR14_0: u32 = 268435456;
pub const GPIO_OSPEEDER_OSPEEDR14_1: u32 = 536870912;
pub const GPIO_OSPEEDER_OSPEEDR15: u32 = 3221225472;
pub const GPIO_OSPEEDER_OSPEEDR15_0: u32 = 1073741824;
pub const GPIO_OSPEEDER_OSPEEDR15_1: u32 = 2147483648;
pub const GPIO_PUPDR_PUPD0_Pos: u32 = 0;
pub const GPIO_PUPDR_PUPD0_Msk: u32 = 3;
pub const GPIO_PUPDR_PUPD0: u32 = 3;
pub const GPIO_PUPDR_PUPD0_0: u32 = 1;
pub const GPIO_PUPDR_PUPD0_1: u32 = 2;
pub const GPIO_PUPDR_PUPD1_Pos: u32 = 2;
pub const GPIO_PUPDR_PUPD1_Msk: u32 = 12;
pub const GPIO_PUPDR_PUPD1: u32 = 12;
pub const GPIO_PUPDR_PUPD1_0: u32 = 4;
pub const GPIO_PUPDR_PUPD1_1: u32 = 8;
pub const GPIO_PUPDR_PUPD2_Pos: u32 = 4;
pub const GPIO_PUPDR_PUPD2_Msk: u32 = 48;
pub const GPIO_PUPDR_PUPD2: u32 = 48;
pub const GPIO_PUPDR_PUPD2_0: u32 = 16;
pub const GPIO_PUPDR_PUPD2_1: u32 = 32;
pub const GPIO_PUPDR_PUPD3_Pos: u32 = 6;
pub const GPIO_PUPDR_PUPD3_Msk: u32 = 192;
pub const GPIO_PUPDR_PUPD3: u32 = 192;
pub const GPIO_PUPDR_PUPD3_0: u32 = 64;
pub const GPIO_PUPDR_PUPD3_1: u32 = 128;
pub const GPIO_PUPDR_PUPD4_Pos: u32 = 8;
pub const GPIO_PUPDR_PUPD4_Msk: u32 = 768;
pub const GPIO_PUPDR_PUPD4: u32 = 768;
pub const GPIO_PUPDR_PUPD4_0: u32 = 256;
pub const GPIO_PUPDR_PUPD4_1: u32 = 512;
pub const GPIO_PUPDR_PUPD5_Pos: u32 = 10;
pub const GPIO_PUPDR_PUPD5_Msk: u32 = 3072;
pub const GPIO_PUPDR_PUPD5: u32 = 3072;
pub const GPIO_PUPDR_PUPD5_0: u32 = 1024;
pub const GPIO_PUPDR_PUPD5_1: u32 = 2048;
pub const GPIO_PUPDR_PUPD6_Pos: u32 = 12;
pub const GPIO_PUPDR_PUPD6_Msk: u32 = 12288;
pub const GPIO_PUPDR_PUPD6: u32 = 12288;
pub const GPIO_PUPDR_PUPD6_0: u32 = 4096;
pub const GPIO_PUPDR_PUPD6_1: u32 = 8192;
pub const GPIO_PUPDR_PUPD7_Pos: u32 = 14;
pub const GPIO_PUPDR_PUPD7_Msk: u32 = 49152;
pub const GPIO_PUPDR_PUPD7: u32 = 49152;
pub const GPIO_PUPDR_PUPD7_0: u32 = 16384;
pub const GPIO_PUPDR_PUPD7_1: u32 = 32768;
pub const GPIO_PUPDR_PUPD8_Pos: u32 = 16;
pub const GPIO_PUPDR_PUPD8_Msk: u32 = 196608;
pub const GPIO_PUPDR_PUPD8: u32 = 196608;
pub const GPIO_PUPDR_PUPD8_0: u32 = 65536;
pub const GPIO_PUPDR_PUPD8_1: u32 = 131072;
pub const GPIO_PUPDR_PUPD9_Pos: u32 = 18;
pub const GPIO_PUPDR_PUPD9_Msk: u32 = 786432;
pub const GPIO_PUPDR_PUPD9: u32 = 786432;
pub const GPIO_PUPDR_PUPD9_0: u32 = 262144;
pub const GPIO_PUPDR_PUPD9_1: u32 = 524288;
pub const GPIO_PUPDR_PUPD10_Pos: u32 = 20;
pub const GPIO_PUPDR_PUPD10_Msk: u32 = 3145728;
pub const GPIO_PUPDR_PUPD10: u32 = 3145728;
pub const GPIO_PUPDR_PUPD10_0: u32 = 1048576;
pub const GPIO_PUPDR_PUPD10_1: u32 = 2097152;
pub const GPIO_PUPDR_PUPD11_Pos: u32 = 22;
pub const GPIO_PUPDR_PUPD11_Msk: u32 = 12582912;
pub const GPIO_PUPDR_PUPD11: u32 = 12582912;
pub const GPIO_PUPDR_PUPD11_0: u32 = 4194304;
pub const GPIO_PUPDR_PUPD11_1: u32 = 8388608;
pub const GPIO_PUPDR_PUPD12_Pos: u32 = 24;
pub const GPIO_PUPDR_PUPD12_Msk: u32 = 50331648;
pub const GPIO_PUPDR_PUPD12: u32 = 50331648;
pub const GPIO_PUPDR_PUPD12_0: u32 = 16777216;
pub const GPIO_PUPDR_PUPD12_1: u32 = 33554432;
pub const GPIO_PUPDR_PUPD13_Pos: u32 = 26;
pub const GPIO_PUPDR_PUPD13_Msk: u32 = 201326592;
pub const GPIO_PUPDR_PUPD13: u32 = 201326592;
pub const GPIO_PUPDR_PUPD13_0: u32 = 67108864;
pub const GPIO_PUPDR_PUPD13_1: u32 = 134217728;
pub const GPIO_PUPDR_PUPD14_Pos: u32 = 28;
pub const GPIO_PUPDR_PUPD14_Msk: u32 = 805306368;
pub const GPIO_PUPDR_PUPD14: u32 = 805306368;
pub const GPIO_PUPDR_PUPD14_0: u32 = 268435456;
pub const GPIO_PUPDR_PUPD14_1: u32 = 536870912;
pub const GPIO_PUPDR_PUPD15_Pos: u32 = 30;
pub const GPIO_PUPDR_PUPD15_Msk: u32 = 3221225472;
pub const GPIO_PUPDR_PUPD15: u32 = 3221225472;
pub const GPIO_PUPDR_PUPD15_0: u32 = 1073741824;
pub const GPIO_PUPDR_PUPD15_1: u32 = 2147483648;
pub const GPIO_PUPDR_PUPDR0: u32 = 3;
pub const GPIO_PUPDR_PUPDR0_0: u32 = 1;
pub const GPIO_PUPDR_PUPDR0_1: u32 = 2;
pub const GPIO_PUPDR_PUPDR1: u32 = 12;
pub const GPIO_PUPDR_PUPDR1_0: u32 = 4;
pub const GPIO_PUPDR_PUPDR1_1: u32 = 8;
pub const GPIO_PUPDR_PUPDR2: u32 = 48;
pub const GPIO_PUPDR_PUPDR2_0: u32 = 16;
pub const GPIO_PUPDR_PUPDR2_1: u32 = 32;
pub const GPIO_PUPDR_PUPDR3: u32 = 192;
pub const GPIO_PUPDR_PUPDR3_0: u32 = 64;
pub const GPIO_PUPDR_PUPDR3_1: u32 = 128;
pub const GPIO_PUPDR_PUPDR4: u32 = 768;
pub const GPIO_PUPDR_PUPDR4_0: u32 = 256;
pub const GPIO_PUPDR_PUPDR4_1: u32 = 512;
pub const GPIO_PUPDR_PUPDR5: u32 = 3072;
pub const GPIO_PUPDR_PUPDR5_0: u32 = 1024;
pub const GPIO_PUPDR_PUPDR5_1: u32 = 2048;
pub const GPIO_PUPDR_PUPDR6: u32 = 12288;
pub const GPIO_PUPDR_PUPDR6_0: u32 = 4096;
pub const GPIO_PUPDR_PUPDR6_1: u32 = 8192;
pub const GPIO_PUPDR_PUPDR7: u32 = 49152;
pub const GPIO_PUPDR_PUPDR7_0: u32 = 16384;
pub const GPIO_PUPDR_PUPDR7_1: u32 = 32768;
pub const GPIO_PUPDR_PUPDR8: u32 = 196608;
pub const GPIO_PUPDR_PUPDR8_0: u32 = 65536;
pub const GPIO_PUPDR_PUPDR8_1: u32 = 131072;
pub const GPIO_PUPDR_PUPDR9: u32 = 786432;
pub const GPIO_PUPDR_PUPDR9_0: u32 = 262144;
pub const GPIO_PUPDR_PUPDR9_1: u32 = 524288;
pub const GPIO_PUPDR_PUPDR10: u32 = 3145728;
pub const GPIO_PUPDR_PUPDR10_0: u32 = 1048576;
pub const GPIO_PUPDR_PUPDR10_1: u32 = 2097152;
pub const GPIO_PUPDR_PUPDR11: u32 = 12582912;
pub const GPIO_PUPDR_PUPDR11_0: u32 = 4194304;
pub const GPIO_PUPDR_PUPDR11_1: u32 = 8388608;
pub const GPIO_PUPDR_PUPDR12: u32 = 50331648;
pub const GPIO_PUPDR_PUPDR12_0: u32 = 16777216;
pub const GPIO_PUPDR_PUPDR12_1: u32 = 33554432;
pub const GPIO_PUPDR_PUPDR13: u32 = 201326592;
pub const GPIO_PUPDR_PUPDR13_0: u32 = 67108864;
pub const GPIO_PUPDR_PUPDR13_1: u32 = 134217728;
pub const GPIO_PUPDR_PUPDR14: u32 = 805306368;
pub const GPIO_PUPDR_PUPDR14_0: u32 = 268435456;
pub const GPIO_PUPDR_PUPDR14_1: u32 = 536870912;
pub const GPIO_PUPDR_PUPDR15: u32 = 3221225472;
pub const GPIO_PUPDR_PUPDR15_0: u32 = 1073741824;
pub const GPIO_PUPDR_PUPDR15_1: u32 = 2147483648;
pub const GPIO_IDR_ID0_Pos: u32 = 0;
pub const GPIO_IDR_ID0_Msk: u32 = 1;
pub const GPIO_IDR_ID0: u32 = 1;
pub const GPIO_IDR_ID1_Pos: u32 = 1;
pub const GPIO_IDR_ID1_Msk: u32 = 2;
pub const GPIO_IDR_ID1: u32 = 2;
pub const GPIO_IDR_ID2_Pos: u32 = 2;
pub const GPIO_IDR_ID2_Msk: u32 = 4;
pub const GPIO_IDR_ID2: u32 = 4;
pub const GPIO_IDR_ID3_Pos: u32 = 3;
pub const GPIO_IDR_ID3_Msk: u32 = 8;
pub const GPIO_IDR_ID3: u32 = 8;
pub const GPIO_IDR_ID4_Pos: u32 = 4;
pub const GPIO_IDR_ID4_Msk: u32 = 16;
pub const GPIO_IDR_ID4: u32 = 16;
pub const GPIO_IDR_ID5_Pos: u32 = 5;
pub const GPIO_IDR_ID5_Msk: u32 = 32;
pub const GPIO_IDR_ID5: u32 = 32;
pub const GPIO_IDR_ID6_Pos: u32 = 6;
pub const GPIO_IDR_ID6_Msk: u32 = 64;
pub const GPIO_IDR_ID6: u32 = 64;
pub const GPIO_IDR_ID7_Pos: u32 = 7;
pub const GPIO_IDR_ID7_Msk: u32 = 128;
pub const GPIO_IDR_ID7: u32 = 128;
pub const GPIO_IDR_ID8_Pos: u32 = 8;
pub const GPIO_IDR_ID8_Msk: u32 = 256;
pub const GPIO_IDR_ID8: u32 = 256;
pub const GPIO_IDR_ID9_Pos: u32 = 9;
pub const GPIO_IDR_ID9_Msk: u32 = 512;
pub const GPIO_IDR_ID9: u32 = 512;
pub const GPIO_IDR_ID10_Pos: u32 = 10;
pub const GPIO_IDR_ID10_Msk: u32 = 1024;
pub const GPIO_IDR_ID10: u32 = 1024;
pub const GPIO_IDR_ID11_Pos: u32 = 11;
pub const GPIO_IDR_ID11_Msk: u32 = 2048;
pub const GPIO_IDR_ID11: u32 = 2048;
pub const GPIO_IDR_ID12_Pos: u32 = 12;
pub const GPIO_IDR_ID12_Msk: u32 = 4096;
pub const GPIO_IDR_ID12: u32 = 4096;
pub const GPIO_IDR_ID13_Pos: u32 = 13;
pub const GPIO_IDR_ID13_Msk: u32 = 8192;
pub const GPIO_IDR_ID13: u32 = 8192;
pub const GPIO_IDR_ID14_Pos: u32 = 14;
pub const GPIO_IDR_ID14_Msk: u32 = 16384;
pub const GPIO_IDR_ID14: u32 = 16384;
pub const GPIO_IDR_ID15_Pos: u32 = 15;
pub const GPIO_IDR_ID15_Msk: u32 = 32768;
pub const GPIO_IDR_ID15: u32 = 32768;
pub const GPIO_IDR_IDR_0: u32 = 1;
pub const GPIO_IDR_IDR_1: u32 = 2;
pub const GPIO_IDR_IDR_2: u32 = 4;
pub const GPIO_IDR_IDR_3: u32 = 8;
pub const GPIO_IDR_IDR_4: u32 = 16;
pub const GPIO_IDR_IDR_5: u32 = 32;
pub const GPIO_IDR_IDR_6: u32 = 64;
pub const GPIO_IDR_IDR_7: u32 = 128;
pub const GPIO_IDR_IDR_8: u32 = 256;
pub const GPIO_IDR_IDR_9: u32 = 512;
pub const GPIO_IDR_IDR_10: u32 = 1024;
pub const GPIO_IDR_IDR_11: u32 = 2048;
pub const GPIO_IDR_IDR_12: u32 = 4096;
pub const GPIO_IDR_IDR_13: u32 = 8192;
pub const GPIO_IDR_IDR_14: u32 = 16384;
pub const GPIO_IDR_IDR_15: u32 = 32768;
pub const GPIO_OTYPER_IDR_0: u32 = 1;
pub const GPIO_OTYPER_IDR_1: u32 = 2;
pub const GPIO_OTYPER_IDR_2: u32 = 4;
pub const GPIO_OTYPER_IDR_3: u32 = 8;
pub const GPIO_OTYPER_IDR_4: u32 = 16;
pub const GPIO_OTYPER_IDR_5: u32 = 32;
pub const GPIO_OTYPER_IDR_6: u32 = 64;
pub const GPIO_OTYPER_IDR_7: u32 = 128;
pub const GPIO_OTYPER_IDR_8: u32 = 256;
pub const GPIO_OTYPER_IDR_9: u32 = 512;
pub const GPIO_OTYPER_IDR_10: u32 = 1024;
pub const GPIO_OTYPER_IDR_11: u32 = 2048;
pub const GPIO_OTYPER_IDR_12: u32 = 4096;
pub const GPIO_OTYPER_IDR_13: u32 = 8192;
pub const GPIO_OTYPER_IDR_14: u32 = 16384;
pub const GPIO_OTYPER_IDR_15: u32 = 32768;
pub const GPIO_ODR_OD0_Pos: u32 = 0;
pub const GPIO_ODR_OD0_Msk: u32 = 1;
pub const GPIO_ODR_OD0: u32 = 1;
pub const GPIO_ODR_OD1_Pos: u32 = 1;
pub const GPIO_ODR_OD1_Msk: u32 = 2;
pub const GPIO_ODR_OD1: u32 = 2;
pub const GPIO_ODR_OD2_Pos: u32 = 2;
pub const GPIO_ODR_OD2_Msk: u32 = 4;
pub const GPIO_ODR_OD2: u32 = 4;
pub const GPIO_ODR_OD3_Pos: u32 = 3;
pub const GPIO_ODR_OD3_Msk: u32 = 8;
pub const GPIO_ODR_OD3: u32 = 8;
pub const GPIO_ODR_OD4_Pos: u32 = 4;
pub const GPIO_ODR_OD4_Msk: u32 = 16;
pub const GPIO_ODR_OD4: u32 = 16;
pub const GPIO_ODR_OD5_Pos: u32 = 5;
pub const GPIO_ODR_OD5_Msk: u32 = 32;
pub const GPIO_ODR_OD5: u32 = 32;
pub const GPIO_ODR_OD6_Pos: u32 = 6;
pub const GPIO_ODR_OD6_Msk: u32 = 64;
pub const GPIO_ODR_OD6: u32 = 64;
pub const GPIO_ODR_OD7_Pos: u32 = 7;
pub const GPIO_ODR_OD7_Msk: u32 = 128;
pub const GPIO_ODR_OD7: u32 = 128;
pub const GPIO_ODR_OD8_Pos: u32 = 8;
pub const GPIO_ODR_OD8_Msk: u32 = 256;
pub const GPIO_ODR_OD8: u32 = 256;
pub const GPIO_ODR_OD9_Pos: u32 = 9;
pub const GPIO_ODR_OD9_Msk: u32 = 512;
pub const GPIO_ODR_OD9: u32 = 512;
pub const GPIO_ODR_OD10_Pos: u32 = 10;
pub const GPIO_ODR_OD10_Msk: u32 = 1024;
pub const GPIO_ODR_OD10: u32 = 1024;
pub const GPIO_ODR_OD11_Pos: u32 = 11;
pub const GPIO_ODR_OD11_Msk: u32 = 2048;
pub const GPIO_ODR_OD11: u32 = 2048;
pub const GPIO_ODR_OD12_Pos: u32 = 12;
pub const GPIO_ODR_OD12_Msk: u32 = 4096;
pub const GPIO_ODR_OD12: u32 = 4096;
pub const GPIO_ODR_OD13_Pos: u32 = 13;
pub const GPIO_ODR_OD13_Msk: u32 = 8192;
pub const GPIO_ODR_OD13: u32 = 8192;
pub const GPIO_ODR_OD14_Pos: u32 = 14;
pub const GPIO_ODR_OD14_Msk: u32 = 16384;
pub const GPIO_ODR_OD14: u32 = 16384;
pub const GPIO_ODR_OD15_Pos: u32 = 15;
pub const GPIO_ODR_OD15_Msk: u32 = 32768;
pub const GPIO_ODR_OD15: u32 = 32768;
pub const GPIO_ODR_ODR_0: u32 = 1;
pub const GPIO_ODR_ODR_1: u32 = 2;
pub const GPIO_ODR_ODR_2: u32 = 4;
pub const GPIO_ODR_ODR_3: u32 = 8;
pub const GPIO_ODR_ODR_4: u32 = 16;
pub const GPIO_ODR_ODR_5: u32 = 32;
pub const GPIO_ODR_ODR_6: u32 = 64;
pub const GPIO_ODR_ODR_7: u32 = 128;
pub const GPIO_ODR_ODR_8: u32 = 256;
pub const GPIO_ODR_ODR_9: u32 = 512;
pub const GPIO_ODR_ODR_10: u32 = 1024;
pub const GPIO_ODR_ODR_11: u32 = 2048;
pub const GPIO_ODR_ODR_12: u32 = 4096;
pub const GPIO_ODR_ODR_13: u32 = 8192;
pub const GPIO_ODR_ODR_14: u32 = 16384;
pub const GPIO_ODR_ODR_15: u32 = 32768;
pub const GPIO_OTYPER_ODR_0: u32 = 1;
pub const GPIO_OTYPER_ODR_1: u32 = 2;
pub const GPIO_OTYPER_ODR_2: u32 = 4;
pub const GPIO_OTYPER_ODR_3: u32 = 8;
pub const GPIO_OTYPER_ODR_4: u32 = 16;
pub const GPIO_OTYPER_ODR_5: u32 = 32;
pub const GPIO_OTYPER_ODR_6: u32 = 64;
pub const GPIO_OTYPER_ODR_7: u32 = 128;
pub const GPIO_OTYPER_ODR_8: u32 = 256;
pub const GPIO_OTYPER_ODR_9: u32 = 512;
pub const GPIO_OTYPER_ODR_10: u32 = 1024;
pub const GPIO_OTYPER_ODR_11: u32 = 2048;
pub const GPIO_OTYPER_ODR_12: u32 = 4096;
pub const GPIO_OTYPER_ODR_13: u32 = 8192;
pub const GPIO_OTYPER_ODR_14: u32 = 16384;
pub const GPIO_OTYPER_ODR_15: u32 = 32768;
pub const GPIO_BSRR_BS0_Pos: u32 = 0;
pub const GPIO_BSRR_BS0_Msk: u32 = 1;
pub const GPIO_BSRR_BS0: u32 = 1;
pub const GPIO_BSRR_BS1_Pos: u32 = 1;
pub const GPIO_BSRR_BS1_Msk: u32 = 2;
pub const GPIO_BSRR_BS1: u32 = 2;
pub const GPIO_BSRR_BS2_Pos: u32 = 2;
pub const GPIO_BSRR_BS2_Msk: u32 = 4;
pub const GPIO_BSRR_BS2: u32 = 4;
pub const GPIO_BSRR_BS3_Pos: u32 = 3;
pub const GPIO_BSRR_BS3_Msk: u32 = 8;
pub const GPIO_BSRR_BS3: u32 = 8;
pub const GPIO_BSRR_BS4_Pos: u32 = 4;
pub const GPIO_BSRR_BS4_Msk: u32 = 16;
pub const GPIO_BSRR_BS4: u32 = 16;
pub const GPIO_BSRR_BS5_Pos: u32 = 5;
pub const GPIO_BSRR_BS5_Msk: u32 = 32;
pub const GPIO_BSRR_BS5: u32 = 32;
pub const GPIO_BSRR_BS6_Pos: u32 = 6;
pub const GPIO_BSRR_BS6_Msk: u32 = 64;
pub const GPIO_BSRR_BS6: u32 = 64;
pub const GPIO_BSRR_BS7_Pos: u32 = 7;
pub const GPIO_BSRR_BS7_Msk: u32 = 128;
pub const GPIO_BSRR_BS7: u32 = 128;
pub const GPIO_BSRR_BS8_Pos: u32 = 8;
pub const GPIO_BSRR_BS8_Msk: u32 = 256;
pub const GPIO_BSRR_BS8: u32 = 256;
pub const GPIO_BSRR_BS9_Pos: u32 = 9;
pub const GPIO_BSRR_BS9_Msk: u32 = 512;
pub const GPIO_BSRR_BS9: u32 = 512;
pub const GPIO_BSRR_BS10_Pos: u32 = 10;
pub const GPIO_BSRR_BS10_Msk: u32 = 1024;
pub const GPIO_BSRR_BS10: u32 = 1024;
pub const GPIO_BSRR_BS11_Pos: u32 = 11;
pub const GPIO_BSRR_BS11_Msk: u32 = 2048;
pub const GPIO_BSRR_BS11: u32 = 2048;
pub const GPIO_BSRR_BS12_Pos: u32 = 12;
pub const GPIO_BSRR_BS12_Msk: u32 = 4096;
pub const GPIO_BSRR_BS12: u32 = 4096;
pub const GPIO_BSRR_BS13_Pos: u32 = 13;
pub const GPIO_BSRR_BS13_Msk: u32 = 8192;
pub const GPIO_BSRR_BS13: u32 = 8192;
pub const GPIO_BSRR_BS14_Pos: u32 = 14;
pub const GPIO_BSRR_BS14_Msk: u32 = 16384;
pub const GPIO_BSRR_BS14: u32 = 16384;
pub const GPIO_BSRR_BS15_Pos: u32 = 15;
pub const GPIO_BSRR_BS15_Msk: u32 = 32768;
pub const GPIO_BSRR_BS15: u32 = 32768;
pub const GPIO_BSRR_BR0_Pos: u32 = 16;
pub const GPIO_BSRR_BR0_Msk: u32 = 65536;
pub const GPIO_BSRR_BR0: u32 = 65536;
pub const GPIO_BSRR_BR1_Pos: u32 = 17;
pub const GPIO_BSRR_BR1_Msk: u32 = 131072;
pub const GPIO_BSRR_BR1: u32 = 131072;
pub const GPIO_BSRR_BR2_Pos: u32 = 18;
pub const GPIO_BSRR_BR2_Msk: u32 = 262144;
pub const GPIO_BSRR_BR2: u32 = 262144;
pub const GPIO_BSRR_BR3_Pos: u32 = 19;
pub const GPIO_BSRR_BR3_Msk: u32 = 524288;
pub const GPIO_BSRR_BR3: u32 = 524288;
pub const GPIO_BSRR_BR4_Pos: u32 = 20;
pub const GPIO_BSRR_BR4_Msk: u32 = 1048576;
pub const GPIO_BSRR_BR4: u32 = 1048576;
pub const GPIO_BSRR_BR5_Pos: u32 = 21;
pub const GPIO_BSRR_BR5_Msk: u32 = 2097152;
pub const GPIO_BSRR_BR5: u32 = 2097152;
pub const GPIO_BSRR_BR6_Pos: u32 = 22;
pub const GPIO_BSRR_BR6_Msk: u32 = 4194304;
pub const GPIO_BSRR_BR6: u32 = 4194304;
pub const GPIO_BSRR_BR7_Pos: u32 = 23;
pub const GPIO_BSRR_BR7_Msk: u32 = 8388608;
pub const GPIO_BSRR_BR7: u32 = 8388608;
pub const GPIO_BSRR_BR8_Pos: u32 = 24;
pub const GPIO_BSRR_BR8_Msk: u32 = 16777216;
pub const GPIO_BSRR_BR8: u32 = 16777216;
pub const GPIO_BSRR_BR9_Pos: u32 = 25;
pub const GPIO_BSRR_BR9_Msk: u32 = 33554432;
pub const GPIO_BSRR_BR9: u32 = 33554432;
pub const GPIO_BSRR_BR10_Pos: u32 = 26;
pub const GPIO_BSRR_BR10_Msk: u32 = 67108864;
pub const GPIO_BSRR_BR10: u32 = 67108864;
pub const GPIO_BSRR_BR11_Pos: u32 = 27;
pub const GPIO_BSRR_BR11_Msk: u32 = 134217728;
pub const GPIO_BSRR_BR11: u32 = 134217728;
pub const GPIO_BSRR_BR12_Pos: u32 = 28;
pub const GPIO_BSRR_BR12_Msk: u32 = 268435456;
pub const GPIO_BSRR_BR12: u32 = 268435456;
pub const GPIO_BSRR_BR13_Pos: u32 = 29;
pub const GPIO_BSRR_BR13_Msk: u32 = 536870912;
pub const GPIO_BSRR_BR13: u32 = 536870912;
pub const GPIO_BSRR_BR14_Pos: u32 = 30;
pub const GPIO_BSRR_BR14_Msk: u32 = 1073741824;
pub const GPIO_BSRR_BR14: u32 = 1073741824;
pub const GPIO_BSRR_BR15_Pos: u32 = 31;
pub const GPIO_BSRR_BR15_Msk: u32 = 2147483648;
pub const GPIO_BSRR_BR15: u32 = 2147483648;
pub const GPIO_BSRR_BS_0: u32 = 1;
pub const GPIO_BSRR_BS_1: u32 = 2;
pub const GPIO_BSRR_BS_2: u32 = 4;
pub const GPIO_BSRR_BS_3: u32 = 8;
pub const GPIO_BSRR_BS_4: u32 = 16;
pub const GPIO_BSRR_BS_5: u32 = 32;
pub const GPIO_BSRR_BS_6: u32 = 64;
pub const GPIO_BSRR_BS_7: u32 = 128;
pub const GPIO_BSRR_BS_8: u32 = 256;
pub const GPIO_BSRR_BS_9: u32 = 512;
pub const GPIO_BSRR_BS_10: u32 = 1024;
pub const GPIO_BSRR_BS_11: u32 = 2048;
pub const GPIO_BSRR_BS_12: u32 = 4096;
pub const GPIO_BSRR_BS_13: u32 = 8192;
pub const GPIO_BSRR_BS_14: u32 = 16384;
pub const GPIO_BSRR_BS_15: u32 = 32768;
pub const GPIO_BSRR_BR_0: u32 = 65536;
pub const GPIO_BSRR_BR_1: u32 = 131072;
pub const GPIO_BSRR_BR_2: u32 = 262144;
pub const GPIO_BSRR_BR_3: u32 = 524288;
pub const GPIO_BSRR_BR_4: u32 = 1048576;
pub const GPIO_BSRR_BR_5: u32 = 2097152;
pub const GPIO_BSRR_BR_6: u32 = 4194304;
pub const GPIO_BSRR_BR_7: u32 = 8388608;
pub const GPIO_BSRR_BR_8: u32 = 16777216;
pub const GPIO_BSRR_BR_9: u32 = 33554432;
pub const GPIO_BSRR_BR_10: u32 = 67108864;
pub const GPIO_BSRR_BR_11: u32 = 134217728;
pub const GPIO_BSRR_BR_12: u32 = 268435456;
pub const GPIO_BSRR_BR_13: u32 = 536870912;
pub const GPIO_BSRR_BR_14: u32 = 1073741824;
pub const GPIO_BSRR_BR_15: u32 = 2147483648;
pub const GPIO_LCKR_LCK0_Pos: u32 = 0;
pub const GPIO_LCKR_LCK0_Msk: u32 = 1;
pub const GPIO_LCKR_LCK0: u32 = 1;
pub const GPIO_LCKR_LCK1_Pos: u32 = 1;
pub const GPIO_LCKR_LCK1_Msk: u32 = 2;
pub const GPIO_LCKR_LCK1: u32 = 2;
pub const GPIO_LCKR_LCK2_Pos: u32 = 2;
pub const GPIO_LCKR_LCK2_Msk: u32 = 4;
pub const GPIO_LCKR_LCK2: u32 = 4;
pub const GPIO_LCKR_LCK3_Pos: u32 = 3;
pub const GPIO_LCKR_LCK3_Msk: u32 = 8;
pub const GPIO_LCKR_LCK3: u32 = 8;
pub const GPIO_LCKR_LCK4_Pos: u32 = 4;
pub const GPIO_LCKR_LCK4_Msk: u32 = 16;
pub const GPIO_LCKR_LCK4: u32 = 16;
pub const GPIO_LCKR_LCK5_Pos: u32 = 5;
pub const GPIO_LCKR_LCK5_Msk: u32 = 32;
pub const GPIO_LCKR_LCK5: u32 = 32;
pub const GPIO_LCKR_LCK6_Pos: u32 = 6;
pub const GPIO_LCKR_LCK6_Msk: u32 = 64;
pub const GPIO_LCKR_LCK6: u32 = 64;
pub const GPIO_LCKR_LCK7_Pos: u32 = 7;
pub const GPIO_LCKR_LCK7_Msk: u32 = 128;
pub const GPIO_LCKR_LCK7: u32 = 128;
pub const GPIO_LCKR_LCK8_Pos: u32 = 8;
pub const GPIO_LCKR_LCK8_Msk: u32 = 256;
pub const GPIO_LCKR_LCK8: u32 = 256;
pub const GPIO_LCKR_LCK9_Pos: u32 = 9;
pub const GPIO_LCKR_LCK9_Msk: u32 = 512;
pub const GPIO_LCKR_LCK9: u32 = 512;
pub const GPIO_LCKR_LCK10_Pos: u32 = 10;
pub const GPIO_LCKR_LCK10_Msk: u32 = 1024;
pub const GPIO_LCKR_LCK10: u32 = 1024;
pub const GPIO_LCKR_LCK11_Pos: u32 = 11;
pub const GPIO_LCKR_LCK11_Msk: u32 = 2048;
pub const GPIO_LCKR_LCK11: u32 = 2048;
pub const GPIO_LCKR_LCK12_Pos: u32 = 12;
pub const GPIO_LCKR_LCK12_Msk: u32 = 4096;
pub const GPIO_LCKR_LCK12: u32 = 4096;
pub const GPIO_LCKR_LCK13_Pos: u32 = 13;
pub const GPIO_LCKR_LCK13_Msk: u32 = 8192;
pub const GPIO_LCKR_LCK13: u32 = 8192;
pub const GPIO_LCKR_LCK14_Pos: u32 = 14;
pub const GPIO_LCKR_LCK14_Msk: u32 = 16384;
pub const GPIO_LCKR_LCK14: u32 = 16384;
pub const GPIO_LCKR_LCK15_Pos: u32 = 15;
pub const GPIO_LCKR_LCK15_Msk: u32 = 32768;
pub const GPIO_LCKR_LCK15: u32 = 32768;
pub const GPIO_LCKR_LCKK_Pos: u32 = 16;
pub const GPIO_LCKR_LCKK_Msk: u32 = 65536;
pub const GPIO_LCKR_LCKK: u32 = 65536;
pub const GPIO_AFRL_AFSEL0_Pos: u32 = 0;
pub const GPIO_AFRL_AFSEL0_Msk: u32 = 15;
pub const GPIO_AFRL_AFSEL0: u32 = 15;
pub const GPIO_AFRL_AFSEL0_0: u32 = 1;
pub const GPIO_AFRL_AFSEL0_1: u32 = 2;
pub const GPIO_AFRL_AFSEL0_2: u32 = 4;
pub const GPIO_AFRL_AFSEL0_3: u32 = 8;
pub const GPIO_AFRL_AFSEL1_Pos: u32 = 4;
pub const GPIO_AFRL_AFSEL1_Msk: u32 = 240;
pub const GPIO_AFRL_AFSEL1: u32 = 240;
pub const GPIO_AFRL_AFSEL1_0: u32 = 16;
pub const GPIO_AFRL_AFSEL1_1: u32 = 32;
pub const GPIO_AFRL_AFSEL1_2: u32 = 64;
pub const GPIO_AFRL_AFSEL1_3: u32 = 128;
pub const GPIO_AFRL_AFSEL2_Pos: u32 = 8;
pub const GPIO_AFRL_AFSEL2_Msk: u32 = 3840;
pub const GPIO_AFRL_AFSEL2: u32 = 3840;
pub const GPIO_AFRL_AFSEL2_0: u32 = 256;
pub const GPIO_AFRL_AFSEL2_1: u32 = 512;
pub const GPIO_AFRL_AFSEL2_2: u32 = 1024;
pub const GPIO_AFRL_AFSEL2_3: u32 = 2048;
pub const GPIO_AFRL_AFSEL3_Pos: u32 = 12;
pub const GPIO_AFRL_AFSEL3_Msk: u32 = 61440;
pub const GPIO_AFRL_AFSEL3: u32 = 61440;
pub const GPIO_AFRL_AFSEL3_0: u32 = 4096;
pub const GPIO_AFRL_AFSEL3_1: u32 = 8192;
pub const GPIO_AFRL_AFSEL3_2: u32 = 16384;
pub const GPIO_AFRL_AFSEL3_3: u32 = 32768;
pub const GPIO_AFRL_AFSEL4_Pos: u32 = 16;
pub const GPIO_AFRL_AFSEL4_Msk: u32 = 983040;
pub const GPIO_AFRL_AFSEL4: u32 = 983040;
pub const GPIO_AFRL_AFSEL4_0: u32 = 65536;
pub const GPIO_AFRL_AFSEL4_1: u32 = 131072;
pub const GPIO_AFRL_AFSEL4_2: u32 = 262144;
pub const GPIO_AFRL_AFSEL4_3: u32 = 524288;
pub const GPIO_AFRL_AFSEL5_Pos: u32 = 20;
pub const GPIO_AFRL_AFSEL5_Msk: u32 = 15728640;
pub const GPIO_AFRL_AFSEL5: u32 = 15728640;
pub const GPIO_AFRL_AFSEL5_0: u32 = 1048576;
pub const GPIO_AFRL_AFSEL5_1: u32 = 2097152;
pub const GPIO_AFRL_AFSEL5_2: u32 = 4194304;
pub const GPIO_AFRL_AFSEL5_3: u32 = 8388608;
pub const GPIO_AFRL_AFSEL6_Pos: u32 = 24;
pub const GPIO_AFRL_AFSEL6_Msk: u32 = 251658240;
pub const GPIO_AFRL_AFSEL6: u32 = 251658240;
pub const GPIO_AFRL_AFSEL6_0: u32 = 16777216;
pub const GPIO_AFRL_AFSEL6_1: u32 = 33554432;
pub const GPIO_AFRL_AFSEL6_2: u32 = 67108864;
pub const GPIO_AFRL_AFSEL6_3: u32 = 134217728;
pub const GPIO_AFRL_AFSEL7_Pos: u32 = 28;
pub const GPIO_AFRL_AFSEL7_Msk: u32 = 4026531840;
pub const GPIO_AFRL_AFSEL7: u32 = 4026531840;
pub const GPIO_AFRL_AFSEL7_0: u32 = 268435456;
pub const GPIO_AFRL_AFSEL7_1: u32 = 536870912;
pub const GPIO_AFRL_AFSEL7_2: u32 = 1073741824;
pub const GPIO_AFRL_AFSEL7_3: u32 = 2147483648;
pub const GPIO_AFRL_AFRL0: u32 = 15;
pub const GPIO_AFRL_AFRL1: u32 = 240;
pub const GPIO_AFRL_AFRL2: u32 = 3840;
pub const GPIO_AFRL_AFRL3: u32 = 61440;
pub const GPIO_AFRL_AFRL4: u32 = 983040;
pub const GPIO_AFRL_AFRL5: u32 = 15728640;
pub const GPIO_AFRL_AFRL6: u32 = 251658240;
pub const GPIO_AFRL_AFRL7: u32 = 4026531840;
pub const GPIO_AFRH_AFSEL8_Pos: u32 = 0;
pub const GPIO_AFRH_AFSEL8_Msk: u32 = 15;
pub const GPIO_AFRH_AFSEL8: u32 = 15;
pub const GPIO_AFRH_AFSEL8_0: u32 = 1;
pub const GPIO_AFRH_AFSEL8_1: u32 = 2;
pub const GPIO_AFRH_AFSEL8_2: u32 = 4;
pub const GPIO_AFRH_AFSEL8_3: u32 = 8;
pub const GPIO_AFRH_AFSEL9_Pos: u32 = 4;
pub const GPIO_AFRH_AFSEL9_Msk: u32 = 240;
pub const GPIO_AFRH_AFSEL9: u32 = 240;
pub const GPIO_AFRH_AFSEL9_0: u32 = 16;
pub const GPIO_AFRH_AFSEL9_1: u32 = 32;
pub const GPIO_AFRH_AFSEL9_2: u32 = 64;
pub const GPIO_AFRH_AFSEL9_3: u32 = 128;
pub const GPIO_AFRH_AFSEL10_Pos: u32 = 8;
pub const GPIO_AFRH_AFSEL10_Msk: u32 = 3840;
pub const GPIO_AFRH_AFSEL10: u32 = 3840;
pub const GPIO_AFRH_AFSEL10_0: u32 = 256;
pub const GPIO_AFRH_AFSEL10_1: u32 = 512;
pub const GPIO_AFRH_AFSEL10_2: u32 = 1024;
pub const GPIO_AFRH_AFSEL10_3: u32 = 2048;
pub const GPIO_AFRH_AFSEL11_Pos: u32 = 12;
pub const GPIO_AFRH_AFSEL11_Msk: u32 = 61440;
pub const GPIO_AFRH_AFSEL11: u32 = 61440;
pub const GPIO_AFRH_AFSEL11_0: u32 = 4096;
pub const GPIO_AFRH_AFSEL11_1: u32 = 8192;
pub const GPIO_AFRH_AFSEL11_2: u32 = 16384;
pub const GPIO_AFRH_AFSEL11_3: u32 = 32768;
pub const GPIO_AFRH_AFSEL12_Pos: u32 = 16;
pub const GPIO_AFRH_AFSEL12_Msk: u32 = 983040;
pub const GPIO_AFRH_AFSEL12: u32 = 983040;
pub const GPIO_AFRH_AFSEL12_0: u32 = 65536;
pub const GPIO_AFRH_AFSEL12_1: u32 = 131072;
pub const GPIO_AFRH_AFSEL12_2: u32 = 262144;
pub const GPIO_AFRH_AFSEL12_3: u32 = 524288;
pub const GPIO_AFRH_AFSEL13_Pos: u32 = 20;
pub const GPIO_AFRH_AFSEL13_Msk: u32 = 15728640;
pub const GPIO_AFRH_AFSEL13: u32 = 15728640;
pub const GPIO_AFRH_AFSEL13_0: u32 = 1048576;
pub const GPIO_AFRH_AFSEL13_1: u32 = 2097152;
pub const GPIO_AFRH_AFSEL13_2: u32 = 4194304;
pub const GPIO_AFRH_AFSEL13_3: u32 = 8388608;
pub const GPIO_AFRH_AFSEL14_Pos: u32 = 24;
pub const GPIO_AFRH_AFSEL14_Msk: u32 = 251658240;
pub const GPIO_AFRH_AFSEL14: u32 = 251658240;
pub const GPIO_AFRH_AFSEL14_0: u32 = 16777216;
pub const GPIO_AFRH_AFSEL14_1: u32 = 33554432;
pub const GPIO_AFRH_AFSEL14_2: u32 = 67108864;
pub const GPIO_AFRH_AFSEL14_3: u32 = 134217728;
pub const GPIO_AFRH_AFSEL15_Pos: u32 = 28;
pub const GPIO_AFRH_AFSEL15_Msk: u32 = 4026531840;
pub const GPIO_AFRH_AFSEL15: u32 = 4026531840;
pub const GPIO_AFRH_AFSEL15_0: u32 = 268435456;
pub const GPIO_AFRH_AFSEL15_1: u32 = 536870912;
pub const GPIO_AFRH_AFSEL15_2: u32 = 1073741824;
pub const GPIO_AFRH_AFSEL15_3: u32 = 2147483648;
pub const GPIO_AFRH_AFRH0: u32 = 15;
pub const GPIO_AFRH_AFRH1: u32 = 240;
pub const GPIO_AFRH_AFRH2: u32 = 3840;
pub const GPIO_AFRH_AFRH3: u32 = 61440;
pub const GPIO_AFRH_AFRH4: u32 = 983040;
pub const GPIO_AFRH_AFRH5: u32 = 15728640;
pub const GPIO_AFRH_AFRH6: u32 = 251658240;
pub const GPIO_AFRH_AFRH7: u32 = 4026531840;
pub const GPIO_BRR_BR0_Pos: u32 = 0;
pub const GPIO_BRR_BR0_Msk: u32 = 1;
pub const GPIO_BRR_BR0: u32 = 1;
pub const GPIO_BRR_BR1_Pos: u32 = 1;
pub const GPIO_BRR_BR1_Msk: u32 = 2;
pub const GPIO_BRR_BR1: u32 = 2;
pub const GPIO_BRR_BR2_Pos: u32 = 2;
pub const GPIO_BRR_BR2_Msk: u32 = 4;
pub const GPIO_BRR_BR2: u32 = 4;
pub const GPIO_BRR_BR3_Pos: u32 = 3;
pub const GPIO_BRR_BR3_Msk: u32 = 8;
pub const GPIO_BRR_BR3: u32 = 8;
pub const GPIO_BRR_BR4_Pos: u32 = 4;
pub const GPIO_BRR_BR4_Msk: u32 = 16;
pub const GPIO_BRR_BR4: u32 = 16;
pub const GPIO_BRR_BR5_Pos: u32 = 5;
pub const GPIO_BRR_BR5_Msk: u32 = 32;
pub const GPIO_BRR_BR5: u32 = 32;
pub const GPIO_BRR_BR6_Pos: u32 = 6;
pub const GPIO_BRR_BR6_Msk: u32 = 64;
pub const GPIO_BRR_BR6: u32 = 64;
pub const GPIO_BRR_BR7_Pos: u32 = 7;
pub const GPIO_BRR_BR7_Msk: u32 = 128;
pub const GPIO_BRR_BR7: u32 = 128;
pub const GPIO_BRR_BR8_Pos: u32 = 8;
pub const GPIO_BRR_BR8_Msk: u32 = 256;
pub const GPIO_BRR_BR8: u32 = 256;
pub const GPIO_BRR_BR9_Pos: u32 = 9;
pub const GPIO_BRR_BR9_Msk: u32 = 512;
pub const GPIO_BRR_BR9: u32 = 512;
pub const GPIO_BRR_BR10_Pos: u32 = 10;
pub const GPIO_BRR_BR10_Msk: u32 = 1024;
pub const GPIO_BRR_BR10: u32 = 1024;
pub const GPIO_BRR_BR11_Pos: u32 = 11;
pub const GPIO_BRR_BR11_Msk: u32 = 2048;
pub const GPIO_BRR_BR11: u32 = 2048;
pub const GPIO_BRR_BR12_Pos: u32 = 12;
pub const GPIO_BRR_BR12_Msk: u32 = 4096;
pub const GPIO_BRR_BR12: u32 = 4096;
pub const GPIO_BRR_BR13_Pos: u32 = 13;
pub const GPIO_BRR_BR13_Msk: u32 = 8192;
pub const GPIO_BRR_BR13: u32 = 8192;
pub const GPIO_BRR_BR14_Pos: u32 = 14;
pub const GPIO_BRR_BR14_Msk: u32 = 16384;
pub const GPIO_BRR_BR14: u32 = 16384;
pub const GPIO_BRR_BR15_Pos: u32 = 15;
pub const GPIO_BRR_BR15_Msk: u32 = 32768;
pub const GPIO_BRR_BR15: u32 = 32768;
pub const GPIO_BRR_BR_0: u32 = 1;
pub const GPIO_BRR_BR_1: u32 = 2;
pub const GPIO_BRR_BR_2: u32 = 4;
pub const GPIO_BRR_BR_3: u32 = 8;
pub const GPIO_BRR_BR_4: u32 = 16;
pub const GPIO_BRR_BR_5: u32 = 32;
pub const GPIO_BRR_BR_6: u32 = 64;
pub const GPIO_BRR_BR_7: u32 = 128;
pub const GPIO_BRR_BR_8: u32 = 256;
pub const GPIO_BRR_BR_9: u32 = 512;
pub const GPIO_BRR_BR_10: u32 = 1024;
pub const GPIO_BRR_BR_11: u32 = 2048;
pub const GPIO_BRR_BR_12: u32 = 4096;
pub const GPIO_BRR_BR_13: u32 = 8192;
pub const GPIO_BRR_BR_14: u32 = 16384;
pub const GPIO_BRR_BR_15: u32 = 32768;
pub const GPIO_ASCR_ASC0_Pos: u32 = 0;
pub const GPIO_ASCR_ASC0_Msk: u32 = 1;
pub const GPIO_ASCR_ASC0: u32 = 1;
pub const GPIO_ASCR_ASC1_Pos: u32 = 1;
pub const GPIO_ASCR_ASC1_Msk: u32 = 2;
pub const GPIO_ASCR_ASC1: u32 = 2;
pub const GPIO_ASCR_ASC2_Pos: u32 = 2;
pub const GPIO_ASCR_ASC2_Msk: u32 = 4;
pub const GPIO_ASCR_ASC2: u32 = 4;
pub const GPIO_ASCR_ASC3_Pos: u32 = 3;
pub const GPIO_ASCR_ASC3_Msk: u32 = 8;
pub const GPIO_ASCR_ASC3: u32 = 8;
pub const GPIO_ASCR_ASC4_Pos: u32 = 4;
pub const GPIO_ASCR_ASC4_Msk: u32 = 16;
pub const GPIO_ASCR_ASC4: u32 = 16;
pub const GPIO_ASCR_ASC5_Pos: u32 = 5;
pub const GPIO_ASCR_ASC5_Msk: u32 = 32;
pub const GPIO_ASCR_ASC5: u32 = 32;
pub const GPIO_ASCR_ASC6_Pos: u32 = 6;
pub const GPIO_ASCR_ASC6_Msk: u32 = 64;
pub const GPIO_ASCR_ASC6: u32 = 64;
pub const GPIO_ASCR_ASC7_Pos: u32 = 7;
pub const GPIO_ASCR_ASC7_Msk: u32 = 128;
pub const GPIO_ASCR_ASC7: u32 = 128;
pub const GPIO_ASCR_ASC8_Pos: u32 = 8;
pub const GPIO_ASCR_ASC8_Msk: u32 = 256;
pub const GPIO_ASCR_ASC8: u32 = 256;
pub const GPIO_ASCR_ASC9_Pos: u32 = 9;
pub const GPIO_ASCR_ASC9_Msk: u32 = 512;
pub const GPIO_ASCR_ASC9: u32 = 512;
pub const GPIO_ASCR_ASC10_Pos: u32 = 10;
pub const GPIO_ASCR_ASC10_Msk: u32 = 1024;
pub const GPIO_ASCR_ASC10: u32 = 1024;
pub const GPIO_ASCR_ASC11_Pos: u32 = 11;
pub const GPIO_ASCR_ASC11_Msk: u32 = 2048;
pub const GPIO_ASCR_ASC11: u32 = 2048;
pub const GPIO_ASCR_ASC12_Pos: u32 = 12;
pub const GPIO_ASCR_ASC12_Msk: u32 = 4096;
pub const GPIO_ASCR_ASC12: u32 = 4096;
pub const GPIO_ASCR_ASC13_Pos: u32 = 13;
pub const GPIO_ASCR_ASC13_Msk: u32 = 8192;
pub const GPIO_ASCR_ASC13: u32 = 8192;
pub const GPIO_ASCR_ASC14_Pos: u32 = 14;
pub const GPIO_ASCR_ASC14_Msk: u32 = 16384;
pub const GPIO_ASCR_ASC14: u32 = 16384;
pub const GPIO_ASCR_ASC15_Pos: u32 = 15;
pub const GPIO_ASCR_ASC15_Msk: u32 = 32768;
pub const GPIO_ASCR_ASC15: u32 = 32768;
pub const GPIO_ASCR_EN_0: u32 = 1;
pub const GPIO_ASCR_EN_1: u32 = 2;
pub const GPIO_ASCR_EN_2: u32 = 4;
pub const GPIO_ASCR_EN_3: u32 = 8;
pub const GPIO_ASCR_EN_4: u32 = 16;
pub const GPIO_ASCR_EN_5: u32 = 32;
pub const GPIO_ASCR_EN_6: u32 = 64;
pub const GPIO_ASCR_EN_7: u32 = 128;
pub const GPIO_ASCR_EN_8: u32 = 256;
pub const GPIO_ASCR_EN_9: u32 = 512;
pub const GPIO_ASCR_EN_10: u32 = 1024;
pub const GPIO_ASCR_EN_11: u32 = 2048;
pub const GPIO_ASCR_EN_12: u32 = 4096;
pub const GPIO_ASCR_EN_13: u32 = 8192;
pub const GPIO_ASCR_EN_14: u32 = 16384;
pub const GPIO_ASCR_EN_15: u32 = 32768;
pub const I2C_CR1_PE_Pos: u32 = 0;
pub const I2C_CR1_PE_Msk: u32 = 1;
pub const I2C_CR1_PE: u32 = 1;
pub const I2C_CR1_TXIE_Pos: u32 = 1;
pub const I2C_CR1_TXIE_Msk: u32 = 2;
pub const I2C_CR1_TXIE: u32 = 2;
pub const I2C_CR1_RXIE_Pos: u32 = 2;
pub const I2C_CR1_RXIE_Msk: u32 = 4;
pub const I2C_CR1_RXIE: u32 = 4;
pub const I2C_CR1_ADDRIE_Pos: u32 = 3;
pub const I2C_CR1_ADDRIE_Msk: u32 = 8;
pub const I2C_CR1_ADDRIE: u32 = 8;
pub const I2C_CR1_NACKIE_Pos: u32 = 4;
pub const I2C_CR1_NACKIE_Msk: u32 = 16;
pub const I2C_CR1_NACKIE: u32 = 16;
pub const I2C_CR1_STOPIE_Pos: u32 = 5;
pub const I2C_CR1_STOPIE_Msk: u32 = 32;
pub const I2C_CR1_STOPIE: u32 = 32;
pub const I2C_CR1_TCIE_Pos: u32 = 6;
pub const I2C_CR1_TCIE_Msk: u32 = 64;
pub const I2C_CR1_TCIE: u32 = 64;
pub const I2C_CR1_ERRIE_Pos: u32 = 7;
pub const I2C_CR1_ERRIE_Msk: u32 = 128;
pub const I2C_CR1_ERRIE: u32 = 128;
pub const I2C_CR1_DNF_Pos: u32 = 8;
pub const I2C_CR1_DNF_Msk: u32 = 3840;
pub const I2C_CR1_DNF: u32 = 3840;
pub const I2C_CR1_ANFOFF_Pos: u32 = 12;
pub const I2C_CR1_ANFOFF_Msk: u32 = 4096;
pub const I2C_CR1_ANFOFF: u32 = 4096;
pub const I2C_CR1_SWRST_Pos: u32 = 13;
pub const I2C_CR1_SWRST_Msk: u32 = 8192;
pub const I2C_CR1_SWRST: u32 = 8192;
pub const I2C_CR1_TXDMAEN_Pos: u32 = 14;
pub const I2C_CR1_TXDMAEN_Msk: u32 = 16384;
pub const I2C_CR1_TXDMAEN: u32 = 16384;
pub const I2C_CR1_RXDMAEN_Pos: u32 = 15;
pub const I2C_CR1_RXDMAEN_Msk: u32 = 32768;
pub const I2C_CR1_RXDMAEN: u32 = 32768;
pub const I2C_CR1_SBC_Pos: u32 = 16;
pub const I2C_CR1_SBC_Msk: u32 = 65536;
pub const I2C_CR1_SBC: u32 = 65536;
pub const I2C_CR1_NOSTRETCH_Pos: u32 = 17;
pub const I2C_CR1_NOSTRETCH_Msk: u32 = 131072;
pub const I2C_CR1_NOSTRETCH: u32 = 131072;
pub const I2C_CR1_WUPEN_Pos: u32 = 18;
pub const I2C_CR1_WUPEN_Msk: u32 = 262144;
pub const I2C_CR1_WUPEN: u32 = 262144;
pub const I2C_CR1_GCEN_Pos: u32 = 19;
pub const I2C_CR1_GCEN_Msk: u32 = 524288;
pub const I2C_CR1_GCEN: u32 = 524288;
pub const I2C_CR1_SMBHEN_Pos: u32 = 20;
pub const I2C_CR1_SMBHEN_Msk: u32 = 1048576;
pub const I2C_CR1_SMBHEN: u32 = 1048576;
pub const I2C_CR1_SMBDEN_Pos: u32 = 21;
pub const I2C_CR1_SMBDEN_Msk: u32 = 2097152;
pub const I2C_CR1_SMBDEN: u32 = 2097152;
pub const I2C_CR1_ALERTEN_Pos: u32 = 22;
pub const I2C_CR1_ALERTEN_Msk: u32 = 4194304;
pub const I2C_CR1_ALERTEN: u32 = 4194304;
pub const I2C_CR1_PECEN_Pos: u32 = 23;
pub const I2C_CR1_PECEN_Msk: u32 = 8388608;
pub const I2C_CR1_PECEN: u32 = 8388608;
pub const I2C_CR2_SADD_Pos: u32 = 0;
pub const I2C_CR2_SADD_Msk: u32 = 1023;
pub const I2C_CR2_SADD: u32 = 1023;
pub const I2C_CR2_RD_WRN_Pos: u32 = 10;
pub const I2C_CR2_RD_WRN_Msk: u32 = 1024;
pub const I2C_CR2_RD_WRN: u32 = 1024;
pub const I2C_CR2_ADD10_Pos: u32 = 11;
pub const I2C_CR2_ADD10_Msk: u32 = 2048;
pub const I2C_CR2_ADD10: u32 = 2048;
pub const I2C_CR2_HEAD10R_Pos: u32 = 12;
pub const I2C_CR2_HEAD10R_Msk: u32 = 4096;
pub const I2C_CR2_HEAD10R: u32 = 4096;
pub const I2C_CR2_START_Pos: u32 = 13;
pub const I2C_CR2_START_Msk: u32 = 8192;
pub const I2C_CR2_START: u32 = 8192;
pub const I2C_CR2_STOP_Pos: u32 = 14;
pub const I2C_CR2_STOP_Msk: u32 = 16384;
pub const I2C_CR2_STOP: u32 = 16384;
pub const I2C_CR2_NACK_Pos: u32 = 15;
pub const I2C_CR2_NACK_Msk: u32 = 32768;
pub const I2C_CR2_NACK: u32 = 32768;
pub const I2C_CR2_NBYTES_Pos: u32 = 16;
pub const I2C_CR2_NBYTES_Msk: u32 = 16711680;
pub const I2C_CR2_NBYTES: u32 = 16711680;
pub const I2C_CR2_RELOAD_Pos: u32 = 24;
pub const I2C_CR2_RELOAD_Msk: u32 = 16777216;
pub const I2C_CR2_RELOAD: u32 = 16777216;
pub const I2C_CR2_AUTOEND_Pos: u32 = 25;
pub const I2C_CR2_AUTOEND_Msk: u32 = 33554432;
pub const I2C_CR2_AUTOEND: u32 = 33554432;
pub const I2C_CR2_PECBYTE_Pos: u32 = 26;
pub const I2C_CR2_PECBYTE_Msk: u32 = 67108864;
pub const I2C_CR2_PECBYTE: u32 = 67108864;
pub const I2C_OAR1_OA1_Pos: u32 = 0;
pub const I2C_OAR1_OA1_Msk: u32 = 1023;
pub const I2C_OAR1_OA1: u32 = 1023;
pub const I2C_OAR1_OA1MODE_Pos: u32 = 10;
pub const I2C_OAR1_OA1MODE_Msk: u32 = 1024;
pub const I2C_OAR1_OA1MODE: u32 = 1024;
pub const I2C_OAR1_OA1EN_Pos: u32 = 15;
pub const I2C_OAR1_OA1EN_Msk: u32 = 32768;
pub const I2C_OAR1_OA1EN: u32 = 32768;
pub const I2C_OAR2_OA2_Pos: u32 = 1;
pub const I2C_OAR2_OA2_Msk: u32 = 254;
pub const I2C_OAR2_OA2: u32 = 254;
pub const I2C_OAR2_OA2MSK_Pos: u32 = 8;
pub const I2C_OAR2_OA2MSK_Msk: u32 = 1792;
pub const I2C_OAR2_OA2MSK: u32 = 1792;
pub const I2C_OAR2_OA2NOMASK: u32 = 0;
pub const I2C_OAR2_OA2MASK01_Pos: u32 = 8;
pub const I2C_OAR2_OA2MASK01_Msk: u32 = 256;
pub const I2C_OAR2_OA2MASK01: u32 = 256;
pub const I2C_OAR2_OA2MASK02_Pos: u32 = 9;
pub const I2C_OAR2_OA2MASK02_Msk: u32 = 512;
pub const I2C_OAR2_OA2MASK02: u32 = 512;
pub const I2C_OAR2_OA2MASK03_Pos: u32 = 8;
pub const I2C_OAR2_OA2MASK03_Msk: u32 = 768;
pub const I2C_OAR2_OA2MASK03: u32 = 768;
pub const I2C_OAR2_OA2MASK04_Pos: u32 = 10;
pub const I2C_OAR2_OA2MASK04_Msk: u32 = 1024;
pub const I2C_OAR2_OA2MASK04: u32 = 1024;
pub const I2C_OAR2_OA2MASK05_Pos: u32 = 8;
pub const I2C_OAR2_OA2MASK05_Msk: u32 = 1280;
pub const I2C_OAR2_OA2MASK05: u32 = 1280;
pub const I2C_OAR2_OA2MASK06_Pos: u32 = 9;
pub const I2C_OAR2_OA2MASK06_Msk: u32 = 1536;
pub const I2C_OAR2_OA2MASK06: u32 = 1536;
pub const I2C_OAR2_OA2MASK07_Pos: u32 = 8;
pub const I2C_OAR2_OA2MASK07_Msk: u32 = 1792;
pub const I2C_OAR2_OA2MASK07: u32 = 1792;
pub const I2C_OAR2_OA2EN_Pos: u32 = 15;
pub const I2C_OAR2_OA2EN_Msk: u32 = 32768;
pub const I2C_OAR2_OA2EN: u32 = 32768;
pub const I2C_TIMINGR_SCLL_Pos: u32 = 0;
pub const I2C_TIMINGR_SCLL_Msk: u32 = 255;
pub const I2C_TIMINGR_SCLL: u32 = 255;
pub const I2C_TIMINGR_SCLH_Pos: u32 = 8;
pub const I2C_TIMINGR_SCLH_Msk: u32 = 65280;
pub const I2C_TIMINGR_SCLH: u32 = 65280;
pub const I2C_TIMINGR_SDADEL_Pos: u32 = 16;
pub const I2C_TIMINGR_SDADEL_Msk: u32 = 983040;
pub const I2C_TIMINGR_SDADEL: u32 = 983040;
pub const I2C_TIMINGR_SCLDEL_Pos: u32 = 20;
pub const I2C_TIMINGR_SCLDEL_Msk: u32 = 15728640;
pub const I2C_TIMINGR_SCLDEL: u32 = 15728640;
pub const I2C_TIMINGR_PRESC_Pos: u32 = 28;
pub const I2C_TIMINGR_PRESC_Msk: u32 = 4026531840;
pub const I2C_TIMINGR_PRESC: u32 = 4026531840;
pub const I2C_TIMEOUTR_TIMEOUTA_Pos: u32 = 0;
pub const I2C_TIMEOUTR_TIMEOUTA_Msk: u32 = 4095;
pub const I2C_TIMEOUTR_TIMEOUTA: u32 = 4095;
pub const I2C_TIMEOUTR_TIDLE_Pos: u32 = 12;
pub const I2C_TIMEOUTR_TIDLE_Msk: u32 = 4096;
pub const I2C_TIMEOUTR_TIDLE: u32 = 4096;
pub const I2C_TIMEOUTR_TIMOUTEN_Pos: u32 = 15;
pub const I2C_TIMEOUTR_TIMOUTEN_Msk: u32 = 32768;
pub const I2C_TIMEOUTR_TIMOUTEN: u32 = 32768;
pub const I2C_TIMEOUTR_TIMEOUTB_Pos: u32 = 16;
pub const I2C_TIMEOUTR_TIMEOUTB_Msk: u32 = 268369920;
pub const I2C_TIMEOUTR_TIMEOUTB: u32 = 268369920;
pub const I2C_TIMEOUTR_TEXTEN_Pos: u32 = 31;
pub const I2C_TIMEOUTR_TEXTEN_Msk: u32 = 2147483648;
pub const I2C_TIMEOUTR_TEXTEN: u32 = 2147483648;
pub const I2C_ISR_TXE_Pos: u32 = 0;
pub const I2C_ISR_TXE_Msk: u32 = 1;
pub const I2C_ISR_TXE: u32 = 1;
pub const I2C_ISR_TXIS_Pos: u32 = 1;
pub const I2C_ISR_TXIS_Msk: u32 = 2;
pub const I2C_ISR_TXIS: u32 = 2;
pub const I2C_ISR_RXNE_Pos: u32 = 2;
pub const I2C_ISR_RXNE_Msk: u32 = 4;
pub const I2C_ISR_RXNE: u32 = 4;
pub const I2C_ISR_ADDR_Pos: u32 = 3;
pub const I2C_ISR_ADDR_Msk: u32 = 8;
pub const I2C_ISR_ADDR: u32 = 8;
pub const I2C_ISR_NACKF_Pos: u32 = 4;
pub const I2C_ISR_NACKF_Msk: u32 = 16;
pub const I2C_ISR_NACKF: u32 = 16;
pub const I2C_ISR_STOPF_Pos: u32 = 5;
pub const I2C_ISR_STOPF_Msk: u32 = 32;
pub const I2C_ISR_STOPF: u32 = 32;
pub const I2C_ISR_TC_Pos: u32 = 6;
pub const I2C_ISR_TC_Msk: u32 = 64;
pub const I2C_ISR_TC: u32 = 64;
pub const I2C_ISR_TCR_Pos: u32 = 7;
pub const I2C_ISR_TCR_Msk: u32 = 128;
pub const I2C_ISR_TCR: u32 = 128;
pub const I2C_ISR_BERR_Pos: u32 = 8;
pub const I2C_ISR_BERR_Msk: u32 = 256;
pub const I2C_ISR_BERR: u32 = 256;
pub const I2C_ISR_ARLO_Pos: u32 = 9;
pub const I2C_ISR_ARLO_Msk: u32 = 512;
pub const I2C_ISR_ARLO: u32 = 512;
pub const I2C_ISR_OVR_Pos: u32 = 10;
pub const I2C_ISR_OVR_Msk: u32 = 1024;
pub const I2C_ISR_OVR: u32 = 1024;
pub const I2C_ISR_PECERR_Pos: u32 = 11;
pub const I2C_ISR_PECERR_Msk: u32 = 2048;
pub const I2C_ISR_PECERR: u32 = 2048;
pub const I2C_ISR_TIMEOUT_Pos: u32 = 12;
pub const I2C_ISR_TIMEOUT_Msk: u32 = 4096;
pub const I2C_ISR_TIMEOUT: u32 = 4096;
pub const I2C_ISR_ALERT_Pos: u32 = 13;
pub const I2C_ISR_ALERT_Msk: u32 = 8192;
pub const I2C_ISR_ALERT: u32 = 8192;
pub const I2C_ISR_BUSY_Pos: u32 = 15;
pub const I2C_ISR_BUSY_Msk: u32 = 32768;
pub const I2C_ISR_BUSY: u32 = 32768;
pub const I2C_ISR_DIR_Pos: u32 = 16;
pub const I2C_ISR_DIR_Msk: u32 = 65536;
pub const I2C_ISR_DIR: u32 = 65536;
pub const I2C_ISR_ADDCODE_Pos: u32 = 17;
pub const I2C_ISR_ADDCODE_Msk: u32 = 16646144;
pub const I2C_ISR_ADDCODE: u32 = 16646144;
pub const I2C_ICR_ADDRCF_Pos: u32 = 3;
pub const I2C_ICR_ADDRCF_Msk: u32 = 8;
pub const I2C_ICR_ADDRCF: u32 = 8;
pub const I2C_ICR_NACKCF_Pos: u32 = 4;
pub const I2C_ICR_NACKCF_Msk: u32 = 16;
pub const I2C_ICR_NACKCF: u32 = 16;
pub const I2C_ICR_STOPCF_Pos: u32 = 5;
pub const I2C_ICR_STOPCF_Msk: u32 = 32;
pub const I2C_ICR_STOPCF: u32 = 32;
pub const I2C_ICR_BERRCF_Pos: u32 = 8;
pub const I2C_ICR_BERRCF_Msk: u32 = 256;
pub const I2C_ICR_BERRCF: u32 = 256;
pub const I2C_ICR_ARLOCF_Pos: u32 = 9;
pub const I2C_ICR_ARLOCF_Msk: u32 = 512;
pub const I2C_ICR_ARLOCF: u32 = 512;
pub const I2C_ICR_OVRCF_Pos: u32 = 10;
pub const I2C_ICR_OVRCF_Msk: u32 = 1024;
pub const I2C_ICR_OVRCF: u32 = 1024;
pub const I2C_ICR_PECCF_Pos: u32 = 11;
pub const I2C_ICR_PECCF_Msk: u32 = 2048;
pub const I2C_ICR_PECCF: u32 = 2048;
pub const I2C_ICR_TIMOUTCF_Pos: u32 = 12;
pub const I2C_ICR_TIMOUTCF_Msk: u32 = 4096;
pub const I2C_ICR_TIMOUTCF: u32 = 4096;
pub const I2C_ICR_ALERTCF_Pos: u32 = 13;
pub const I2C_ICR_ALERTCF_Msk: u32 = 8192;
pub const I2C_ICR_ALERTCF: u32 = 8192;
pub const I2C_PECR_PEC_Pos: u32 = 0;
pub const I2C_PECR_PEC_Msk: u32 = 255;
pub const I2C_PECR_PEC: u32 = 255;
pub const I2C_RXDR_RXDATA_Pos: u32 = 0;
pub const I2C_RXDR_RXDATA_Msk: u32 = 255;
pub const I2C_RXDR_RXDATA: u32 = 255;
pub const I2C_TXDR_TXDATA_Pos: u32 = 0;
pub const I2C_TXDR_TXDATA_Msk: u32 = 255;
pub const I2C_TXDR_TXDATA: u32 = 255;
pub const IWDG_KR_KEY_Pos: u32 = 0;
pub const IWDG_KR_KEY_Msk: u32 = 65535;
pub const IWDG_KR_KEY: u32 = 65535;
pub const IWDG_PR_PR_Pos: u32 = 0;
pub const IWDG_PR_PR_Msk: u32 = 7;
pub const IWDG_PR_PR: u32 = 7;
pub const IWDG_PR_PR_0: u32 = 1;
pub const IWDG_PR_PR_1: u32 = 2;
pub const IWDG_PR_PR_2: u32 = 4;
pub const IWDG_RLR_RL_Pos: u32 = 0;
pub const IWDG_RLR_RL_Msk: u32 = 4095;
pub const IWDG_RLR_RL: u32 = 4095;
pub const IWDG_SR_PVU_Pos: u32 = 0;
pub const IWDG_SR_PVU_Msk: u32 = 1;
pub const IWDG_SR_PVU: u32 = 1;
pub const IWDG_SR_RVU_Pos: u32 = 1;
pub const IWDG_SR_RVU_Msk: u32 = 2;
pub const IWDG_SR_RVU: u32 = 2;
pub const IWDG_SR_WVU_Pos: u32 = 2;
pub const IWDG_SR_WVU_Msk: u32 = 4;
pub const IWDG_SR_WVU: u32 = 4;
pub const IWDG_WINR_WIN_Pos: u32 = 0;
pub const IWDG_WINR_WIN_Msk: u32 = 4095;
pub const IWDG_WINR_WIN: u32 = 4095;
pub const FW_CSSA_ADD_Pos: u32 = 8;
pub const FW_CSSA_ADD_Msk: u32 = 16776960;
pub const FW_CSSA_ADD: u32 = 16776960;
pub const FW_CSL_LENG_Pos: u32 = 8;
pub const FW_CSL_LENG_Msk: u32 = 4194048;
pub const FW_CSL_LENG: u32 = 4194048;
pub const FW_NVDSSA_ADD_Pos: u32 = 8;
pub const FW_NVDSSA_ADD_Msk: u32 = 16776960;
pub const FW_NVDSSA_ADD: u32 = 16776960;
pub const FW_NVDSL_LENG_Pos: u32 = 8;
pub const FW_NVDSL_LENG_Msk: u32 = 4194048;
pub const FW_NVDSL_LENG: u32 = 4194048;
pub const FW_VDSSA_ADD_Pos: u32 = 6;
pub const FW_VDSSA_ADD_Msk: u32 = 131008;
pub const FW_VDSSA_ADD: u32 = 131008;
pub const FW_VDSL_LENG_Pos: u32 = 6;
pub const FW_VDSL_LENG_Msk: u32 = 131008;
pub const FW_VDSL_LENG: u32 = 131008;
pub const FW_CR_FPA_Pos: u32 = 0;
pub const FW_CR_FPA_Msk: u32 = 1;
pub const FW_CR_FPA: u32 = 1;
pub const FW_CR_VDS_Pos: u32 = 1;
pub const FW_CR_VDS_Msk: u32 = 2;
pub const FW_CR_VDS: u32 = 2;
pub const FW_CR_VDE_Pos: u32 = 2;
pub const FW_CR_VDE_Msk: u32 = 4;
pub const FW_CR_VDE: u32 = 4;
pub const PWR_CR1_LPR_Pos: u32 = 14;
pub const PWR_CR1_LPR_Msk: u32 = 16384;
pub const PWR_CR1_LPR: u32 = 16384;
pub const PWR_CR1_VOS_Pos: u32 = 9;
pub const PWR_CR1_VOS_Msk: u32 = 1536;
pub const PWR_CR1_VOS: u32 = 1536;
pub const PWR_CR1_VOS_0: u32 = 512;
pub const PWR_CR1_VOS_1: u32 = 1024;
pub const PWR_CR1_DBP_Pos: u32 = 8;
pub const PWR_CR1_DBP_Msk: u32 = 256;
pub const PWR_CR1_DBP: u32 = 256;
pub const PWR_CR1_LPMS_Pos: u32 = 0;
pub const PWR_CR1_LPMS_Msk: u32 = 7;
pub const PWR_CR1_LPMS: u32 = 7;
pub const PWR_CR1_LPMS_STOP0: u32 = 0;
pub const PWR_CR1_LPMS_STOP1_Pos: u32 = 0;
pub const PWR_CR1_LPMS_STOP1_Msk: u32 = 1;
pub const PWR_CR1_LPMS_STOP1: u32 = 1;
pub const PWR_CR1_LPMS_STOP2_Pos: u32 = 1;
pub const PWR_CR1_LPMS_STOP2_Msk: u32 = 2;
pub const PWR_CR1_LPMS_STOP2: u32 = 2;
pub const PWR_CR1_LPMS_STANDBY_Pos: u32 = 0;
pub const PWR_CR1_LPMS_STANDBY_Msk: u32 = 3;
pub const PWR_CR1_LPMS_STANDBY: u32 = 3;
pub const PWR_CR1_LPMS_SHUTDOWN_Pos: u32 = 2;
pub const PWR_CR1_LPMS_SHUTDOWN_Msk: u32 = 4;
pub const PWR_CR1_LPMS_SHUTDOWN: u32 = 4;
pub const PWR_CR2_USV_Pos: u32 = 10;
pub const PWR_CR2_USV_Msk: u32 = 1024;
pub const PWR_CR2_USV: u32 = 1024;
pub const PWR_CR2_IOSV_Pos: u32 = 9;
pub const PWR_CR2_IOSV_Msk: u32 = 512;
pub const PWR_CR2_IOSV: u32 = 512;
pub const PWR_CR2_PVME_Pos: u32 = 4;
pub const PWR_CR2_PVME_Msk: u32 = 240;
pub const PWR_CR2_PVME: u32 = 240;
pub const PWR_CR2_PVME4_Pos: u32 = 7;
pub const PWR_CR2_PVME4_Msk: u32 = 128;
pub const PWR_CR2_PVME4: u32 = 128;
pub const PWR_CR2_PVME3_Pos: u32 = 6;
pub const PWR_CR2_PVME3_Msk: u32 = 64;
pub const PWR_CR2_PVME3: u32 = 64;
pub const PWR_CR2_PVME2_Pos: u32 = 5;
pub const PWR_CR2_PVME2_Msk: u32 = 32;
pub const PWR_CR2_PVME2: u32 = 32;
pub const PWR_CR2_PVME1_Pos: u32 = 4;
pub const PWR_CR2_PVME1_Msk: u32 = 16;
pub const PWR_CR2_PVME1: u32 = 16;
pub const PWR_CR2_PLS_Pos: u32 = 1;
pub const PWR_CR2_PLS_Msk: u32 = 14;
pub const PWR_CR2_PLS: u32 = 14;
pub const PWR_CR2_PLS_LEV0: u32 = 0;
pub const PWR_CR2_PLS_LEV1_Pos: u32 = 1;
pub const PWR_CR2_PLS_LEV1_Msk: u32 = 2;
pub const PWR_CR2_PLS_LEV1: u32 = 2;
pub const PWR_CR2_PLS_LEV2_Pos: u32 = 2;
pub const PWR_CR2_PLS_LEV2_Msk: u32 = 4;
pub const PWR_CR2_PLS_LEV2: u32 = 4;
pub const PWR_CR2_PLS_LEV3_Pos: u32 = 1;
pub const PWR_CR2_PLS_LEV3_Msk: u32 = 6;
pub const PWR_CR2_PLS_LEV3: u32 = 6;
pub const PWR_CR2_PLS_LEV4_Pos: u32 = 3;
pub const PWR_CR2_PLS_LEV4_Msk: u32 = 8;
pub const PWR_CR2_PLS_LEV4: u32 = 8;
pub const PWR_CR2_PLS_LEV5_Pos: u32 = 1;
pub const PWR_CR2_PLS_LEV5_Msk: u32 = 10;
pub const PWR_CR2_PLS_LEV5: u32 = 10;
pub const PWR_CR2_PLS_LEV6_Pos: u32 = 2;
pub const PWR_CR2_PLS_LEV6_Msk: u32 = 12;
pub const PWR_CR2_PLS_LEV6: u32 = 12;
pub const PWR_CR2_PLS_LEV7_Pos: u32 = 1;
pub const PWR_CR2_PLS_LEV7_Msk: u32 = 14;
pub const PWR_CR2_PLS_LEV7: u32 = 14;
pub const PWR_CR2_PVDE_Pos: u32 = 0;
pub const PWR_CR2_PVDE_Msk: u32 = 1;
pub const PWR_CR2_PVDE: u32 = 1;
pub const PWR_CR3_EIWUL_Pos: u32 = 15;
pub const PWR_CR3_EIWUL_Msk: u32 = 32768;
pub const PWR_CR3_EIWUL: u32 = 32768;
pub const PWR_CR3_APC_Pos: u32 = 10;
pub const PWR_CR3_APC_Msk: u32 = 1024;
pub const PWR_CR3_APC: u32 = 1024;
pub const PWR_CR3_RRS_Pos: u32 = 8;
pub const PWR_CR3_RRS_Msk: u32 = 256;
pub const PWR_CR3_RRS: u32 = 256;
pub const PWR_CR3_EWUP5_Pos: u32 = 4;
pub const PWR_CR3_EWUP5_Msk: u32 = 16;
pub const PWR_CR3_EWUP5: u32 = 16;
pub const PWR_CR3_EWUP4_Pos: u32 = 3;
pub const PWR_CR3_EWUP4_Msk: u32 = 8;
pub const PWR_CR3_EWUP4: u32 = 8;
pub const PWR_CR3_EWUP3_Pos: u32 = 2;
pub const PWR_CR3_EWUP3_Msk: u32 = 4;
pub const PWR_CR3_EWUP3: u32 = 4;
pub const PWR_CR3_EWUP2_Pos: u32 = 1;
pub const PWR_CR3_EWUP2_Msk: u32 = 2;
pub const PWR_CR3_EWUP2: u32 = 2;
pub const PWR_CR3_EWUP1_Pos: u32 = 0;
pub const PWR_CR3_EWUP1_Msk: u32 = 1;
pub const PWR_CR3_EWUP1: u32 = 1;
pub const PWR_CR3_EWUP_Pos: u32 = 0;
pub const PWR_CR3_EWUP_Msk: u32 = 31;
pub const PWR_CR3_EWUP: u32 = 31;
pub const PWR_CR3_EIWF_Pos: u32 = 15;
pub const PWR_CR3_EIWF_Msk: u32 = 32768;
pub const PWR_CR3_EIWF: u32 = 32768;
pub const PWR_CR4_VBRS_Pos: u32 = 9;
pub const PWR_CR4_VBRS_Msk: u32 = 512;
pub const PWR_CR4_VBRS: u32 = 512;
pub const PWR_CR4_VBE_Pos: u32 = 8;
pub const PWR_CR4_VBE_Msk: u32 = 256;
pub const PWR_CR4_VBE: u32 = 256;
pub const PWR_CR4_WP5_Pos: u32 = 4;
pub const PWR_CR4_WP5_Msk: u32 = 16;
pub const PWR_CR4_WP5: u32 = 16;
pub const PWR_CR4_WP4_Pos: u32 = 3;
pub const PWR_CR4_WP4_Msk: u32 = 8;
pub const PWR_CR4_WP4: u32 = 8;
pub const PWR_CR4_WP3_Pos: u32 = 2;
pub const PWR_CR4_WP3_Msk: u32 = 4;
pub const PWR_CR4_WP3: u32 = 4;
pub const PWR_CR4_WP2_Pos: u32 = 1;
pub const PWR_CR4_WP2_Msk: u32 = 2;
pub const PWR_CR4_WP2: u32 = 2;
pub const PWR_CR4_WP1_Pos: u32 = 0;
pub const PWR_CR4_WP1_Msk: u32 = 1;
pub const PWR_CR4_WP1: u32 = 1;
pub const PWR_SR1_WUFI_Pos: u32 = 15;
pub const PWR_SR1_WUFI_Msk: u32 = 32768;
pub const PWR_SR1_WUFI: u32 = 32768;
pub const PWR_SR1_SBF_Pos: u32 = 8;
pub const PWR_SR1_SBF_Msk: u32 = 256;
pub const PWR_SR1_SBF: u32 = 256;
pub const PWR_SR1_WUF_Pos: u32 = 0;
pub const PWR_SR1_WUF_Msk: u32 = 31;
pub const PWR_SR1_WUF: u32 = 31;
pub const PWR_SR1_WUF5_Pos: u32 = 4;
pub const PWR_SR1_WUF5_Msk: u32 = 16;
pub const PWR_SR1_WUF5: u32 = 16;
pub const PWR_SR1_WUF4_Pos: u32 = 3;
pub const PWR_SR1_WUF4_Msk: u32 = 8;
pub const PWR_SR1_WUF4: u32 = 8;
pub const PWR_SR1_WUF3_Pos: u32 = 2;
pub const PWR_SR1_WUF3_Msk: u32 = 4;
pub const PWR_SR1_WUF3: u32 = 4;
pub const PWR_SR1_WUF2_Pos: u32 = 1;
pub const PWR_SR1_WUF2_Msk: u32 = 2;
pub const PWR_SR1_WUF2: u32 = 2;
pub const PWR_SR1_WUF1_Pos: u32 = 0;
pub const PWR_SR1_WUF1_Msk: u32 = 1;
pub const PWR_SR1_WUF1: u32 = 1;
pub const PWR_SR2_PVMO4_Pos: u32 = 15;
pub const PWR_SR2_PVMO4_Msk: u32 = 32768;
pub const PWR_SR2_PVMO4: u32 = 32768;
pub const PWR_SR2_PVMO3_Pos: u32 = 14;
pub const PWR_SR2_PVMO3_Msk: u32 = 16384;
pub const PWR_SR2_PVMO3: u32 = 16384;
pub const PWR_SR2_PVMO2_Pos: u32 = 13;
pub const PWR_SR2_PVMO2_Msk: u32 = 8192;
pub const PWR_SR2_PVMO2: u32 = 8192;
pub const PWR_SR2_PVMO1_Pos: u32 = 12;
pub const PWR_SR2_PVMO1_Msk: u32 = 4096;
pub const PWR_SR2_PVMO1: u32 = 4096;
pub const PWR_SR2_PVDO_Pos: u32 = 11;
pub const PWR_SR2_PVDO_Msk: u32 = 2048;
pub const PWR_SR2_PVDO: u32 = 2048;
pub const PWR_SR2_VOSF_Pos: u32 = 10;
pub const PWR_SR2_VOSF_Msk: u32 = 1024;
pub const PWR_SR2_VOSF: u32 = 1024;
pub const PWR_SR2_REGLPF_Pos: u32 = 9;
pub const PWR_SR2_REGLPF_Msk: u32 = 512;
pub const PWR_SR2_REGLPF: u32 = 512;
pub const PWR_SR2_REGLPS_Pos: u32 = 8;
pub const PWR_SR2_REGLPS_Msk: u32 = 256;
pub const PWR_SR2_REGLPS: u32 = 256;
pub const PWR_SCR_CSBF_Pos: u32 = 8;
pub const PWR_SCR_CSBF_Msk: u32 = 256;
pub const PWR_SCR_CSBF: u32 = 256;
pub const PWR_SCR_CWUF_Pos: u32 = 0;
pub const PWR_SCR_CWUF_Msk: u32 = 31;
pub const PWR_SCR_CWUF: u32 = 31;
pub const PWR_SCR_CWUF5_Pos: u32 = 4;
pub const PWR_SCR_CWUF5_Msk: u32 = 16;
pub const PWR_SCR_CWUF5: u32 = 16;
pub const PWR_SCR_CWUF4_Pos: u32 = 3;
pub const PWR_SCR_CWUF4_Msk: u32 = 8;
pub const PWR_SCR_CWUF4: u32 = 8;
pub const PWR_SCR_CWUF3_Pos: u32 = 2;
pub const PWR_SCR_CWUF3_Msk: u32 = 4;
pub const PWR_SCR_CWUF3: u32 = 4;
pub const PWR_SCR_CWUF2_Pos: u32 = 1;
pub const PWR_SCR_CWUF2_Msk: u32 = 2;
pub const PWR_SCR_CWUF2: u32 = 2;
pub const PWR_SCR_CWUF1_Pos: u32 = 0;
pub const PWR_SCR_CWUF1_Msk: u32 = 1;
pub const PWR_SCR_CWUF1: u32 = 1;
pub const PWR_PUCRA_PA15_Pos: u32 = 15;
pub const PWR_PUCRA_PA15_Msk: u32 = 32768;
pub const PWR_PUCRA_PA15: u32 = 32768;
pub const PWR_PUCRA_PA13_Pos: u32 = 13;
pub const PWR_PUCRA_PA13_Msk: u32 = 8192;
pub const PWR_PUCRA_PA13: u32 = 8192;
pub const PWR_PUCRA_PA12_Pos: u32 = 12;
pub const PWR_PUCRA_PA12_Msk: u32 = 4096;
pub const PWR_PUCRA_PA12: u32 = 4096;
pub const PWR_PUCRA_PA11_Pos: u32 = 11;
pub const PWR_PUCRA_PA11_Msk: u32 = 2048;
pub const PWR_PUCRA_PA11: u32 = 2048;
pub const PWR_PUCRA_PA10_Pos: u32 = 10;
pub const PWR_PUCRA_PA10_Msk: u32 = 1024;
pub const PWR_PUCRA_PA10: u32 = 1024;
pub const PWR_PUCRA_PA9_Pos: u32 = 9;
pub const PWR_PUCRA_PA9_Msk: u32 = 512;
pub const PWR_PUCRA_PA9: u32 = 512;
pub const PWR_PUCRA_PA8_Pos: u32 = 8;
pub const PWR_PUCRA_PA8_Msk: u32 = 256;
pub const PWR_PUCRA_PA8: u32 = 256;
pub const PWR_PUCRA_PA7_Pos: u32 = 7;
pub const PWR_PUCRA_PA7_Msk: u32 = 128;
pub const PWR_PUCRA_PA7: u32 = 128;
pub const PWR_PUCRA_PA6_Pos: u32 = 6;
pub const PWR_PUCRA_PA6_Msk: u32 = 64;
pub const PWR_PUCRA_PA6: u32 = 64;
pub const PWR_PUCRA_PA5_Pos: u32 = 5;
pub const PWR_PUCRA_PA5_Msk: u32 = 32;
pub const PWR_PUCRA_PA5: u32 = 32;
pub const PWR_PUCRA_PA4_Pos: u32 = 4;
pub const PWR_PUCRA_PA4_Msk: u32 = 16;
pub const PWR_PUCRA_PA4: u32 = 16;
pub const PWR_PUCRA_PA3_Pos: u32 = 3;
pub const PWR_PUCRA_PA3_Msk: u32 = 8;
pub const PWR_PUCRA_PA3: u32 = 8;
pub const PWR_PUCRA_PA2_Pos: u32 = 2;
pub const PWR_PUCRA_PA2_Msk: u32 = 4;
pub const PWR_PUCRA_PA2: u32 = 4;
pub const PWR_PUCRA_PA1_Pos: u32 = 1;
pub const PWR_PUCRA_PA1_Msk: u32 = 2;
pub const PWR_PUCRA_PA1: u32 = 2;
pub const PWR_PUCRA_PA0_Pos: u32 = 0;
pub const PWR_PUCRA_PA0_Msk: u32 = 1;
pub const PWR_PUCRA_PA0: u32 = 1;
pub const PWR_PDCRA_PA14_Pos: u32 = 14;
pub const PWR_PDCRA_PA14_Msk: u32 = 16384;
pub const PWR_PDCRA_PA14: u32 = 16384;
pub const PWR_PDCRA_PA12_Pos: u32 = 12;
pub const PWR_PDCRA_PA12_Msk: u32 = 4096;
pub const PWR_PDCRA_PA12: u32 = 4096;
pub const PWR_PDCRA_PA11_Pos: u32 = 11;
pub const PWR_PDCRA_PA11_Msk: u32 = 2048;
pub const PWR_PDCRA_PA11: u32 = 2048;
pub const PWR_PDCRA_PA10_Pos: u32 = 10;
pub const PWR_PDCRA_PA10_Msk: u32 = 1024;
pub const PWR_PDCRA_PA10: u32 = 1024;
pub const PWR_PDCRA_PA9_Pos: u32 = 9;
pub const PWR_PDCRA_PA9_Msk: u32 = 512;
pub const PWR_PDCRA_PA9: u32 = 512;
pub const PWR_PDCRA_PA8_Pos: u32 = 8;
pub const PWR_PDCRA_PA8_Msk: u32 = 256;
pub const PWR_PDCRA_PA8: u32 = 256;
pub const PWR_PDCRA_PA7_Pos: u32 = 7;
pub const PWR_PDCRA_PA7_Msk: u32 = 128;
pub const PWR_PDCRA_PA7: u32 = 128;
pub const PWR_PDCRA_PA6_Pos: u32 = 6;
pub const PWR_PDCRA_PA6_Msk: u32 = 64;
pub const PWR_PDCRA_PA6: u32 = 64;
pub const PWR_PDCRA_PA5_Pos: u32 = 5;
pub const PWR_PDCRA_PA5_Msk: u32 = 32;
pub const PWR_PDCRA_PA5: u32 = 32;
pub const PWR_PDCRA_PA4_Pos: u32 = 4;
pub const PWR_PDCRA_PA4_Msk: u32 = 16;
pub const PWR_PDCRA_PA4: u32 = 16;
pub const PWR_PDCRA_PA3_Pos: u32 = 3;
pub const PWR_PDCRA_PA3_Msk: u32 = 8;
pub const PWR_PDCRA_PA3: u32 = 8;
pub const PWR_PDCRA_PA2_Pos: u32 = 2;
pub const PWR_PDCRA_PA2_Msk: u32 = 4;
pub const PWR_PDCRA_PA2: u32 = 4;
pub const PWR_PDCRA_PA1_Pos: u32 = 1;
pub const PWR_PDCRA_PA1_Msk: u32 = 2;
pub const PWR_PDCRA_PA1: u32 = 2;
pub const PWR_PDCRA_PA0_Pos: u32 = 0;
pub const PWR_PDCRA_PA0_Msk: u32 = 1;
pub const PWR_PDCRA_PA0: u32 = 1;
pub const PWR_PUCRB_PB15_Pos: u32 = 15;
pub const PWR_PUCRB_PB15_Msk: u32 = 32768;
pub const PWR_PUCRB_PB15: u32 = 32768;
pub const PWR_PUCRB_PB14_Pos: u32 = 14;
pub const PWR_PUCRB_PB14_Msk: u32 = 16384;
pub const PWR_PUCRB_PB14: u32 = 16384;
pub const PWR_PUCRB_PB13_Pos: u32 = 13;
pub const PWR_PUCRB_PB13_Msk: u32 = 8192;
pub const PWR_PUCRB_PB13: u32 = 8192;
pub const PWR_PUCRB_PB12_Pos: u32 = 12;
pub const PWR_PUCRB_PB12_Msk: u32 = 4096;
pub const PWR_PUCRB_PB12: u32 = 4096;
pub const PWR_PUCRB_PB11_Pos: u32 = 11;
pub const PWR_PUCRB_PB11_Msk: u32 = 2048;
pub const PWR_PUCRB_PB11: u32 = 2048;
pub const PWR_PUCRB_PB10_Pos: u32 = 10;
pub const PWR_PUCRB_PB10_Msk: u32 = 1024;
pub const PWR_PUCRB_PB10: u32 = 1024;
pub const PWR_PUCRB_PB9_Pos: u32 = 9;
pub const PWR_PUCRB_PB9_Msk: u32 = 512;
pub const PWR_PUCRB_PB9: u32 = 512;
pub const PWR_PUCRB_PB8_Pos: u32 = 8;
pub const PWR_PUCRB_PB8_Msk: u32 = 256;
pub const PWR_PUCRB_PB8: u32 = 256;
pub const PWR_PUCRB_PB7_Pos: u32 = 7;
pub const PWR_PUCRB_PB7_Msk: u32 = 128;
pub const PWR_PUCRB_PB7: u32 = 128;
pub const PWR_PUCRB_PB6_Pos: u32 = 6;
pub const PWR_PUCRB_PB6_Msk: u32 = 64;
pub const PWR_PUCRB_PB6: u32 = 64;
pub const PWR_PUCRB_PB5_Pos: u32 = 5;
pub const PWR_PUCRB_PB5_Msk: u32 = 32;
pub const PWR_PUCRB_PB5: u32 = 32;
pub const PWR_PUCRB_PB4_Pos: u32 = 4;
pub const PWR_PUCRB_PB4_Msk: u32 = 16;
pub const PWR_PUCRB_PB4: u32 = 16;
pub const PWR_PUCRB_PB3_Pos: u32 = 3;
pub const PWR_PUCRB_PB3_Msk: u32 = 8;
pub const PWR_PUCRB_PB3: u32 = 8;
pub const PWR_PUCRB_PB2_Pos: u32 = 2;
pub const PWR_PUCRB_PB2_Msk: u32 = 4;
pub const PWR_PUCRB_PB2: u32 = 4;
pub const PWR_PUCRB_PB1_Pos: u32 = 1;
pub const PWR_PUCRB_PB1_Msk: u32 = 2;
pub const PWR_PUCRB_PB1: u32 = 2;
pub const PWR_PUCRB_PB0_Pos: u32 = 0;
pub const PWR_PUCRB_PB0_Msk: u32 = 1;
pub const PWR_PUCRB_PB0: u32 = 1;
pub const PWR_PDCRB_PB15_Pos: u32 = 15;
pub const PWR_PDCRB_PB15_Msk: u32 = 32768;
pub const PWR_PDCRB_PB15: u32 = 32768;
pub const PWR_PDCRB_PB14_Pos: u32 = 14;
pub const PWR_PDCRB_PB14_Msk: u32 = 16384;
pub const PWR_PDCRB_PB14: u32 = 16384;
pub const PWR_PDCRB_PB13_Pos: u32 = 13;
pub const PWR_PDCRB_PB13_Msk: u32 = 8192;
pub const PWR_PDCRB_PB13: u32 = 8192;
pub const PWR_PDCRB_PB12_Pos: u32 = 12;
pub const PWR_PDCRB_PB12_Msk: u32 = 4096;
pub const PWR_PDCRB_PB12: u32 = 4096;
pub const PWR_PDCRB_PB11_Pos: u32 = 11;
pub const PWR_PDCRB_PB11_Msk: u32 = 2048;
pub const PWR_PDCRB_PB11: u32 = 2048;
pub const PWR_PDCRB_PB10_Pos: u32 = 10;
pub const PWR_PDCRB_PB10_Msk: u32 = 1024;
pub const PWR_PDCRB_PB10: u32 = 1024;
pub const PWR_PDCRB_PB9_Pos: u32 = 9;
pub const PWR_PDCRB_PB9_Msk: u32 = 512;
pub const PWR_PDCRB_PB9: u32 = 512;
pub const PWR_PDCRB_PB8_Pos: u32 = 8;
pub const PWR_PDCRB_PB8_Msk: u32 = 256;
pub const PWR_PDCRB_PB8: u32 = 256;
pub const PWR_PDCRB_PB7_Pos: u32 = 7;
pub const PWR_PDCRB_PB7_Msk: u32 = 128;
pub const PWR_PDCRB_PB7: u32 = 128;
pub const PWR_PDCRB_PB6_Pos: u32 = 6;
pub const PWR_PDCRB_PB6_Msk: u32 = 64;
pub const PWR_PDCRB_PB6: u32 = 64;
pub const PWR_PDCRB_PB5_Pos: u32 = 5;
pub const PWR_PDCRB_PB5_Msk: u32 = 32;
pub const PWR_PDCRB_PB5: u32 = 32;
pub const PWR_PDCRB_PB3_Pos: u32 = 3;
pub const PWR_PDCRB_PB3_Msk: u32 = 8;
pub const PWR_PDCRB_PB3: u32 = 8;
pub const PWR_PDCRB_PB2_Pos: u32 = 2;
pub const PWR_PDCRB_PB2_Msk: u32 = 4;
pub const PWR_PDCRB_PB2: u32 = 4;
pub const PWR_PDCRB_PB1_Pos: u32 = 1;
pub const PWR_PDCRB_PB1_Msk: u32 = 2;
pub const PWR_PDCRB_PB1: u32 = 2;
pub const PWR_PDCRB_PB0_Pos: u32 = 0;
pub const PWR_PDCRB_PB0_Msk: u32 = 1;
pub const PWR_PDCRB_PB0: u32 = 1;
pub const PWR_PUCRC_PC15_Pos: u32 = 15;
pub const PWR_PUCRC_PC15_Msk: u32 = 32768;
pub const PWR_PUCRC_PC15: u32 = 32768;
pub const PWR_PUCRC_PC14_Pos: u32 = 14;
pub const PWR_PUCRC_PC14_Msk: u32 = 16384;
pub const PWR_PUCRC_PC14: u32 = 16384;
pub const PWR_PUCRC_PC13_Pos: u32 = 13;
pub const PWR_PUCRC_PC13_Msk: u32 = 8192;
pub const PWR_PUCRC_PC13: u32 = 8192;
pub const PWR_PUCRC_PC12_Pos: u32 = 12;
pub const PWR_PUCRC_PC12_Msk: u32 = 4096;
pub const PWR_PUCRC_PC12: u32 = 4096;
pub const PWR_PUCRC_PC11_Pos: u32 = 11;
pub const PWR_PUCRC_PC11_Msk: u32 = 2048;
pub const PWR_PUCRC_PC11: u32 = 2048;
pub const PWR_PUCRC_PC10_Pos: u32 = 10;
pub const PWR_PUCRC_PC10_Msk: u32 = 1024;
pub const PWR_PUCRC_PC10: u32 = 1024;
pub const PWR_PUCRC_PC9_Pos: u32 = 9;
pub const PWR_PUCRC_PC9_Msk: u32 = 512;
pub const PWR_PUCRC_PC9: u32 = 512;
pub const PWR_PUCRC_PC8_Pos: u32 = 8;
pub const PWR_PUCRC_PC8_Msk: u32 = 256;
pub const PWR_PUCRC_PC8: u32 = 256;
pub const PWR_PUCRC_PC7_Pos: u32 = 7;
pub const PWR_PUCRC_PC7_Msk: u32 = 128;
pub const PWR_PUCRC_PC7: u32 = 128;
pub const PWR_PUCRC_PC6_Pos: u32 = 6;
pub const PWR_PUCRC_PC6_Msk: u32 = 64;
pub const PWR_PUCRC_PC6: u32 = 64;
pub const PWR_PUCRC_PC5_Pos: u32 = 5;
pub const PWR_PUCRC_PC5_Msk: u32 = 32;
pub const PWR_PUCRC_PC5: u32 = 32;
pub const PWR_PUCRC_PC4_Pos: u32 = 4;
pub const PWR_PUCRC_PC4_Msk: u32 = 16;
pub const PWR_PUCRC_PC4: u32 = 16;
pub const PWR_PUCRC_PC3_Pos: u32 = 3;
pub const PWR_PUCRC_PC3_Msk: u32 = 8;
pub const PWR_PUCRC_PC3: u32 = 8;
pub const PWR_PUCRC_PC2_Pos: u32 = 2;
pub const PWR_PUCRC_PC2_Msk: u32 = 4;
pub const PWR_PUCRC_PC2: u32 = 4;
pub const PWR_PUCRC_PC1_Pos: u32 = 1;
pub const PWR_PUCRC_PC1_Msk: u32 = 2;
pub const PWR_PUCRC_PC1: u32 = 2;
pub const PWR_PUCRC_PC0_Pos: u32 = 0;
pub const PWR_PUCRC_PC0_Msk: u32 = 1;
pub const PWR_PUCRC_PC0: u32 = 1;
pub const PWR_PDCRC_PC15_Pos: u32 = 15;
pub const PWR_PDCRC_PC15_Msk: u32 = 32768;
pub const PWR_PDCRC_PC15: u32 = 32768;
pub const PWR_PDCRC_PC14_Pos: u32 = 14;
pub const PWR_PDCRC_PC14_Msk: u32 = 16384;
pub const PWR_PDCRC_PC14: u32 = 16384;
pub const PWR_PDCRC_PC13_Pos: u32 = 13;
pub const PWR_PDCRC_PC13_Msk: u32 = 8192;
pub const PWR_PDCRC_PC13: u32 = 8192;
pub const PWR_PDCRC_PC12_Pos: u32 = 12;
pub const PWR_PDCRC_PC12_Msk: u32 = 4096;
pub const PWR_PDCRC_PC12: u32 = 4096;
pub const PWR_PDCRC_PC11_Pos: u32 = 11;
pub const PWR_PDCRC_PC11_Msk: u32 = 2048;
pub const PWR_PDCRC_PC11: u32 = 2048;
pub const PWR_PDCRC_PC10_Pos: u32 = 10;
pub const PWR_PDCRC_PC10_Msk: u32 = 1024;
pub const PWR_PDCRC_PC10: u32 = 1024;
pub const PWR_PDCRC_PC9_Pos: u32 = 9;
pub const PWR_PDCRC_PC9_Msk: u32 = 512;
pub const PWR_PDCRC_PC9: u32 = 512;
pub const PWR_PDCRC_PC8_Pos: u32 = 8;
pub const PWR_PDCRC_PC8_Msk: u32 = 256;
pub const PWR_PDCRC_PC8: u32 = 256;
pub const PWR_PDCRC_PC7_Pos: u32 = 7;
pub const PWR_PDCRC_PC7_Msk: u32 = 128;
pub const PWR_PDCRC_PC7: u32 = 128;
pub const PWR_PDCRC_PC6_Pos: u32 = 6;
pub const PWR_PDCRC_PC6_Msk: u32 = 64;
pub const PWR_PDCRC_PC6: u32 = 64;
pub const PWR_PDCRC_PC5_Pos: u32 = 5;
pub const PWR_PDCRC_PC5_Msk: u32 = 32;
pub const PWR_PDCRC_PC5: u32 = 32;
pub const PWR_PDCRC_PC4_Pos: u32 = 4;
pub const PWR_PDCRC_PC4_Msk: u32 = 16;
pub const PWR_PDCRC_PC4: u32 = 16;
pub const PWR_PDCRC_PC3_Pos: u32 = 3;
pub const PWR_PDCRC_PC3_Msk: u32 = 8;
pub const PWR_PDCRC_PC3: u32 = 8;
pub const PWR_PDCRC_PC2_Pos: u32 = 2;
pub const PWR_PDCRC_PC2_Msk: u32 = 4;
pub const PWR_PDCRC_PC2: u32 = 4;
pub const PWR_PDCRC_PC1_Pos: u32 = 1;
pub const PWR_PDCRC_PC1_Msk: u32 = 2;
pub const PWR_PDCRC_PC1: u32 = 2;
pub const PWR_PDCRC_PC0_Pos: u32 = 0;
pub const PWR_PDCRC_PC0_Msk: u32 = 1;
pub const PWR_PDCRC_PC0: u32 = 1;
pub const PWR_PUCRD_PD15_Pos: u32 = 15;
pub const PWR_PUCRD_PD15_Msk: u32 = 32768;
pub const PWR_PUCRD_PD15: u32 = 32768;
pub const PWR_PUCRD_PD14_Pos: u32 = 14;
pub const PWR_PUCRD_PD14_Msk: u32 = 16384;
pub const PWR_PUCRD_PD14: u32 = 16384;
pub const PWR_PUCRD_PD13_Pos: u32 = 13;
pub const PWR_PUCRD_PD13_Msk: u32 = 8192;
pub const PWR_PUCRD_PD13: u32 = 8192;
pub const PWR_PUCRD_PD12_Pos: u32 = 12;
pub const PWR_PUCRD_PD12_Msk: u32 = 4096;
pub const PWR_PUCRD_PD12: u32 = 4096;
pub const PWR_PUCRD_PD11_Pos: u32 = 11;
pub const PWR_PUCRD_PD11_Msk: u32 = 2048;
pub const PWR_PUCRD_PD11: u32 = 2048;
pub const PWR_PUCRD_PD10_Pos: u32 = 10;
pub const PWR_PUCRD_PD10_Msk: u32 = 1024;
pub const PWR_PUCRD_PD10: u32 = 1024;
pub const PWR_PUCRD_PD9_Pos: u32 = 9;
pub const PWR_PUCRD_PD9_Msk: u32 = 512;
pub const PWR_PUCRD_PD9: u32 = 512;
pub const PWR_PUCRD_PD8_Pos: u32 = 8;
pub const PWR_PUCRD_PD8_Msk: u32 = 256;
pub const PWR_PUCRD_PD8: u32 = 256;
pub const PWR_PUCRD_PD7_Pos: u32 = 7;
pub const PWR_PUCRD_PD7_Msk: u32 = 128;
pub const PWR_PUCRD_PD7: u32 = 128;
pub const PWR_PUCRD_PD6_Pos: u32 = 6;
pub const PWR_PUCRD_PD6_Msk: u32 = 64;
pub const PWR_PUCRD_PD6: u32 = 64;
pub const PWR_PUCRD_PD5_Pos: u32 = 5;
pub const PWR_PUCRD_PD5_Msk: u32 = 32;
pub const PWR_PUCRD_PD5: u32 = 32;
pub const PWR_PUCRD_PD4_Pos: u32 = 4;
pub const PWR_PUCRD_PD4_Msk: u32 = 16;
pub const PWR_PUCRD_PD4: u32 = 16;
pub const PWR_PUCRD_PD3_Pos: u32 = 3;
pub const PWR_PUCRD_PD3_Msk: u32 = 8;
pub const PWR_PUCRD_PD3: u32 = 8;
pub const PWR_PUCRD_PD2_Pos: u32 = 2;
pub const PWR_PUCRD_PD2_Msk: u32 = 4;
pub const PWR_PUCRD_PD2: u32 = 4;
pub const PWR_PUCRD_PD1_Pos: u32 = 1;
pub const PWR_PUCRD_PD1_Msk: u32 = 2;
pub const PWR_PUCRD_PD1: u32 = 2;
pub const PWR_PUCRD_PD0_Pos: u32 = 0;
pub const PWR_PUCRD_PD0_Msk: u32 = 1;
pub const PWR_PUCRD_PD0: u32 = 1;
pub const PWR_PDCRD_PD15_Pos: u32 = 15;
pub const PWR_PDCRD_PD15_Msk: u32 = 32768;
pub const PWR_PDCRD_PD15: u32 = 32768;
pub const PWR_PDCRD_PD14_Pos: u32 = 14;
pub const PWR_PDCRD_PD14_Msk: u32 = 16384;
pub const PWR_PDCRD_PD14: u32 = 16384;
pub const PWR_PDCRD_PD13_Pos: u32 = 13;
pub const PWR_PDCRD_PD13_Msk: u32 = 8192;
pub const PWR_PDCRD_PD13: u32 = 8192;
pub const PWR_PDCRD_PD12_Pos: u32 = 12;
pub const PWR_PDCRD_PD12_Msk: u32 = 4096;
pub const PWR_PDCRD_PD12: u32 = 4096;
pub const PWR_PDCRD_PD11_Pos: u32 = 11;
pub const PWR_PDCRD_PD11_Msk: u32 = 2048;
pub const PWR_PDCRD_PD11: u32 = 2048;
pub const PWR_PDCRD_PD10_Pos: u32 = 10;
pub const PWR_PDCRD_PD10_Msk: u32 = 1024;
pub const PWR_PDCRD_PD10: u32 = 1024;
pub const PWR_PDCRD_PD9_Pos: u32 = 9;
pub const PWR_PDCRD_PD9_Msk: u32 = 512;
pub const PWR_PDCRD_PD9: u32 = 512;
pub const PWR_PDCRD_PD8_Pos: u32 = 8;
pub const PWR_PDCRD_PD8_Msk: u32 = 256;
pub const PWR_PDCRD_PD8: u32 = 256;
pub const PWR_PDCRD_PD7_Pos: u32 = 7;
pub const PWR_PDCRD_PD7_Msk: u32 = 128;
pub const PWR_PDCRD_PD7: u32 = 128;
pub const PWR_PDCRD_PD6_Pos: u32 = 6;
pub const PWR_PDCRD_PD6_Msk: u32 = 64;
pub const PWR_PDCRD_PD6: u32 = 64;
pub const PWR_PDCRD_PD5_Pos: u32 = 5;
pub const PWR_PDCRD_PD5_Msk: u32 = 32;
pub const PWR_PDCRD_PD5: u32 = 32;
pub const PWR_PDCRD_PD4_Pos: u32 = 4;
pub const PWR_PDCRD_PD4_Msk: u32 = 16;
pub const PWR_PDCRD_PD4: u32 = 16;
pub const PWR_PDCRD_PD3_Pos: u32 = 3;
pub const PWR_PDCRD_PD3_Msk: u32 = 8;
pub const PWR_PDCRD_PD3: u32 = 8;
pub const PWR_PDCRD_PD2_Pos: u32 = 2;
pub const PWR_PDCRD_PD2_Msk: u32 = 4;
pub const PWR_PDCRD_PD2: u32 = 4;
pub const PWR_PDCRD_PD1_Pos: u32 = 1;
pub const PWR_PDCRD_PD1_Msk: u32 = 2;
pub const PWR_PDCRD_PD1: u32 = 2;
pub const PWR_PDCRD_PD0_Pos: u32 = 0;
pub const PWR_PDCRD_PD0_Msk: u32 = 1;
pub const PWR_PDCRD_PD0: u32 = 1;
pub const PWR_PUCRE_PE15_Pos: u32 = 15;
pub const PWR_PUCRE_PE15_Msk: u32 = 32768;
pub const PWR_PUCRE_PE15: u32 = 32768;
pub const PWR_PUCRE_PE14_Pos: u32 = 14;
pub const PWR_PUCRE_PE14_Msk: u32 = 16384;
pub const PWR_PUCRE_PE14: u32 = 16384;
pub const PWR_PUCRE_PE13_Pos: u32 = 13;
pub const PWR_PUCRE_PE13_Msk: u32 = 8192;
pub const PWR_PUCRE_PE13: u32 = 8192;
pub const PWR_PUCRE_PE12_Pos: u32 = 12;
pub const PWR_PUCRE_PE12_Msk: u32 = 4096;
pub const PWR_PUCRE_PE12: u32 = 4096;
pub const PWR_PUCRE_PE11_Pos: u32 = 11;
pub const PWR_PUCRE_PE11_Msk: u32 = 2048;
pub const PWR_PUCRE_PE11: u32 = 2048;
pub const PWR_PUCRE_PE10_Pos: u32 = 10;
pub const PWR_PUCRE_PE10_Msk: u32 = 1024;
pub const PWR_PUCRE_PE10: u32 = 1024;
pub const PWR_PUCRE_PE9_Pos: u32 = 9;
pub const PWR_PUCRE_PE9_Msk: u32 = 512;
pub const PWR_PUCRE_PE9: u32 = 512;
pub const PWR_PUCRE_PE8_Pos: u32 = 8;
pub const PWR_PUCRE_PE8_Msk: u32 = 256;
pub const PWR_PUCRE_PE8: u32 = 256;
pub const PWR_PUCRE_PE7_Pos: u32 = 7;
pub const PWR_PUCRE_PE7_Msk: u32 = 128;
pub const PWR_PUCRE_PE7: u32 = 128;
pub const PWR_PUCRE_PE6_Pos: u32 = 6;
pub const PWR_PUCRE_PE6_Msk: u32 = 64;
pub const PWR_PUCRE_PE6: u32 = 64;
pub const PWR_PUCRE_PE5_Pos: u32 = 5;
pub const PWR_PUCRE_PE5_Msk: u32 = 32;
pub const PWR_PUCRE_PE5: u32 = 32;
pub const PWR_PUCRE_PE4_Pos: u32 = 4;
pub const PWR_PUCRE_PE4_Msk: u32 = 16;
pub const PWR_PUCRE_PE4: u32 = 16;
pub const PWR_PUCRE_PE3_Pos: u32 = 3;
pub const PWR_PUCRE_PE3_Msk: u32 = 8;
pub const PWR_PUCRE_PE3: u32 = 8;
pub const PWR_PUCRE_PE2_Pos: u32 = 2;
pub const PWR_PUCRE_PE2_Msk: u32 = 4;
pub const PWR_PUCRE_PE2: u32 = 4;
pub const PWR_PUCRE_PE1_Pos: u32 = 1;
pub const PWR_PUCRE_PE1_Msk: u32 = 2;
pub const PWR_PUCRE_PE1: u32 = 2;
pub const PWR_PUCRE_PE0_Pos: u32 = 0;
pub const PWR_PUCRE_PE0_Msk: u32 = 1;
pub const PWR_PUCRE_PE0: u32 = 1;
pub const PWR_PDCRE_PE15_Pos: u32 = 15;
pub const PWR_PDCRE_PE15_Msk: u32 = 32768;
pub const PWR_PDCRE_PE15: u32 = 32768;
pub const PWR_PDCRE_PE14_Pos: u32 = 14;
pub const PWR_PDCRE_PE14_Msk: u32 = 16384;
pub const PWR_PDCRE_PE14: u32 = 16384;
pub const PWR_PDCRE_PE13_Pos: u32 = 13;
pub const PWR_PDCRE_PE13_Msk: u32 = 8192;
pub const PWR_PDCRE_PE13: u32 = 8192;
pub const PWR_PDCRE_PE12_Pos: u32 = 12;
pub const PWR_PDCRE_PE12_Msk: u32 = 4096;
pub const PWR_PDCRE_PE12: u32 = 4096;
pub const PWR_PDCRE_PE11_Pos: u32 = 11;
pub const PWR_PDCRE_PE11_Msk: u32 = 2048;
pub const PWR_PDCRE_PE11: u32 = 2048;
pub const PWR_PDCRE_PE10_Pos: u32 = 10;
pub const PWR_PDCRE_PE10_Msk: u32 = 1024;
pub const PWR_PDCRE_PE10: u32 = 1024;
pub const PWR_PDCRE_PE9_Pos: u32 = 9;
pub const PWR_PDCRE_PE9_Msk: u32 = 512;
pub const PWR_PDCRE_PE9: u32 = 512;
pub const PWR_PDCRE_PE8_Pos: u32 = 8;
pub const PWR_PDCRE_PE8_Msk: u32 = 256;
pub const PWR_PDCRE_PE8: u32 = 256;
pub const PWR_PDCRE_PE7_Pos: u32 = 7;
pub const PWR_PDCRE_PE7_Msk: u32 = 128;
pub const PWR_PDCRE_PE7: u32 = 128;
pub const PWR_PDCRE_PE6_Pos: u32 = 6;
pub const PWR_PDCRE_PE6_Msk: u32 = 64;
pub const PWR_PDCRE_PE6: u32 = 64;
pub const PWR_PDCRE_PE5_Pos: u32 = 5;
pub const PWR_PDCRE_PE5_Msk: u32 = 32;
pub const PWR_PDCRE_PE5: u32 = 32;
pub const PWR_PDCRE_PE4_Pos: u32 = 4;
pub const PWR_PDCRE_PE4_Msk: u32 = 16;
pub const PWR_PDCRE_PE4: u32 = 16;
pub const PWR_PDCRE_PE3_Pos: u32 = 3;
pub const PWR_PDCRE_PE3_Msk: u32 = 8;
pub const PWR_PDCRE_PE3: u32 = 8;
pub const PWR_PDCRE_PE2_Pos: u32 = 2;
pub const PWR_PDCRE_PE2_Msk: u32 = 4;
pub const PWR_PDCRE_PE2: u32 = 4;
pub const PWR_PDCRE_PE1_Pos: u32 = 1;
pub const PWR_PDCRE_PE1_Msk: u32 = 2;
pub const PWR_PDCRE_PE1: u32 = 2;
pub const PWR_PDCRE_PE0_Pos: u32 = 0;
pub const PWR_PDCRE_PE0_Msk: u32 = 1;
pub const PWR_PDCRE_PE0: u32 = 1;
pub const PWR_PUCRF_PF15_Pos: u32 = 15;
pub const PWR_PUCRF_PF15_Msk: u32 = 32768;
pub const PWR_PUCRF_PF15: u32 = 32768;
pub const PWR_PUCRF_PF14_Pos: u32 = 14;
pub const PWR_PUCRF_PF14_Msk: u32 = 16384;
pub const PWR_PUCRF_PF14: u32 = 16384;
pub const PWR_PUCRF_PF13_Pos: u32 = 13;
pub const PWR_PUCRF_PF13_Msk: u32 = 8192;
pub const PWR_PUCRF_PF13: u32 = 8192;
pub const PWR_PUCRF_PF12_Pos: u32 = 12;
pub const PWR_PUCRF_PF12_Msk: u32 = 4096;
pub const PWR_PUCRF_PF12: u32 = 4096;
pub const PWR_PUCRF_PF11_Pos: u32 = 11;
pub const PWR_PUCRF_PF11_Msk: u32 = 2048;
pub const PWR_PUCRF_PF11: u32 = 2048;
pub const PWR_PUCRF_PF10_Pos: u32 = 10;
pub const PWR_PUCRF_PF10_Msk: u32 = 1024;
pub const PWR_PUCRF_PF10: u32 = 1024;
pub const PWR_PUCRF_PF9_Pos: u32 = 9;
pub const PWR_PUCRF_PF9_Msk: u32 = 512;
pub const PWR_PUCRF_PF9: u32 = 512;
pub const PWR_PUCRF_PF8_Pos: u32 = 8;
pub const PWR_PUCRF_PF8_Msk: u32 = 256;
pub const PWR_PUCRF_PF8: u32 = 256;
pub const PWR_PUCRF_PF7_Pos: u32 = 7;
pub const PWR_PUCRF_PF7_Msk: u32 = 128;
pub const PWR_PUCRF_PF7: u32 = 128;
pub const PWR_PUCRF_PF6_Pos: u32 = 6;
pub const PWR_PUCRF_PF6_Msk: u32 = 64;
pub const PWR_PUCRF_PF6: u32 = 64;
pub const PWR_PUCRF_PF5_Pos: u32 = 5;
pub const PWR_PUCRF_PF5_Msk: u32 = 32;
pub const PWR_PUCRF_PF5: u32 = 32;
pub const PWR_PUCRF_PF4_Pos: u32 = 4;
pub const PWR_PUCRF_PF4_Msk: u32 = 16;
pub const PWR_PUCRF_PF4: u32 = 16;
pub const PWR_PUCRF_PF3_Pos: u32 = 3;
pub const PWR_PUCRF_PF3_Msk: u32 = 8;
pub const PWR_PUCRF_PF3: u32 = 8;
pub const PWR_PUCRF_PF2_Pos: u32 = 2;
pub const PWR_PUCRF_PF2_Msk: u32 = 4;
pub const PWR_PUCRF_PF2: u32 = 4;
pub const PWR_PUCRF_PF1_Pos: u32 = 1;
pub const PWR_PUCRF_PF1_Msk: u32 = 2;
pub const PWR_PUCRF_PF1: u32 = 2;
pub const PWR_PUCRF_PF0_Pos: u32 = 0;
pub const PWR_PUCRF_PF0_Msk: u32 = 1;
pub const PWR_PUCRF_PF0: u32 = 1;
pub const PWR_PDCRF_PF15_Pos: u32 = 15;
pub const PWR_PDCRF_PF15_Msk: u32 = 32768;
pub const PWR_PDCRF_PF15: u32 = 32768;
pub const PWR_PDCRF_PF14_Pos: u32 = 14;
pub const PWR_PDCRF_PF14_Msk: u32 = 16384;
pub const PWR_PDCRF_PF14: u32 = 16384;
pub const PWR_PDCRF_PF13_Pos: u32 = 13;
pub const PWR_PDCRF_PF13_Msk: u32 = 8192;
pub const PWR_PDCRF_PF13: u32 = 8192;
pub const PWR_PDCRF_PF12_Pos: u32 = 12;
pub const PWR_PDCRF_PF12_Msk: u32 = 4096;
pub const PWR_PDCRF_PF12: u32 = 4096;
pub const PWR_PDCRF_PF11_Pos: u32 = 11;
pub const PWR_PDCRF_PF11_Msk: u32 = 2048;
pub const PWR_PDCRF_PF11: u32 = 2048;
pub const PWR_PDCRF_PF10_Pos: u32 = 10;
pub const PWR_PDCRF_PF10_Msk: u32 = 1024;
pub const PWR_PDCRF_PF10: u32 = 1024;
pub const PWR_PDCRF_PF9_Pos: u32 = 9;
pub const PWR_PDCRF_PF9_Msk: u32 = 512;
pub const PWR_PDCRF_PF9: u32 = 512;
pub const PWR_PDCRF_PF8_Pos: u32 = 8;
pub const PWR_PDCRF_PF8_Msk: u32 = 256;
pub const PWR_PDCRF_PF8: u32 = 256;
pub const PWR_PDCRF_PF7_Pos: u32 = 7;
pub const PWR_PDCRF_PF7_Msk: u32 = 128;
pub const PWR_PDCRF_PF7: u32 = 128;
pub const PWR_PDCRF_PF6_Pos: u32 = 6;
pub const PWR_PDCRF_PF6_Msk: u32 = 64;
pub const PWR_PDCRF_PF6: u32 = 64;
pub const PWR_PDCRF_PF5_Pos: u32 = 5;
pub const PWR_PDCRF_PF5_Msk: u32 = 32;
pub const PWR_PDCRF_PF5: u32 = 32;
pub const PWR_PDCRF_PF4_Pos: u32 = 4;
pub const PWR_PDCRF_PF4_Msk: u32 = 16;
pub const PWR_PDCRF_PF4: u32 = 16;
pub const PWR_PDCRF_PF3_Pos: u32 = 3;
pub const PWR_PDCRF_PF3_Msk: u32 = 8;
pub const PWR_PDCRF_PF3: u32 = 8;
pub const PWR_PDCRF_PF2_Pos: u32 = 2;
pub const PWR_PDCRF_PF2_Msk: u32 = 4;
pub const PWR_PDCRF_PF2: u32 = 4;
pub const PWR_PDCRF_PF1_Pos: u32 = 1;
pub const PWR_PDCRF_PF1_Msk: u32 = 2;
pub const PWR_PDCRF_PF1: u32 = 2;
pub const PWR_PDCRF_PF0_Pos: u32 = 0;
pub const PWR_PDCRF_PF0_Msk: u32 = 1;
pub const PWR_PDCRF_PF0: u32 = 1;
pub const PWR_PUCRG_PG15_Pos: u32 = 15;
pub const PWR_PUCRG_PG15_Msk: u32 = 32768;
pub const PWR_PUCRG_PG15: u32 = 32768;
pub const PWR_PUCRG_PG14_Pos: u32 = 14;
pub const PWR_PUCRG_PG14_Msk: u32 = 16384;
pub const PWR_PUCRG_PG14: u32 = 16384;
pub const PWR_PUCRG_PG13_Pos: u32 = 13;
pub const PWR_PUCRG_PG13_Msk: u32 = 8192;
pub const PWR_PUCRG_PG13: u32 = 8192;
pub const PWR_PUCRG_PG12_Pos: u32 = 12;
pub const PWR_PUCRG_PG12_Msk: u32 = 4096;
pub const PWR_PUCRG_PG12: u32 = 4096;
pub const PWR_PUCRG_PG11_Pos: u32 = 11;
pub const PWR_PUCRG_PG11_Msk: u32 = 2048;
pub const PWR_PUCRG_PG11: u32 = 2048;
pub const PWR_PUCRG_PG10_Pos: u32 = 10;
pub const PWR_PUCRG_PG10_Msk: u32 = 1024;
pub const PWR_PUCRG_PG10: u32 = 1024;
pub const PWR_PUCRG_PG9_Pos: u32 = 9;
pub const PWR_PUCRG_PG9_Msk: u32 = 512;
pub const PWR_PUCRG_PG9: u32 = 512;
pub const PWR_PUCRG_PG8_Pos: u32 = 8;
pub const PWR_PUCRG_PG8_Msk: u32 = 256;
pub const PWR_PUCRG_PG8: u32 = 256;
pub const PWR_PUCRG_PG7_Pos: u32 = 7;
pub const PWR_PUCRG_PG7_Msk: u32 = 128;
pub const PWR_PUCRG_PG7: u32 = 128;
pub const PWR_PUCRG_PG6_Pos: u32 = 6;
pub const PWR_PUCRG_PG6_Msk: u32 = 64;
pub const PWR_PUCRG_PG6: u32 = 64;
pub const PWR_PUCRG_PG5_Pos: u32 = 5;
pub const PWR_PUCRG_PG5_Msk: u32 = 32;
pub const PWR_PUCRG_PG5: u32 = 32;
pub const PWR_PUCRG_PG4_Pos: u32 = 4;
pub const PWR_PUCRG_PG4_Msk: u32 = 16;
pub const PWR_PUCRG_PG4: u32 = 16;
pub const PWR_PUCRG_PG3_Pos: u32 = 3;
pub const PWR_PUCRG_PG3_Msk: u32 = 8;
pub const PWR_PUCRG_PG3: u32 = 8;
pub const PWR_PUCRG_PG2_Pos: u32 = 2;
pub const PWR_PUCRG_PG2_Msk: u32 = 4;
pub const PWR_PUCRG_PG2: u32 = 4;
pub const PWR_PUCRG_PG1_Pos: u32 = 1;
pub const PWR_PUCRG_PG1_Msk: u32 = 2;
pub const PWR_PUCRG_PG1: u32 = 2;
pub const PWR_PUCRG_PG0_Pos: u32 = 0;
pub const PWR_PUCRG_PG0_Msk: u32 = 1;
pub const PWR_PUCRG_PG0: u32 = 1;
pub const PWR_PDCRG_PG15_Pos: u32 = 15;
pub const PWR_PDCRG_PG15_Msk: u32 = 32768;
pub const PWR_PDCRG_PG15: u32 = 32768;
pub const PWR_PDCRG_PG14_Pos: u32 = 14;
pub const PWR_PDCRG_PG14_Msk: u32 = 16384;
pub const PWR_PDCRG_PG14: u32 = 16384;
pub const PWR_PDCRG_PG13_Pos: u32 = 13;
pub const PWR_PDCRG_PG13_Msk: u32 = 8192;
pub const PWR_PDCRG_PG13: u32 = 8192;
pub const PWR_PDCRG_PG12_Pos: u32 = 12;
pub const PWR_PDCRG_PG12_Msk: u32 = 4096;
pub const PWR_PDCRG_PG12: u32 = 4096;
pub const PWR_PDCRG_PG11_Pos: u32 = 11;
pub const PWR_PDCRG_PG11_Msk: u32 = 2048;
pub const PWR_PDCRG_PG11: u32 = 2048;
pub const PWR_PDCRG_PG10_Pos: u32 = 10;
pub const PWR_PDCRG_PG10_Msk: u32 = 1024;
pub const PWR_PDCRG_PG10: u32 = 1024;
pub const PWR_PDCRG_PG9_Pos: u32 = 9;
pub const PWR_PDCRG_PG9_Msk: u32 = 512;
pub const PWR_PDCRG_PG9: u32 = 512;
pub const PWR_PDCRG_PG8_Pos: u32 = 8;
pub const PWR_PDCRG_PG8_Msk: u32 = 256;
pub const PWR_PDCRG_PG8: u32 = 256;
pub const PWR_PDCRG_PG7_Pos: u32 = 7;
pub const PWR_PDCRG_PG7_Msk: u32 = 128;
pub const PWR_PDCRG_PG7: u32 = 128;
pub const PWR_PDCRG_PG6_Pos: u32 = 6;
pub const PWR_PDCRG_PG6_Msk: u32 = 64;
pub const PWR_PDCRG_PG6: u32 = 64;
pub const PWR_PDCRG_PG5_Pos: u32 = 5;
pub const PWR_PDCRG_PG5_Msk: u32 = 32;
pub const PWR_PDCRG_PG5: u32 = 32;
pub const PWR_PDCRG_PG4_Pos: u32 = 4;
pub const PWR_PDCRG_PG4_Msk: u32 = 16;
pub const PWR_PDCRG_PG4: u32 = 16;
pub const PWR_PDCRG_PG3_Pos: u32 = 3;
pub const PWR_PDCRG_PG3_Msk: u32 = 8;
pub const PWR_PDCRG_PG3: u32 = 8;
pub const PWR_PDCRG_PG2_Pos: u32 = 2;
pub const PWR_PDCRG_PG2_Msk: u32 = 4;
pub const PWR_PDCRG_PG2: u32 = 4;
pub const PWR_PDCRG_PG1_Pos: u32 = 1;
pub const PWR_PDCRG_PG1_Msk: u32 = 2;
pub const PWR_PDCRG_PG1: u32 = 2;
pub const PWR_PDCRG_PG0_Pos: u32 = 0;
pub const PWR_PDCRG_PG0_Msk: u32 = 1;
pub const PWR_PDCRG_PG0: u32 = 1;
pub const PWR_PUCRH_PH1_Pos: u32 = 1;
pub const PWR_PUCRH_PH1_Msk: u32 = 2;
pub const PWR_PUCRH_PH1: u32 = 2;
pub const PWR_PUCRH_PH0_Pos: u32 = 0;
pub const PWR_PUCRH_PH0_Msk: u32 = 1;
pub const PWR_PUCRH_PH0: u32 = 1;
pub const PWR_PDCRH_PH1_Pos: u32 = 1;
pub const PWR_PDCRH_PH1_Msk: u32 = 2;
pub const PWR_PDCRH_PH1: u32 = 2;
pub const PWR_PDCRH_PH0_Pos: u32 = 0;
pub const PWR_PDCRH_PH0_Msk: u32 = 1;
pub const PWR_PDCRH_PH0: u32 = 1;
pub const RCC_CR_MSION_Pos: u32 = 0;
pub const RCC_CR_MSION_Msk: u32 = 1;
pub const RCC_CR_MSION: u32 = 1;
pub const RCC_CR_MSIRDY_Pos: u32 = 1;
pub const RCC_CR_MSIRDY_Msk: u32 = 2;
pub const RCC_CR_MSIRDY: u32 = 2;
pub const RCC_CR_MSIPLLEN_Pos: u32 = 2;
pub const RCC_CR_MSIPLLEN_Msk: u32 = 4;
pub const RCC_CR_MSIPLLEN: u32 = 4;
pub const RCC_CR_MSIRGSEL_Pos: u32 = 3;
pub const RCC_CR_MSIRGSEL_Msk: u32 = 8;
pub const RCC_CR_MSIRGSEL: u32 = 8;
pub const RCC_CR_MSIRANGE_Pos: u32 = 4;
pub const RCC_CR_MSIRANGE_Msk: u32 = 240;
pub const RCC_CR_MSIRANGE: u32 = 240;
pub const RCC_CR_MSIRANGE_0: u32 = 0;
pub const RCC_CR_MSIRANGE_1: u32 = 16;
pub const RCC_CR_MSIRANGE_2: u32 = 32;
pub const RCC_CR_MSIRANGE_3: u32 = 48;
pub const RCC_CR_MSIRANGE_4: u32 = 64;
pub const RCC_CR_MSIRANGE_5: u32 = 80;
pub const RCC_CR_MSIRANGE_6: u32 = 96;
pub const RCC_CR_MSIRANGE_7: u32 = 112;
pub const RCC_CR_MSIRANGE_8: u32 = 128;
pub const RCC_CR_MSIRANGE_9: u32 = 144;
pub const RCC_CR_MSIRANGE_10: u32 = 160;
pub const RCC_CR_MSIRANGE_11: u32 = 176;
pub const RCC_CR_HSION_Pos: u32 = 8;
pub const RCC_CR_HSION_Msk: u32 = 256;
pub const RCC_CR_HSION: u32 = 256;
pub const RCC_CR_HSIKERON_Pos: u32 = 9;
pub const RCC_CR_HSIKERON_Msk: u32 = 512;
pub const RCC_CR_HSIKERON: u32 = 512;
pub const RCC_CR_HSIRDY_Pos: u32 = 10;
pub const RCC_CR_HSIRDY_Msk: u32 = 1024;
pub const RCC_CR_HSIRDY: u32 = 1024;
pub const RCC_CR_HSIASFS_Pos: u32 = 11;
pub const RCC_CR_HSIASFS_Msk: u32 = 2048;
pub const RCC_CR_HSIASFS: u32 = 2048;
pub const RCC_CR_HSEON_Pos: u32 = 16;
pub const RCC_CR_HSEON_Msk: u32 = 65536;
pub const RCC_CR_HSEON: u32 = 65536;
pub const RCC_CR_HSERDY_Pos: u32 = 17;
pub const RCC_CR_HSERDY_Msk: u32 = 131072;
pub const RCC_CR_HSERDY: u32 = 131072;
pub const RCC_CR_HSEBYP_Pos: u32 = 18;
pub const RCC_CR_HSEBYP_Msk: u32 = 262144;
pub const RCC_CR_HSEBYP: u32 = 262144;
pub const RCC_CR_CSSON_Pos: u32 = 19;
pub const RCC_CR_CSSON_Msk: u32 = 524288;
pub const RCC_CR_CSSON: u32 = 524288;
pub const RCC_CR_PLLON_Pos: u32 = 24;
pub const RCC_CR_PLLON_Msk: u32 = 16777216;
pub const RCC_CR_PLLON: u32 = 16777216;
pub const RCC_CR_PLLRDY_Pos: u32 = 25;
pub const RCC_CR_PLLRDY_Msk: u32 = 33554432;
pub const RCC_CR_PLLRDY: u32 = 33554432;
pub const RCC_CR_PLLSAI1ON_Pos: u32 = 26;
pub const RCC_CR_PLLSAI1ON_Msk: u32 = 67108864;
pub const RCC_CR_PLLSAI1ON: u32 = 67108864;
pub const RCC_CR_PLLSAI1RDY_Pos: u32 = 27;
pub const RCC_CR_PLLSAI1RDY_Msk: u32 = 134217728;
pub const RCC_CR_PLLSAI1RDY: u32 = 134217728;
pub const RCC_CR_PLLSAI2ON_Pos: u32 = 28;
pub const RCC_CR_PLLSAI2ON_Msk: u32 = 268435456;
pub const RCC_CR_PLLSAI2ON: u32 = 268435456;
pub const RCC_CR_PLLSAI2RDY_Pos: u32 = 29;
pub const RCC_CR_PLLSAI2RDY_Msk: u32 = 536870912;
pub const RCC_CR_PLLSAI2RDY: u32 = 536870912;
pub const RCC_ICSCR_MSICAL_Pos: u32 = 0;
pub const RCC_ICSCR_MSICAL_Msk: u32 = 255;
pub const RCC_ICSCR_MSICAL: u32 = 255;
pub const RCC_ICSCR_MSICAL_0: u32 = 1;
pub const RCC_ICSCR_MSICAL_1: u32 = 2;
pub const RCC_ICSCR_MSICAL_2: u32 = 4;
pub const RCC_ICSCR_MSICAL_3: u32 = 8;
pub const RCC_ICSCR_MSICAL_4: u32 = 16;
pub const RCC_ICSCR_MSICAL_5: u32 = 32;
pub const RCC_ICSCR_MSICAL_6: u32 = 64;
pub const RCC_ICSCR_MSICAL_7: u32 = 128;
pub const RCC_ICSCR_MSITRIM_Pos: u32 = 8;
pub const RCC_ICSCR_MSITRIM_Msk: u32 = 65280;
pub const RCC_ICSCR_MSITRIM: u32 = 65280;
pub const RCC_ICSCR_MSITRIM_0: u32 = 256;
pub const RCC_ICSCR_MSITRIM_1: u32 = 512;
pub const RCC_ICSCR_MSITRIM_2: u32 = 1024;
pub const RCC_ICSCR_MSITRIM_3: u32 = 2048;
pub const RCC_ICSCR_MSITRIM_4: u32 = 4096;
pub const RCC_ICSCR_MSITRIM_5: u32 = 8192;
pub const RCC_ICSCR_MSITRIM_6: u32 = 16384;
pub const RCC_ICSCR_MSITRIM_7: u32 = 32768;
pub const RCC_ICSCR_HSICAL_Pos: u32 = 16;
pub const RCC_ICSCR_HSICAL_Msk: u32 = 16711680;
pub const RCC_ICSCR_HSICAL: u32 = 16711680;
pub const RCC_ICSCR_HSICAL_0: u32 = 65536;
pub const RCC_ICSCR_HSICAL_1: u32 = 131072;
pub const RCC_ICSCR_HSICAL_2: u32 = 262144;
pub const RCC_ICSCR_HSICAL_3: u32 = 524288;
pub const RCC_ICSCR_HSICAL_4: u32 = 1048576;
pub const RCC_ICSCR_HSICAL_5: u32 = 2097152;
pub const RCC_ICSCR_HSICAL_6: u32 = 4194304;
pub const RCC_ICSCR_HSICAL_7: u32 = 8388608;
pub const RCC_ICSCR_HSITRIM_Pos: u32 = 24;
pub const RCC_ICSCR_HSITRIM_Msk: u32 = 520093696;
pub const RCC_ICSCR_HSITRIM: u32 = 520093696;
pub const RCC_ICSCR_HSITRIM_0: u32 = 16777216;
pub const RCC_ICSCR_HSITRIM_1: u32 = 33554432;
pub const RCC_ICSCR_HSITRIM_2: u32 = 67108864;
pub const RCC_ICSCR_HSITRIM_3: u32 = 134217728;
pub const RCC_ICSCR_HSITRIM_4: u32 = 268435456;
pub const RCC_CFGR_SW_Pos: u32 = 0;
pub const RCC_CFGR_SW_Msk: u32 = 3;
pub const RCC_CFGR_SW: u32 = 3;
pub const RCC_CFGR_SW_0: u32 = 1;
pub const RCC_CFGR_SW_1: u32 = 2;
pub const RCC_CFGR_SW_MSI: u32 = 0;
pub const RCC_CFGR_SW_HSI: u32 = 1;
pub const RCC_CFGR_SW_HSE: u32 = 2;
pub const RCC_CFGR_SW_PLL: u32 = 3;
pub const RCC_CFGR_SWS_Pos: u32 = 2;
pub const RCC_CFGR_SWS_Msk: u32 = 12;
pub const RCC_CFGR_SWS: u32 = 12;
pub const RCC_CFGR_SWS_0: u32 = 4;
pub const RCC_CFGR_SWS_1: u32 = 8;
pub const RCC_CFGR_SWS_MSI: u32 = 0;
pub const RCC_CFGR_SWS_HSI: u32 = 4;
pub const RCC_CFGR_SWS_HSE: u32 = 8;
pub const RCC_CFGR_SWS_PLL: u32 = 12;
pub const RCC_CFGR_HPRE_Pos: u32 = 4;
pub const RCC_CFGR_HPRE_Msk: u32 = 240;
pub const RCC_CFGR_HPRE: u32 = 240;
pub const RCC_CFGR_HPRE_0: u32 = 16;
pub const RCC_CFGR_HPRE_1: u32 = 32;
pub const RCC_CFGR_HPRE_2: u32 = 64;
pub const RCC_CFGR_HPRE_3: u32 = 128;
pub const RCC_CFGR_HPRE_DIV1: u32 = 0;
pub const RCC_CFGR_HPRE_DIV2: u32 = 128;
pub const RCC_CFGR_HPRE_DIV4: u32 = 144;
pub const RCC_CFGR_HPRE_DIV8: u32 = 160;
pub const RCC_CFGR_HPRE_DIV16: u32 = 176;
pub const RCC_CFGR_HPRE_DIV64: u32 = 192;
pub const RCC_CFGR_HPRE_DIV128: u32 = 208;
pub const RCC_CFGR_HPRE_DIV256: u32 = 224;
pub const RCC_CFGR_HPRE_DIV512: u32 = 240;
pub const RCC_CFGR_PPRE1_Pos: u32 = 8;
pub const RCC_CFGR_PPRE1_Msk: u32 = 1792;
pub const RCC_CFGR_PPRE1: u32 = 1792;
pub const RCC_CFGR_PPRE1_0: u32 = 256;
pub const RCC_CFGR_PPRE1_1: u32 = 512;
pub const RCC_CFGR_PPRE1_2: u32 = 1024;
pub const RCC_CFGR_PPRE1_DIV1: u32 = 0;
pub const RCC_CFGR_PPRE1_DIV2: u32 = 1024;
pub const RCC_CFGR_PPRE1_DIV4: u32 = 1280;
pub const RCC_CFGR_PPRE1_DIV8: u32 = 1536;
pub const RCC_CFGR_PPRE1_DIV16: u32 = 1792;
pub const RCC_CFGR_PPRE2_Pos: u32 = 11;
pub const RCC_CFGR_PPRE2_Msk: u32 = 14336;
pub const RCC_CFGR_PPRE2: u32 = 14336;
pub const RCC_CFGR_PPRE2_0: u32 = 2048;
pub const RCC_CFGR_PPRE2_1: u32 = 4096;
pub const RCC_CFGR_PPRE2_2: u32 = 8192;
pub const RCC_CFGR_PPRE2_DIV1: u32 = 0;
pub const RCC_CFGR_PPRE2_DIV2: u32 = 8192;
pub const RCC_CFGR_PPRE2_DIV4: u32 = 10240;
pub const RCC_CFGR_PPRE2_DIV8: u32 = 12288;
pub const RCC_CFGR_PPRE2_DIV16: u32 = 14336;
pub const RCC_CFGR_STOPWUCK_Pos: u32 = 15;
pub const RCC_CFGR_STOPWUCK_Msk: u32 = 32768;
pub const RCC_CFGR_STOPWUCK: u32 = 32768;
pub const RCC_CFGR_MCOSEL_Pos: u32 = 24;
pub const RCC_CFGR_MCOSEL_Msk: u32 = 117440512;
pub const RCC_CFGR_MCOSEL: u32 = 117440512;
pub const RCC_CFGR_MCOSEL_0: u32 = 16777216;
pub const RCC_CFGR_MCOSEL_1: u32 = 33554432;
pub const RCC_CFGR_MCOSEL_2: u32 = 67108864;
pub const RCC_CFGR_MCOPRE_Pos: u32 = 28;
pub const RCC_CFGR_MCOPRE_Msk: u32 = 1879048192;
pub const RCC_CFGR_MCOPRE: u32 = 1879048192;
pub const RCC_CFGR_MCOPRE_0: u32 = 268435456;
pub const RCC_CFGR_MCOPRE_1: u32 = 536870912;
pub const RCC_CFGR_MCOPRE_2: u32 = 1073741824;
pub const RCC_CFGR_MCOPRE_DIV1: u32 = 0;
pub const RCC_CFGR_MCOPRE_DIV2: u32 = 268435456;
pub const RCC_CFGR_MCOPRE_DIV4: u32 = 536870912;
pub const RCC_CFGR_MCOPRE_DIV8: u32 = 805306368;
pub const RCC_CFGR_MCOPRE_DIV16: u32 = 1073741824;
pub const RCC_CFGR_MCO_PRE: u32 = 1879048192;
pub const RCC_CFGR_MCO_PRE_1: u32 = 0;
pub const RCC_CFGR_MCO_PRE_2: u32 = 268435456;
pub const RCC_CFGR_MCO_PRE_4: u32 = 536870912;
pub const RCC_CFGR_MCO_PRE_8: u32 = 805306368;
pub const RCC_CFGR_MCO_PRE_16: u32 = 1073741824;
pub const RCC_PLLCFGR_PLLSRC_Pos: u32 = 0;
pub const RCC_PLLCFGR_PLLSRC_Msk: u32 = 3;
pub const RCC_PLLCFGR_PLLSRC: u32 = 3;
pub const RCC_PLLCFGR_PLLSRC_MSI_Pos: u32 = 0;
pub const RCC_PLLCFGR_PLLSRC_MSI_Msk: u32 = 1;
pub const RCC_PLLCFGR_PLLSRC_MSI: u32 = 1;
pub const RCC_PLLCFGR_PLLSRC_HSI_Pos: u32 = 1;
pub const RCC_PLLCFGR_PLLSRC_HSI_Msk: u32 = 2;
pub const RCC_PLLCFGR_PLLSRC_HSI: u32 = 2;
pub const RCC_PLLCFGR_PLLSRC_HSE_Pos: u32 = 0;
pub const RCC_PLLCFGR_PLLSRC_HSE_Msk: u32 = 3;
pub const RCC_PLLCFGR_PLLSRC_HSE: u32 = 3;
pub const RCC_PLLCFGR_PLLM_Pos: u32 = 4;
pub const RCC_PLLCFGR_PLLM_Msk: u32 = 112;
pub const RCC_PLLCFGR_PLLM: u32 = 112;
pub const RCC_PLLCFGR_PLLM_0: u32 = 16;
pub const RCC_PLLCFGR_PLLM_1: u32 = 32;
pub const RCC_PLLCFGR_PLLM_2: u32 = 64;
pub const RCC_PLLCFGR_PLLN_Pos: u32 = 8;
pub const RCC_PLLCFGR_PLLN_Msk: u32 = 32512;
pub const RCC_PLLCFGR_PLLN: u32 = 32512;
pub const RCC_PLLCFGR_PLLN_0: u32 = 256;
pub const RCC_PLLCFGR_PLLN_1: u32 = 512;
pub const RCC_PLLCFGR_PLLN_2: u32 = 1024;
pub const RCC_PLLCFGR_PLLN_3: u32 = 2048;
pub const RCC_PLLCFGR_PLLN_4: u32 = 4096;
pub const RCC_PLLCFGR_PLLN_5: u32 = 8192;
pub const RCC_PLLCFGR_PLLN_6: u32 = 16384;
pub const RCC_PLLCFGR_PLLPEN_Pos: u32 = 16;
pub const RCC_PLLCFGR_PLLPEN_Msk: u32 = 65536;
pub const RCC_PLLCFGR_PLLPEN: u32 = 65536;
pub const RCC_PLLCFGR_PLLP_Pos: u32 = 17;
pub const RCC_PLLCFGR_PLLP_Msk: u32 = 131072;
pub const RCC_PLLCFGR_PLLP: u32 = 131072;
pub const RCC_PLLCFGR_PLLQEN_Pos: u32 = 20;
pub const RCC_PLLCFGR_PLLQEN_Msk: u32 = 1048576;
pub const RCC_PLLCFGR_PLLQEN: u32 = 1048576;
pub const RCC_PLLCFGR_PLLQ_Pos: u32 = 21;
pub const RCC_PLLCFGR_PLLQ_Msk: u32 = 6291456;
pub const RCC_PLLCFGR_PLLQ: u32 = 6291456;
pub const RCC_PLLCFGR_PLLQ_0: u32 = 2097152;
pub const RCC_PLLCFGR_PLLQ_1: u32 = 4194304;
pub const RCC_PLLCFGR_PLLREN_Pos: u32 = 24;
pub const RCC_PLLCFGR_PLLREN_Msk: u32 = 16777216;
pub const RCC_PLLCFGR_PLLREN: u32 = 16777216;
pub const RCC_PLLCFGR_PLLR_Pos: u32 = 25;
pub const RCC_PLLCFGR_PLLR_Msk: u32 = 100663296;
pub const RCC_PLLCFGR_PLLR: u32 = 100663296;
pub const RCC_PLLCFGR_PLLR_0: u32 = 33554432;
pub const RCC_PLLCFGR_PLLR_1: u32 = 67108864;
pub const RCC_PLLSAI1CFGR_PLLSAI1N_Pos: u32 = 8;
pub const RCC_PLLSAI1CFGR_PLLSAI1N_Msk: u32 = 32512;
pub const RCC_PLLSAI1CFGR_PLLSAI1N: u32 = 32512;
pub const RCC_PLLSAI1CFGR_PLLSAI1N_0: u32 = 256;
pub const RCC_PLLSAI1CFGR_PLLSAI1N_1: u32 = 512;
pub const RCC_PLLSAI1CFGR_PLLSAI1N_2: u32 = 1024;
pub const RCC_PLLSAI1CFGR_PLLSAI1N_3: u32 = 2048;
pub const RCC_PLLSAI1CFGR_PLLSAI1N_4: u32 = 4096;
pub const RCC_PLLSAI1CFGR_PLLSAI1N_5: u32 = 8192;
pub const RCC_PLLSAI1CFGR_PLLSAI1N_6: u32 = 16384;
pub const RCC_PLLSAI1CFGR_PLLSAI1PEN_Pos: u32 = 16;
pub const RCC_PLLSAI1CFGR_PLLSAI1PEN_Msk: u32 = 65536;
pub const RCC_PLLSAI1CFGR_PLLSAI1PEN: u32 = 65536;
pub const RCC_PLLSAI1CFGR_PLLSAI1P_Pos: u32 = 17;
pub const RCC_PLLSAI1CFGR_PLLSAI1P_Msk: u32 = 131072;
pub const RCC_PLLSAI1CFGR_PLLSAI1P: u32 = 131072;
pub const RCC_PLLSAI1CFGR_PLLSAI1QEN_Pos: u32 = 20;
pub const RCC_PLLSAI1CFGR_PLLSAI1QEN_Msk: u32 = 1048576;
pub const RCC_PLLSAI1CFGR_PLLSAI1QEN: u32 = 1048576;
pub const RCC_PLLSAI1CFGR_PLLSAI1Q_Pos: u32 = 21;
pub const RCC_PLLSAI1CFGR_PLLSAI1Q_Msk: u32 = 6291456;
pub const RCC_PLLSAI1CFGR_PLLSAI1Q: u32 = 6291456;
pub const RCC_PLLSAI1CFGR_PLLSAI1Q_0: u32 = 2097152;
pub const RCC_PLLSAI1CFGR_PLLSAI1Q_1: u32 = 4194304;
pub const RCC_PLLSAI1CFGR_PLLSAI1REN_Pos: u32 = 24;
pub const RCC_PLLSAI1CFGR_PLLSAI1REN_Msk: u32 = 16777216;
pub const RCC_PLLSAI1CFGR_PLLSAI1REN: u32 = 16777216;
pub const RCC_PLLSAI1CFGR_PLLSAI1R_Pos: u32 = 25;
pub const RCC_PLLSAI1CFGR_PLLSAI1R_Msk: u32 = 100663296;
pub const RCC_PLLSAI1CFGR_PLLSAI1R: u32 = 100663296;
pub const RCC_PLLSAI1CFGR_PLLSAI1R_0: u32 = 33554432;
pub const RCC_PLLSAI1CFGR_PLLSAI1R_1: u32 = 67108864;
pub const RCC_PLLSAI2CFGR_PLLSAI2N_Pos: u32 = 8;
pub const RCC_PLLSAI2CFGR_PLLSAI2N_Msk: u32 = 32512;
pub const RCC_PLLSAI2CFGR_PLLSAI2N: u32 = 32512;
pub const RCC_PLLSAI2CFGR_PLLSAI2N_0: u32 = 256;
pub const RCC_PLLSAI2CFGR_PLLSAI2N_1: u32 = 512;
pub const RCC_PLLSAI2CFGR_PLLSAI2N_2: u32 = 1024;
pub const RCC_PLLSAI2CFGR_PLLSAI2N_3: u32 = 2048;
pub const RCC_PLLSAI2CFGR_PLLSAI2N_4: u32 = 4096;
pub const RCC_PLLSAI2CFGR_PLLSAI2N_5: u32 = 8192;
pub const RCC_PLLSAI2CFGR_PLLSAI2N_6: u32 = 16384;
pub const RCC_PLLSAI2CFGR_PLLSAI2PEN_Pos: u32 = 16;
pub const RCC_PLLSAI2CFGR_PLLSAI2PEN_Msk: u32 = 65536;
pub const RCC_PLLSAI2CFGR_PLLSAI2PEN: u32 = 65536;
pub const RCC_PLLSAI2CFGR_PLLSAI2P_Pos: u32 = 17;
pub const RCC_PLLSAI2CFGR_PLLSAI2P_Msk: u32 = 131072;
pub const RCC_PLLSAI2CFGR_PLLSAI2P: u32 = 131072;
pub const RCC_PLLSAI2CFGR_PLLSAI2REN_Pos: u32 = 24;
pub const RCC_PLLSAI2CFGR_PLLSAI2REN_Msk: u32 = 16777216;
pub const RCC_PLLSAI2CFGR_PLLSAI2REN: u32 = 16777216;
pub const RCC_PLLSAI2CFGR_PLLSAI2R_Pos: u32 = 25;
pub const RCC_PLLSAI2CFGR_PLLSAI2R_Msk: u32 = 100663296;
pub const RCC_PLLSAI2CFGR_PLLSAI2R: u32 = 100663296;
pub const RCC_PLLSAI2CFGR_PLLSAI2R_0: u32 = 33554432;
pub const RCC_PLLSAI2CFGR_PLLSAI2R_1: u32 = 67108864;
pub const RCC_CIER_LSIRDYIE_Pos: u32 = 0;
pub const RCC_CIER_LSIRDYIE_Msk: u32 = 1;
pub const RCC_CIER_LSIRDYIE: u32 = 1;
pub const RCC_CIER_LSERDYIE_Pos: u32 = 1;
pub const RCC_CIER_LSERDYIE_Msk: u32 = 2;
pub const RCC_CIER_LSERDYIE: u32 = 2;
pub const RCC_CIER_MSIRDYIE_Pos: u32 = 2;
pub const RCC_CIER_MSIRDYIE_Msk: u32 = 4;
pub const RCC_CIER_MSIRDYIE: u32 = 4;
pub const RCC_CIER_HSIRDYIE_Pos: u32 = 3;
pub const RCC_CIER_HSIRDYIE_Msk: u32 = 8;
pub const RCC_CIER_HSIRDYIE: u32 = 8;
pub const RCC_CIER_HSERDYIE_Pos: u32 = 4;
pub const RCC_CIER_HSERDYIE_Msk: u32 = 16;
pub const RCC_CIER_HSERDYIE: u32 = 16;
pub const RCC_CIER_PLLRDYIE_Pos: u32 = 5;
pub const RCC_CIER_PLLRDYIE_Msk: u32 = 32;
pub const RCC_CIER_PLLRDYIE: u32 = 32;
pub const RCC_CIER_PLLSAI1RDYIE_Pos: u32 = 6;
pub const RCC_CIER_PLLSAI1RDYIE_Msk: u32 = 64;
pub const RCC_CIER_PLLSAI1RDYIE: u32 = 64;
pub const RCC_CIER_PLLSAI2RDYIE_Pos: u32 = 7;
pub const RCC_CIER_PLLSAI2RDYIE_Msk: u32 = 128;
pub const RCC_CIER_PLLSAI2RDYIE: u32 = 128;
pub const RCC_CIER_LSECSSIE_Pos: u32 = 9;
pub const RCC_CIER_LSECSSIE_Msk: u32 = 512;
pub const RCC_CIER_LSECSSIE: u32 = 512;
pub const RCC_CIFR_LSIRDYF_Pos: u32 = 0;
pub const RCC_CIFR_LSIRDYF_Msk: u32 = 1;
pub const RCC_CIFR_LSIRDYF: u32 = 1;
pub const RCC_CIFR_LSERDYF_Pos: u32 = 1;
pub const RCC_CIFR_LSERDYF_Msk: u32 = 2;
pub const RCC_CIFR_LSERDYF: u32 = 2;
pub const RCC_CIFR_MSIRDYF_Pos: u32 = 2;
pub const RCC_CIFR_MSIRDYF_Msk: u32 = 4;
pub const RCC_CIFR_MSIRDYF: u32 = 4;
pub const RCC_CIFR_HSIRDYF_Pos: u32 = 3;
pub const RCC_CIFR_HSIRDYF_Msk: u32 = 8;
pub const RCC_CIFR_HSIRDYF: u32 = 8;
pub const RCC_CIFR_HSERDYF_Pos: u32 = 4;
pub const RCC_CIFR_HSERDYF_Msk: u32 = 16;
pub const RCC_CIFR_HSERDYF: u32 = 16;
pub const RCC_CIFR_PLLRDYF_Pos: u32 = 5;
pub const RCC_CIFR_PLLRDYF_Msk: u32 = 32;
pub const RCC_CIFR_PLLRDYF: u32 = 32;
pub const RCC_CIFR_PLLSAI1RDYF_Pos: u32 = 6;
pub const RCC_CIFR_PLLSAI1RDYF_Msk: u32 = 64;
pub const RCC_CIFR_PLLSAI1RDYF: u32 = 64;
pub const RCC_CIFR_PLLSAI2RDYF_Pos: u32 = 7;
pub const RCC_CIFR_PLLSAI2RDYF_Msk: u32 = 128;
pub const RCC_CIFR_PLLSAI2RDYF: u32 = 128;
pub const RCC_CIFR_CSSF_Pos: u32 = 8;
pub const RCC_CIFR_CSSF_Msk: u32 = 256;
pub const RCC_CIFR_CSSF: u32 = 256;
pub const RCC_CIFR_LSECSSF_Pos: u32 = 9;
pub const RCC_CIFR_LSECSSF_Msk: u32 = 512;
pub const RCC_CIFR_LSECSSF: u32 = 512;
pub const RCC_CICR_LSIRDYC_Pos: u32 = 0;
pub const RCC_CICR_LSIRDYC_Msk: u32 = 1;
pub const RCC_CICR_LSIRDYC: u32 = 1;
pub const RCC_CICR_LSERDYC_Pos: u32 = 1;
pub const RCC_CICR_LSERDYC_Msk: u32 = 2;
pub const RCC_CICR_LSERDYC: u32 = 2;
pub const RCC_CICR_MSIRDYC_Pos: u32 = 2;
pub const RCC_CICR_MSIRDYC_Msk: u32 = 4;
pub const RCC_CICR_MSIRDYC: u32 = 4;
pub const RCC_CICR_HSIRDYC_Pos: u32 = 3;
pub const RCC_CICR_HSIRDYC_Msk: u32 = 8;
pub const RCC_CICR_HSIRDYC: u32 = 8;
pub const RCC_CICR_HSERDYC_Pos: u32 = 4;
pub const RCC_CICR_HSERDYC_Msk: u32 = 16;
pub const RCC_CICR_HSERDYC: u32 = 16;
pub const RCC_CICR_PLLRDYC_Pos: u32 = 5;
pub const RCC_CICR_PLLRDYC_Msk: u32 = 32;
pub const RCC_CICR_PLLRDYC: u32 = 32;
pub const RCC_CICR_PLLSAI1RDYC_Pos: u32 = 6;
pub const RCC_CICR_PLLSAI1RDYC_Msk: u32 = 64;
pub const RCC_CICR_PLLSAI1RDYC: u32 = 64;
pub const RCC_CICR_PLLSAI2RDYC_Pos: u32 = 7;
pub const RCC_CICR_PLLSAI2RDYC_Msk: u32 = 128;
pub const RCC_CICR_PLLSAI2RDYC: u32 = 128;
pub const RCC_CICR_CSSC_Pos: u32 = 8;
pub const RCC_CICR_CSSC_Msk: u32 = 256;
pub const RCC_CICR_CSSC: u32 = 256;
pub const RCC_CICR_LSECSSC_Pos: u32 = 9;
pub const RCC_CICR_LSECSSC_Msk: u32 = 512;
pub const RCC_CICR_LSECSSC: u32 = 512;
pub const RCC_AHB1RSTR_DMA1RST_Pos: u32 = 0;
pub const RCC_AHB1RSTR_DMA1RST_Msk: u32 = 1;
pub const RCC_AHB1RSTR_DMA1RST: u32 = 1;
pub const RCC_AHB1RSTR_DMA2RST_Pos: u32 = 1;
pub const RCC_AHB1RSTR_DMA2RST_Msk: u32 = 2;
pub const RCC_AHB1RSTR_DMA2RST: u32 = 2;
pub const RCC_AHB1RSTR_FLASHRST_Pos: u32 = 8;
pub const RCC_AHB1RSTR_FLASHRST_Msk: u32 = 256;
pub const RCC_AHB1RSTR_FLASHRST: u32 = 256;
pub const RCC_AHB1RSTR_CRCRST_Pos: u32 = 12;
pub const RCC_AHB1RSTR_CRCRST_Msk: u32 = 4096;
pub const RCC_AHB1RSTR_CRCRST: u32 = 4096;
pub const RCC_AHB1RSTR_TSCRST_Pos: u32 = 16;
pub const RCC_AHB1RSTR_TSCRST_Msk: u32 = 65536;
pub const RCC_AHB1RSTR_TSCRST: u32 = 65536;
pub const RCC_AHB2RSTR_GPIOARST_Pos: u32 = 0;
pub const RCC_AHB2RSTR_GPIOARST_Msk: u32 = 1;
pub const RCC_AHB2RSTR_GPIOARST: u32 = 1;
pub const RCC_AHB2RSTR_GPIOBRST_Pos: u32 = 1;
pub const RCC_AHB2RSTR_GPIOBRST_Msk: u32 = 2;
pub const RCC_AHB2RSTR_GPIOBRST: u32 = 2;
pub const RCC_AHB2RSTR_GPIOCRST_Pos: u32 = 2;
pub const RCC_AHB2RSTR_GPIOCRST_Msk: u32 = 4;
pub const RCC_AHB2RSTR_GPIOCRST: u32 = 4;
pub const RCC_AHB2RSTR_GPIODRST_Pos: u32 = 3;
pub const RCC_AHB2RSTR_GPIODRST_Msk: u32 = 8;
pub const RCC_AHB2RSTR_GPIODRST: u32 = 8;
pub const RCC_AHB2RSTR_GPIOERST_Pos: u32 = 4;
pub const RCC_AHB2RSTR_GPIOERST_Msk: u32 = 16;
pub const RCC_AHB2RSTR_GPIOERST: u32 = 16;
pub const RCC_AHB2RSTR_GPIOFRST_Pos: u32 = 5;
pub const RCC_AHB2RSTR_GPIOFRST_Msk: u32 = 32;
pub const RCC_AHB2RSTR_GPIOFRST: u32 = 32;
pub const RCC_AHB2RSTR_GPIOGRST_Pos: u32 = 6;
pub const RCC_AHB2RSTR_GPIOGRST_Msk: u32 = 64;
pub const RCC_AHB2RSTR_GPIOGRST: u32 = 64;
pub const RCC_AHB2RSTR_GPIOHRST_Pos: u32 = 7;
pub const RCC_AHB2RSTR_GPIOHRST_Msk: u32 = 128;
pub const RCC_AHB2RSTR_GPIOHRST: u32 = 128;
pub const RCC_AHB2RSTR_OTGFSRST_Pos: u32 = 12;
pub const RCC_AHB2RSTR_OTGFSRST_Msk: u32 = 4096;
pub const RCC_AHB2RSTR_OTGFSRST: u32 = 4096;
pub const RCC_AHB2RSTR_ADCRST_Pos: u32 = 13;
pub const RCC_AHB2RSTR_ADCRST_Msk: u32 = 8192;
pub const RCC_AHB2RSTR_ADCRST: u32 = 8192;
pub const RCC_AHB2RSTR_RNGRST_Pos: u32 = 18;
pub const RCC_AHB2RSTR_RNGRST_Msk: u32 = 262144;
pub const RCC_AHB2RSTR_RNGRST: u32 = 262144;
pub const RCC_AHB3RSTR_FMCRST_Pos: u32 = 0;
pub const RCC_AHB3RSTR_FMCRST_Msk: u32 = 1;
pub const RCC_AHB3RSTR_FMCRST: u32 = 1;
pub const RCC_AHB3RSTR_QSPIRST_Pos: u32 = 8;
pub const RCC_AHB3RSTR_QSPIRST_Msk: u32 = 256;
pub const RCC_AHB3RSTR_QSPIRST: u32 = 256;
pub const RCC_APB1RSTR1_TIM2RST_Pos: u32 = 0;
pub const RCC_APB1RSTR1_TIM2RST_Msk: u32 = 1;
pub const RCC_APB1RSTR1_TIM2RST: u32 = 1;
pub const RCC_APB1RSTR1_TIM3RST_Pos: u32 = 1;
pub const RCC_APB1RSTR1_TIM3RST_Msk: u32 = 2;
pub const RCC_APB1RSTR1_TIM3RST: u32 = 2;
pub const RCC_APB1RSTR1_TIM4RST_Pos: u32 = 2;
pub const RCC_APB1RSTR1_TIM4RST_Msk: u32 = 4;
pub const RCC_APB1RSTR1_TIM4RST: u32 = 4;
pub const RCC_APB1RSTR1_TIM5RST_Pos: u32 = 3;
pub const RCC_APB1RSTR1_TIM5RST_Msk: u32 = 8;
pub const RCC_APB1RSTR1_TIM5RST: u32 = 8;
pub const RCC_APB1RSTR1_TIM6RST_Pos: u32 = 4;
pub const RCC_APB1RSTR1_TIM6RST_Msk: u32 = 16;
pub const RCC_APB1RSTR1_TIM6RST: u32 = 16;
pub const RCC_APB1RSTR1_TIM7RST_Pos: u32 = 5;
pub const RCC_APB1RSTR1_TIM7RST_Msk: u32 = 32;
pub const RCC_APB1RSTR1_TIM7RST: u32 = 32;
pub const RCC_APB1RSTR1_SPI2RST_Pos: u32 = 14;
pub const RCC_APB1RSTR1_SPI2RST_Msk: u32 = 16384;
pub const RCC_APB1RSTR1_SPI2RST: u32 = 16384;
pub const RCC_APB1RSTR1_SPI3RST_Pos: u32 = 15;
pub const RCC_APB1RSTR1_SPI3RST_Msk: u32 = 32768;
pub const RCC_APB1RSTR1_SPI3RST: u32 = 32768;
pub const RCC_APB1RSTR1_USART2RST_Pos: u32 = 17;
pub const RCC_APB1RSTR1_USART2RST_Msk: u32 = 131072;
pub const RCC_APB1RSTR1_USART2RST: u32 = 131072;
pub const RCC_APB1RSTR1_USART3RST_Pos: u32 = 18;
pub const RCC_APB1RSTR1_USART3RST_Msk: u32 = 262144;
pub const RCC_APB1RSTR1_USART3RST: u32 = 262144;
pub const RCC_APB1RSTR1_UART4RST_Pos: u32 = 19;
pub const RCC_APB1RSTR1_UART4RST_Msk: u32 = 524288;
pub const RCC_APB1RSTR1_UART4RST: u32 = 524288;
pub const RCC_APB1RSTR1_UART5RST_Pos: u32 = 20;
pub const RCC_APB1RSTR1_UART5RST_Msk: u32 = 1048576;
pub const RCC_APB1RSTR1_UART5RST: u32 = 1048576;
pub const RCC_APB1RSTR1_I2C1RST_Pos: u32 = 21;
pub const RCC_APB1RSTR1_I2C1RST_Msk: u32 = 2097152;
pub const RCC_APB1RSTR1_I2C1RST: u32 = 2097152;
pub const RCC_APB1RSTR1_I2C2RST_Pos: u32 = 22;
pub const RCC_APB1RSTR1_I2C2RST_Msk: u32 = 4194304;
pub const RCC_APB1RSTR1_I2C2RST: u32 = 4194304;
pub const RCC_APB1RSTR1_I2C3RST_Pos: u32 = 23;
pub const RCC_APB1RSTR1_I2C3RST_Msk: u32 = 8388608;
pub const RCC_APB1RSTR1_I2C3RST: u32 = 8388608;
pub const RCC_APB1RSTR1_CAN1RST_Pos: u32 = 25;
pub const RCC_APB1RSTR1_CAN1RST_Msk: u32 = 33554432;
pub const RCC_APB1RSTR1_CAN1RST: u32 = 33554432;
pub const RCC_APB1RSTR1_PWRRST_Pos: u32 = 28;
pub const RCC_APB1RSTR1_PWRRST_Msk: u32 = 268435456;
pub const RCC_APB1RSTR1_PWRRST: u32 = 268435456;
pub const RCC_APB1RSTR1_DAC1RST_Pos: u32 = 29;
pub const RCC_APB1RSTR1_DAC1RST_Msk: u32 = 536870912;
pub const RCC_APB1RSTR1_DAC1RST: u32 = 536870912;
pub const RCC_APB1RSTR1_OPAMPRST_Pos: u32 = 30;
pub const RCC_APB1RSTR1_OPAMPRST_Msk: u32 = 1073741824;
pub const RCC_APB1RSTR1_OPAMPRST: u32 = 1073741824;
pub const RCC_APB1RSTR1_LPTIM1RST_Pos: u32 = 31;
pub const RCC_APB1RSTR1_LPTIM1RST_Msk: u32 = 2147483648;
pub const RCC_APB1RSTR1_LPTIM1RST: u32 = 2147483648;
pub const RCC_APB1RSTR2_LPUART1RST_Pos: u32 = 0;
pub const RCC_APB1RSTR2_LPUART1RST_Msk: u32 = 1;
pub const RCC_APB1RSTR2_LPUART1RST: u32 = 1;
pub const RCC_APB1RSTR2_SWPMI1RST_Pos: u32 = 2;
pub const RCC_APB1RSTR2_SWPMI1RST_Msk: u32 = 4;
pub const RCC_APB1RSTR2_SWPMI1RST: u32 = 4;
pub const RCC_APB1RSTR2_LPTIM2RST_Pos: u32 = 5;
pub const RCC_APB1RSTR2_LPTIM2RST_Msk: u32 = 32;
pub const RCC_APB1RSTR2_LPTIM2RST: u32 = 32;
pub const RCC_APB2RSTR_SYSCFGRST_Pos: u32 = 0;
pub const RCC_APB2RSTR_SYSCFGRST_Msk: u32 = 1;
pub const RCC_APB2RSTR_SYSCFGRST: u32 = 1;
pub const RCC_APB2RSTR_SDMMC1RST_Pos: u32 = 10;
pub const RCC_APB2RSTR_SDMMC1RST_Msk: u32 = 1024;
pub const RCC_APB2RSTR_SDMMC1RST: u32 = 1024;
pub const RCC_APB2RSTR_TIM1RST_Pos: u32 = 11;
pub const RCC_APB2RSTR_TIM1RST_Msk: u32 = 2048;
pub const RCC_APB2RSTR_TIM1RST: u32 = 2048;
pub const RCC_APB2RSTR_SPI1RST_Pos: u32 = 12;
pub const RCC_APB2RSTR_SPI1RST_Msk: u32 = 4096;
pub const RCC_APB2RSTR_SPI1RST: u32 = 4096;
pub const RCC_APB2RSTR_TIM8RST_Pos: u32 = 13;
pub const RCC_APB2RSTR_TIM8RST_Msk: u32 = 8192;
pub const RCC_APB2RSTR_TIM8RST: u32 = 8192;
pub const RCC_APB2RSTR_USART1RST_Pos: u32 = 14;
pub const RCC_APB2RSTR_USART1RST_Msk: u32 = 16384;
pub const RCC_APB2RSTR_USART1RST: u32 = 16384;
pub const RCC_APB2RSTR_TIM15RST_Pos: u32 = 16;
pub const RCC_APB2RSTR_TIM15RST_Msk: u32 = 65536;
pub const RCC_APB2RSTR_TIM15RST: u32 = 65536;
pub const RCC_APB2RSTR_TIM16RST_Pos: u32 = 17;
pub const RCC_APB2RSTR_TIM16RST_Msk: u32 = 131072;
pub const RCC_APB2RSTR_TIM16RST: u32 = 131072;
pub const RCC_APB2RSTR_TIM17RST_Pos: u32 = 18;
pub const RCC_APB2RSTR_TIM17RST_Msk: u32 = 262144;
pub const RCC_APB2RSTR_TIM17RST: u32 = 262144;
pub const RCC_APB2RSTR_SAI1RST_Pos: u32 = 21;
pub const RCC_APB2RSTR_SAI1RST_Msk: u32 = 2097152;
pub const RCC_APB2RSTR_SAI1RST: u32 = 2097152;
pub const RCC_APB2RSTR_SAI2RST_Pos: u32 = 22;
pub const RCC_APB2RSTR_SAI2RST_Msk: u32 = 4194304;
pub const RCC_APB2RSTR_SAI2RST: u32 = 4194304;
pub const RCC_APB2RSTR_DFSDM1RST_Pos: u32 = 24;
pub const RCC_APB2RSTR_DFSDM1RST_Msk: u32 = 16777216;
pub const RCC_APB2RSTR_DFSDM1RST: u32 = 16777216;
pub const RCC_AHB1ENR_DMA1EN_Pos: u32 = 0;
pub const RCC_AHB1ENR_DMA1EN_Msk: u32 = 1;
pub const RCC_AHB1ENR_DMA1EN: u32 = 1;
pub const RCC_AHB1ENR_DMA2EN_Pos: u32 = 1;
pub const RCC_AHB1ENR_DMA2EN_Msk: u32 = 2;
pub const RCC_AHB1ENR_DMA2EN: u32 = 2;
pub const RCC_AHB1ENR_FLASHEN_Pos: u32 = 8;
pub const RCC_AHB1ENR_FLASHEN_Msk: u32 = 256;
pub const RCC_AHB1ENR_FLASHEN: u32 = 256;
pub const RCC_AHB1ENR_CRCEN_Pos: u32 = 12;
pub const RCC_AHB1ENR_CRCEN_Msk: u32 = 4096;
pub const RCC_AHB1ENR_CRCEN: u32 = 4096;
pub const RCC_AHB1ENR_TSCEN_Pos: u32 = 16;
pub const RCC_AHB1ENR_TSCEN_Msk: u32 = 65536;
pub const RCC_AHB1ENR_TSCEN: u32 = 65536;
pub const RCC_AHB2ENR_GPIOAEN_Pos: u32 = 0;
pub const RCC_AHB2ENR_GPIOAEN_Msk: u32 = 1;
pub const RCC_AHB2ENR_GPIOAEN: u32 = 1;
pub const RCC_AHB2ENR_GPIOBEN_Pos: u32 = 1;
pub const RCC_AHB2ENR_GPIOBEN_Msk: u32 = 2;
pub const RCC_AHB2ENR_GPIOBEN: u32 = 2;
pub const RCC_AHB2ENR_GPIOCEN_Pos: u32 = 2;
pub const RCC_AHB2ENR_GPIOCEN_Msk: u32 = 4;
pub const RCC_AHB2ENR_GPIOCEN: u32 = 4;
pub const RCC_AHB2ENR_GPIODEN_Pos: u32 = 3;
pub const RCC_AHB2ENR_GPIODEN_Msk: u32 = 8;
pub const RCC_AHB2ENR_GPIODEN: u32 = 8;
pub const RCC_AHB2ENR_GPIOEEN_Pos: u32 = 4;
pub const RCC_AHB2ENR_GPIOEEN_Msk: u32 = 16;
pub const RCC_AHB2ENR_GPIOEEN: u32 = 16;
pub const RCC_AHB2ENR_GPIOFEN_Pos: u32 = 5;
pub const RCC_AHB2ENR_GPIOFEN_Msk: u32 = 32;
pub const RCC_AHB2ENR_GPIOFEN: u32 = 32;
pub const RCC_AHB2ENR_GPIOGEN_Pos: u32 = 6;
pub const RCC_AHB2ENR_GPIOGEN_Msk: u32 = 64;
pub const RCC_AHB2ENR_GPIOGEN: u32 = 64;
pub const RCC_AHB2ENR_GPIOHEN_Pos: u32 = 7;
pub const RCC_AHB2ENR_GPIOHEN_Msk: u32 = 128;
pub const RCC_AHB2ENR_GPIOHEN: u32 = 128;
pub const RCC_AHB2ENR_OTGFSEN_Pos: u32 = 12;
pub const RCC_AHB2ENR_OTGFSEN_Msk: u32 = 4096;
pub const RCC_AHB2ENR_OTGFSEN: u32 = 4096;
pub const RCC_AHB2ENR_ADCEN_Pos: u32 = 13;
pub const RCC_AHB2ENR_ADCEN_Msk: u32 = 8192;
pub const RCC_AHB2ENR_ADCEN: u32 = 8192;
pub const RCC_AHB2ENR_RNGEN_Pos: u32 = 18;
pub const RCC_AHB2ENR_RNGEN_Msk: u32 = 262144;
pub const RCC_AHB2ENR_RNGEN: u32 = 262144;
pub const RCC_AHB3ENR_FMCEN_Pos: u32 = 0;
pub const RCC_AHB3ENR_FMCEN_Msk: u32 = 1;
pub const RCC_AHB3ENR_FMCEN: u32 = 1;
pub const RCC_AHB3ENR_QSPIEN_Pos: u32 = 8;
pub const RCC_AHB3ENR_QSPIEN_Msk: u32 = 256;
pub const RCC_AHB3ENR_QSPIEN: u32 = 256;
pub const RCC_APB1ENR1_TIM2EN_Pos: u32 = 0;
pub const RCC_APB1ENR1_TIM2EN_Msk: u32 = 1;
pub const RCC_APB1ENR1_TIM2EN: u32 = 1;
pub const RCC_APB1ENR1_TIM3EN_Pos: u32 = 1;
pub const RCC_APB1ENR1_TIM3EN_Msk: u32 = 2;
pub const RCC_APB1ENR1_TIM3EN: u32 = 2;
pub const RCC_APB1ENR1_TIM4EN_Pos: u32 = 2;
pub const RCC_APB1ENR1_TIM4EN_Msk: u32 = 4;
pub const RCC_APB1ENR1_TIM4EN: u32 = 4;
pub const RCC_APB1ENR1_TIM5EN_Pos: u32 = 3;
pub const RCC_APB1ENR1_TIM5EN_Msk: u32 = 8;
pub const RCC_APB1ENR1_TIM5EN: u32 = 8;
pub const RCC_APB1ENR1_TIM6EN_Pos: u32 = 4;
pub const RCC_APB1ENR1_TIM6EN_Msk: u32 = 16;
pub const RCC_APB1ENR1_TIM6EN: u32 = 16;
pub const RCC_APB1ENR1_TIM7EN_Pos: u32 = 5;
pub const RCC_APB1ENR1_TIM7EN_Msk: u32 = 32;
pub const RCC_APB1ENR1_TIM7EN: u32 = 32;
pub const RCC_APB1ENR1_WWDGEN_Pos: u32 = 11;
pub const RCC_APB1ENR1_WWDGEN_Msk: u32 = 2048;
pub const RCC_APB1ENR1_WWDGEN: u32 = 2048;
pub const RCC_APB1ENR1_SPI2EN_Pos: u32 = 14;
pub const RCC_APB1ENR1_SPI2EN_Msk: u32 = 16384;
pub const RCC_APB1ENR1_SPI2EN: u32 = 16384;
pub const RCC_APB1ENR1_SPI3EN_Pos: u32 = 15;
pub const RCC_APB1ENR1_SPI3EN_Msk: u32 = 32768;
pub const RCC_APB1ENR1_SPI3EN: u32 = 32768;
pub const RCC_APB1ENR1_USART2EN_Pos: u32 = 17;
pub const RCC_APB1ENR1_USART2EN_Msk: u32 = 131072;
pub const RCC_APB1ENR1_USART2EN: u32 = 131072;
pub const RCC_APB1ENR1_USART3EN_Pos: u32 = 18;
pub const RCC_APB1ENR1_USART3EN_Msk: u32 = 262144;
pub const RCC_APB1ENR1_USART3EN: u32 = 262144;
pub const RCC_APB1ENR1_UART4EN_Pos: u32 = 19;
pub const RCC_APB1ENR1_UART4EN_Msk: u32 = 524288;
pub const RCC_APB1ENR1_UART4EN: u32 = 524288;
pub const RCC_APB1ENR1_UART5EN_Pos: u32 = 20;
pub const RCC_APB1ENR1_UART5EN_Msk: u32 = 1048576;
pub const RCC_APB1ENR1_UART5EN: u32 = 1048576;
pub const RCC_APB1ENR1_I2C1EN_Pos: u32 = 21;
pub const RCC_APB1ENR1_I2C1EN_Msk: u32 = 2097152;
pub const RCC_APB1ENR1_I2C1EN: u32 = 2097152;
pub const RCC_APB1ENR1_I2C2EN_Pos: u32 = 22;
pub const RCC_APB1ENR1_I2C2EN_Msk: u32 = 4194304;
pub const RCC_APB1ENR1_I2C2EN: u32 = 4194304;
pub const RCC_APB1ENR1_I2C3EN_Pos: u32 = 23;
pub const RCC_APB1ENR1_I2C3EN_Msk: u32 = 8388608;
pub const RCC_APB1ENR1_I2C3EN: u32 = 8388608;
pub const RCC_APB1ENR1_CAN1EN_Pos: u32 = 25;
pub const RCC_APB1ENR1_CAN1EN_Msk: u32 = 33554432;
pub const RCC_APB1ENR1_CAN1EN: u32 = 33554432;
pub const RCC_APB1ENR1_PWREN_Pos: u32 = 28;
pub const RCC_APB1ENR1_PWREN_Msk: u32 = 268435456;
pub const RCC_APB1ENR1_PWREN: u32 = 268435456;
pub const RCC_APB1ENR1_DAC1EN_Pos: u32 = 29;
pub const RCC_APB1ENR1_DAC1EN_Msk: u32 = 536870912;
pub const RCC_APB1ENR1_DAC1EN: u32 = 536870912;
pub const RCC_APB1ENR1_OPAMPEN_Pos: u32 = 30;
pub const RCC_APB1ENR1_OPAMPEN_Msk: u32 = 1073741824;
pub const RCC_APB1ENR1_OPAMPEN: u32 = 1073741824;
pub const RCC_APB1ENR1_LPTIM1EN_Pos: u32 = 31;
pub const RCC_APB1ENR1_LPTIM1EN_Msk: u32 = 2147483648;
pub const RCC_APB1ENR1_LPTIM1EN: u32 = 2147483648;
pub const RCC_APB1ENR2_LPUART1EN_Pos: u32 = 0;
pub const RCC_APB1ENR2_LPUART1EN_Msk: u32 = 1;
pub const RCC_APB1ENR2_LPUART1EN: u32 = 1;
pub const RCC_APB1ENR2_SWPMI1EN_Pos: u32 = 2;
pub const RCC_APB1ENR2_SWPMI1EN_Msk: u32 = 4;
pub const RCC_APB1ENR2_SWPMI1EN: u32 = 4;
pub const RCC_APB1ENR2_LPTIM2EN_Pos: u32 = 5;
pub const RCC_APB1ENR2_LPTIM2EN_Msk: u32 = 32;
pub const RCC_APB1ENR2_LPTIM2EN: u32 = 32;
pub const RCC_APB2ENR_SYSCFGEN_Pos: u32 = 0;
pub const RCC_APB2ENR_SYSCFGEN_Msk: u32 = 1;
pub const RCC_APB2ENR_SYSCFGEN: u32 = 1;
pub const RCC_APB2ENR_FWEN_Pos: u32 = 7;
pub const RCC_APB2ENR_FWEN_Msk: u32 = 128;
pub const RCC_APB2ENR_FWEN: u32 = 128;
pub const RCC_APB2ENR_SDMMC1EN_Pos: u32 = 10;
pub const RCC_APB2ENR_SDMMC1EN_Msk: u32 = 1024;
pub const RCC_APB2ENR_SDMMC1EN: u32 = 1024;
pub const RCC_APB2ENR_TIM1EN_Pos: u32 = 11;
pub const RCC_APB2ENR_TIM1EN_Msk: u32 = 2048;
pub const RCC_APB2ENR_TIM1EN: u32 = 2048;
pub const RCC_APB2ENR_SPI1EN_Pos: u32 = 12;
pub const RCC_APB2ENR_SPI1EN_Msk: u32 = 4096;
pub const RCC_APB2ENR_SPI1EN: u32 = 4096;
pub const RCC_APB2ENR_TIM8EN_Pos: u32 = 13;
pub const RCC_APB2ENR_TIM8EN_Msk: u32 = 8192;
pub const RCC_APB2ENR_TIM8EN: u32 = 8192;
pub const RCC_APB2ENR_USART1EN_Pos: u32 = 14;
pub const RCC_APB2ENR_USART1EN_Msk: u32 = 16384;
pub const RCC_APB2ENR_USART1EN: u32 = 16384;
pub const RCC_APB2ENR_TIM15EN_Pos: u32 = 16;
pub const RCC_APB2ENR_TIM15EN_Msk: u32 = 65536;
pub const RCC_APB2ENR_TIM15EN: u32 = 65536;
pub const RCC_APB2ENR_TIM16EN_Pos: u32 = 17;
pub const RCC_APB2ENR_TIM16EN_Msk: u32 = 131072;
pub const RCC_APB2ENR_TIM16EN: u32 = 131072;
pub const RCC_APB2ENR_TIM17EN_Pos: u32 = 18;
pub const RCC_APB2ENR_TIM17EN_Msk: u32 = 262144;
pub const RCC_APB2ENR_TIM17EN: u32 = 262144;
pub const RCC_APB2ENR_SAI1EN_Pos: u32 = 21;
pub const RCC_APB2ENR_SAI1EN_Msk: u32 = 2097152;
pub const RCC_APB2ENR_SAI1EN: u32 = 2097152;
pub const RCC_APB2ENR_SAI2EN_Pos: u32 = 22;
pub const RCC_APB2ENR_SAI2EN_Msk: u32 = 4194304;
pub const RCC_APB2ENR_SAI2EN: u32 = 4194304;
pub const RCC_APB2ENR_DFSDM1EN_Pos: u32 = 24;
pub const RCC_APB2ENR_DFSDM1EN_Msk: u32 = 16777216;
pub const RCC_APB2ENR_DFSDM1EN: u32 = 16777216;
pub const RCC_AHB1SMENR_DMA1SMEN_Pos: u32 = 0;
pub const RCC_AHB1SMENR_DMA1SMEN_Msk: u32 = 1;
pub const RCC_AHB1SMENR_DMA1SMEN: u32 = 1;
pub const RCC_AHB1SMENR_DMA2SMEN_Pos: u32 = 1;
pub const RCC_AHB1SMENR_DMA2SMEN_Msk: u32 = 2;
pub const RCC_AHB1SMENR_DMA2SMEN: u32 = 2;
pub const RCC_AHB1SMENR_FLASHSMEN_Pos: u32 = 8;
pub const RCC_AHB1SMENR_FLASHSMEN_Msk: u32 = 256;
pub const RCC_AHB1SMENR_FLASHSMEN: u32 = 256;
pub const RCC_AHB1SMENR_SRAM1SMEN_Pos: u32 = 9;
pub const RCC_AHB1SMENR_SRAM1SMEN_Msk: u32 = 512;
pub const RCC_AHB1SMENR_SRAM1SMEN: u32 = 512;
pub const RCC_AHB1SMENR_CRCSMEN_Pos: u32 = 12;
pub const RCC_AHB1SMENR_CRCSMEN_Msk: u32 = 4096;
pub const RCC_AHB1SMENR_CRCSMEN: u32 = 4096;
pub const RCC_AHB1SMENR_TSCSMEN_Pos: u32 = 16;
pub const RCC_AHB1SMENR_TSCSMEN_Msk: u32 = 65536;
pub const RCC_AHB1SMENR_TSCSMEN: u32 = 65536;
pub const RCC_AHB2SMENR_GPIOASMEN_Pos: u32 = 0;
pub const RCC_AHB2SMENR_GPIOASMEN_Msk: u32 = 1;
pub const RCC_AHB2SMENR_GPIOASMEN: u32 = 1;
pub const RCC_AHB2SMENR_GPIOBSMEN_Pos: u32 = 1;
pub const RCC_AHB2SMENR_GPIOBSMEN_Msk: u32 = 2;
pub const RCC_AHB2SMENR_GPIOBSMEN: u32 = 2;
pub const RCC_AHB2SMENR_GPIOCSMEN_Pos: u32 = 2;
pub const RCC_AHB2SMENR_GPIOCSMEN_Msk: u32 = 4;
pub const RCC_AHB2SMENR_GPIOCSMEN: u32 = 4;
pub const RCC_AHB2SMENR_GPIODSMEN_Pos: u32 = 3;
pub const RCC_AHB2SMENR_GPIODSMEN_Msk: u32 = 8;
pub const RCC_AHB2SMENR_GPIODSMEN: u32 = 8;
pub const RCC_AHB2SMENR_GPIOESMEN_Pos: u32 = 4;
pub const RCC_AHB2SMENR_GPIOESMEN_Msk: u32 = 16;
pub const RCC_AHB2SMENR_GPIOESMEN: u32 = 16;
pub const RCC_AHB2SMENR_GPIOFSMEN_Pos: u32 = 5;
pub const RCC_AHB2SMENR_GPIOFSMEN_Msk: u32 = 32;
pub const RCC_AHB2SMENR_GPIOFSMEN: u32 = 32;
pub const RCC_AHB2SMENR_GPIOGSMEN_Pos: u32 = 6;
pub const RCC_AHB2SMENR_GPIOGSMEN_Msk: u32 = 64;
pub const RCC_AHB2SMENR_GPIOGSMEN: u32 = 64;
pub const RCC_AHB2SMENR_GPIOHSMEN_Pos: u32 = 7;
pub const RCC_AHB2SMENR_GPIOHSMEN_Msk: u32 = 128;
pub const RCC_AHB2SMENR_GPIOHSMEN: u32 = 128;
pub const RCC_AHB2SMENR_SRAM2SMEN_Pos: u32 = 9;
pub const RCC_AHB2SMENR_SRAM2SMEN_Msk: u32 = 512;
pub const RCC_AHB2SMENR_SRAM2SMEN: u32 = 512;
pub const RCC_AHB2SMENR_OTGFSSMEN_Pos: u32 = 12;
pub const RCC_AHB2SMENR_OTGFSSMEN_Msk: u32 = 4096;
pub const RCC_AHB2SMENR_OTGFSSMEN: u32 = 4096;
pub const RCC_AHB2SMENR_ADCSMEN_Pos: u32 = 13;
pub const RCC_AHB2SMENR_ADCSMEN_Msk: u32 = 8192;
pub const RCC_AHB2SMENR_ADCSMEN: u32 = 8192;
pub const RCC_AHB2SMENR_RNGSMEN_Pos: u32 = 18;
pub const RCC_AHB2SMENR_RNGSMEN_Msk: u32 = 262144;
pub const RCC_AHB2SMENR_RNGSMEN: u32 = 262144;
pub const RCC_AHB3SMENR_FMCSMEN_Pos: u32 = 0;
pub const RCC_AHB3SMENR_FMCSMEN_Msk: u32 = 1;
pub const RCC_AHB3SMENR_FMCSMEN: u32 = 1;
pub const RCC_AHB3SMENR_QSPISMEN_Pos: u32 = 8;
pub const RCC_AHB3SMENR_QSPISMEN_Msk: u32 = 256;
pub const RCC_AHB3SMENR_QSPISMEN: u32 = 256;
pub const RCC_APB1SMENR1_TIM2SMEN_Pos: u32 = 0;
pub const RCC_APB1SMENR1_TIM2SMEN_Msk: u32 = 1;
pub const RCC_APB1SMENR1_TIM2SMEN: u32 = 1;
pub const RCC_APB1SMENR1_TIM3SMEN_Pos: u32 = 1;
pub const RCC_APB1SMENR1_TIM3SMEN_Msk: u32 = 2;
pub const RCC_APB1SMENR1_TIM3SMEN: u32 = 2;
pub const RCC_APB1SMENR1_TIM4SMEN_Pos: u32 = 2;
pub const RCC_APB1SMENR1_TIM4SMEN_Msk: u32 = 4;
pub const RCC_APB1SMENR1_TIM4SMEN: u32 = 4;
pub const RCC_APB1SMENR1_TIM5SMEN_Pos: u32 = 3;
pub const RCC_APB1SMENR1_TIM5SMEN_Msk: u32 = 8;
pub const RCC_APB1SMENR1_TIM5SMEN: u32 = 8;
pub const RCC_APB1SMENR1_TIM6SMEN_Pos: u32 = 4;
pub const RCC_APB1SMENR1_TIM6SMEN_Msk: u32 = 16;
pub const RCC_APB1SMENR1_TIM6SMEN: u32 = 16;
pub const RCC_APB1SMENR1_TIM7SMEN_Pos: u32 = 5;
pub const RCC_APB1SMENR1_TIM7SMEN_Msk: u32 = 32;
pub const RCC_APB1SMENR1_TIM7SMEN: u32 = 32;
pub const RCC_APB1SMENR1_WWDGSMEN_Pos: u32 = 11;
pub const RCC_APB1SMENR1_WWDGSMEN_Msk: u32 = 2048;
pub const RCC_APB1SMENR1_WWDGSMEN: u32 = 2048;
pub const RCC_APB1SMENR1_SPI2SMEN_Pos: u32 = 14;
pub const RCC_APB1SMENR1_SPI2SMEN_Msk: u32 = 16384;
pub const RCC_APB1SMENR1_SPI2SMEN: u32 = 16384;
pub const RCC_APB1SMENR1_SPI3SMEN_Pos: u32 = 15;
pub const RCC_APB1SMENR1_SPI3SMEN_Msk: u32 = 32768;
pub const RCC_APB1SMENR1_SPI3SMEN: u32 = 32768;
pub const RCC_APB1SMENR1_USART2SMEN_Pos: u32 = 17;
pub const RCC_APB1SMENR1_USART2SMEN_Msk: u32 = 131072;
pub const RCC_APB1SMENR1_USART2SMEN: u32 = 131072;
pub const RCC_APB1SMENR1_USART3SMEN_Pos: u32 = 18;
pub const RCC_APB1SMENR1_USART3SMEN_Msk: u32 = 262144;
pub const RCC_APB1SMENR1_USART3SMEN: u32 = 262144;
pub const RCC_APB1SMENR1_UART4SMEN_Pos: u32 = 19;
pub const RCC_APB1SMENR1_UART4SMEN_Msk: u32 = 524288;
pub const RCC_APB1SMENR1_UART4SMEN: u32 = 524288;
pub const RCC_APB1SMENR1_UART5SMEN_Pos: u32 = 20;
pub const RCC_APB1SMENR1_UART5SMEN_Msk: u32 = 1048576;
pub const RCC_APB1SMENR1_UART5SMEN: u32 = 1048576;
pub const RCC_APB1SMENR1_I2C1SMEN_Pos: u32 = 21;
pub const RCC_APB1SMENR1_I2C1SMEN_Msk: u32 = 2097152;
pub const RCC_APB1SMENR1_I2C1SMEN: u32 = 2097152;
pub const RCC_APB1SMENR1_I2C2SMEN_Pos: u32 = 22;
pub const RCC_APB1SMENR1_I2C2SMEN_Msk: u32 = 4194304;
pub const RCC_APB1SMENR1_I2C2SMEN: u32 = 4194304;
pub const RCC_APB1SMENR1_I2C3SMEN_Pos: u32 = 23;
pub const RCC_APB1SMENR1_I2C3SMEN_Msk: u32 = 8388608;
pub const RCC_APB1SMENR1_I2C3SMEN: u32 = 8388608;
pub const RCC_APB1SMENR1_CAN1SMEN_Pos: u32 = 25;
pub const RCC_APB1SMENR1_CAN1SMEN_Msk: u32 = 33554432;
pub const RCC_APB1SMENR1_CAN1SMEN: u32 = 33554432;
pub const RCC_APB1SMENR1_PWRSMEN_Pos: u32 = 28;
pub const RCC_APB1SMENR1_PWRSMEN_Msk: u32 = 268435456;
pub const RCC_APB1SMENR1_PWRSMEN: u32 = 268435456;
pub const RCC_APB1SMENR1_DAC1SMEN_Pos: u32 = 29;
pub const RCC_APB1SMENR1_DAC1SMEN_Msk: u32 = 536870912;
pub const RCC_APB1SMENR1_DAC1SMEN: u32 = 536870912;
pub const RCC_APB1SMENR1_OPAMPSMEN_Pos: u32 = 30;
pub const RCC_APB1SMENR1_OPAMPSMEN_Msk: u32 = 1073741824;
pub const RCC_APB1SMENR1_OPAMPSMEN: u32 = 1073741824;
pub const RCC_APB1SMENR1_LPTIM1SMEN_Pos: u32 = 31;
pub const RCC_APB1SMENR1_LPTIM1SMEN_Msk: u32 = 2147483648;
pub const RCC_APB1SMENR1_LPTIM1SMEN: u32 = 2147483648;
pub const RCC_APB1SMENR2_LPUART1SMEN_Pos: u32 = 0;
pub const RCC_APB1SMENR2_LPUART1SMEN_Msk: u32 = 1;
pub const RCC_APB1SMENR2_LPUART1SMEN: u32 = 1;
pub const RCC_APB1SMENR2_SWPMI1SMEN_Pos: u32 = 2;
pub const RCC_APB1SMENR2_SWPMI1SMEN_Msk: u32 = 4;
pub const RCC_APB1SMENR2_SWPMI1SMEN: u32 = 4;
pub const RCC_APB1SMENR2_LPTIM2SMEN_Pos: u32 = 5;
pub const RCC_APB1SMENR2_LPTIM2SMEN_Msk: u32 = 32;
pub const RCC_APB1SMENR2_LPTIM2SMEN: u32 = 32;
pub const RCC_APB2SMENR_SYSCFGSMEN_Pos: u32 = 0;
pub const RCC_APB2SMENR_SYSCFGSMEN_Msk: u32 = 1;
pub const RCC_APB2SMENR_SYSCFGSMEN: u32 = 1;
pub const RCC_APB2SMENR_SDMMC1SMEN_Pos: u32 = 10;
pub const RCC_APB2SMENR_SDMMC1SMEN_Msk: u32 = 1024;
pub const RCC_APB2SMENR_SDMMC1SMEN: u32 = 1024;
pub const RCC_APB2SMENR_TIM1SMEN_Pos: u32 = 11;
pub const RCC_APB2SMENR_TIM1SMEN_Msk: u32 = 2048;
pub const RCC_APB2SMENR_TIM1SMEN: u32 = 2048;
pub const RCC_APB2SMENR_SPI1SMEN_Pos: u32 = 12;
pub const RCC_APB2SMENR_SPI1SMEN_Msk: u32 = 4096;
pub const RCC_APB2SMENR_SPI1SMEN: u32 = 4096;
pub const RCC_APB2SMENR_TIM8SMEN_Pos: u32 = 13;
pub const RCC_APB2SMENR_TIM8SMEN_Msk: u32 = 8192;
pub const RCC_APB2SMENR_TIM8SMEN: u32 = 8192;
pub const RCC_APB2SMENR_USART1SMEN_Pos: u32 = 14;
pub const RCC_APB2SMENR_USART1SMEN_Msk: u32 = 16384;
pub const RCC_APB2SMENR_USART1SMEN: u32 = 16384;
pub const RCC_APB2SMENR_TIM15SMEN_Pos: u32 = 16;
pub const RCC_APB2SMENR_TIM15SMEN_Msk: u32 = 65536;
pub const RCC_APB2SMENR_TIM15SMEN: u32 = 65536;
pub const RCC_APB2SMENR_TIM16SMEN_Pos: u32 = 17;
pub const RCC_APB2SMENR_TIM16SMEN_Msk: u32 = 131072;
pub const RCC_APB2SMENR_TIM16SMEN: u32 = 131072;
pub const RCC_APB2SMENR_TIM17SMEN_Pos: u32 = 18;
pub const RCC_APB2SMENR_TIM17SMEN_Msk: u32 = 262144;
pub const RCC_APB2SMENR_TIM17SMEN: u32 = 262144;
pub const RCC_APB2SMENR_SAI1SMEN_Pos: u32 = 21;
pub const RCC_APB2SMENR_SAI1SMEN_Msk: u32 = 2097152;
pub const RCC_APB2SMENR_SAI1SMEN: u32 = 2097152;
pub const RCC_APB2SMENR_SAI2SMEN_Pos: u32 = 22;
pub const RCC_APB2SMENR_SAI2SMEN_Msk: u32 = 4194304;
pub const RCC_APB2SMENR_SAI2SMEN: u32 = 4194304;
pub const RCC_APB2SMENR_DFSDM1SMEN_Pos: u32 = 24;
pub const RCC_APB2SMENR_DFSDM1SMEN_Msk: u32 = 16777216;
pub const RCC_APB2SMENR_DFSDM1SMEN: u32 = 16777216;
pub const RCC_CCIPR_USART1SEL_Pos: u32 = 0;
pub const RCC_CCIPR_USART1SEL_Msk: u32 = 3;
pub const RCC_CCIPR_USART1SEL: u32 = 3;
pub const RCC_CCIPR_USART1SEL_0: u32 = 1;
pub const RCC_CCIPR_USART1SEL_1: u32 = 2;
pub const RCC_CCIPR_USART2SEL_Pos: u32 = 2;
pub const RCC_CCIPR_USART2SEL_Msk: u32 = 12;
pub const RCC_CCIPR_USART2SEL: u32 = 12;
pub const RCC_CCIPR_USART2SEL_0: u32 = 4;
pub const RCC_CCIPR_USART2SEL_1: u32 = 8;
pub const RCC_CCIPR_USART3SEL_Pos: u32 = 4;
pub const RCC_CCIPR_USART3SEL_Msk: u32 = 48;
pub const RCC_CCIPR_USART3SEL: u32 = 48;
pub const RCC_CCIPR_USART3SEL_0: u32 = 16;
pub const RCC_CCIPR_USART3SEL_1: u32 = 32;
pub const RCC_CCIPR_UART4SEL_Pos: u32 = 6;
pub const RCC_CCIPR_UART4SEL_Msk: u32 = 192;
pub const RCC_CCIPR_UART4SEL: u32 = 192;
pub const RCC_CCIPR_UART4SEL_0: u32 = 64;
pub const RCC_CCIPR_UART4SEL_1: u32 = 128;
pub const RCC_CCIPR_UART5SEL_Pos: u32 = 8;
pub const RCC_CCIPR_UART5SEL_Msk: u32 = 768;
pub const RCC_CCIPR_UART5SEL: u32 = 768;
pub const RCC_CCIPR_UART5SEL_0: u32 = 256;
pub const RCC_CCIPR_UART5SEL_1: u32 = 512;
pub const RCC_CCIPR_LPUART1SEL_Pos: u32 = 10;
pub const RCC_CCIPR_LPUART1SEL_Msk: u32 = 3072;
pub const RCC_CCIPR_LPUART1SEL: u32 = 3072;
pub const RCC_CCIPR_LPUART1SEL_0: u32 = 1024;
pub const RCC_CCIPR_LPUART1SEL_1: u32 = 2048;
pub const RCC_CCIPR_I2C1SEL_Pos: u32 = 12;
pub const RCC_CCIPR_I2C1SEL_Msk: u32 = 12288;
pub const RCC_CCIPR_I2C1SEL: u32 = 12288;
pub const RCC_CCIPR_I2C1SEL_0: u32 = 4096;
pub const RCC_CCIPR_I2C1SEL_1: u32 = 8192;
pub const RCC_CCIPR_I2C2SEL_Pos: u32 = 14;
pub const RCC_CCIPR_I2C2SEL_Msk: u32 = 49152;
pub const RCC_CCIPR_I2C2SEL: u32 = 49152;
pub const RCC_CCIPR_I2C2SEL_0: u32 = 16384;
pub const RCC_CCIPR_I2C2SEL_1: u32 = 32768;
pub const RCC_CCIPR_I2C3SEL_Pos: u32 = 16;
pub const RCC_CCIPR_I2C3SEL_Msk: u32 = 196608;
pub const RCC_CCIPR_I2C3SEL: u32 = 196608;
pub const RCC_CCIPR_I2C3SEL_0: u32 = 65536;
pub const RCC_CCIPR_I2C3SEL_1: u32 = 131072;
pub const RCC_CCIPR_LPTIM1SEL_Pos: u32 = 18;
pub const RCC_CCIPR_LPTIM1SEL_Msk: u32 = 786432;
pub const RCC_CCIPR_LPTIM1SEL: u32 = 786432;
pub const RCC_CCIPR_LPTIM1SEL_0: u32 = 262144;
pub const RCC_CCIPR_LPTIM1SEL_1: u32 = 524288;
pub const RCC_CCIPR_LPTIM2SEL_Pos: u32 = 20;
pub const RCC_CCIPR_LPTIM2SEL_Msk: u32 = 3145728;
pub const RCC_CCIPR_LPTIM2SEL: u32 = 3145728;
pub const RCC_CCIPR_LPTIM2SEL_0: u32 = 1048576;
pub const RCC_CCIPR_LPTIM2SEL_1: u32 = 2097152;
pub const RCC_CCIPR_SAI1SEL_Pos: u32 = 22;
pub const RCC_CCIPR_SAI1SEL_Msk: u32 = 12582912;
pub const RCC_CCIPR_SAI1SEL: u32 = 12582912;
pub const RCC_CCIPR_SAI1SEL_0: u32 = 4194304;
pub const RCC_CCIPR_SAI1SEL_1: u32 = 8388608;
pub const RCC_CCIPR_SAI2SEL_Pos: u32 = 24;
pub const RCC_CCIPR_SAI2SEL_Msk: u32 = 50331648;
pub const RCC_CCIPR_SAI2SEL: u32 = 50331648;
pub const RCC_CCIPR_SAI2SEL_0: u32 = 16777216;
pub const RCC_CCIPR_SAI2SEL_1: u32 = 33554432;
pub const RCC_CCIPR_CLK48SEL_Pos: u32 = 26;
pub const RCC_CCIPR_CLK48SEL_Msk: u32 = 201326592;
pub const RCC_CCIPR_CLK48SEL: u32 = 201326592;
pub const RCC_CCIPR_CLK48SEL_0: u32 = 67108864;
pub const RCC_CCIPR_CLK48SEL_1: u32 = 134217728;
pub const RCC_CCIPR_ADCSEL_Pos: u32 = 28;
pub const RCC_CCIPR_ADCSEL_Msk: u32 = 805306368;
pub const RCC_CCIPR_ADCSEL: u32 = 805306368;
pub const RCC_CCIPR_ADCSEL_0: u32 = 268435456;
pub const RCC_CCIPR_ADCSEL_1: u32 = 536870912;
pub const RCC_CCIPR_SWPMI1SEL_Pos: u32 = 30;
pub const RCC_CCIPR_SWPMI1SEL_Msk: u32 = 1073741824;
pub const RCC_CCIPR_SWPMI1SEL: u32 = 1073741824;
pub const RCC_CCIPR_DFSDM1SEL_Pos: u32 = 31;
pub const RCC_CCIPR_DFSDM1SEL_Msk: u32 = 2147483648;
pub const RCC_CCIPR_DFSDM1SEL: u32 = 2147483648;
pub const RCC_BDCR_LSEON_Pos: u32 = 0;
pub const RCC_BDCR_LSEON_Msk: u32 = 1;
pub const RCC_BDCR_LSEON: u32 = 1;
pub const RCC_BDCR_LSERDY_Pos: u32 = 1;
pub const RCC_BDCR_LSERDY_Msk: u32 = 2;
pub const RCC_BDCR_LSERDY: u32 = 2;
pub const RCC_BDCR_LSEBYP_Pos: u32 = 2;
pub const RCC_BDCR_LSEBYP_Msk: u32 = 4;
pub const RCC_BDCR_LSEBYP: u32 = 4;
pub const RCC_BDCR_LSEDRV_Pos: u32 = 3;
pub const RCC_BDCR_LSEDRV_Msk: u32 = 24;
pub const RCC_BDCR_LSEDRV: u32 = 24;
pub const RCC_BDCR_LSEDRV_0: u32 = 8;
pub const RCC_BDCR_LSEDRV_1: u32 = 16;
pub const RCC_BDCR_LSECSSON_Pos: u32 = 5;
pub const RCC_BDCR_LSECSSON_Msk: u32 = 32;
pub const RCC_BDCR_LSECSSON: u32 = 32;
pub const RCC_BDCR_LSECSSD_Pos: u32 = 6;
pub const RCC_BDCR_LSECSSD_Msk: u32 = 64;
pub const RCC_BDCR_LSECSSD: u32 = 64;
pub const RCC_BDCR_RTCSEL_Pos: u32 = 8;
pub const RCC_BDCR_RTCSEL_Msk: u32 = 768;
pub const RCC_BDCR_RTCSEL: u32 = 768;
pub const RCC_BDCR_RTCSEL_0: u32 = 256;
pub const RCC_BDCR_RTCSEL_1: u32 = 512;
pub const RCC_BDCR_RTCEN_Pos: u32 = 15;
pub const RCC_BDCR_RTCEN_Msk: u32 = 32768;
pub const RCC_BDCR_RTCEN: u32 = 32768;
pub const RCC_BDCR_BDRST_Pos: u32 = 16;
pub const RCC_BDCR_BDRST_Msk: u32 = 65536;
pub const RCC_BDCR_BDRST: u32 = 65536;
pub const RCC_BDCR_LSCOEN_Pos: u32 = 24;
pub const RCC_BDCR_LSCOEN_Msk: u32 = 16777216;
pub const RCC_BDCR_LSCOEN: u32 = 16777216;
pub const RCC_BDCR_LSCOSEL_Pos: u32 = 25;
pub const RCC_BDCR_LSCOSEL_Msk: u32 = 33554432;
pub const RCC_BDCR_LSCOSEL: u32 = 33554432;
pub const RCC_CSR_LSION_Pos: u32 = 0;
pub const RCC_CSR_LSION_Msk: u32 = 1;
pub const RCC_CSR_LSION: u32 = 1;
pub const RCC_CSR_LSIRDY_Pos: u32 = 1;
pub const RCC_CSR_LSIRDY_Msk: u32 = 2;
pub const RCC_CSR_LSIRDY: u32 = 2;
pub const RCC_CSR_MSISRANGE_Pos: u32 = 8;
pub const RCC_CSR_MSISRANGE_Msk: u32 = 3840;
pub const RCC_CSR_MSISRANGE: u32 = 3840;
pub const RCC_CSR_MSISRANGE_1: u32 = 1024;
pub const RCC_CSR_MSISRANGE_2: u32 = 1280;
pub const RCC_CSR_MSISRANGE_4: u32 = 1536;
pub const RCC_CSR_MSISRANGE_8: u32 = 1792;
pub const RCC_CSR_RMVF_Pos: u32 = 23;
pub const RCC_CSR_RMVF_Msk: u32 = 8388608;
pub const RCC_CSR_RMVF: u32 = 8388608;
pub const RCC_CSR_FWRSTF_Pos: u32 = 24;
pub const RCC_CSR_FWRSTF_Msk: u32 = 16777216;
pub const RCC_CSR_FWRSTF: u32 = 16777216;
pub const RCC_CSR_OBLRSTF_Pos: u32 = 25;
pub const RCC_CSR_OBLRSTF_Msk: u32 = 33554432;
pub const RCC_CSR_OBLRSTF: u32 = 33554432;
pub const RCC_CSR_PINRSTF_Pos: u32 = 26;
pub const RCC_CSR_PINRSTF_Msk: u32 = 67108864;
pub const RCC_CSR_PINRSTF: u32 = 67108864;
pub const RCC_CSR_BORRSTF_Pos: u32 = 27;
pub const RCC_CSR_BORRSTF_Msk: u32 = 134217728;
pub const RCC_CSR_BORRSTF: u32 = 134217728;
pub const RCC_CSR_SFTRSTF_Pos: u32 = 28;
pub const RCC_CSR_SFTRSTF_Msk: u32 = 268435456;
pub const RCC_CSR_SFTRSTF: u32 = 268435456;
pub const RCC_CSR_IWDGRSTF_Pos: u32 = 29;
pub const RCC_CSR_IWDGRSTF_Msk: u32 = 536870912;
pub const RCC_CSR_IWDGRSTF: u32 = 536870912;
pub const RCC_CSR_WWDGRSTF_Pos: u32 = 30;
pub const RCC_CSR_WWDGRSTF_Msk: u32 = 1073741824;
pub const RCC_CSR_WWDGRSTF: u32 = 1073741824;
pub const RCC_CSR_LPWRRSTF_Pos: u32 = 31;
pub const RCC_CSR_LPWRRSTF_Msk: u32 = 2147483648;
pub const RCC_CSR_LPWRRSTF: u32 = 2147483648;
pub const RNG_CR_RNGEN_Pos: u32 = 2;
pub const RNG_CR_RNGEN_Msk: u32 = 4;
pub const RNG_CR_RNGEN: u32 = 4;
pub const RNG_CR_IE_Pos: u32 = 3;
pub const RNG_CR_IE_Msk: u32 = 8;
pub const RNG_CR_IE: u32 = 8;
pub const RNG_SR_DRDY_Pos: u32 = 0;
pub const RNG_SR_DRDY_Msk: u32 = 1;
pub const RNG_SR_DRDY: u32 = 1;
pub const RNG_SR_CECS_Pos: u32 = 1;
pub const RNG_SR_CECS_Msk: u32 = 2;
pub const RNG_SR_CECS: u32 = 2;
pub const RNG_SR_SECS_Pos: u32 = 2;
pub const RNG_SR_SECS_Msk: u32 = 4;
pub const RNG_SR_SECS: u32 = 4;
pub const RNG_SR_CEIS_Pos: u32 = 5;
pub const RNG_SR_CEIS_Msk: u32 = 32;
pub const RNG_SR_CEIS: u32 = 32;
pub const RNG_SR_SEIS_Pos: u32 = 6;
pub const RNG_SR_SEIS_Msk: u32 = 64;
pub const RNG_SR_SEIS: u32 = 64;
pub const RTC_BKP_NUMBER: u32 = 32;
pub const RTC_TR_PM_Pos: u32 = 22;
pub const RTC_TR_PM_Msk: u32 = 4194304;
pub const RTC_TR_PM: u32 = 4194304;
pub const RTC_TR_HT_Pos: u32 = 20;
pub const RTC_TR_HT_Msk: u32 = 3145728;
pub const RTC_TR_HT: u32 = 3145728;
pub const RTC_TR_HT_0: u32 = 1048576;
pub const RTC_TR_HT_1: u32 = 2097152;
pub const RTC_TR_HU_Pos: u32 = 16;
pub const RTC_TR_HU_Msk: u32 = 983040;
pub const RTC_TR_HU: u32 = 983040;
pub const RTC_TR_HU_0: u32 = 65536;
pub const RTC_TR_HU_1: u32 = 131072;
pub const RTC_TR_HU_2: u32 = 262144;
pub const RTC_TR_HU_3: u32 = 524288;
pub const RTC_TR_MNT_Pos: u32 = 12;
pub const RTC_TR_MNT_Msk: u32 = 28672;
pub const RTC_TR_MNT: u32 = 28672;
pub const RTC_TR_MNT_0: u32 = 4096;
pub const RTC_TR_MNT_1: u32 = 8192;
pub const RTC_TR_MNT_2: u32 = 16384;
pub const RTC_TR_MNU_Pos: u32 = 8;
pub const RTC_TR_MNU_Msk: u32 = 3840;
pub const RTC_TR_MNU: u32 = 3840;
pub const RTC_TR_MNU_0: u32 = 256;
pub const RTC_TR_MNU_1: u32 = 512;
pub const RTC_TR_MNU_2: u32 = 1024;
pub const RTC_TR_MNU_3: u32 = 2048;
pub const RTC_TR_ST_Pos: u32 = 4;
pub const RTC_TR_ST_Msk: u32 = 112;
pub const RTC_TR_ST: u32 = 112;
pub const RTC_TR_ST_0: u32 = 16;
pub const RTC_TR_ST_1: u32 = 32;
pub const RTC_TR_ST_2: u32 = 64;
pub const RTC_TR_SU_Pos: u32 = 0;
pub const RTC_TR_SU_Msk: u32 = 15;
pub const RTC_TR_SU: u32 = 15;
pub const RTC_TR_SU_0: u32 = 1;
pub const RTC_TR_SU_1: u32 = 2;
pub const RTC_TR_SU_2: u32 = 4;
pub const RTC_TR_SU_3: u32 = 8;
pub const RTC_DR_YT_Pos: u32 = 20;
pub const RTC_DR_YT_Msk: u32 = 15728640;
pub const RTC_DR_YT: u32 = 15728640;
pub const RTC_DR_YT_0: u32 = 1048576;
pub const RTC_DR_YT_1: u32 = 2097152;
pub const RTC_DR_YT_2: u32 = 4194304;
pub const RTC_DR_YT_3: u32 = 8388608;
pub const RTC_DR_YU_Pos: u32 = 16;
pub const RTC_DR_YU_Msk: u32 = 983040;
pub const RTC_DR_YU: u32 = 983040;
pub const RTC_DR_YU_0: u32 = 65536;
pub const RTC_DR_YU_1: u32 = 131072;
pub const RTC_DR_YU_2: u32 = 262144;
pub const RTC_DR_YU_3: u32 = 524288;
pub const RTC_DR_WDU_Pos: u32 = 13;
pub const RTC_DR_WDU_Msk: u32 = 57344;
pub const RTC_DR_WDU: u32 = 57344;
pub const RTC_DR_WDU_0: u32 = 8192;
pub const RTC_DR_WDU_1: u32 = 16384;
pub const RTC_DR_WDU_2: u32 = 32768;
pub const RTC_DR_MT_Pos: u32 = 12;
pub const RTC_DR_MT_Msk: u32 = 4096;
pub const RTC_DR_MT: u32 = 4096;
pub const RTC_DR_MU_Pos: u32 = 8;
pub const RTC_DR_MU_Msk: u32 = 3840;
pub const RTC_DR_MU: u32 = 3840;
pub const RTC_DR_MU_0: u32 = 256;
pub const RTC_DR_MU_1: u32 = 512;
pub const RTC_DR_MU_2: u32 = 1024;
pub const RTC_DR_MU_3: u32 = 2048;
pub const RTC_DR_DT_Pos: u32 = 4;
pub const RTC_DR_DT_Msk: u32 = 48;
pub const RTC_DR_DT: u32 = 48;
pub const RTC_DR_DT_0: u32 = 16;
pub const RTC_DR_DT_1: u32 = 32;
pub const RTC_DR_DU_Pos: u32 = 0;
pub const RTC_DR_DU_Msk: u32 = 15;
pub const RTC_DR_DU: u32 = 15;
pub const RTC_DR_DU_0: u32 = 1;
pub const RTC_DR_DU_1: u32 = 2;
pub const RTC_DR_DU_2: u32 = 4;
pub const RTC_DR_DU_3: u32 = 8;
pub const RTC_CR_ITSE_Pos: u32 = 24;
pub const RTC_CR_ITSE_Msk: u32 = 16777216;
pub const RTC_CR_ITSE: u32 = 16777216;
pub const RTC_CR_COE_Pos: u32 = 23;
pub const RTC_CR_COE_Msk: u32 = 8388608;
pub const RTC_CR_COE: u32 = 8388608;
pub const RTC_CR_OSEL_Pos: u32 = 21;
pub const RTC_CR_OSEL_Msk: u32 = 6291456;
pub const RTC_CR_OSEL: u32 = 6291456;
pub const RTC_CR_OSEL_0: u32 = 2097152;
pub const RTC_CR_OSEL_1: u32 = 4194304;
pub const RTC_CR_POL_Pos: u32 = 20;
pub const RTC_CR_POL_Msk: u32 = 1048576;
pub const RTC_CR_POL: u32 = 1048576;
pub const RTC_CR_COSEL_Pos: u32 = 19;
pub const RTC_CR_COSEL_Msk: u32 = 524288;
pub const RTC_CR_COSEL: u32 = 524288;
pub const RTC_CR_BKP_Pos: u32 = 18;
pub const RTC_CR_BKP_Msk: u32 = 262144;
pub const RTC_CR_BKP: u32 = 262144;
pub const RTC_CR_SUB1H_Pos: u32 = 17;
pub const RTC_CR_SUB1H_Msk: u32 = 131072;
pub const RTC_CR_SUB1H: u32 = 131072;
pub const RTC_CR_ADD1H_Pos: u32 = 16;
pub const RTC_CR_ADD1H_Msk: u32 = 65536;
pub const RTC_CR_ADD1H: u32 = 65536;
pub const RTC_CR_TSIE_Pos: u32 = 15;
pub const RTC_CR_TSIE_Msk: u32 = 32768;
pub const RTC_CR_TSIE: u32 = 32768;
pub const RTC_CR_WUTIE_Pos: u32 = 14;
pub const RTC_CR_WUTIE_Msk: u32 = 16384;
pub const RTC_CR_WUTIE: u32 = 16384;
pub const RTC_CR_ALRBIE_Pos: u32 = 13;
pub const RTC_CR_ALRBIE_Msk: u32 = 8192;
pub const RTC_CR_ALRBIE: u32 = 8192;
pub const RTC_CR_ALRAIE_Pos: u32 = 12;
pub const RTC_CR_ALRAIE_Msk: u32 = 4096;
pub const RTC_CR_ALRAIE: u32 = 4096;
pub const RTC_CR_TSE_Pos: u32 = 11;
pub const RTC_CR_TSE_Msk: u32 = 2048;
pub const RTC_CR_TSE: u32 = 2048;
pub const RTC_CR_WUTE_Pos: u32 = 10;
pub const RTC_CR_WUTE_Msk: u32 = 1024;
pub const RTC_CR_WUTE: u32 = 1024;
pub const RTC_CR_ALRBE_Pos: u32 = 9;
pub const RTC_CR_ALRBE_Msk: u32 = 512;
pub const RTC_CR_ALRBE: u32 = 512;
pub const RTC_CR_ALRAE_Pos: u32 = 8;
pub const RTC_CR_ALRAE_Msk: u32 = 256;
pub const RTC_CR_ALRAE: u32 = 256;
pub const RTC_CR_FMT_Pos: u32 = 6;
pub const RTC_CR_FMT_Msk: u32 = 64;
pub const RTC_CR_FMT: u32 = 64;
pub const RTC_CR_BYPSHAD_Pos: u32 = 5;
pub const RTC_CR_BYPSHAD_Msk: u32 = 32;
pub const RTC_CR_BYPSHAD: u32 = 32;
pub const RTC_CR_REFCKON_Pos: u32 = 4;
pub const RTC_CR_REFCKON_Msk: u32 = 16;
pub const RTC_CR_REFCKON: u32 = 16;
pub const RTC_CR_TSEDGE_Pos: u32 = 3;
pub const RTC_CR_TSEDGE_Msk: u32 = 8;
pub const RTC_CR_TSEDGE: u32 = 8;
pub const RTC_CR_WUCKSEL_Pos: u32 = 0;
pub const RTC_CR_WUCKSEL_Msk: u32 = 7;
pub const RTC_CR_WUCKSEL: u32 = 7;
pub const RTC_CR_WUCKSEL_0: u32 = 1;
pub const RTC_CR_WUCKSEL_1: u32 = 2;
pub const RTC_CR_WUCKSEL_2: u32 = 4;
pub const RTC_CR_BCK_Pos: u32 = 18;
pub const RTC_CR_BCK_Msk: u32 = 262144;
pub const RTC_CR_BCK: u32 = 262144;
pub const RTC_ISR_ITSF_Pos: u32 = 17;
pub const RTC_ISR_ITSF_Msk: u32 = 131072;
pub const RTC_ISR_ITSF: u32 = 131072;
pub const RTC_ISR_RECALPF_Pos: u32 = 16;
pub const RTC_ISR_RECALPF_Msk: u32 = 65536;
pub const RTC_ISR_RECALPF: u32 = 65536;
pub const RTC_ISR_TAMP3F_Pos: u32 = 15;
pub const RTC_ISR_TAMP3F_Msk: u32 = 32768;
pub const RTC_ISR_TAMP3F: u32 = 32768;
pub const RTC_ISR_TAMP2F_Pos: u32 = 14;
pub const RTC_ISR_TAMP2F_Msk: u32 = 16384;
pub const RTC_ISR_TAMP2F: u32 = 16384;
pub const RTC_ISR_TAMP1F_Pos: u32 = 13;
pub const RTC_ISR_TAMP1F_Msk: u32 = 8192;
pub const RTC_ISR_TAMP1F: u32 = 8192;
pub const RTC_ISR_TSOVF_Pos: u32 = 12;
pub const RTC_ISR_TSOVF_Msk: u32 = 4096;
pub const RTC_ISR_TSOVF: u32 = 4096;
pub const RTC_ISR_TSF_Pos: u32 = 11;
pub const RTC_ISR_TSF_Msk: u32 = 2048;
pub const RTC_ISR_TSF: u32 = 2048;
pub const RTC_ISR_WUTF_Pos: u32 = 10;
pub const RTC_ISR_WUTF_Msk: u32 = 1024;
pub const RTC_ISR_WUTF: u32 = 1024;
pub const RTC_ISR_ALRBF_Pos: u32 = 9;
pub const RTC_ISR_ALRBF_Msk: u32 = 512;
pub const RTC_ISR_ALRBF: u32 = 512;
pub const RTC_ISR_ALRAF_Pos: u32 = 8;
pub const RTC_ISR_ALRAF_Msk: u32 = 256;
pub const RTC_ISR_ALRAF: u32 = 256;
pub const RTC_ISR_INIT_Pos: u32 = 7;
pub const RTC_ISR_INIT_Msk: u32 = 128;
pub const RTC_ISR_INIT: u32 = 128;
pub const RTC_ISR_INITF_Pos: u32 = 6;
pub const RTC_ISR_INITF_Msk: u32 = 64;
pub const RTC_ISR_INITF: u32 = 64;
pub const RTC_ISR_RSF_Pos: u32 = 5;
pub const RTC_ISR_RSF_Msk: u32 = 32;
pub const RTC_ISR_RSF: u32 = 32;
pub const RTC_ISR_INITS_Pos: u32 = 4;
pub const RTC_ISR_INITS_Msk: u32 = 16;
pub const RTC_ISR_INITS: u32 = 16;
pub const RTC_ISR_SHPF_Pos: u32 = 3;
pub const RTC_ISR_SHPF_Msk: u32 = 8;
pub const RTC_ISR_SHPF: u32 = 8;
pub const RTC_ISR_WUTWF_Pos: u32 = 2;
pub const RTC_ISR_WUTWF_Msk: u32 = 4;
pub const RTC_ISR_WUTWF: u32 = 4;
pub const RTC_ISR_ALRBWF_Pos: u32 = 1;
pub const RTC_ISR_ALRBWF_Msk: u32 = 2;
pub const RTC_ISR_ALRBWF: u32 = 2;
pub const RTC_ISR_ALRAWF_Pos: u32 = 0;
pub const RTC_ISR_ALRAWF_Msk: u32 = 1;
pub const RTC_ISR_ALRAWF: u32 = 1;
pub const RTC_PRER_PREDIV_A_Pos: u32 = 16;
pub const RTC_PRER_PREDIV_A_Msk: u32 = 8323072;
pub const RTC_PRER_PREDIV_A: u32 = 8323072;
pub const RTC_PRER_PREDIV_S_Pos: u32 = 0;
pub const RTC_PRER_PREDIV_S_Msk: u32 = 32767;
pub const RTC_PRER_PREDIV_S: u32 = 32767;
pub const RTC_WUTR_WUT_Pos: u32 = 0;
pub const RTC_WUTR_WUT_Msk: u32 = 65535;
pub const RTC_WUTR_WUT: u32 = 65535;
pub const RTC_ALRMAR_MSK4_Pos: u32 = 31;
pub const RTC_ALRMAR_MSK4_Msk: u32 = 2147483648;
pub const RTC_ALRMAR_MSK4: u32 = 2147483648;
pub const RTC_ALRMAR_WDSEL_Pos: u32 = 30;
pub const RTC_ALRMAR_WDSEL_Msk: u32 = 1073741824;
pub const RTC_ALRMAR_WDSEL: u32 = 1073741824;
pub const RTC_ALRMAR_DT_Pos: u32 = 28;
pub const RTC_ALRMAR_DT_Msk: u32 = 805306368;
pub const RTC_ALRMAR_DT: u32 = 805306368;
pub const RTC_ALRMAR_DT_0: u32 = 268435456;
pub const RTC_ALRMAR_DT_1: u32 = 536870912;
pub const RTC_ALRMAR_DU_Pos: u32 = 24;
pub const RTC_ALRMAR_DU_Msk: u32 = 251658240;
pub const RTC_ALRMAR_DU: u32 = 251658240;
pub const RTC_ALRMAR_DU_0: u32 = 16777216;
pub const RTC_ALRMAR_DU_1: u32 = 33554432;
pub const RTC_ALRMAR_DU_2: u32 = 67108864;
pub const RTC_ALRMAR_DU_3: u32 = 134217728;
pub const RTC_ALRMAR_MSK3_Pos: u32 = 23;
pub const RTC_ALRMAR_MSK3_Msk: u32 = 8388608;
pub const RTC_ALRMAR_MSK3: u32 = 8388608;
pub const RTC_ALRMAR_PM_Pos: u32 = 22;
pub const RTC_ALRMAR_PM_Msk: u32 = 4194304;
pub const RTC_ALRMAR_PM: u32 = 4194304;
pub const RTC_ALRMAR_HT_Pos: u32 = 20;
pub const RTC_ALRMAR_HT_Msk: u32 = 3145728;
pub const RTC_ALRMAR_HT: u32 = 3145728;
pub const RTC_ALRMAR_HT_0: u32 = 1048576;
pub const RTC_ALRMAR_HT_1: u32 = 2097152;
pub const RTC_ALRMAR_HU_Pos: u32 = 16;
pub const RTC_ALRMAR_HU_Msk: u32 = 983040;
pub const RTC_ALRMAR_HU: u32 = 983040;
pub const RTC_ALRMAR_HU_0: u32 = 65536;
pub const RTC_ALRMAR_HU_1: u32 = 131072;
pub const RTC_ALRMAR_HU_2: u32 = 262144;
pub const RTC_ALRMAR_HU_3: u32 = 524288;
pub const RTC_ALRMAR_MSK2_Pos: u32 = 15;
pub const RTC_ALRMAR_MSK2_Msk: u32 = 32768;
pub const RTC_ALRMAR_MSK2: u32 = 32768;
pub const RTC_ALRMAR_MNT_Pos: u32 = 12;
pub const RTC_ALRMAR_MNT_Msk: u32 = 28672;
pub const RTC_ALRMAR_MNT: u32 = 28672;
pub const RTC_ALRMAR_MNT_0: u32 = 4096;
pub const RTC_ALRMAR_MNT_1: u32 = 8192;
pub const RTC_ALRMAR_MNT_2: u32 = 16384;
pub const RTC_ALRMAR_MNU_Pos: u32 = 8;
pub const RTC_ALRMAR_MNU_Msk: u32 = 3840;
pub const RTC_ALRMAR_MNU: u32 = 3840;
pub const RTC_ALRMAR_MNU_0: u32 = 256;
pub const RTC_ALRMAR_MNU_1: u32 = 512;
pub const RTC_ALRMAR_MNU_2: u32 = 1024;
pub const RTC_ALRMAR_MNU_3: u32 = 2048;
pub const RTC_ALRMAR_MSK1_Pos: u32 = 7;
pub const RTC_ALRMAR_MSK1_Msk: u32 = 128;
pub const RTC_ALRMAR_MSK1: u32 = 128;
pub const RTC_ALRMAR_ST_Pos: u32 = 4;
pub const RTC_ALRMAR_ST_Msk: u32 = 112;
pub const RTC_ALRMAR_ST: u32 = 112;
pub const RTC_ALRMAR_ST_0: u32 = 16;
pub const RTC_ALRMAR_ST_1: u32 = 32;
pub const RTC_ALRMAR_ST_2: u32 = 64;
pub const RTC_ALRMAR_SU_Pos: u32 = 0;
pub const RTC_ALRMAR_SU_Msk: u32 = 15;
pub const RTC_ALRMAR_SU: u32 = 15;
pub const RTC_ALRMAR_SU_0: u32 = 1;
pub const RTC_ALRMAR_SU_1: u32 = 2;
pub const RTC_ALRMAR_SU_2: u32 = 4;
pub const RTC_ALRMAR_SU_3: u32 = 8;
pub const RTC_ALRMBR_MSK4_Pos: u32 = 31;
pub const RTC_ALRMBR_MSK4_Msk: u32 = 2147483648;
pub const RTC_ALRMBR_MSK4: u32 = 2147483648;
pub const RTC_ALRMBR_WDSEL_Pos: u32 = 30;
pub const RTC_ALRMBR_WDSEL_Msk: u32 = 1073741824;
pub const RTC_ALRMBR_WDSEL: u32 = 1073741824;
pub const RTC_ALRMBR_DT_Pos: u32 = 28;
pub const RTC_ALRMBR_DT_Msk: u32 = 805306368;
pub const RTC_ALRMBR_DT: u32 = 805306368;
pub const RTC_ALRMBR_DT_0: u32 = 268435456;
pub const RTC_ALRMBR_DT_1: u32 = 536870912;
pub const RTC_ALRMBR_DU_Pos: u32 = 24;
pub const RTC_ALRMBR_DU_Msk: u32 = 251658240;
pub const RTC_ALRMBR_DU: u32 = 251658240;
pub const RTC_ALRMBR_DU_0: u32 = 16777216;
pub const RTC_ALRMBR_DU_1: u32 = 33554432;
pub const RTC_ALRMBR_DU_2: u32 = 67108864;
pub const RTC_ALRMBR_DU_3: u32 = 134217728;
pub const RTC_ALRMBR_MSK3_Pos: u32 = 23;
pub const RTC_ALRMBR_MSK3_Msk: u32 = 8388608;
pub const RTC_ALRMBR_MSK3: u32 = 8388608;
pub const RTC_ALRMBR_PM_Pos: u32 = 22;
pub const RTC_ALRMBR_PM_Msk: u32 = 4194304;
pub const RTC_ALRMBR_PM: u32 = 4194304;
pub const RTC_ALRMBR_HT_Pos: u32 = 20;
pub const RTC_ALRMBR_HT_Msk: u32 = 3145728;
pub const RTC_ALRMBR_HT: u32 = 3145728;
pub const RTC_ALRMBR_HT_0: u32 = 1048576;
pub const RTC_ALRMBR_HT_1: u32 = 2097152;
pub const RTC_ALRMBR_HU_Pos: u32 = 16;
pub const RTC_ALRMBR_HU_Msk: u32 = 983040;
pub const RTC_ALRMBR_HU: u32 = 983040;
pub const RTC_ALRMBR_HU_0: u32 = 65536;
pub const RTC_ALRMBR_HU_1: u32 = 131072;
pub const RTC_ALRMBR_HU_2: u32 = 262144;
pub const RTC_ALRMBR_HU_3: u32 = 524288;
pub const RTC_ALRMBR_MSK2_Pos: u32 = 15;
pub const RTC_ALRMBR_MSK2_Msk: u32 = 32768;
pub const RTC_ALRMBR_MSK2: u32 = 32768;
pub const RTC_ALRMBR_MNT_Pos: u32 = 12;
pub const RTC_ALRMBR_MNT_Msk: u32 = 28672;
pub const RTC_ALRMBR_MNT: u32 = 28672;
pub const RTC_ALRMBR_MNT_0: u32 = 4096;
pub const RTC_ALRMBR_MNT_1: u32 = 8192;
pub const RTC_ALRMBR_MNT_2: u32 = 16384;
pub const RTC_ALRMBR_MNU_Pos: u32 = 8;
pub const RTC_ALRMBR_MNU_Msk: u32 = 3840;
pub const RTC_ALRMBR_MNU: u32 = 3840;
pub const RTC_ALRMBR_MNU_0: u32 = 256;
pub const RTC_ALRMBR_MNU_1: u32 = 512;
pub const RTC_ALRMBR_MNU_2: u32 = 1024;
pub const RTC_ALRMBR_MNU_3: u32 = 2048;
pub const RTC_ALRMBR_MSK1_Pos: u32 = 7;
pub const RTC_ALRMBR_MSK1_Msk: u32 = 128;
pub const RTC_ALRMBR_MSK1: u32 = 128;
pub const RTC_ALRMBR_ST_Pos: u32 = 4;
pub const RTC_ALRMBR_ST_Msk: u32 = 112;
pub const RTC_ALRMBR_ST: u32 = 112;
pub const RTC_ALRMBR_ST_0: u32 = 16;
pub const RTC_ALRMBR_ST_1: u32 = 32;
pub const RTC_ALRMBR_ST_2: u32 = 64;
pub const RTC_ALRMBR_SU_Pos: u32 = 0;
pub const RTC_ALRMBR_SU_Msk: u32 = 15;
pub const RTC_ALRMBR_SU: u32 = 15;
pub const RTC_ALRMBR_SU_0: u32 = 1;
pub const RTC_ALRMBR_SU_1: u32 = 2;
pub const RTC_ALRMBR_SU_2: u32 = 4;
pub const RTC_ALRMBR_SU_3: u32 = 8;
pub const RTC_WPR_KEY_Pos: u32 = 0;
pub const RTC_WPR_KEY_Msk: u32 = 255;
pub const RTC_WPR_KEY: u32 = 255;
pub const RTC_SSR_SS_Pos: u32 = 0;
pub const RTC_SSR_SS_Msk: u32 = 65535;
pub const RTC_SSR_SS: u32 = 65535;
pub const RTC_SHIFTR_SUBFS_Pos: u32 = 0;
pub const RTC_SHIFTR_SUBFS_Msk: u32 = 32767;
pub const RTC_SHIFTR_SUBFS: u32 = 32767;
pub const RTC_SHIFTR_ADD1S_Pos: u32 = 31;
pub const RTC_SHIFTR_ADD1S_Msk: u32 = 2147483648;
pub const RTC_SHIFTR_ADD1S: u32 = 2147483648;
pub const RTC_TSTR_PM_Pos: u32 = 22;
pub const RTC_TSTR_PM_Msk: u32 = 4194304;
pub const RTC_TSTR_PM: u32 = 4194304;
pub const RTC_TSTR_HT_Pos: u32 = 20;
pub const RTC_TSTR_HT_Msk: u32 = 3145728;
pub const RTC_TSTR_HT: u32 = 3145728;
pub const RTC_TSTR_HT_0: u32 = 1048576;
pub const RTC_TSTR_HT_1: u32 = 2097152;
pub const RTC_TSTR_HU_Pos: u32 = 16;
pub const RTC_TSTR_HU_Msk: u32 = 983040;
pub const RTC_TSTR_HU: u32 = 983040;
pub const RTC_TSTR_HU_0: u32 = 65536;
pub const RTC_TSTR_HU_1: u32 = 131072;
pub const RTC_TSTR_HU_2: u32 = 262144;
pub const RTC_TSTR_HU_3: u32 = 524288;
pub const RTC_TSTR_MNT_Pos: u32 = 12;
pub const RTC_TSTR_MNT_Msk: u32 = 28672;
pub const RTC_TSTR_MNT: u32 = 28672;
pub const RTC_TSTR_MNT_0: u32 = 4096;
pub const RTC_TSTR_MNT_1: u32 = 8192;
pub const RTC_TSTR_MNT_2: u32 = 16384;
pub const RTC_TSTR_MNU_Pos: u32 = 8;
pub const RTC_TSTR_MNU_Msk: u32 = 3840;
pub const RTC_TSTR_MNU: u32 = 3840;
pub const RTC_TSTR_MNU_0: u32 = 256;
pub const RTC_TSTR_MNU_1: u32 = 512;
pub const RTC_TSTR_MNU_2: u32 = 1024;
pub const RTC_TSTR_MNU_3: u32 = 2048;
pub const RTC_TSTR_ST_Pos: u32 = 4;
pub const RTC_TSTR_ST_Msk: u32 = 112;
pub const RTC_TSTR_ST: u32 = 112;
pub const RTC_TSTR_ST_0: u32 = 16;
pub const RTC_TSTR_ST_1: u32 = 32;
pub const RTC_TSTR_ST_2: u32 = 64;
pub const RTC_TSTR_SU_Pos: u32 = 0;
pub const RTC_TSTR_SU_Msk: u32 = 15;
pub const RTC_TSTR_SU: u32 = 15;
pub const RTC_TSTR_SU_0: u32 = 1;
pub const RTC_TSTR_SU_1: u32 = 2;
pub const RTC_TSTR_SU_2: u32 = 4;
pub const RTC_TSTR_SU_3: u32 = 8;
pub const RTC_TSDR_WDU_Pos: u32 = 13;
pub const RTC_TSDR_WDU_Msk: u32 = 57344;
pub const RTC_TSDR_WDU: u32 = 57344;
pub const RTC_TSDR_WDU_0: u32 = 8192;
pub const RTC_TSDR_WDU_1: u32 = 16384;
pub const RTC_TSDR_WDU_2: u32 = 32768;
pub const RTC_TSDR_MT_Pos: u32 = 12;
pub const RTC_TSDR_MT_Msk: u32 = 4096;
pub const RTC_TSDR_MT: u32 = 4096;
pub const RTC_TSDR_MU_Pos: u32 = 8;
pub const RTC_TSDR_MU_Msk: u32 = 3840;
pub const RTC_TSDR_MU: u32 = 3840;
pub const RTC_TSDR_MU_0: u32 = 256;
pub const RTC_TSDR_MU_1: u32 = 512;
pub const RTC_TSDR_MU_2: u32 = 1024;
pub const RTC_TSDR_MU_3: u32 = 2048;
pub const RTC_TSDR_DT_Pos: u32 = 4;
pub const RTC_TSDR_DT_Msk: u32 = 48;
pub const RTC_TSDR_DT: u32 = 48;
pub const RTC_TSDR_DT_0: u32 = 16;
pub const RTC_TSDR_DT_1: u32 = 32;
pub const RTC_TSDR_DU_Pos: u32 = 0;
pub const RTC_TSDR_DU_Msk: u32 = 15;
pub const RTC_TSDR_DU: u32 = 15;
pub const RTC_TSDR_DU_0: u32 = 1;
pub const RTC_TSDR_DU_1: u32 = 2;
pub const RTC_TSDR_DU_2: u32 = 4;
pub const RTC_TSDR_DU_3: u32 = 8;
pub const RTC_TSSSR_SS_Pos: u32 = 0;
pub const RTC_TSSSR_SS_Msk: u32 = 65535;
pub const RTC_TSSSR_SS: u32 = 65535;
pub const RTC_CALR_CALP_Pos: u32 = 15;
pub const RTC_CALR_CALP_Msk: u32 = 32768;
pub const RTC_CALR_CALP: u32 = 32768;
pub const RTC_CALR_CALW8_Pos: u32 = 14;
pub const RTC_CALR_CALW8_Msk: u32 = 16384;
pub const RTC_CALR_CALW8: u32 = 16384;
pub const RTC_CALR_CALW16_Pos: u32 = 13;
pub const RTC_CALR_CALW16_Msk: u32 = 8192;
pub const RTC_CALR_CALW16: u32 = 8192;
pub const RTC_CALR_CALM_Pos: u32 = 0;
pub const RTC_CALR_CALM_Msk: u32 = 511;
pub const RTC_CALR_CALM: u32 = 511;
pub const RTC_CALR_CALM_0: u32 = 1;
pub const RTC_CALR_CALM_1: u32 = 2;
pub const RTC_CALR_CALM_2: u32 = 4;
pub const RTC_CALR_CALM_3: u32 = 8;
pub const RTC_CALR_CALM_4: u32 = 16;
pub const RTC_CALR_CALM_5: u32 = 32;
pub const RTC_CALR_CALM_6: u32 = 64;
pub const RTC_CALR_CALM_7: u32 = 128;
pub const RTC_CALR_CALM_8: u32 = 256;
pub const RTC_TAMPCR_TAMP3MF_Pos: u32 = 24;
pub const RTC_TAMPCR_TAMP3MF_Msk: u32 = 16777216;
pub const RTC_TAMPCR_TAMP3MF: u32 = 16777216;
pub const RTC_TAMPCR_TAMP3NOERASE_Pos: u32 = 23;
pub const RTC_TAMPCR_TAMP3NOERASE_Msk: u32 = 8388608;
pub const RTC_TAMPCR_TAMP3NOERASE: u32 = 8388608;
pub const RTC_TAMPCR_TAMP3IE_Pos: u32 = 22;
pub const RTC_TAMPCR_TAMP3IE_Msk: u32 = 4194304;
pub const RTC_TAMPCR_TAMP3IE: u32 = 4194304;
pub const RTC_TAMPCR_TAMP2MF_Pos: u32 = 21;
pub const RTC_TAMPCR_TAMP2MF_Msk: u32 = 2097152;
pub const RTC_TAMPCR_TAMP2MF: u32 = 2097152;
pub const RTC_TAMPCR_TAMP2NOERASE_Pos: u32 = 20;
pub const RTC_TAMPCR_TAMP2NOERASE_Msk: u32 = 1048576;
pub const RTC_TAMPCR_TAMP2NOERASE: u32 = 1048576;
pub const RTC_TAMPCR_TAMP2IE_Pos: u32 = 19;
pub const RTC_TAMPCR_TAMP2IE_Msk: u32 = 524288;
pub const RTC_TAMPCR_TAMP2IE: u32 = 524288;
pub const RTC_TAMPCR_TAMP1MF_Pos: u32 = 18;
pub const RTC_TAMPCR_TAMP1MF_Msk: u32 = 262144;
pub const RTC_TAMPCR_TAMP1MF: u32 = 262144;
pub const RTC_TAMPCR_TAMP1NOERASE_Pos: u32 = 17;
pub const RTC_TAMPCR_TAMP1NOERASE_Msk: u32 = 131072;
pub const RTC_TAMPCR_TAMP1NOERASE: u32 = 131072;
pub const RTC_TAMPCR_TAMP1IE_Pos: u32 = 16;
pub const RTC_TAMPCR_TAMP1IE_Msk: u32 = 65536;
pub const RTC_TAMPCR_TAMP1IE: u32 = 65536;
pub const RTC_TAMPCR_TAMPPUDIS_Pos: u32 = 15;
pub const RTC_TAMPCR_TAMPPUDIS_Msk: u32 = 32768;
pub const RTC_TAMPCR_TAMPPUDIS: u32 = 32768;
pub const RTC_TAMPCR_TAMPPRCH_Pos: u32 = 13;
pub const RTC_TAMPCR_TAMPPRCH_Msk: u32 = 24576;
pub const RTC_TAMPCR_TAMPPRCH: u32 = 24576;
pub const RTC_TAMPCR_TAMPPRCH_0: u32 = 8192;
pub const RTC_TAMPCR_TAMPPRCH_1: u32 = 16384;
pub const RTC_TAMPCR_TAMPFLT_Pos: u32 = 11;
pub const RTC_TAMPCR_TAMPFLT_Msk: u32 = 6144;
pub const RTC_TAMPCR_TAMPFLT: u32 = 6144;
pub const RTC_TAMPCR_TAMPFLT_0: u32 = 2048;
pub const RTC_TAMPCR_TAMPFLT_1: u32 = 4096;
pub const RTC_TAMPCR_TAMPFREQ_Pos: u32 = 8;
pub const RTC_TAMPCR_TAMPFREQ_Msk: u32 = 1792;
pub const RTC_TAMPCR_TAMPFREQ: u32 = 1792;
pub const RTC_TAMPCR_TAMPFREQ_0: u32 = 256;
pub const RTC_TAMPCR_TAMPFREQ_1: u32 = 512;
pub const RTC_TAMPCR_TAMPFREQ_2: u32 = 1024;
pub const RTC_TAMPCR_TAMPTS_Pos: u32 = 7;
pub const RTC_TAMPCR_TAMPTS_Msk: u32 = 128;
pub const RTC_TAMPCR_TAMPTS: u32 = 128;
pub const RTC_TAMPCR_TAMP3TRG_Pos: u32 = 6;
pub const RTC_TAMPCR_TAMP3TRG_Msk: u32 = 64;
pub const RTC_TAMPCR_TAMP3TRG: u32 = 64;
pub const RTC_TAMPCR_TAMP3E_Pos: u32 = 5;
pub const RTC_TAMPCR_TAMP3E_Msk: u32 = 32;
pub const RTC_TAMPCR_TAMP3E: u32 = 32;
pub const RTC_TAMPCR_TAMP2TRG_Pos: u32 = 4;
pub const RTC_TAMPCR_TAMP2TRG_Msk: u32 = 16;
pub const RTC_TAMPCR_TAMP2TRG: u32 = 16;
pub const RTC_TAMPCR_TAMP2E_Pos: u32 = 3;
pub const RTC_TAMPCR_TAMP2E_Msk: u32 = 8;
pub const RTC_TAMPCR_TAMP2E: u32 = 8;
pub const RTC_TAMPCR_TAMPIE_Pos: u32 = 2;
pub const RTC_TAMPCR_TAMPIE_Msk: u32 = 4;
pub const RTC_TAMPCR_TAMPIE: u32 = 4;
pub const RTC_TAMPCR_TAMP1TRG_Pos: u32 = 1;
pub const RTC_TAMPCR_TAMP1TRG_Msk: u32 = 2;
pub const RTC_TAMPCR_TAMP1TRG: u32 = 2;
pub const RTC_TAMPCR_TAMP1E_Pos: u32 = 0;
pub const RTC_TAMPCR_TAMP1E_Msk: u32 = 1;
pub const RTC_TAMPCR_TAMP1E: u32 = 1;
pub const RTC_ALRMASSR_MASKSS_Pos: u32 = 24;
pub const RTC_ALRMASSR_MASKSS_Msk: u32 = 251658240;
pub const RTC_ALRMASSR_MASKSS: u32 = 251658240;
pub const RTC_ALRMASSR_MASKSS_0: u32 = 16777216;
pub const RTC_ALRMASSR_MASKSS_1: u32 = 33554432;
pub const RTC_ALRMASSR_MASKSS_2: u32 = 67108864;
pub const RTC_ALRMASSR_MASKSS_3: u32 = 134217728;
pub const RTC_ALRMASSR_SS_Pos: u32 = 0;
pub const RTC_ALRMASSR_SS_Msk: u32 = 32767;
pub const RTC_ALRMASSR_SS: u32 = 32767;
pub const RTC_ALRMBSSR_MASKSS_Pos: u32 = 24;
pub const RTC_ALRMBSSR_MASKSS_Msk: u32 = 251658240;
pub const RTC_ALRMBSSR_MASKSS: u32 = 251658240;
pub const RTC_ALRMBSSR_MASKSS_0: u32 = 16777216;
pub const RTC_ALRMBSSR_MASKSS_1: u32 = 33554432;
pub const RTC_ALRMBSSR_MASKSS_2: u32 = 67108864;
pub const RTC_ALRMBSSR_MASKSS_3: u32 = 134217728;
pub const RTC_ALRMBSSR_SS_Pos: u32 = 0;
pub const RTC_ALRMBSSR_SS_Msk: u32 = 32767;
pub const RTC_ALRMBSSR_SS: u32 = 32767;
pub const RTC_OR_OUT_RMP_Pos: u32 = 1;
pub const RTC_OR_OUT_RMP_Msk: u32 = 2;
pub const RTC_OR_OUT_RMP: u32 = 2;
pub const RTC_OR_ALARMOUTTYPE_Pos: u32 = 0;
pub const RTC_OR_ALARMOUTTYPE_Msk: u32 = 1;
pub const RTC_OR_ALARMOUTTYPE: u32 = 1;
pub const RTC_BKP0R_Pos: u32 = 0;
pub const RTC_BKP0R_Msk: u32 = 4294967295;
pub const RTC_BKP0R: u32 = 4294967295;
pub const RTC_BKP1R_Pos: u32 = 0;
pub const RTC_BKP1R_Msk: u32 = 4294967295;
pub const RTC_BKP1R: u32 = 4294967295;
pub const RTC_BKP2R_Pos: u32 = 0;
pub const RTC_BKP2R_Msk: u32 = 4294967295;
pub const RTC_BKP2R: u32 = 4294967295;
pub const RTC_BKP3R_Pos: u32 = 0;
pub const RTC_BKP3R_Msk: u32 = 4294967295;
pub const RTC_BKP3R: u32 = 4294967295;
pub const RTC_BKP4R_Pos: u32 = 0;
pub const RTC_BKP4R_Msk: u32 = 4294967295;
pub const RTC_BKP4R: u32 = 4294967295;
pub const RTC_BKP5R_Pos: u32 = 0;
pub const RTC_BKP5R_Msk: u32 = 4294967295;
pub const RTC_BKP5R: u32 = 4294967295;
pub const RTC_BKP6R_Pos: u32 = 0;
pub const RTC_BKP6R_Msk: u32 = 4294967295;
pub const RTC_BKP6R: u32 = 4294967295;
pub const RTC_BKP7R_Pos: u32 = 0;
pub const RTC_BKP7R_Msk: u32 = 4294967295;
pub const RTC_BKP7R: u32 = 4294967295;
pub const RTC_BKP8R_Pos: u32 = 0;
pub const RTC_BKP8R_Msk: u32 = 4294967295;
pub const RTC_BKP8R: u32 = 4294967295;
pub const RTC_BKP9R_Pos: u32 = 0;
pub const RTC_BKP9R_Msk: u32 = 4294967295;
pub const RTC_BKP9R: u32 = 4294967295;
pub const RTC_BKP10R_Pos: u32 = 0;
pub const RTC_BKP10R_Msk: u32 = 4294967295;
pub const RTC_BKP10R: u32 = 4294967295;
pub const RTC_BKP11R_Pos: u32 = 0;
pub const RTC_BKP11R_Msk: u32 = 4294967295;
pub const RTC_BKP11R: u32 = 4294967295;
pub const RTC_BKP12R_Pos: u32 = 0;
pub const RTC_BKP12R_Msk: u32 = 4294967295;
pub const RTC_BKP12R: u32 = 4294967295;
pub const RTC_BKP13R_Pos: u32 = 0;
pub const RTC_BKP13R_Msk: u32 = 4294967295;
pub const RTC_BKP13R: u32 = 4294967295;
pub const RTC_BKP14R_Pos: u32 = 0;
pub const RTC_BKP14R_Msk: u32 = 4294967295;
pub const RTC_BKP14R: u32 = 4294967295;
pub const RTC_BKP15R_Pos: u32 = 0;
pub const RTC_BKP15R_Msk: u32 = 4294967295;
pub const RTC_BKP15R: u32 = 4294967295;
pub const RTC_BKP16R_Pos: u32 = 0;
pub const RTC_BKP16R_Msk: u32 = 4294967295;
pub const RTC_BKP16R: u32 = 4294967295;
pub const RTC_BKP17R_Pos: u32 = 0;
pub const RTC_BKP17R_Msk: u32 = 4294967295;
pub const RTC_BKP17R: u32 = 4294967295;
pub const RTC_BKP18R_Pos: u32 = 0;
pub const RTC_BKP18R_Msk: u32 = 4294967295;
pub const RTC_BKP18R: u32 = 4294967295;
pub const RTC_BKP19R_Pos: u32 = 0;
pub const RTC_BKP19R_Msk: u32 = 4294967295;
pub const RTC_BKP19R: u32 = 4294967295;
pub const RTC_BKP20R_Pos: u32 = 0;
pub const RTC_BKP20R_Msk: u32 = 4294967295;
pub const RTC_BKP20R: u32 = 4294967295;
pub const RTC_BKP21R_Pos: u32 = 0;
pub const RTC_BKP21R_Msk: u32 = 4294967295;
pub const RTC_BKP21R: u32 = 4294967295;
pub const RTC_BKP22R_Pos: u32 = 0;
pub const RTC_BKP22R_Msk: u32 = 4294967295;
pub const RTC_BKP22R: u32 = 4294967295;
pub const RTC_BKP23R_Pos: u32 = 0;
pub const RTC_BKP23R_Msk: u32 = 4294967295;
pub const RTC_BKP23R: u32 = 4294967295;
pub const RTC_BKP24R_Pos: u32 = 0;
pub const RTC_BKP24R_Msk: u32 = 4294967295;
pub const RTC_BKP24R: u32 = 4294967295;
pub const RTC_BKP25R_Pos: u32 = 0;
pub const RTC_BKP25R_Msk: u32 = 4294967295;
pub const RTC_BKP25R: u32 = 4294967295;
pub const RTC_BKP26R_Pos: u32 = 0;
pub const RTC_BKP26R_Msk: u32 = 4294967295;
pub const RTC_BKP26R: u32 = 4294967295;
pub const RTC_BKP27R_Pos: u32 = 0;
pub const RTC_BKP27R_Msk: u32 = 4294967295;
pub const RTC_BKP27R: u32 = 4294967295;
pub const RTC_BKP28R_Pos: u32 = 0;
pub const RTC_BKP28R_Msk: u32 = 4294967295;
pub const RTC_BKP28R: u32 = 4294967295;
pub const RTC_BKP29R_Pos: u32 = 0;
pub const RTC_BKP29R_Msk: u32 = 4294967295;
pub const RTC_BKP29R: u32 = 4294967295;
pub const RTC_BKP30R_Pos: u32 = 0;
pub const RTC_BKP30R_Msk: u32 = 4294967295;
pub const RTC_BKP30R: u32 = 4294967295;
pub const RTC_BKP31R_Pos: u32 = 0;
pub const RTC_BKP31R_Msk: u32 = 4294967295;
pub const RTC_BKP31R: u32 = 4294967295;
pub const SAI_GCR_SYNCIN_Pos: u32 = 0;
pub const SAI_GCR_SYNCIN_Msk: u32 = 3;
pub const SAI_GCR_SYNCIN: u32 = 3;
pub const SAI_GCR_SYNCIN_0: u32 = 1;
pub const SAI_GCR_SYNCIN_1: u32 = 2;
pub const SAI_GCR_SYNCOUT_Pos: u32 = 4;
pub const SAI_GCR_SYNCOUT_Msk: u32 = 48;
pub const SAI_GCR_SYNCOUT: u32 = 48;
pub const SAI_GCR_SYNCOUT_0: u32 = 16;
pub const SAI_GCR_SYNCOUT_1: u32 = 32;
pub const SAI_xCR1_MODE_Pos: u32 = 0;
pub const SAI_xCR1_MODE_Msk: u32 = 3;
pub const SAI_xCR1_MODE: u32 = 3;
pub const SAI_xCR1_MODE_0: u32 = 1;
pub const SAI_xCR1_MODE_1: u32 = 2;
pub const SAI_xCR1_PRTCFG_Pos: u32 = 2;
pub const SAI_xCR1_PRTCFG_Msk: u32 = 12;
pub const SAI_xCR1_PRTCFG: u32 = 12;
pub const SAI_xCR1_PRTCFG_0: u32 = 4;
pub const SAI_xCR1_PRTCFG_1: u32 = 8;
pub const SAI_xCR1_DS_Pos: u32 = 5;
pub const SAI_xCR1_DS_Msk: u32 = 224;
pub const SAI_xCR1_DS: u32 = 224;
pub const SAI_xCR1_DS_0: u32 = 32;
pub const SAI_xCR1_DS_1: u32 = 64;
pub const SAI_xCR1_DS_2: u32 = 128;
pub const SAI_xCR1_LSBFIRST_Pos: u32 = 8;
pub const SAI_xCR1_LSBFIRST_Msk: u32 = 256;
pub const SAI_xCR1_LSBFIRST: u32 = 256;
pub const SAI_xCR1_CKSTR_Pos: u32 = 9;
pub const SAI_xCR1_CKSTR_Msk: u32 = 512;
pub const SAI_xCR1_CKSTR: u32 = 512;
pub const SAI_xCR1_SYNCEN_Pos: u32 = 10;
pub const SAI_xCR1_SYNCEN_Msk: u32 = 3072;
pub const SAI_xCR1_SYNCEN: u32 = 3072;
pub const SAI_xCR1_SYNCEN_0: u32 = 1024;
pub const SAI_xCR1_SYNCEN_1: u32 = 2048;
pub const SAI_xCR1_MONO_Pos: u32 = 12;
pub const SAI_xCR1_MONO_Msk: u32 = 4096;
pub const SAI_xCR1_MONO: u32 = 4096;
pub const SAI_xCR1_OUTDRIV_Pos: u32 = 13;
pub const SAI_xCR1_OUTDRIV_Msk: u32 = 8192;
pub const SAI_xCR1_OUTDRIV: u32 = 8192;
pub const SAI_xCR1_SAIEN_Pos: u32 = 16;
pub const SAI_xCR1_SAIEN_Msk: u32 = 65536;
pub const SAI_xCR1_SAIEN: u32 = 65536;
pub const SAI_xCR1_DMAEN_Pos: u32 = 17;
pub const SAI_xCR1_DMAEN_Msk: u32 = 131072;
pub const SAI_xCR1_DMAEN: u32 = 131072;
pub const SAI_xCR1_NODIV_Pos: u32 = 19;
pub const SAI_xCR1_NODIV_Msk: u32 = 524288;
pub const SAI_xCR1_NODIV: u32 = 524288;
pub const SAI_xCR1_MCKDIV_Pos: u32 = 20;
pub const SAI_xCR1_MCKDIV_Msk: u32 = 15728640;
pub const SAI_xCR1_MCKDIV: u32 = 15728640;
pub const SAI_xCR1_MCKDIV_0: u32 = 1048576;
pub const SAI_xCR1_MCKDIV_1: u32 = 2097152;
pub const SAI_xCR1_MCKDIV_2: u32 = 4194304;
pub const SAI_xCR1_MCKDIV_3: u32 = 8388608;
pub const SAI_xCR2_FTH_Pos: u32 = 0;
pub const SAI_xCR2_FTH_Msk: u32 = 7;
pub const SAI_xCR2_FTH: u32 = 7;
pub const SAI_xCR2_FTH_0: u32 = 1;
pub const SAI_xCR2_FTH_1: u32 = 2;
pub const SAI_xCR2_FTH_2: u32 = 4;
pub const SAI_xCR2_FFLUSH_Pos: u32 = 3;
pub const SAI_xCR2_FFLUSH_Msk: u32 = 8;
pub const SAI_xCR2_FFLUSH: u32 = 8;
pub const SAI_xCR2_TRIS_Pos: u32 = 4;
pub const SAI_xCR2_TRIS_Msk: u32 = 16;
pub const SAI_xCR2_TRIS: u32 = 16;
pub const SAI_xCR2_MUTE_Pos: u32 = 5;
pub const SAI_xCR2_MUTE_Msk: u32 = 32;
pub const SAI_xCR2_MUTE: u32 = 32;
pub const SAI_xCR2_MUTEVAL_Pos: u32 = 6;
pub const SAI_xCR2_MUTEVAL_Msk: u32 = 64;
pub const SAI_xCR2_MUTEVAL: u32 = 64;
pub const SAI_xCR2_MUTECNT_Pos: u32 = 7;
pub const SAI_xCR2_MUTECNT_Msk: u32 = 8064;
pub const SAI_xCR2_MUTECNT: u32 = 8064;
pub const SAI_xCR2_MUTECNT_0: u32 = 128;
pub const SAI_xCR2_MUTECNT_1: u32 = 256;
pub const SAI_xCR2_MUTECNT_2: u32 = 512;
pub const SAI_xCR2_MUTECNT_3: u32 = 1024;
pub const SAI_xCR2_MUTECNT_4: u32 = 2048;
pub const SAI_xCR2_MUTECNT_5: u32 = 4096;
pub const SAI_xCR2_CPL_Pos: u32 = 13;
pub const SAI_xCR2_CPL_Msk: u32 = 8192;
pub const SAI_xCR2_CPL: u32 = 8192;
pub const SAI_xCR2_COMP_Pos: u32 = 14;
pub const SAI_xCR2_COMP_Msk: u32 = 49152;
pub const SAI_xCR2_COMP: u32 = 49152;
pub const SAI_xCR2_COMP_0: u32 = 16384;
pub const SAI_xCR2_COMP_1: u32 = 32768;
pub const SAI_xFRCR_FRL_Pos: u32 = 0;
pub const SAI_xFRCR_FRL_Msk: u32 = 255;
pub const SAI_xFRCR_FRL: u32 = 255;
pub const SAI_xFRCR_FRL_0: u32 = 1;
pub const SAI_xFRCR_FRL_1: u32 = 2;
pub const SAI_xFRCR_FRL_2: u32 = 4;
pub const SAI_xFRCR_FRL_3: u32 = 8;
pub const SAI_xFRCR_FRL_4: u32 = 16;
pub const SAI_xFRCR_FRL_5: u32 = 32;
pub const SAI_xFRCR_FRL_6: u32 = 64;
pub const SAI_xFRCR_FRL_7: u32 = 128;
pub const SAI_xFRCR_FSALL_Pos: u32 = 8;
pub const SAI_xFRCR_FSALL_Msk: u32 = 32512;
pub const SAI_xFRCR_FSALL: u32 = 32512;
pub const SAI_xFRCR_FSALL_0: u32 = 256;
pub const SAI_xFRCR_FSALL_1: u32 = 512;
pub const SAI_xFRCR_FSALL_2: u32 = 1024;
pub const SAI_xFRCR_FSALL_3: u32 = 2048;
pub const SAI_xFRCR_FSALL_4: u32 = 4096;
pub const SAI_xFRCR_FSALL_5: u32 = 8192;
pub const SAI_xFRCR_FSALL_6: u32 = 16384;
pub const SAI_xFRCR_FSDEF_Pos: u32 = 16;
pub const SAI_xFRCR_FSDEF_Msk: u32 = 65536;
pub const SAI_xFRCR_FSDEF: u32 = 65536;
pub const SAI_xFRCR_FSPOL_Pos: u32 = 17;
pub const SAI_xFRCR_FSPOL_Msk: u32 = 131072;
pub const SAI_xFRCR_FSPOL: u32 = 131072;
pub const SAI_xFRCR_FSOFF_Pos: u32 = 18;
pub const SAI_xFRCR_FSOFF_Msk: u32 = 262144;
pub const SAI_xFRCR_FSOFF: u32 = 262144;
pub const SAI_xSLOTR_FBOFF_Pos: u32 = 0;
pub const SAI_xSLOTR_FBOFF_Msk: u32 = 31;
pub const SAI_xSLOTR_FBOFF: u32 = 31;
pub const SAI_xSLOTR_FBOFF_0: u32 = 1;
pub const SAI_xSLOTR_FBOFF_1: u32 = 2;
pub const SAI_xSLOTR_FBOFF_2: u32 = 4;
pub const SAI_xSLOTR_FBOFF_3: u32 = 8;
pub const SAI_xSLOTR_FBOFF_4: u32 = 16;
pub const SAI_xSLOTR_SLOTSZ_Pos: u32 = 6;
pub const SAI_xSLOTR_SLOTSZ_Msk: u32 = 192;
pub const SAI_xSLOTR_SLOTSZ: u32 = 192;
pub const SAI_xSLOTR_SLOTSZ_0: u32 = 64;
pub const SAI_xSLOTR_SLOTSZ_1: u32 = 128;
pub const SAI_xSLOTR_NBSLOT_Pos: u32 = 8;
pub const SAI_xSLOTR_NBSLOT_Msk: u32 = 3840;
pub const SAI_xSLOTR_NBSLOT: u32 = 3840;
pub const SAI_xSLOTR_NBSLOT_0: u32 = 256;
pub const SAI_xSLOTR_NBSLOT_1: u32 = 512;
pub const SAI_xSLOTR_NBSLOT_2: u32 = 1024;
pub const SAI_xSLOTR_NBSLOT_3: u32 = 2048;
pub const SAI_xSLOTR_SLOTEN_Pos: u32 = 16;
pub const SAI_xSLOTR_SLOTEN_Msk: u32 = 4294901760;
pub const SAI_xSLOTR_SLOTEN: u32 = 4294901760;
pub const SAI_xIMR_OVRUDRIE_Pos: u32 = 0;
pub const SAI_xIMR_OVRUDRIE_Msk: u32 = 1;
pub const SAI_xIMR_OVRUDRIE: u32 = 1;
pub const SAI_xIMR_MUTEDETIE_Pos: u32 = 1;
pub const SAI_xIMR_MUTEDETIE_Msk: u32 = 2;
pub const SAI_xIMR_MUTEDETIE: u32 = 2;
pub const SAI_xIMR_WCKCFGIE_Pos: u32 = 2;
pub const SAI_xIMR_WCKCFGIE_Msk: u32 = 4;
pub const SAI_xIMR_WCKCFGIE: u32 = 4;
pub const SAI_xIMR_FREQIE_Pos: u32 = 3;
pub const SAI_xIMR_FREQIE_Msk: u32 = 8;
pub const SAI_xIMR_FREQIE: u32 = 8;
pub const SAI_xIMR_CNRDYIE_Pos: u32 = 4;
pub const SAI_xIMR_CNRDYIE_Msk: u32 = 16;
pub const SAI_xIMR_CNRDYIE: u32 = 16;
pub const SAI_xIMR_AFSDETIE_Pos: u32 = 5;
pub const SAI_xIMR_AFSDETIE_Msk: u32 = 32;
pub const SAI_xIMR_AFSDETIE: u32 = 32;
pub const SAI_xIMR_LFSDETIE_Pos: u32 = 6;
pub const SAI_xIMR_LFSDETIE_Msk: u32 = 64;
pub const SAI_xIMR_LFSDETIE: u32 = 64;
pub const SAI_xSR_OVRUDR_Pos: u32 = 0;
pub const SAI_xSR_OVRUDR_Msk: u32 = 1;
pub const SAI_xSR_OVRUDR: u32 = 1;
pub const SAI_xSR_MUTEDET_Pos: u32 = 1;
pub const SAI_xSR_MUTEDET_Msk: u32 = 2;
pub const SAI_xSR_MUTEDET: u32 = 2;
pub const SAI_xSR_WCKCFG_Pos: u32 = 2;
pub const SAI_xSR_WCKCFG_Msk: u32 = 4;
pub const SAI_xSR_WCKCFG: u32 = 4;
pub const SAI_xSR_FREQ_Pos: u32 = 3;
pub const SAI_xSR_FREQ_Msk: u32 = 8;
pub const SAI_xSR_FREQ: u32 = 8;
pub const SAI_xSR_CNRDY_Pos: u32 = 4;
pub const SAI_xSR_CNRDY_Msk: u32 = 16;
pub const SAI_xSR_CNRDY: u32 = 16;
pub const SAI_xSR_AFSDET_Pos: u32 = 5;
pub const SAI_xSR_AFSDET_Msk: u32 = 32;
pub const SAI_xSR_AFSDET: u32 = 32;
pub const SAI_xSR_LFSDET_Pos: u32 = 6;
pub const SAI_xSR_LFSDET_Msk: u32 = 64;
pub const SAI_xSR_LFSDET: u32 = 64;
pub const SAI_xSR_FLVL_Pos: u32 = 16;
pub const SAI_xSR_FLVL_Msk: u32 = 458752;
pub const SAI_xSR_FLVL: u32 = 458752;
pub const SAI_xSR_FLVL_0: u32 = 65536;
pub const SAI_xSR_FLVL_1: u32 = 131072;
pub const SAI_xSR_FLVL_2: u32 = 262144;
pub const SAI_xCLRFR_COVRUDR_Pos: u32 = 0;
pub const SAI_xCLRFR_COVRUDR_Msk: u32 = 1;
pub const SAI_xCLRFR_COVRUDR: u32 = 1;
pub const SAI_xCLRFR_CMUTEDET_Pos: u32 = 1;
pub const SAI_xCLRFR_CMUTEDET_Msk: u32 = 2;
pub const SAI_xCLRFR_CMUTEDET: u32 = 2;
pub const SAI_xCLRFR_CWCKCFG_Pos: u32 = 2;
pub const SAI_xCLRFR_CWCKCFG_Msk: u32 = 4;
pub const SAI_xCLRFR_CWCKCFG: u32 = 4;
pub const SAI_xCLRFR_CFREQ_Pos: u32 = 3;
pub const SAI_xCLRFR_CFREQ_Msk: u32 = 8;
pub const SAI_xCLRFR_CFREQ: u32 = 8;
pub const SAI_xCLRFR_CCNRDY_Pos: u32 = 4;
pub const SAI_xCLRFR_CCNRDY_Msk: u32 = 16;
pub const SAI_xCLRFR_CCNRDY: u32 = 16;
pub const SAI_xCLRFR_CAFSDET_Pos: u32 = 5;
pub const SAI_xCLRFR_CAFSDET_Msk: u32 = 32;
pub const SAI_xCLRFR_CAFSDET: u32 = 32;
pub const SAI_xCLRFR_CLFSDET_Pos: u32 = 6;
pub const SAI_xCLRFR_CLFSDET_Msk: u32 = 64;
pub const SAI_xCLRFR_CLFSDET: u32 = 64;
pub const SAI_xDR_DATA_Pos: u32 = 0;
pub const SAI_xDR_DATA_Msk: u32 = 4294967295;
pub const SAI_xDR_DATA: u32 = 4294967295;
pub const SDMMC_POWER_PWRCTRL_Pos: u32 = 0;
pub const SDMMC_POWER_PWRCTRL_Msk: u32 = 3;
pub const SDMMC_POWER_PWRCTRL: u32 = 3;
pub const SDMMC_POWER_PWRCTRL_0: u32 = 1;
pub const SDMMC_POWER_PWRCTRL_1: u32 = 2;
pub const SDMMC_CLKCR_CLKDIV_Pos: u32 = 0;
pub const SDMMC_CLKCR_CLKDIV_Msk: u32 = 255;
pub const SDMMC_CLKCR_CLKDIV: u32 = 255;
pub const SDMMC_CLKCR_CLKEN_Pos: u32 = 8;
pub const SDMMC_CLKCR_CLKEN_Msk: u32 = 256;
pub const SDMMC_CLKCR_CLKEN: u32 = 256;
pub const SDMMC_CLKCR_PWRSAV_Pos: u32 = 9;
pub const SDMMC_CLKCR_PWRSAV_Msk: u32 = 512;
pub const SDMMC_CLKCR_PWRSAV: u32 = 512;
pub const SDMMC_CLKCR_BYPASS_Pos: u32 = 10;
pub const SDMMC_CLKCR_BYPASS_Msk: u32 = 1024;
pub const SDMMC_CLKCR_BYPASS: u32 = 1024;
pub const SDMMC_CLKCR_WIDBUS_Pos: u32 = 11;
pub const SDMMC_CLKCR_WIDBUS_Msk: u32 = 6144;
pub const SDMMC_CLKCR_WIDBUS: u32 = 6144;
pub const SDMMC_CLKCR_WIDBUS_0: u32 = 2048;
pub const SDMMC_CLKCR_WIDBUS_1: u32 = 4096;
pub const SDMMC_CLKCR_NEGEDGE_Pos: u32 = 13;
pub const SDMMC_CLKCR_NEGEDGE_Msk: u32 = 8192;
pub const SDMMC_CLKCR_NEGEDGE: u32 = 8192;
pub const SDMMC_CLKCR_HWFC_EN_Pos: u32 = 14;
pub const SDMMC_CLKCR_HWFC_EN_Msk: u32 = 16384;
pub const SDMMC_CLKCR_HWFC_EN: u32 = 16384;
pub const SDMMC_ARG_CMDARG_Pos: u32 = 0;
pub const SDMMC_ARG_CMDARG_Msk: u32 = 4294967295;
pub const SDMMC_ARG_CMDARG: u32 = 4294967295;
pub const SDMMC_CMD_CMDINDEX_Pos: u32 = 0;
pub const SDMMC_CMD_CMDINDEX_Msk: u32 = 63;
pub const SDMMC_CMD_CMDINDEX: u32 = 63;
pub const SDMMC_CMD_WAITRESP_Pos: u32 = 6;
pub const SDMMC_CMD_WAITRESP_Msk: u32 = 192;
pub const SDMMC_CMD_WAITRESP: u32 = 192;
pub const SDMMC_CMD_WAITRESP_0: u32 = 64;
pub const SDMMC_CMD_WAITRESP_1: u32 = 128;
pub const SDMMC_CMD_WAITINT_Pos: u32 = 8;
pub const SDMMC_CMD_WAITINT_Msk: u32 = 256;
pub const SDMMC_CMD_WAITINT: u32 = 256;
pub const SDMMC_CMD_WAITPEND_Pos: u32 = 9;
pub const SDMMC_CMD_WAITPEND_Msk: u32 = 512;
pub const SDMMC_CMD_WAITPEND: u32 = 512;
pub const SDMMC_CMD_CPSMEN_Pos: u32 = 10;
pub const SDMMC_CMD_CPSMEN_Msk: u32 = 1024;
pub const SDMMC_CMD_CPSMEN: u32 = 1024;
pub const SDMMC_CMD_SDIOSUSPEND_Pos: u32 = 11;
pub const SDMMC_CMD_SDIOSUSPEND_Msk: u32 = 2048;
pub const SDMMC_CMD_SDIOSUSPEND: u32 = 2048;
pub const SDMMC_RESPCMD_RESPCMD_Pos: u32 = 0;
pub const SDMMC_RESPCMD_RESPCMD_Msk: u32 = 63;
pub const SDMMC_RESPCMD_RESPCMD: u32 = 63;
pub const SDMMC_RESP1_CARDSTATUS1_Pos: u32 = 0;
pub const SDMMC_RESP1_CARDSTATUS1_Msk: u32 = 4294967295;
pub const SDMMC_RESP1_CARDSTATUS1: u32 = 4294967295;
pub const SDMMC_RESP2_CARDSTATUS2_Pos: u32 = 0;
pub const SDMMC_RESP2_CARDSTATUS2_Msk: u32 = 4294967295;
pub const SDMMC_RESP2_CARDSTATUS2: u32 = 4294967295;
pub const SDMMC_RESP3_CARDSTATUS3_Pos: u32 = 0;
pub const SDMMC_RESP3_CARDSTATUS3_Msk: u32 = 4294967295;
pub const SDMMC_RESP3_CARDSTATUS3: u32 = 4294967295;
pub const SDMMC_RESP4_CARDSTATUS4_Pos: u32 = 0;
pub const SDMMC_RESP4_CARDSTATUS4_Msk: u32 = 4294967295;
pub const SDMMC_RESP4_CARDSTATUS4: u32 = 4294967295;
pub const SDMMC_DTIMER_DATATIME_Pos: u32 = 0;
pub const SDMMC_DTIMER_DATATIME_Msk: u32 = 4294967295;
pub const SDMMC_DTIMER_DATATIME: u32 = 4294967295;
pub const SDMMC_DLEN_DATALENGTH_Pos: u32 = 0;
pub const SDMMC_DLEN_DATALENGTH_Msk: u32 = 33554431;
pub const SDMMC_DLEN_DATALENGTH: u32 = 33554431;
pub const SDMMC_DCTRL_DTEN_Pos: u32 = 0;
pub const SDMMC_DCTRL_DTEN_Msk: u32 = 1;
pub const SDMMC_DCTRL_DTEN: u32 = 1;
pub const SDMMC_DCTRL_DTDIR_Pos: u32 = 1;
pub const SDMMC_DCTRL_DTDIR_Msk: u32 = 2;
pub const SDMMC_DCTRL_DTDIR: u32 = 2;
pub const SDMMC_DCTRL_DTMODE_Pos: u32 = 2;
pub const SDMMC_DCTRL_DTMODE_Msk: u32 = 4;
pub const SDMMC_DCTRL_DTMODE: u32 = 4;
pub const SDMMC_DCTRL_DMAEN_Pos: u32 = 3;
pub const SDMMC_DCTRL_DMAEN_Msk: u32 = 8;
pub const SDMMC_DCTRL_DMAEN: u32 = 8;
pub const SDMMC_DCTRL_DBLOCKSIZE_Pos: u32 = 4;
pub const SDMMC_DCTRL_DBLOCKSIZE_Msk: u32 = 240;
pub const SDMMC_DCTRL_DBLOCKSIZE: u32 = 240;
pub const SDMMC_DCTRL_DBLOCKSIZE_0: u32 = 16;
pub const SDMMC_DCTRL_DBLOCKSIZE_1: u32 = 32;
pub const SDMMC_DCTRL_DBLOCKSIZE_2: u32 = 64;
pub const SDMMC_DCTRL_DBLOCKSIZE_3: u32 = 128;
pub const SDMMC_DCTRL_RWSTART_Pos: u32 = 8;
pub const SDMMC_DCTRL_RWSTART_Msk: u32 = 256;
pub const SDMMC_DCTRL_RWSTART: u32 = 256;
pub const SDMMC_DCTRL_RWSTOP_Pos: u32 = 9;
pub const SDMMC_DCTRL_RWSTOP_Msk: u32 = 512;
pub const SDMMC_DCTRL_RWSTOP: u32 = 512;
pub const SDMMC_DCTRL_RWMOD_Pos: u32 = 10;
pub const SDMMC_DCTRL_RWMOD_Msk: u32 = 1024;
pub const SDMMC_DCTRL_RWMOD: u32 = 1024;
pub const SDMMC_DCTRL_SDIOEN_Pos: u32 = 11;
pub const SDMMC_DCTRL_SDIOEN_Msk: u32 = 2048;
pub const SDMMC_DCTRL_SDIOEN: u32 = 2048;
pub const SDMMC_DCOUNT_DATACOUNT_Pos: u32 = 0;
pub const SDMMC_DCOUNT_DATACOUNT_Msk: u32 = 33554431;
pub const SDMMC_DCOUNT_DATACOUNT: u32 = 33554431;
pub const SDMMC_STA_CCRCFAIL_Pos: u32 = 0;
pub const SDMMC_STA_CCRCFAIL_Msk: u32 = 1;
pub const SDMMC_STA_CCRCFAIL: u32 = 1;
pub const SDMMC_STA_DCRCFAIL_Pos: u32 = 1;
pub const SDMMC_STA_DCRCFAIL_Msk: u32 = 2;
pub const SDMMC_STA_DCRCFAIL: u32 = 2;
pub const SDMMC_STA_CTIMEOUT_Pos: u32 = 2;
pub const SDMMC_STA_CTIMEOUT_Msk: u32 = 4;
pub const SDMMC_STA_CTIMEOUT: u32 = 4;
pub const SDMMC_STA_DTIMEOUT_Pos: u32 = 3;
pub const SDMMC_STA_DTIMEOUT_Msk: u32 = 8;
pub const SDMMC_STA_DTIMEOUT: u32 = 8;
pub const SDMMC_STA_TXUNDERR_Pos: u32 = 4;
pub const SDMMC_STA_TXUNDERR_Msk: u32 = 16;
pub const SDMMC_STA_TXUNDERR: u32 = 16;
pub const SDMMC_STA_RXOVERR_Pos: u32 = 5;
pub const SDMMC_STA_RXOVERR_Msk: u32 = 32;
pub const SDMMC_STA_RXOVERR: u32 = 32;
pub const SDMMC_STA_CMDREND_Pos: u32 = 6;
pub const SDMMC_STA_CMDREND_Msk: u32 = 64;
pub const SDMMC_STA_CMDREND: u32 = 64;
pub const SDMMC_STA_CMDSENT_Pos: u32 = 7;
pub const SDMMC_STA_CMDSENT_Msk: u32 = 128;
pub const SDMMC_STA_CMDSENT: u32 = 128;
pub const SDMMC_STA_DATAEND_Pos: u32 = 8;
pub const SDMMC_STA_DATAEND_Msk: u32 = 256;
pub const SDMMC_STA_DATAEND: u32 = 256;
pub const SDMMC_STA_STBITERR_Pos: u32 = 9;
pub const SDMMC_STA_STBITERR_Msk: u32 = 512;
pub const SDMMC_STA_STBITERR: u32 = 512;
pub const SDMMC_STA_DBCKEND_Pos: u32 = 10;
pub const SDMMC_STA_DBCKEND_Msk: u32 = 1024;
pub const SDMMC_STA_DBCKEND: u32 = 1024;
pub const SDMMC_STA_CMDACT_Pos: u32 = 11;
pub const SDMMC_STA_CMDACT_Msk: u32 = 2048;
pub const SDMMC_STA_CMDACT: u32 = 2048;
pub const SDMMC_STA_TXACT_Pos: u32 = 12;
pub const SDMMC_STA_TXACT_Msk: u32 = 4096;
pub const SDMMC_STA_TXACT: u32 = 4096;
pub const SDMMC_STA_RXACT_Pos: u32 = 13;
pub const SDMMC_STA_RXACT_Msk: u32 = 8192;
pub const SDMMC_STA_RXACT: u32 = 8192;
pub const SDMMC_STA_TXFIFOHE_Pos: u32 = 14;
pub const SDMMC_STA_TXFIFOHE_Msk: u32 = 16384;
pub const SDMMC_STA_TXFIFOHE: u32 = 16384;
pub const SDMMC_STA_RXFIFOHF_Pos: u32 = 15;
pub const SDMMC_STA_RXFIFOHF_Msk: u32 = 32768;
pub const SDMMC_STA_RXFIFOHF: u32 = 32768;
pub const SDMMC_STA_TXFIFOF_Pos: u32 = 16;
pub const SDMMC_STA_TXFIFOF_Msk: u32 = 65536;
pub const SDMMC_STA_TXFIFOF: u32 = 65536;
pub const SDMMC_STA_RXFIFOF_Pos: u32 = 17;
pub const SDMMC_STA_RXFIFOF_Msk: u32 = 131072;
pub const SDMMC_STA_RXFIFOF: u32 = 131072;
pub const SDMMC_STA_TXFIFOE_Pos: u32 = 18;
pub const SDMMC_STA_TXFIFOE_Msk: u32 = 262144;
pub const SDMMC_STA_TXFIFOE: u32 = 262144;
pub const SDMMC_STA_RXFIFOE_Pos: u32 = 19;
pub const SDMMC_STA_RXFIFOE_Msk: u32 = 524288;
pub const SDMMC_STA_RXFIFOE: u32 = 524288;
pub const SDMMC_STA_TXDAVL_Pos: u32 = 20;
pub const SDMMC_STA_TXDAVL_Msk: u32 = 1048576;
pub const SDMMC_STA_TXDAVL: u32 = 1048576;
pub const SDMMC_STA_RXDAVL_Pos: u32 = 21;
pub const SDMMC_STA_RXDAVL_Msk: u32 = 2097152;
pub const SDMMC_STA_RXDAVL: u32 = 2097152;
pub const SDMMC_STA_SDIOIT_Pos: u32 = 22;
pub const SDMMC_STA_SDIOIT_Msk: u32 = 4194304;
pub const SDMMC_STA_SDIOIT: u32 = 4194304;
pub const SDMMC_ICR_CCRCFAILC_Pos: u32 = 0;
pub const SDMMC_ICR_CCRCFAILC_Msk: u32 = 1;
pub const SDMMC_ICR_CCRCFAILC: u32 = 1;
pub const SDMMC_ICR_DCRCFAILC_Pos: u32 = 1;
pub const SDMMC_ICR_DCRCFAILC_Msk: u32 = 2;
pub const SDMMC_ICR_DCRCFAILC: u32 = 2;
pub const SDMMC_ICR_CTIMEOUTC_Pos: u32 = 2;
pub const SDMMC_ICR_CTIMEOUTC_Msk: u32 = 4;
pub const SDMMC_ICR_CTIMEOUTC: u32 = 4;
pub const SDMMC_ICR_DTIMEOUTC_Pos: u32 = 3;
pub const SDMMC_ICR_DTIMEOUTC_Msk: u32 = 8;
pub const SDMMC_ICR_DTIMEOUTC: u32 = 8;
pub const SDMMC_ICR_TXUNDERRC_Pos: u32 = 4;
pub const SDMMC_ICR_TXUNDERRC_Msk: u32 = 16;
pub const SDMMC_ICR_TXUNDERRC: u32 = 16;
pub const SDMMC_ICR_RXOVERRC_Pos: u32 = 5;
pub const SDMMC_ICR_RXOVERRC_Msk: u32 = 32;
pub const SDMMC_ICR_RXOVERRC: u32 = 32;
pub const SDMMC_ICR_CMDRENDC_Pos: u32 = 6;
pub const SDMMC_ICR_CMDRENDC_Msk: u32 = 64;
pub const SDMMC_ICR_CMDRENDC: u32 = 64;
pub const SDMMC_ICR_CMDSENTC_Pos: u32 = 7;
pub const SDMMC_ICR_CMDSENTC_Msk: u32 = 128;
pub const SDMMC_ICR_CMDSENTC: u32 = 128;
pub const SDMMC_ICR_DATAENDC_Pos: u32 = 8;
pub const SDMMC_ICR_DATAENDC_Msk: u32 = 256;
pub const SDMMC_ICR_DATAENDC: u32 = 256;
pub const SDMMC_ICR_STBITERRC_Pos: u32 = 9;
pub const SDMMC_ICR_STBITERRC_Msk: u32 = 512;
pub const SDMMC_ICR_STBITERRC: u32 = 512;
pub const SDMMC_ICR_DBCKENDC_Pos: u32 = 10;
pub const SDMMC_ICR_DBCKENDC_Msk: u32 = 1024;
pub const SDMMC_ICR_DBCKENDC: u32 = 1024;
pub const SDMMC_ICR_SDIOITC_Pos: u32 = 22;
pub const SDMMC_ICR_SDIOITC_Msk: u32 = 4194304;
pub const SDMMC_ICR_SDIOITC: u32 = 4194304;
pub const SDMMC_MASK_CCRCFAILIE_Pos: u32 = 0;
pub const SDMMC_MASK_CCRCFAILIE_Msk: u32 = 1;
pub const SDMMC_MASK_CCRCFAILIE: u32 = 1;
pub const SDMMC_MASK_DCRCFAILIE_Pos: u32 = 1;
pub const SDMMC_MASK_DCRCFAILIE_Msk: u32 = 2;
pub const SDMMC_MASK_DCRCFAILIE: u32 = 2;
pub const SDMMC_MASK_CTIMEOUTIE_Pos: u32 = 2;
pub const SDMMC_MASK_CTIMEOUTIE_Msk: u32 = 4;
pub const SDMMC_MASK_CTIMEOUTIE: u32 = 4;
pub const SDMMC_MASK_DTIMEOUTIE_Pos: u32 = 3;
pub const SDMMC_MASK_DTIMEOUTIE_Msk: u32 = 8;
pub const SDMMC_MASK_DTIMEOUTIE: u32 = 8;
pub const SDMMC_MASK_TXUNDERRIE_Pos: u32 = 4;
pub const SDMMC_MASK_TXUNDERRIE_Msk: u32 = 16;
pub const SDMMC_MASK_TXUNDERRIE: u32 = 16;
pub const SDMMC_MASK_RXOVERRIE_Pos: u32 = 5;
pub const SDMMC_MASK_RXOVERRIE_Msk: u32 = 32;
pub const SDMMC_MASK_RXOVERRIE: u32 = 32;
pub const SDMMC_MASK_CMDRENDIE_Pos: u32 = 6;
pub const SDMMC_MASK_CMDRENDIE_Msk: u32 = 64;
pub const SDMMC_MASK_CMDRENDIE: u32 = 64;
pub const SDMMC_MASK_CMDSENTIE_Pos: u32 = 7;
pub const SDMMC_MASK_CMDSENTIE_Msk: u32 = 128;
pub const SDMMC_MASK_CMDSENTIE: u32 = 128;
pub const SDMMC_MASK_DATAENDIE_Pos: u32 = 8;
pub const SDMMC_MASK_DATAENDIE_Msk: u32 = 256;
pub const SDMMC_MASK_DATAENDIE: u32 = 256;
pub const SDMMC_MASK_DBCKENDIE_Pos: u32 = 10;
pub const SDMMC_MASK_DBCKENDIE_Msk: u32 = 1024;
pub const SDMMC_MASK_DBCKENDIE: u32 = 1024;
pub const SDMMC_MASK_CMDACTIE_Pos: u32 = 11;
pub const SDMMC_MASK_CMDACTIE_Msk: u32 = 2048;
pub const SDMMC_MASK_CMDACTIE: u32 = 2048;
pub const SDMMC_MASK_TXACTIE_Pos: u32 = 12;
pub const SDMMC_MASK_TXACTIE_Msk: u32 = 4096;
pub const SDMMC_MASK_TXACTIE: u32 = 4096;
pub const SDMMC_MASK_RXACTIE_Pos: u32 = 13;
pub const SDMMC_MASK_RXACTIE_Msk: u32 = 8192;
pub const SDMMC_MASK_RXACTIE: u32 = 8192;
pub const SDMMC_MASK_TXFIFOHEIE_Pos: u32 = 14;
pub const SDMMC_MASK_TXFIFOHEIE_Msk: u32 = 16384;
pub const SDMMC_MASK_TXFIFOHEIE: u32 = 16384;
pub const SDMMC_MASK_RXFIFOHFIE_Pos: u32 = 15;
pub const SDMMC_MASK_RXFIFOHFIE_Msk: u32 = 32768;
pub const SDMMC_MASK_RXFIFOHFIE: u32 = 32768;
pub const SDMMC_MASK_TXFIFOFIE_Pos: u32 = 16;
pub const SDMMC_MASK_TXFIFOFIE_Msk: u32 = 65536;
pub const SDMMC_MASK_TXFIFOFIE: u32 = 65536;
pub const SDMMC_MASK_RXFIFOFIE_Pos: u32 = 17;
pub const SDMMC_MASK_RXFIFOFIE_Msk: u32 = 131072;
pub const SDMMC_MASK_RXFIFOFIE: u32 = 131072;
pub const SDMMC_MASK_TXFIFOEIE_Pos: u32 = 18;
pub const SDMMC_MASK_TXFIFOEIE_Msk: u32 = 262144;
pub const SDMMC_MASK_TXFIFOEIE: u32 = 262144;
pub const SDMMC_MASK_RXFIFOEIE_Pos: u32 = 19;
pub const SDMMC_MASK_RXFIFOEIE_Msk: u32 = 524288;
pub const SDMMC_MASK_RXFIFOEIE: u32 = 524288;
pub const SDMMC_MASK_TXDAVLIE_Pos: u32 = 20;
pub const SDMMC_MASK_TXDAVLIE_Msk: u32 = 1048576;
pub const SDMMC_MASK_TXDAVLIE: u32 = 1048576;
pub const SDMMC_MASK_RXDAVLIE_Pos: u32 = 21;
pub const SDMMC_MASK_RXDAVLIE_Msk: u32 = 2097152;
pub const SDMMC_MASK_RXDAVLIE: u32 = 2097152;
pub const SDMMC_MASK_SDIOITIE_Pos: u32 = 22;
pub const SDMMC_MASK_SDIOITIE_Msk: u32 = 4194304;
pub const SDMMC_MASK_SDIOITIE: u32 = 4194304;
pub const SDMMC_FIFOCNT_FIFOCOUNT_Pos: u32 = 0;
pub const SDMMC_FIFOCNT_FIFOCOUNT_Msk: u32 = 16777215;
pub const SDMMC_FIFOCNT_FIFOCOUNT: u32 = 16777215;
pub const SDMMC_FIFO_FIFODATA_Pos: u32 = 0;
pub const SDMMC_FIFO_FIFODATA_Msk: u32 = 4294967295;
pub const SDMMC_FIFO_FIFODATA: u32 = 4294967295;
pub const SPI_CR1_CPHA_Pos: u32 = 0;
pub const SPI_CR1_CPHA_Msk: u32 = 1;
pub const SPI_CR1_CPHA: u32 = 1;
pub const SPI_CR1_CPOL_Pos: u32 = 1;
pub const SPI_CR1_CPOL_Msk: u32 = 2;
pub const SPI_CR1_CPOL: u32 = 2;
pub const SPI_CR1_MSTR_Pos: u32 = 2;
pub const SPI_CR1_MSTR_Msk: u32 = 4;
pub const SPI_CR1_MSTR: u32 = 4;
pub const SPI_CR1_BR_Pos: u32 = 3;
pub const SPI_CR1_BR_Msk: u32 = 56;
pub const SPI_CR1_BR: u32 = 56;
pub const SPI_CR1_BR_0: u32 = 8;
pub const SPI_CR1_BR_1: u32 = 16;
pub const SPI_CR1_BR_2: u32 = 32;
pub const SPI_CR1_SPE_Pos: u32 = 6;
pub const SPI_CR1_SPE_Msk: u32 = 64;
pub const SPI_CR1_SPE: u32 = 64;
pub const SPI_CR1_LSBFIRST_Pos: u32 = 7;
pub const SPI_CR1_LSBFIRST_Msk: u32 = 128;
pub const SPI_CR1_LSBFIRST: u32 = 128;
pub const SPI_CR1_SSI_Pos: u32 = 8;
pub const SPI_CR1_SSI_Msk: u32 = 256;
pub const SPI_CR1_SSI: u32 = 256;
pub const SPI_CR1_SSM_Pos: u32 = 9;
pub const SPI_CR1_SSM_Msk: u32 = 512;
pub const SPI_CR1_SSM: u32 = 512;
pub const SPI_CR1_RXONLY_Pos: u32 = 10;
pub const SPI_CR1_RXONLY_Msk: u32 = 1024;
pub const SPI_CR1_RXONLY: u32 = 1024;
pub const SPI_CR1_CRCL_Pos: u32 = 11;
pub const SPI_CR1_CRCL_Msk: u32 = 2048;
pub const SPI_CR1_CRCL: u32 = 2048;
pub const SPI_CR1_CRCNEXT_Pos: u32 = 12;
pub const SPI_CR1_CRCNEXT_Msk: u32 = 4096;
pub const SPI_CR1_CRCNEXT: u32 = 4096;
pub const SPI_CR1_CRCEN_Pos: u32 = 13;
pub const SPI_CR1_CRCEN_Msk: u32 = 8192;
pub const SPI_CR1_CRCEN: u32 = 8192;
pub const SPI_CR1_BIDIOE_Pos: u32 = 14;
pub const SPI_CR1_BIDIOE_Msk: u32 = 16384;
pub const SPI_CR1_BIDIOE: u32 = 16384;
pub const SPI_CR1_BIDIMODE_Pos: u32 = 15;
pub const SPI_CR1_BIDIMODE_Msk: u32 = 32768;
pub const SPI_CR1_BIDIMODE: u32 = 32768;
pub const SPI_CR2_RXDMAEN_Pos: u32 = 0;
pub const SPI_CR2_RXDMAEN_Msk: u32 = 1;
pub const SPI_CR2_RXDMAEN: u32 = 1;
pub const SPI_CR2_TXDMAEN_Pos: u32 = 1;
pub const SPI_CR2_TXDMAEN_Msk: u32 = 2;
pub const SPI_CR2_TXDMAEN: u32 = 2;
pub const SPI_CR2_SSOE_Pos: u32 = 2;
pub const SPI_CR2_SSOE_Msk: u32 = 4;
pub const SPI_CR2_SSOE: u32 = 4;
pub const SPI_CR2_NSSP_Pos: u32 = 3;
pub const SPI_CR2_NSSP_Msk: u32 = 8;
pub const SPI_CR2_NSSP: u32 = 8;
pub const SPI_CR2_FRF_Pos: u32 = 4;
pub const SPI_CR2_FRF_Msk: u32 = 16;
pub const SPI_CR2_FRF: u32 = 16;
pub const SPI_CR2_ERRIE_Pos: u32 = 5;
pub const SPI_CR2_ERRIE_Msk: u32 = 32;
pub const SPI_CR2_ERRIE: u32 = 32;
pub const SPI_CR2_RXNEIE_Pos: u32 = 6;
pub const SPI_CR2_RXNEIE_Msk: u32 = 64;
pub const SPI_CR2_RXNEIE: u32 = 64;
pub const SPI_CR2_TXEIE_Pos: u32 = 7;
pub const SPI_CR2_TXEIE_Msk: u32 = 128;
pub const SPI_CR2_TXEIE: u32 = 128;
pub const SPI_CR2_DS_Pos: u32 = 8;
pub const SPI_CR2_DS_Msk: u32 = 3840;
pub const SPI_CR2_DS: u32 = 3840;
pub const SPI_CR2_DS_0: u32 = 256;
pub const SPI_CR2_DS_1: u32 = 512;
pub const SPI_CR2_DS_2: u32 = 1024;
pub const SPI_CR2_DS_3: u32 = 2048;
pub const SPI_CR2_FRXTH_Pos: u32 = 12;
pub const SPI_CR2_FRXTH_Msk: u32 = 4096;
pub const SPI_CR2_FRXTH: u32 = 4096;
pub const SPI_CR2_LDMARX_Pos: u32 = 13;
pub const SPI_CR2_LDMARX_Msk: u32 = 8192;
pub const SPI_CR2_LDMARX: u32 = 8192;
pub const SPI_CR2_LDMATX_Pos: u32 = 14;
pub const SPI_CR2_LDMATX_Msk: u32 = 16384;
pub const SPI_CR2_LDMATX: u32 = 16384;
pub const SPI_SR_RXNE_Pos: u32 = 0;
pub const SPI_SR_RXNE_Msk: u32 = 1;
pub const SPI_SR_RXNE: u32 = 1;
pub const SPI_SR_TXE_Pos: u32 = 1;
pub const SPI_SR_TXE_Msk: u32 = 2;
pub const SPI_SR_TXE: u32 = 2;
pub const SPI_SR_CHSIDE_Pos: u32 = 2;
pub const SPI_SR_CHSIDE_Msk: u32 = 4;
pub const SPI_SR_CHSIDE: u32 = 4;
pub const SPI_SR_UDR_Pos: u32 = 3;
pub const SPI_SR_UDR_Msk: u32 = 8;
pub const SPI_SR_UDR: u32 = 8;
pub const SPI_SR_CRCERR_Pos: u32 = 4;
pub const SPI_SR_CRCERR_Msk: u32 = 16;
pub const SPI_SR_CRCERR: u32 = 16;
pub const SPI_SR_MODF_Pos: u32 = 5;
pub const SPI_SR_MODF_Msk: u32 = 32;
pub const SPI_SR_MODF: u32 = 32;
pub const SPI_SR_OVR_Pos: u32 = 6;
pub const SPI_SR_OVR_Msk: u32 = 64;
pub const SPI_SR_OVR: u32 = 64;
pub const SPI_SR_BSY_Pos: u32 = 7;
pub const SPI_SR_BSY_Msk: u32 = 128;
pub const SPI_SR_BSY: u32 = 128;
pub const SPI_SR_FRE_Pos: u32 = 8;
pub const SPI_SR_FRE_Msk: u32 = 256;
pub const SPI_SR_FRE: u32 = 256;
pub const SPI_SR_FRLVL_Pos: u32 = 9;
pub const SPI_SR_FRLVL_Msk: u32 = 1536;
pub const SPI_SR_FRLVL: u32 = 1536;
pub const SPI_SR_FRLVL_0: u32 = 512;
pub const SPI_SR_FRLVL_1: u32 = 1024;
pub const SPI_SR_FTLVL_Pos: u32 = 11;
pub const SPI_SR_FTLVL_Msk: u32 = 6144;
pub const SPI_SR_FTLVL: u32 = 6144;
pub const SPI_SR_FTLVL_0: u32 = 2048;
pub const SPI_SR_FTLVL_1: u32 = 4096;
pub const SPI_DR_DR_Pos: u32 = 0;
pub const SPI_DR_DR_Msk: u32 = 65535;
pub const SPI_DR_DR: u32 = 65535;
pub const SPI_CRCPR_CRCPOLY_Pos: u32 = 0;
pub const SPI_CRCPR_CRCPOLY_Msk: u32 = 65535;
pub const SPI_CRCPR_CRCPOLY: u32 = 65535;
pub const SPI_RXCRCR_RXCRC_Pos: u32 = 0;
pub const SPI_RXCRCR_RXCRC_Msk: u32 = 65535;
pub const SPI_RXCRCR_RXCRC: u32 = 65535;
pub const SPI_TXCRCR_TXCRC_Pos: u32 = 0;
pub const SPI_TXCRCR_TXCRC_Msk: u32 = 65535;
pub const SPI_TXCRCR_TXCRC: u32 = 65535;
pub const QUADSPI_CR_EN_Pos: u32 = 0;
pub const QUADSPI_CR_EN_Msk: u32 = 1;
pub const QUADSPI_CR_EN: u32 = 1;
pub const QUADSPI_CR_ABORT_Pos: u32 = 1;
pub const QUADSPI_CR_ABORT_Msk: u32 = 2;
pub const QUADSPI_CR_ABORT: u32 = 2;
pub const QUADSPI_CR_DMAEN_Pos: u32 = 2;
pub const QUADSPI_CR_DMAEN_Msk: u32 = 4;
pub const QUADSPI_CR_DMAEN: u32 = 4;
pub const QUADSPI_CR_TCEN_Pos: u32 = 3;
pub const QUADSPI_CR_TCEN_Msk: u32 = 8;
pub const QUADSPI_CR_TCEN: u32 = 8;
pub const QUADSPI_CR_SSHIFT_Pos: u32 = 4;
pub const QUADSPI_CR_SSHIFT_Msk: u32 = 16;
pub const QUADSPI_CR_SSHIFT: u32 = 16;
pub const QUADSPI_CR_FTHRES_Pos: u32 = 8;
pub const QUADSPI_CR_FTHRES_Msk: u32 = 3840;
pub const QUADSPI_CR_FTHRES: u32 = 3840;
pub const QUADSPI_CR_TEIE_Pos: u32 = 16;
pub const QUADSPI_CR_TEIE_Msk: u32 = 65536;
pub const QUADSPI_CR_TEIE: u32 = 65536;
pub const QUADSPI_CR_TCIE_Pos: u32 = 17;
pub const QUADSPI_CR_TCIE_Msk: u32 = 131072;
pub const QUADSPI_CR_TCIE: u32 = 131072;
pub const QUADSPI_CR_FTIE_Pos: u32 = 18;
pub const QUADSPI_CR_FTIE_Msk: u32 = 262144;
pub const QUADSPI_CR_FTIE: u32 = 262144;
pub const QUADSPI_CR_SMIE_Pos: u32 = 19;
pub const QUADSPI_CR_SMIE_Msk: u32 = 524288;
pub const QUADSPI_CR_SMIE: u32 = 524288;
pub const QUADSPI_CR_TOIE_Pos: u32 = 20;
pub const QUADSPI_CR_TOIE_Msk: u32 = 1048576;
pub const QUADSPI_CR_TOIE: u32 = 1048576;
pub const QUADSPI_CR_APMS_Pos: u32 = 22;
pub const QUADSPI_CR_APMS_Msk: u32 = 4194304;
pub const QUADSPI_CR_APMS: u32 = 4194304;
pub const QUADSPI_CR_PMM_Pos: u32 = 23;
pub const QUADSPI_CR_PMM_Msk: u32 = 8388608;
pub const QUADSPI_CR_PMM: u32 = 8388608;
pub const QUADSPI_CR_PRESCALER_Pos: u32 = 24;
pub const QUADSPI_CR_PRESCALER_Msk: u32 = 4278190080;
pub const QUADSPI_CR_PRESCALER: u32 = 4278190080;
pub const QUADSPI_DCR_CKMODE_Pos: u32 = 0;
pub const QUADSPI_DCR_CKMODE_Msk: u32 = 1;
pub const QUADSPI_DCR_CKMODE: u32 = 1;
pub const QUADSPI_DCR_CSHT_Pos: u32 = 8;
pub const QUADSPI_DCR_CSHT_Msk: u32 = 1792;
pub const QUADSPI_DCR_CSHT: u32 = 1792;
pub const QUADSPI_DCR_CSHT_0: u32 = 256;
pub const QUADSPI_DCR_CSHT_1: u32 = 512;
pub const QUADSPI_DCR_CSHT_2: u32 = 1024;
pub const QUADSPI_DCR_FSIZE_Pos: u32 = 16;
pub const QUADSPI_DCR_FSIZE_Msk: u32 = 2031616;
pub const QUADSPI_DCR_FSIZE: u32 = 2031616;
pub const QUADSPI_SR_TEF_Pos: u32 = 0;
pub const QUADSPI_SR_TEF_Msk: u32 = 1;
pub const QUADSPI_SR_TEF: u32 = 1;
pub const QUADSPI_SR_TCF_Pos: u32 = 1;
pub const QUADSPI_SR_TCF_Msk: u32 = 2;
pub const QUADSPI_SR_TCF: u32 = 2;
pub const QUADSPI_SR_FTF_Pos: u32 = 2;
pub const QUADSPI_SR_FTF_Msk: u32 = 4;
pub const QUADSPI_SR_FTF: u32 = 4;
pub const QUADSPI_SR_SMF_Pos: u32 = 3;
pub const QUADSPI_SR_SMF_Msk: u32 = 8;
pub const QUADSPI_SR_SMF: u32 = 8;
pub const QUADSPI_SR_TOF_Pos: u32 = 4;
pub const QUADSPI_SR_TOF_Msk: u32 = 16;
pub const QUADSPI_SR_TOF: u32 = 16;
pub const QUADSPI_SR_BUSY_Pos: u32 = 5;
pub const QUADSPI_SR_BUSY_Msk: u32 = 32;
pub const QUADSPI_SR_BUSY: u32 = 32;
pub const QUADSPI_SR_FLEVEL_Pos: u32 = 8;
pub const QUADSPI_SR_FLEVEL_Msk: u32 = 7936;
pub const QUADSPI_SR_FLEVEL: u32 = 7936;
pub const QUADSPI_FCR_CTEF_Pos: u32 = 0;
pub const QUADSPI_FCR_CTEF_Msk: u32 = 1;
pub const QUADSPI_FCR_CTEF: u32 = 1;
pub const QUADSPI_FCR_CTCF_Pos: u32 = 1;
pub const QUADSPI_FCR_CTCF_Msk: u32 = 2;
pub const QUADSPI_FCR_CTCF: u32 = 2;
pub const QUADSPI_FCR_CSMF_Pos: u32 = 3;
pub const QUADSPI_FCR_CSMF_Msk: u32 = 8;
pub const QUADSPI_FCR_CSMF: u32 = 8;
pub const QUADSPI_FCR_CTOF_Pos: u32 = 4;
pub const QUADSPI_FCR_CTOF_Msk: u32 = 16;
pub const QUADSPI_FCR_CTOF: u32 = 16;
pub const QUADSPI_DLR_DL_Pos: u32 = 0;
pub const QUADSPI_DLR_DL_Msk: u32 = 4294967295;
pub const QUADSPI_DLR_DL: u32 = 4294967295;
pub const QUADSPI_CCR_INSTRUCTION_Pos: u32 = 0;
pub const QUADSPI_CCR_INSTRUCTION_Msk: u32 = 255;
pub const QUADSPI_CCR_INSTRUCTION: u32 = 255;
pub const QUADSPI_CCR_IMODE_Pos: u32 = 8;
pub const QUADSPI_CCR_IMODE_Msk: u32 = 768;
pub const QUADSPI_CCR_IMODE: u32 = 768;
pub const QUADSPI_CCR_IMODE_0: u32 = 256;
pub const QUADSPI_CCR_IMODE_1: u32 = 512;
pub const QUADSPI_CCR_ADMODE_Pos: u32 = 10;
pub const QUADSPI_CCR_ADMODE_Msk: u32 = 3072;
pub const QUADSPI_CCR_ADMODE: u32 = 3072;
pub const QUADSPI_CCR_ADMODE_0: u32 = 1024;
pub const QUADSPI_CCR_ADMODE_1: u32 = 2048;
pub const QUADSPI_CCR_ADSIZE_Pos: u32 = 12;
pub const QUADSPI_CCR_ADSIZE_Msk: u32 = 12288;
pub const QUADSPI_CCR_ADSIZE: u32 = 12288;
pub const QUADSPI_CCR_ADSIZE_0: u32 = 4096;
pub const QUADSPI_CCR_ADSIZE_1: u32 = 8192;
pub const QUADSPI_CCR_ABMODE_Pos: u32 = 14;
pub const QUADSPI_CCR_ABMODE_Msk: u32 = 49152;
pub const QUADSPI_CCR_ABMODE: u32 = 49152;
pub const QUADSPI_CCR_ABMODE_0: u32 = 16384;
pub const QUADSPI_CCR_ABMODE_1: u32 = 32768;
pub const QUADSPI_CCR_ABSIZE_Pos: u32 = 16;
pub const QUADSPI_CCR_ABSIZE_Msk: u32 = 196608;
pub const QUADSPI_CCR_ABSIZE: u32 = 196608;
pub const QUADSPI_CCR_ABSIZE_0: u32 = 65536;
pub const QUADSPI_CCR_ABSIZE_1: u32 = 131072;
pub const QUADSPI_CCR_DCYC_Pos: u32 = 18;
pub const QUADSPI_CCR_DCYC_Msk: u32 = 8126464;
pub const QUADSPI_CCR_DCYC: u32 = 8126464;
pub const QUADSPI_CCR_DMODE_Pos: u32 = 24;
pub const QUADSPI_CCR_DMODE_Msk: u32 = 50331648;
pub const QUADSPI_CCR_DMODE: u32 = 50331648;
pub const QUADSPI_CCR_DMODE_0: u32 = 16777216;
pub const QUADSPI_CCR_DMODE_1: u32 = 33554432;
pub const QUADSPI_CCR_FMODE_Pos: u32 = 26;
pub const QUADSPI_CCR_FMODE_Msk: u32 = 201326592;
pub const QUADSPI_CCR_FMODE: u32 = 201326592;
pub const QUADSPI_CCR_FMODE_0: u32 = 67108864;
pub const QUADSPI_CCR_FMODE_1: u32 = 134217728;
pub const QUADSPI_CCR_SIOO_Pos: u32 = 28;
pub const QUADSPI_CCR_SIOO_Msk: u32 = 268435456;
pub const QUADSPI_CCR_SIOO: u32 = 268435456;
pub const QUADSPI_CCR_DDRM_Pos: u32 = 31;
pub const QUADSPI_CCR_DDRM_Msk: u32 = 2147483648;
pub const QUADSPI_CCR_DDRM: u32 = 2147483648;
pub const QUADSPI_AR_ADDRESS_Pos: u32 = 0;
pub const QUADSPI_AR_ADDRESS_Msk: u32 = 4294967295;
pub const QUADSPI_AR_ADDRESS: u32 = 4294967295;
pub const QUADSPI_ABR_ALTERNATE_Pos: u32 = 0;
pub const QUADSPI_ABR_ALTERNATE_Msk: u32 = 4294967295;
pub const QUADSPI_ABR_ALTERNATE: u32 = 4294967295;
pub const QUADSPI_DR_DATA_Pos: u32 = 0;
pub const QUADSPI_DR_DATA_Msk: u32 = 4294967295;
pub const QUADSPI_DR_DATA: u32 = 4294967295;
pub const QUADSPI_PSMKR_MASK_Pos: u32 = 0;
pub const QUADSPI_PSMKR_MASK_Msk: u32 = 4294967295;
pub const QUADSPI_PSMKR_MASK: u32 = 4294967295;
pub const QUADSPI_PSMAR_MATCH_Pos: u32 = 0;
pub const QUADSPI_PSMAR_MATCH_Msk: u32 = 4294967295;
pub const QUADSPI_PSMAR_MATCH: u32 = 4294967295;
pub const QUADSPI_PIR_INTERVAL_Pos: u32 = 0;
pub const QUADSPI_PIR_INTERVAL_Msk: u32 = 65535;
pub const QUADSPI_PIR_INTERVAL: u32 = 65535;
pub const QUADSPI_LPTR_TIMEOUT_Pos: u32 = 0;
pub const QUADSPI_LPTR_TIMEOUT_Msk: u32 = 65535;
pub const QUADSPI_LPTR_TIMEOUT: u32 = 65535;
pub const SYSCFG_MEMRMP_MEM_MODE_Pos: u32 = 0;
pub const SYSCFG_MEMRMP_MEM_MODE_Msk: u32 = 7;
pub const SYSCFG_MEMRMP_MEM_MODE: u32 = 7;
pub const SYSCFG_MEMRMP_MEM_MODE_0: u32 = 1;
pub const SYSCFG_MEMRMP_MEM_MODE_1: u32 = 2;
pub const SYSCFG_MEMRMP_MEM_MODE_2: u32 = 4;
pub const SYSCFG_MEMRMP_FB_MODE_Pos: u32 = 8;
pub const SYSCFG_MEMRMP_FB_MODE_Msk: u32 = 256;
pub const SYSCFG_MEMRMP_FB_MODE: u32 = 256;
pub const SYSCFG_CFGR1_FWDIS_Pos: u32 = 0;
pub const SYSCFG_CFGR1_FWDIS_Msk: u32 = 1;
pub const SYSCFG_CFGR1_FWDIS: u32 = 1;
pub const SYSCFG_CFGR1_BOOSTEN_Pos: u32 = 8;
pub const SYSCFG_CFGR1_BOOSTEN_Msk: u32 = 256;
pub const SYSCFG_CFGR1_BOOSTEN: u32 = 256;
pub const SYSCFG_CFGR1_I2C_PB6_FMP_Pos: u32 = 16;
pub const SYSCFG_CFGR1_I2C_PB6_FMP_Msk: u32 = 65536;
pub const SYSCFG_CFGR1_I2C_PB6_FMP: u32 = 65536;
pub const SYSCFG_CFGR1_I2C_PB7_FMP_Pos: u32 = 17;
pub const SYSCFG_CFGR1_I2C_PB7_FMP_Msk: u32 = 131072;
pub const SYSCFG_CFGR1_I2C_PB7_FMP: u32 = 131072;
pub const SYSCFG_CFGR1_I2C_PB8_FMP_Pos: u32 = 18;
pub const SYSCFG_CFGR1_I2C_PB8_FMP_Msk: u32 = 262144;
pub const SYSCFG_CFGR1_I2C_PB8_FMP: u32 = 262144;
pub const SYSCFG_CFGR1_I2C_PB9_FMP_Pos: u32 = 19;
pub const SYSCFG_CFGR1_I2C_PB9_FMP_Msk: u32 = 524288;
pub const SYSCFG_CFGR1_I2C_PB9_FMP: u32 = 524288;
pub const SYSCFG_CFGR1_I2C1_FMP_Pos: u32 = 20;
pub const SYSCFG_CFGR1_I2C1_FMP_Msk: u32 = 1048576;
pub const SYSCFG_CFGR1_I2C1_FMP: u32 = 1048576;
pub const SYSCFG_CFGR1_I2C2_FMP_Pos: u32 = 21;
pub const SYSCFG_CFGR1_I2C2_FMP_Msk: u32 = 2097152;
pub const SYSCFG_CFGR1_I2C2_FMP: u32 = 2097152;
pub const SYSCFG_CFGR1_I2C3_FMP_Pos: u32 = 22;
pub const SYSCFG_CFGR1_I2C3_FMP_Msk: u32 = 4194304;
pub const SYSCFG_CFGR1_I2C3_FMP: u32 = 4194304;
pub const SYSCFG_CFGR1_FPU_IE_0: u32 = 67108864;
pub const SYSCFG_CFGR1_FPU_IE_1: u32 = 134217728;
pub const SYSCFG_CFGR1_FPU_IE_2: u32 = 268435456;
pub const SYSCFG_CFGR1_FPU_IE_3: u32 = 536870912;
pub const SYSCFG_CFGR1_FPU_IE_4: u32 = 1073741824;
pub const SYSCFG_CFGR1_FPU_IE_5: u32 = 2147483648;
pub const SYSCFG_EXTICR1_EXTI0_Pos: u32 = 0;
pub const SYSCFG_EXTICR1_EXTI0_Msk: u32 = 7;
pub const SYSCFG_EXTICR1_EXTI0: u32 = 7;
pub const SYSCFG_EXTICR1_EXTI1_Pos: u32 = 4;
pub const SYSCFG_EXTICR1_EXTI1_Msk: u32 = 112;
pub const SYSCFG_EXTICR1_EXTI1: u32 = 112;
pub const SYSCFG_EXTICR1_EXTI2_Pos: u32 = 8;
pub const SYSCFG_EXTICR1_EXTI2_Msk: u32 = 1792;
pub const SYSCFG_EXTICR1_EXTI2: u32 = 1792;
pub const SYSCFG_EXTICR1_EXTI3_Pos: u32 = 12;
pub const SYSCFG_EXTICR1_EXTI3_Msk: u32 = 28672;
pub const SYSCFG_EXTICR1_EXTI3: u32 = 28672;
pub const SYSCFG_EXTICR1_EXTI0_PA: u32 = 0;
pub const SYSCFG_EXTICR1_EXTI0_PB: u32 = 1;
pub const SYSCFG_EXTICR1_EXTI0_PC: u32 = 2;
pub const SYSCFG_EXTICR1_EXTI0_PD: u32 = 3;
pub const SYSCFG_EXTICR1_EXTI0_PE: u32 = 4;
pub const SYSCFG_EXTICR1_EXTI0_PF: u32 = 5;
pub const SYSCFG_EXTICR1_EXTI0_PG: u32 = 6;
pub const SYSCFG_EXTICR1_EXTI0_PH: u32 = 7;
pub const SYSCFG_EXTICR1_EXTI1_PA: u32 = 0;
pub const SYSCFG_EXTICR1_EXTI1_PB: u32 = 16;
pub const SYSCFG_EXTICR1_EXTI1_PC: u32 = 32;
pub const SYSCFG_EXTICR1_EXTI1_PD: u32 = 48;
pub const SYSCFG_EXTICR1_EXTI1_PE: u32 = 64;
pub const SYSCFG_EXTICR1_EXTI1_PF: u32 = 80;
pub const SYSCFG_EXTICR1_EXTI1_PG: u32 = 96;
pub const SYSCFG_EXTICR1_EXTI1_PH: u32 = 112;
pub const SYSCFG_EXTICR1_EXTI2_PA: u32 = 0;
pub const SYSCFG_EXTICR1_EXTI2_PB: u32 = 256;
pub const SYSCFG_EXTICR1_EXTI2_PC: u32 = 512;
pub const SYSCFG_EXTICR1_EXTI2_PD: u32 = 768;
pub const SYSCFG_EXTICR1_EXTI2_PE: u32 = 1024;
pub const SYSCFG_EXTICR1_EXTI2_PF: u32 = 1280;
pub const SYSCFG_EXTICR1_EXTI2_PG: u32 = 1536;
pub const SYSCFG_EXTICR1_EXTI3_PA: u32 = 0;
pub const SYSCFG_EXTICR1_EXTI3_PB: u32 = 4096;
pub const SYSCFG_EXTICR1_EXTI3_PC: u32 = 8192;
pub const SYSCFG_EXTICR1_EXTI3_PD: u32 = 12288;
pub const SYSCFG_EXTICR1_EXTI3_PE: u32 = 16384;
pub const SYSCFG_EXTICR1_EXTI3_PF: u32 = 20480;
pub const SYSCFG_EXTICR1_EXTI3_PG: u32 = 24576;
pub const SYSCFG_EXTICR2_EXTI4_Pos: u32 = 0;
pub const SYSCFG_EXTICR2_EXTI4_Msk: u32 = 7;
pub const SYSCFG_EXTICR2_EXTI4: u32 = 7;
pub const SYSCFG_EXTICR2_EXTI5_Pos: u32 = 4;
pub const SYSCFG_EXTICR2_EXTI5_Msk: u32 = 112;
pub const SYSCFG_EXTICR2_EXTI5: u32 = 112;
pub const SYSCFG_EXTICR2_EXTI6_Pos: u32 = 8;
pub const SYSCFG_EXTICR2_EXTI6_Msk: u32 = 1792;
pub const SYSCFG_EXTICR2_EXTI6: u32 = 1792;
pub const SYSCFG_EXTICR2_EXTI7_Pos: u32 = 12;
pub const SYSCFG_EXTICR2_EXTI7_Msk: u32 = 28672;
pub const SYSCFG_EXTICR2_EXTI7: u32 = 28672;
pub const SYSCFG_EXTICR2_EXTI4_PA: u32 = 0;
pub const SYSCFG_EXTICR2_EXTI4_PB: u32 = 1;
pub const SYSCFG_EXTICR2_EXTI4_PC: u32 = 2;
pub const SYSCFG_EXTICR2_EXTI4_PD: u32 = 3;
pub const SYSCFG_EXTICR2_EXTI4_PE: u32 = 4;
pub const SYSCFG_EXTICR2_EXTI4_PF: u32 = 5;
pub const SYSCFG_EXTICR2_EXTI4_PG: u32 = 6;
pub const SYSCFG_EXTICR2_EXTI5_PA: u32 = 0;
pub const SYSCFG_EXTICR2_EXTI5_PB: u32 = 16;
pub const SYSCFG_EXTICR2_EXTI5_PC: u32 = 32;
pub const SYSCFG_EXTICR2_EXTI5_PD: u32 = 48;
pub const SYSCFG_EXTICR2_EXTI5_PE: u32 = 64;
pub const SYSCFG_EXTICR2_EXTI5_PF: u32 = 80;
pub const SYSCFG_EXTICR2_EXTI5_PG: u32 = 96;
pub const SYSCFG_EXTICR2_EXTI6_PA: u32 = 0;
pub const SYSCFG_EXTICR2_EXTI6_PB: u32 = 256;
pub const SYSCFG_EXTICR2_EXTI6_PC: u32 = 512;
pub const SYSCFG_EXTICR2_EXTI6_PD: u32 = 768;
pub const SYSCFG_EXTICR2_EXTI6_PE: u32 = 1024;
pub const SYSCFG_EXTICR2_EXTI6_PF: u32 = 1280;
pub const SYSCFG_EXTICR2_EXTI6_PG: u32 = 1536;
pub const SYSCFG_EXTICR2_EXTI7_PA: u32 = 0;
pub const SYSCFG_EXTICR2_EXTI7_PB: u32 = 4096;
pub const SYSCFG_EXTICR2_EXTI7_PC: u32 = 8192;
pub const SYSCFG_EXTICR2_EXTI7_PD: u32 = 12288;
pub const SYSCFG_EXTICR2_EXTI7_PE: u32 = 16384;
pub const SYSCFG_EXTICR2_EXTI7_PF: u32 = 20480;
pub const SYSCFG_EXTICR2_EXTI7_PG: u32 = 24576;
pub const SYSCFG_EXTICR3_EXTI8_Pos: u32 = 0;
pub const SYSCFG_EXTICR3_EXTI8_Msk: u32 = 7;
pub const SYSCFG_EXTICR3_EXTI8: u32 = 7;
pub const SYSCFG_EXTICR3_EXTI9_Pos: u32 = 4;
pub const SYSCFG_EXTICR3_EXTI9_Msk: u32 = 112;
pub const SYSCFG_EXTICR3_EXTI9: u32 = 112;
pub const SYSCFG_EXTICR3_EXTI10_Pos: u32 = 8;
pub const SYSCFG_EXTICR3_EXTI10_Msk: u32 = 1792;
pub const SYSCFG_EXTICR3_EXTI10: u32 = 1792;
pub const SYSCFG_EXTICR3_EXTI11_Pos: u32 = 12;
pub const SYSCFG_EXTICR3_EXTI11_Msk: u32 = 28672;
pub const SYSCFG_EXTICR3_EXTI11: u32 = 28672;
pub const SYSCFG_EXTICR3_EXTI8_PA: u32 = 0;
pub const SYSCFG_EXTICR3_EXTI8_PB: u32 = 1;
pub const SYSCFG_EXTICR3_EXTI8_PC: u32 = 2;
pub const SYSCFG_EXTICR3_EXTI8_PD: u32 = 3;
pub const SYSCFG_EXTICR3_EXTI8_PE: u32 = 4;
pub const SYSCFG_EXTICR3_EXTI8_PF: u32 = 5;
pub const SYSCFG_EXTICR3_EXTI8_PG: u32 = 6;
pub const SYSCFG_EXTICR3_EXTI9_PA: u32 = 0;
pub const SYSCFG_EXTICR3_EXTI9_PB: u32 = 16;
pub const SYSCFG_EXTICR3_EXTI9_PC: u32 = 32;
pub const SYSCFG_EXTICR3_EXTI9_PD: u32 = 48;
pub const SYSCFG_EXTICR3_EXTI9_PE: u32 = 64;
pub const SYSCFG_EXTICR3_EXTI9_PF: u32 = 80;
pub const SYSCFG_EXTICR3_EXTI9_PG: u32 = 96;
pub const SYSCFG_EXTICR3_EXTI10_PA: u32 = 0;
pub const SYSCFG_EXTICR3_EXTI10_PB: u32 = 256;
pub const SYSCFG_EXTICR3_EXTI10_PC: u32 = 512;
pub const SYSCFG_EXTICR3_EXTI10_PD: u32 = 768;
pub const SYSCFG_EXTICR3_EXTI10_PE: u32 = 1024;
pub const SYSCFG_EXTICR3_EXTI10_PF: u32 = 1280;
pub const SYSCFG_EXTICR3_EXTI10_PG: u32 = 1536;
pub const SYSCFG_EXTICR3_EXTI11_PA: u32 = 0;
pub const SYSCFG_EXTICR3_EXTI11_PB: u32 = 4096;
pub const SYSCFG_EXTICR3_EXTI11_PC: u32 = 8192;
pub const SYSCFG_EXTICR3_EXTI11_PD: u32 = 12288;
pub const SYSCFG_EXTICR3_EXTI11_PE: u32 = 16384;
pub const SYSCFG_EXTICR3_EXTI11_PF: u32 = 20480;
pub const SYSCFG_EXTICR3_EXTI11_PG: u32 = 24576;
pub const SYSCFG_EXTICR4_EXTI12_Pos: u32 = 0;
pub const SYSCFG_EXTICR4_EXTI12_Msk: u32 = 7;
pub const SYSCFG_EXTICR4_EXTI12: u32 = 7;
pub const SYSCFG_EXTICR4_EXTI13_Pos: u32 = 4;
pub const SYSCFG_EXTICR4_EXTI13_Msk: u32 = 112;
pub const SYSCFG_EXTICR4_EXTI13: u32 = 112;
pub const SYSCFG_EXTICR4_EXTI14_Pos: u32 = 8;
pub const SYSCFG_EXTICR4_EXTI14_Msk: u32 = 1792;
pub const SYSCFG_EXTICR4_EXTI14: u32 = 1792;
pub const SYSCFG_EXTICR4_EXTI15_Pos: u32 = 12;
pub const SYSCFG_EXTICR4_EXTI15_Msk: u32 = 28672;
pub const SYSCFG_EXTICR4_EXTI15: u32 = 28672;
pub const SYSCFG_EXTICR4_EXTI12_PA: u32 = 0;
pub const SYSCFG_EXTICR4_EXTI12_PB: u32 = 1;
pub const SYSCFG_EXTICR4_EXTI12_PC: u32 = 2;
pub const SYSCFG_EXTICR4_EXTI12_PD: u32 = 3;
pub const SYSCFG_EXTICR4_EXTI12_PE: u32 = 4;
pub const SYSCFG_EXTICR4_EXTI12_PF: u32 = 5;
pub const SYSCFG_EXTICR4_EXTI12_PG: u32 = 6;
pub const SYSCFG_EXTICR4_EXTI13_PA: u32 = 0;
pub const SYSCFG_EXTICR4_EXTI13_PB: u32 = 16;
pub const SYSCFG_EXTICR4_EXTI13_PC: u32 = 32;
pub const SYSCFG_EXTICR4_EXTI13_PD: u32 = 48;
pub const SYSCFG_EXTICR4_EXTI13_PE: u32 = 64;
pub const SYSCFG_EXTICR4_EXTI13_PF: u32 = 80;
pub const SYSCFG_EXTICR4_EXTI13_PG: u32 = 96;
pub const SYSCFG_EXTICR4_EXTI14_PA: u32 = 0;
pub const SYSCFG_EXTICR4_EXTI14_PB: u32 = 256;
pub const SYSCFG_EXTICR4_EXTI14_PC: u32 = 512;
pub const SYSCFG_EXTICR4_EXTI14_PD: u32 = 768;
pub const SYSCFG_EXTICR4_EXTI14_PE: u32 = 1024;
pub const SYSCFG_EXTICR4_EXTI14_PF: u32 = 1280;
pub const SYSCFG_EXTICR4_EXTI14_PG: u32 = 1536;
pub const SYSCFG_EXTICR4_EXTI15_PA: u32 = 0;
pub const SYSCFG_EXTICR4_EXTI15_PB: u32 = 4096;
pub const SYSCFG_EXTICR4_EXTI15_PC: u32 = 8192;
pub const SYSCFG_EXTICR4_EXTI15_PD: u32 = 12288;
pub const SYSCFG_EXTICR4_EXTI15_PE: u32 = 16384;
pub const SYSCFG_EXTICR4_EXTI15_PF: u32 = 20480;
pub const SYSCFG_EXTICR4_EXTI15_PG: u32 = 24576;
pub const SYSCFG_SCSR_SRAM2ER_Pos: u32 = 0;
pub const SYSCFG_SCSR_SRAM2ER_Msk: u32 = 1;
pub const SYSCFG_SCSR_SRAM2ER: u32 = 1;
pub const SYSCFG_SCSR_SRAM2BSY_Pos: u32 = 1;
pub const SYSCFG_SCSR_SRAM2BSY_Msk: u32 = 2;
pub const SYSCFG_SCSR_SRAM2BSY: u32 = 2;
pub const SYSCFG_CFGR2_CLL_Pos: u32 = 0;
pub const SYSCFG_CFGR2_CLL_Msk: u32 = 1;
pub const SYSCFG_CFGR2_CLL: u32 = 1;
pub const SYSCFG_CFGR2_SPL_Pos: u32 = 1;
pub const SYSCFG_CFGR2_SPL_Msk: u32 = 2;
pub const SYSCFG_CFGR2_SPL: u32 = 2;
pub const SYSCFG_CFGR2_PVDL_Pos: u32 = 2;
pub const SYSCFG_CFGR2_PVDL_Msk: u32 = 4;
pub const SYSCFG_CFGR2_PVDL: u32 = 4;
pub const SYSCFG_CFGR2_ECCL_Pos: u32 = 3;
pub const SYSCFG_CFGR2_ECCL_Msk: u32 = 8;
pub const SYSCFG_CFGR2_ECCL: u32 = 8;
pub const SYSCFG_CFGR2_SPF_Pos: u32 = 8;
pub const SYSCFG_CFGR2_SPF_Msk: u32 = 256;
pub const SYSCFG_CFGR2_SPF: u32 = 256;
pub const SYSCFG_SWPR_PAGE0_Pos: u32 = 0;
pub const SYSCFG_SWPR_PAGE0_Msk: u32 = 1;
pub const SYSCFG_SWPR_PAGE0: u32 = 1;
pub const SYSCFG_SWPR_PAGE1_Pos: u32 = 1;
pub const SYSCFG_SWPR_PAGE1_Msk: u32 = 2;
pub const SYSCFG_SWPR_PAGE1: u32 = 2;
pub const SYSCFG_SWPR_PAGE2_Pos: u32 = 2;
pub const SYSCFG_SWPR_PAGE2_Msk: u32 = 4;
pub const SYSCFG_SWPR_PAGE2: u32 = 4;
pub const SYSCFG_SWPR_PAGE3_Pos: u32 = 3;
pub const SYSCFG_SWPR_PAGE3_Msk: u32 = 8;
pub const SYSCFG_SWPR_PAGE3: u32 = 8;
pub const SYSCFG_SWPR_PAGE4_Pos: u32 = 4;
pub const SYSCFG_SWPR_PAGE4_Msk: u32 = 16;
pub const SYSCFG_SWPR_PAGE4: u32 = 16;
pub const SYSCFG_SWPR_PAGE5_Pos: u32 = 5;
pub const SYSCFG_SWPR_PAGE5_Msk: u32 = 32;
pub const SYSCFG_SWPR_PAGE5: u32 = 32;
pub const SYSCFG_SWPR_PAGE6_Pos: u32 = 6;
pub const SYSCFG_SWPR_PAGE6_Msk: u32 = 64;
pub const SYSCFG_SWPR_PAGE6: u32 = 64;
pub const SYSCFG_SWPR_PAGE7_Pos: u32 = 7;
pub const SYSCFG_SWPR_PAGE7_Msk: u32 = 128;
pub const SYSCFG_SWPR_PAGE7: u32 = 128;
pub const SYSCFG_SWPR_PAGE8_Pos: u32 = 8;
pub const SYSCFG_SWPR_PAGE8_Msk: u32 = 256;
pub const SYSCFG_SWPR_PAGE8: u32 = 256;
pub const SYSCFG_SWPR_PAGE9_Pos: u32 = 9;
pub const SYSCFG_SWPR_PAGE9_Msk: u32 = 512;
pub const SYSCFG_SWPR_PAGE9: u32 = 512;
pub const SYSCFG_SWPR_PAGE10_Pos: u32 = 10;
pub const SYSCFG_SWPR_PAGE10_Msk: u32 = 1024;
pub const SYSCFG_SWPR_PAGE10: u32 = 1024;
pub const SYSCFG_SWPR_PAGE11_Pos: u32 = 11;
pub const SYSCFG_SWPR_PAGE11_Msk: u32 = 2048;
pub const SYSCFG_SWPR_PAGE11: u32 = 2048;
pub const SYSCFG_SWPR_PAGE12_Pos: u32 = 12;
pub const SYSCFG_SWPR_PAGE12_Msk: u32 = 4096;
pub const SYSCFG_SWPR_PAGE12: u32 = 4096;
pub const SYSCFG_SWPR_PAGE13_Pos: u32 = 13;
pub const SYSCFG_SWPR_PAGE13_Msk: u32 = 8192;
pub const SYSCFG_SWPR_PAGE13: u32 = 8192;
pub const SYSCFG_SWPR_PAGE14_Pos: u32 = 14;
pub const SYSCFG_SWPR_PAGE14_Msk: u32 = 16384;
pub const SYSCFG_SWPR_PAGE14: u32 = 16384;
pub const SYSCFG_SWPR_PAGE15_Pos: u32 = 15;
pub const SYSCFG_SWPR_PAGE15_Msk: u32 = 32768;
pub const SYSCFG_SWPR_PAGE15: u32 = 32768;
pub const SYSCFG_SWPR_PAGE16_Pos: u32 = 16;
pub const SYSCFG_SWPR_PAGE16_Msk: u32 = 65536;
pub const SYSCFG_SWPR_PAGE16: u32 = 65536;
pub const SYSCFG_SWPR_PAGE17_Pos: u32 = 17;
pub const SYSCFG_SWPR_PAGE17_Msk: u32 = 131072;
pub const SYSCFG_SWPR_PAGE17: u32 = 131072;
pub const SYSCFG_SWPR_PAGE18_Pos: u32 = 18;
pub const SYSCFG_SWPR_PAGE18_Msk: u32 = 262144;
pub const SYSCFG_SWPR_PAGE18: u32 = 262144;
pub const SYSCFG_SWPR_PAGE19_Pos: u32 = 19;
pub const SYSCFG_SWPR_PAGE19_Msk: u32 = 524288;
pub const SYSCFG_SWPR_PAGE19: u32 = 524288;
pub const SYSCFG_SWPR_PAGE20_Pos: u32 = 20;
pub const SYSCFG_SWPR_PAGE20_Msk: u32 = 1048576;
pub const SYSCFG_SWPR_PAGE20: u32 = 1048576;
pub const SYSCFG_SWPR_PAGE21_Pos: u32 = 21;
pub const SYSCFG_SWPR_PAGE21_Msk: u32 = 2097152;
pub const SYSCFG_SWPR_PAGE21: u32 = 2097152;
pub const SYSCFG_SWPR_PAGE22_Pos: u32 = 22;
pub const SYSCFG_SWPR_PAGE22_Msk: u32 = 4194304;
pub const SYSCFG_SWPR_PAGE22: u32 = 4194304;
pub const SYSCFG_SWPR_PAGE23_Pos: u32 = 23;
pub const SYSCFG_SWPR_PAGE23_Msk: u32 = 8388608;
pub const SYSCFG_SWPR_PAGE23: u32 = 8388608;
pub const SYSCFG_SWPR_PAGE24_Pos: u32 = 24;
pub const SYSCFG_SWPR_PAGE24_Msk: u32 = 16777216;
pub const SYSCFG_SWPR_PAGE24: u32 = 16777216;
pub const SYSCFG_SWPR_PAGE25_Pos: u32 = 25;
pub const SYSCFG_SWPR_PAGE25_Msk: u32 = 33554432;
pub const SYSCFG_SWPR_PAGE25: u32 = 33554432;
pub const SYSCFG_SWPR_PAGE26_Pos: u32 = 26;
pub const SYSCFG_SWPR_PAGE26_Msk: u32 = 67108864;
pub const SYSCFG_SWPR_PAGE26: u32 = 67108864;
pub const SYSCFG_SWPR_PAGE27_Pos: u32 = 27;
pub const SYSCFG_SWPR_PAGE27_Msk: u32 = 134217728;
pub const SYSCFG_SWPR_PAGE27: u32 = 134217728;
pub const SYSCFG_SWPR_PAGE28_Pos: u32 = 28;
pub const SYSCFG_SWPR_PAGE28_Msk: u32 = 268435456;
pub const SYSCFG_SWPR_PAGE28: u32 = 268435456;
pub const SYSCFG_SWPR_PAGE29_Pos: u32 = 29;
pub const SYSCFG_SWPR_PAGE29_Msk: u32 = 536870912;
pub const SYSCFG_SWPR_PAGE29: u32 = 536870912;
pub const SYSCFG_SWPR_PAGE30_Pos: u32 = 30;
pub const SYSCFG_SWPR_PAGE30_Msk: u32 = 1073741824;
pub const SYSCFG_SWPR_PAGE30: u32 = 1073741824;
pub const SYSCFG_SWPR_PAGE31_Pos: u32 = 31;
pub const SYSCFG_SWPR_PAGE31_Msk: u32 = 2147483648;
pub const SYSCFG_SWPR_PAGE31: u32 = 2147483648;
pub const SYSCFG_SKR_KEY_Pos: u32 = 0;
pub const SYSCFG_SKR_KEY_Msk: u32 = 255;
pub const SYSCFG_SKR_KEY: u32 = 255;
pub const TIM_CR1_CEN_Pos: u32 = 0;
pub const TIM_CR1_CEN_Msk: u32 = 1;
pub const TIM_CR1_CEN: u32 = 1;
pub const TIM_CR1_UDIS_Pos: u32 = 1;
pub const TIM_CR1_UDIS_Msk: u32 = 2;
pub const TIM_CR1_UDIS: u32 = 2;
pub const TIM_CR1_URS_Pos: u32 = 2;
pub const TIM_CR1_URS_Msk: u32 = 4;
pub const TIM_CR1_URS: u32 = 4;
pub const TIM_CR1_OPM_Pos: u32 = 3;
pub const TIM_CR1_OPM_Msk: u32 = 8;
pub const TIM_CR1_OPM: u32 = 8;
pub const TIM_CR1_DIR_Pos: u32 = 4;
pub const TIM_CR1_DIR_Msk: u32 = 16;
pub const TIM_CR1_DIR: u32 = 16;
pub const TIM_CR1_CMS_Pos: u32 = 5;
pub const TIM_CR1_CMS_Msk: u32 = 96;
pub const TIM_CR1_CMS: u32 = 96;
pub const TIM_CR1_CMS_0: u32 = 32;
pub const TIM_CR1_CMS_1: u32 = 64;
pub const TIM_CR1_ARPE_Pos: u32 = 7;
pub const TIM_CR1_ARPE_Msk: u32 = 128;
pub const TIM_CR1_ARPE: u32 = 128;
pub const TIM_CR1_CKD_Pos: u32 = 8;
pub const TIM_CR1_CKD_Msk: u32 = 768;
pub const TIM_CR1_CKD: u32 = 768;
pub const TIM_CR1_CKD_0: u32 = 256;
pub const TIM_CR1_CKD_1: u32 = 512;
pub const TIM_CR1_UIFREMAP_Pos: u32 = 11;
pub const TIM_CR1_UIFREMAP_Msk: u32 = 2048;
pub const TIM_CR1_UIFREMAP: u32 = 2048;
pub const TIM_CR2_CCPC_Pos: u32 = 0;
pub const TIM_CR2_CCPC_Msk: u32 = 1;
pub const TIM_CR2_CCPC: u32 = 1;
pub const TIM_CR2_CCUS_Pos: u32 = 2;
pub const TIM_CR2_CCUS_Msk: u32 = 4;
pub const TIM_CR2_CCUS: u32 = 4;
pub const TIM_CR2_CCDS_Pos: u32 = 3;
pub const TIM_CR2_CCDS_Msk: u32 = 8;
pub const TIM_CR2_CCDS: u32 = 8;
pub const TIM_CR2_MMS_Pos: u32 = 4;
pub const TIM_CR2_MMS_Msk: u32 = 112;
pub const TIM_CR2_MMS: u32 = 112;
pub const TIM_CR2_MMS_0: u32 = 16;
pub const TIM_CR2_MMS_1: u32 = 32;
pub const TIM_CR2_MMS_2: u32 = 64;
pub const TIM_CR2_TI1S_Pos: u32 = 7;
pub const TIM_CR2_TI1S_Msk: u32 = 128;
pub const TIM_CR2_TI1S: u32 = 128;
pub const TIM_CR2_OIS1_Pos: u32 = 8;
pub const TIM_CR2_OIS1_Msk: u32 = 256;
pub const TIM_CR2_OIS1: u32 = 256;
pub const TIM_CR2_OIS1N_Pos: u32 = 9;
pub const TIM_CR2_OIS1N_Msk: u32 = 512;
pub const TIM_CR2_OIS1N: u32 = 512;
pub const TIM_CR2_OIS2_Pos: u32 = 10;
pub const TIM_CR2_OIS2_Msk: u32 = 1024;
pub const TIM_CR2_OIS2: u32 = 1024;
pub const TIM_CR2_OIS2N_Pos: u32 = 11;
pub const TIM_CR2_OIS2N_Msk: u32 = 2048;
pub const TIM_CR2_OIS2N: u32 = 2048;
pub const TIM_CR2_OIS3_Pos: u32 = 12;
pub const TIM_CR2_OIS3_Msk: u32 = 4096;
pub const TIM_CR2_OIS3: u32 = 4096;
pub const TIM_CR2_OIS3N_Pos: u32 = 13;
pub const TIM_CR2_OIS3N_Msk: u32 = 8192;
pub const TIM_CR2_OIS3N: u32 = 8192;
pub const TIM_CR2_OIS4_Pos: u32 = 14;
pub const TIM_CR2_OIS4_Msk: u32 = 16384;
pub const TIM_CR2_OIS4: u32 = 16384;
pub const TIM_CR2_OIS5_Pos: u32 = 16;
pub const TIM_CR2_OIS5_Msk: u32 = 65536;
pub const TIM_CR2_OIS5: u32 = 65536;
pub const TIM_CR2_OIS6_Pos: u32 = 18;
pub const TIM_CR2_OIS6_Msk: u32 = 262144;
pub const TIM_CR2_OIS6: u32 = 262144;
pub const TIM_CR2_MMS2_Pos: u32 = 20;
pub const TIM_CR2_MMS2_Msk: u32 = 15728640;
pub const TIM_CR2_MMS2: u32 = 15728640;
pub const TIM_CR2_MMS2_0: u32 = 1048576;
pub const TIM_CR2_MMS2_1: u32 = 2097152;
pub const TIM_CR2_MMS2_2: u32 = 4194304;
pub const TIM_CR2_MMS2_3: u32 = 8388608;
pub const TIM_SMCR_SMS_Pos: u32 = 0;
pub const TIM_SMCR_SMS_Msk: u32 = 65543;
pub const TIM_SMCR_SMS: u32 = 65543;
pub const TIM_SMCR_SMS_0: u32 = 1;
pub const TIM_SMCR_SMS_1: u32 = 2;
pub const TIM_SMCR_SMS_2: u32 = 4;
pub const TIM_SMCR_SMS_3: u32 = 65536;
pub const TIM_SMCR_OCCS_Pos: u32 = 3;
pub const TIM_SMCR_OCCS_Msk: u32 = 8;
pub const TIM_SMCR_OCCS: u32 = 8;
pub const TIM_SMCR_TS_Pos: u32 = 4;
pub const TIM_SMCR_TS_Msk: u32 = 112;
pub const TIM_SMCR_TS: u32 = 112;
pub const TIM_SMCR_TS_0: u32 = 16;
pub const TIM_SMCR_TS_1: u32 = 32;
pub const TIM_SMCR_TS_2: u32 = 64;
pub const TIM_SMCR_MSM_Pos: u32 = 7;
pub const TIM_SMCR_MSM_Msk: u32 = 128;
pub const TIM_SMCR_MSM: u32 = 128;
pub const TIM_SMCR_ETF_Pos: u32 = 8;
pub const TIM_SMCR_ETF_Msk: u32 = 3840;
pub const TIM_SMCR_ETF: u32 = 3840;
pub const TIM_SMCR_ETF_0: u32 = 256;
pub const TIM_SMCR_ETF_1: u32 = 512;
pub const TIM_SMCR_ETF_2: u32 = 1024;
pub const TIM_SMCR_ETF_3: u32 = 2048;
pub const TIM_SMCR_ETPS_Pos: u32 = 12;
pub const TIM_SMCR_ETPS_Msk: u32 = 12288;
pub const TIM_SMCR_ETPS: u32 = 12288;
pub const TIM_SMCR_ETPS_0: u32 = 4096;
pub const TIM_SMCR_ETPS_1: u32 = 8192;
pub const TIM_SMCR_ECE_Pos: u32 = 14;
pub const TIM_SMCR_ECE_Msk: u32 = 16384;
pub const TIM_SMCR_ECE: u32 = 16384;
pub const TIM_SMCR_ETP_Pos: u32 = 15;
pub const TIM_SMCR_ETP_Msk: u32 = 32768;
pub const TIM_SMCR_ETP: u32 = 32768;
pub const TIM_DIER_UIE_Pos: u32 = 0;
pub const TIM_DIER_UIE_Msk: u32 = 1;
pub const TIM_DIER_UIE: u32 = 1;
pub const TIM_DIER_CC1IE_Pos: u32 = 1;
pub const TIM_DIER_CC1IE_Msk: u32 = 2;
pub const TIM_DIER_CC1IE: u32 = 2;
pub const TIM_DIER_CC2IE_Pos: u32 = 2;
pub const TIM_DIER_CC2IE_Msk: u32 = 4;
pub const TIM_DIER_CC2IE: u32 = 4;
pub const TIM_DIER_CC3IE_Pos: u32 = 3;
pub const TIM_DIER_CC3IE_Msk: u32 = 8;
pub const TIM_DIER_CC3IE: u32 = 8;
pub const TIM_DIER_CC4IE_Pos: u32 = 4;
pub const TIM_DIER_CC4IE_Msk: u32 = 16;
pub const TIM_DIER_CC4IE: u32 = 16;
pub const TIM_DIER_COMIE_Pos: u32 = 5;
pub const TIM_DIER_COMIE_Msk: u32 = 32;
pub const TIM_DIER_COMIE: u32 = 32;
pub const TIM_DIER_TIE_Pos: u32 = 6;
pub const TIM_DIER_TIE_Msk: u32 = 64;
pub const TIM_DIER_TIE: u32 = 64;
pub const TIM_DIER_BIE_Pos: u32 = 7;
pub const TIM_DIER_BIE_Msk: u32 = 128;
pub const TIM_DIER_BIE: u32 = 128;
pub const TIM_DIER_UDE_Pos: u32 = 8;
pub const TIM_DIER_UDE_Msk: u32 = 256;
pub const TIM_DIER_UDE: u32 = 256;
pub const TIM_DIER_CC1DE_Pos: u32 = 9;
pub const TIM_DIER_CC1DE_Msk: u32 = 512;
pub const TIM_DIER_CC1DE: u32 = 512;
pub const TIM_DIER_CC2DE_Pos: u32 = 10;
pub const TIM_DIER_CC2DE_Msk: u32 = 1024;
pub const TIM_DIER_CC2DE: u32 = 1024;
pub const TIM_DIER_CC3DE_Pos: u32 = 11;
pub const TIM_DIER_CC3DE_Msk: u32 = 2048;
pub const TIM_DIER_CC3DE: u32 = 2048;
pub const TIM_DIER_CC4DE_Pos: u32 = 12;
pub const TIM_DIER_CC4DE_Msk: u32 = 4096;
pub const TIM_DIER_CC4DE: u32 = 4096;
pub const TIM_DIER_COMDE_Pos: u32 = 13;
pub const TIM_DIER_COMDE_Msk: u32 = 8192;
pub const TIM_DIER_COMDE: u32 = 8192;
pub const TIM_DIER_TDE_Pos: u32 = 14;
pub const TIM_DIER_TDE_Msk: u32 = 16384;
pub const TIM_DIER_TDE: u32 = 16384;
pub const TIM_SR_UIF_Pos: u32 = 0;
pub const TIM_SR_UIF_Msk: u32 = 1;
pub const TIM_SR_UIF: u32 = 1;
pub const TIM_SR_CC1IF_Pos: u32 = 1;
pub const TIM_SR_CC1IF_Msk: u32 = 2;
pub const TIM_SR_CC1IF: u32 = 2;
pub const TIM_SR_CC2IF_Pos: u32 = 2;
pub const TIM_SR_CC2IF_Msk: u32 = 4;
pub const TIM_SR_CC2IF: u32 = 4;
pub const TIM_SR_CC3IF_Pos: u32 = 3;
pub const TIM_SR_CC3IF_Msk: u32 = 8;
pub const TIM_SR_CC3IF: u32 = 8;
pub const TIM_SR_CC4IF_Pos: u32 = 4;
pub const TIM_SR_CC4IF_Msk: u32 = 16;
pub const TIM_SR_CC4IF: u32 = 16;
pub const TIM_SR_COMIF_Pos: u32 = 5;
pub const TIM_SR_COMIF_Msk: u32 = 32;
pub const TIM_SR_COMIF: u32 = 32;
pub const TIM_SR_TIF_Pos: u32 = 6;
pub const TIM_SR_TIF_Msk: u32 = 64;
pub const TIM_SR_TIF: u32 = 64;
pub const TIM_SR_BIF_Pos: u32 = 7;
pub const TIM_SR_BIF_Msk: u32 = 128;
pub const TIM_SR_BIF: u32 = 128;
pub const TIM_SR_B2IF_Pos: u32 = 8;
pub const TIM_SR_B2IF_Msk: u32 = 256;
pub const TIM_SR_B2IF: u32 = 256;
pub const TIM_SR_CC1OF_Pos: u32 = 9;
pub const TIM_SR_CC1OF_Msk: u32 = 512;
pub const TIM_SR_CC1OF: u32 = 512;
pub const TIM_SR_CC2OF_Pos: u32 = 10;
pub const TIM_SR_CC2OF_Msk: u32 = 1024;
pub const TIM_SR_CC2OF: u32 = 1024;
pub const TIM_SR_CC3OF_Pos: u32 = 11;
pub const TIM_SR_CC3OF_Msk: u32 = 2048;
pub const TIM_SR_CC3OF: u32 = 2048;
pub const TIM_SR_CC4OF_Pos: u32 = 12;
pub const TIM_SR_CC4OF_Msk: u32 = 4096;
pub const TIM_SR_CC4OF: u32 = 4096;
pub const TIM_SR_SBIF_Pos: u32 = 13;
pub const TIM_SR_SBIF_Msk: u32 = 8192;
pub const TIM_SR_SBIF: u32 = 8192;
pub const TIM_SR_CC5IF_Pos: u32 = 16;
pub const TIM_SR_CC5IF_Msk: u32 = 65536;
pub const TIM_SR_CC5IF: u32 = 65536;
pub const TIM_SR_CC6IF_Pos: u32 = 17;
pub const TIM_SR_CC6IF_Msk: u32 = 131072;
pub const TIM_SR_CC6IF: u32 = 131072;
pub const TIM_EGR_UG_Pos: u32 = 0;
pub const TIM_EGR_UG_Msk: u32 = 1;
pub const TIM_EGR_UG: u32 = 1;
pub const TIM_EGR_CC1G_Pos: u32 = 1;
pub const TIM_EGR_CC1G_Msk: u32 = 2;
pub const TIM_EGR_CC1G: u32 = 2;
pub const TIM_EGR_CC2G_Pos: u32 = 2;
pub const TIM_EGR_CC2G_Msk: u32 = 4;
pub const TIM_EGR_CC2G: u32 = 4;
pub const TIM_EGR_CC3G_Pos: u32 = 3;
pub const TIM_EGR_CC3G_Msk: u32 = 8;
pub const TIM_EGR_CC3G: u32 = 8;
pub const TIM_EGR_CC4G_Pos: u32 = 4;
pub const TIM_EGR_CC4G_Msk: u32 = 16;
pub const TIM_EGR_CC4G: u32 = 16;
pub const TIM_EGR_COMG_Pos: u32 = 5;
pub const TIM_EGR_COMG_Msk: u32 = 32;
pub const TIM_EGR_COMG: u32 = 32;
pub const TIM_EGR_TG_Pos: u32 = 6;
pub const TIM_EGR_TG_Msk: u32 = 64;
pub const TIM_EGR_TG: u32 = 64;
pub const TIM_EGR_BG_Pos: u32 = 7;
pub const TIM_EGR_BG_Msk: u32 = 128;
pub const TIM_EGR_BG: u32 = 128;
pub const TIM_EGR_B2G_Pos: u32 = 8;
pub const TIM_EGR_B2G_Msk: u32 = 256;
pub const TIM_EGR_B2G: u32 = 256;
pub const TIM_CCMR1_CC1S_Pos: u32 = 0;
pub const TIM_CCMR1_CC1S_Msk: u32 = 3;
pub const TIM_CCMR1_CC1S: u32 = 3;
pub const TIM_CCMR1_CC1S_0: u32 = 1;
pub const TIM_CCMR1_CC1S_1: u32 = 2;
pub const TIM_CCMR1_OC1FE_Pos: u32 = 2;
pub const TIM_CCMR1_OC1FE_Msk: u32 = 4;
pub const TIM_CCMR1_OC1FE: u32 = 4;
pub const TIM_CCMR1_OC1PE_Pos: u32 = 3;
pub const TIM_CCMR1_OC1PE_Msk: u32 = 8;
pub const TIM_CCMR1_OC1PE: u32 = 8;
pub const TIM_CCMR1_OC1M_Pos: u32 = 4;
pub const TIM_CCMR1_OC1M_Msk: u32 = 65648;
pub const TIM_CCMR1_OC1M: u32 = 65648;
pub const TIM_CCMR1_OC1M_0: u32 = 16;
pub const TIM_CCMR1_OC1M_1: u32 = 32;
pub const TIM_CCMR1_OC1M_2: u32 = 64;
pub const TIM_CCMR1_OC1M_3: u32 = 65536;
pub const TIM_CCMR1_OC1CE_Pos: u32 = 7;
pub const TIM_CCMR1_OC1CE_Msk: u32 = 128;
pub const TIM_CCMR1_OC1CE: u32 = 128;
pub const TIM_CCMR1_CC2S_Pos: u32 = 8;
pub const TIM_CCMR1_CC2S_Msk: u32 = 768;
pub const TIM_CCMR1_CC2S: u32 = 768;
pub const TIM_CCMR1_CC2S_0: u32 = 256;
pub const TIM_CCMR1_CC2S_1: u32 = 512;
pub const TIM_CCMR1_OC2FE_Pos: u32 = 10;
pub const TIM_CCMR1_OC2FE_Msk: u32 = 1024;
pub const TIM_CCMR1_OC2FE: u32 = 1024;
pub const TIM_CCMR1_OC2PE_Pos: u32 = 11;
pub const TIM_CCMR1_OC2PE_Msk: u32 = 2048;
pub const TIM_CCMR1_OC2PE: u32 = 2048;
pub const TIM_CCMR1_OC2M_Pos: u32 = 12;
pub const TIM_CCMR1_OC2M_Msk: u32 = 16805888;
pub const TIM_CCMR1_OC2M: u32 = 16805888;
pub const TIM_CCMR1_OC2M_0: u32 = 4096;
pub const TIM_CCMR1_OC2M_1: u32 = 8192;
pub const TIM_CCMR1_OC2M_2: u32 = 16384;
pub const TIM_CCMR1_OC2M_3: u32 = 16777216;
pub const TIM_CCMR1_OC2CE_Pos: u32 = 15;
pub const TIM_CCMR1_OC2CE_Msk: u32 = 32768;
pub const TIM_CCMR1_OC2CE: u32 = 32768;
pub const TIM_CCMR1_IC1PSC_Pos: u32 = 2;
pub const TIM_CCMR1_IC1PSC_Msk: u32 = 12;
pub const TIM_CCMR1_IC1PSC: u32 = 12;
pub const TIM_CCMR1_IC1PSC_0: u32 = 4;
pub const TIM_CCMR1_IC1PSC_1: u32 = 8;
pub const TIM_CCMR1_IC1F_Pos: u32 = 4;
pub const TIM_CCMR1_IC1F_Msk: u32 = 240;
pub const TIM_CCMR1_IC1F: u32 = 240;
pub const TIM_CCMR1_IC1F_0: u32 = 16;
pub const TIM_CCMR1_IC1F_1: u32 = 32;
pub const TIM_CCMR1_IC1F_2: u32 = 64;
pub const TIM_CCMR1_IC1F_3: u32 = 128;
pub const TIM_CCMR1_IC2PSC_Pos: u32 = 10;
pub const TIM_CCMR1_IC2PSC_Msk: u32 = 3072;
pub const TIM_CCMR1_IC2PSC: u32 = 3072;
pub const TIM_CCMR1_IC2PSC_0: u32 = 1024;
pub const TIM_CCMR1_IC2PSC_1: u32 = 2048;
pub const TIM_CCMR1_IC2F_Pos: u32 = 12;
pub const TIM_CCMR1_IC2F_Msk: u32 = 61440;
pub const TIM_CCMR1_IC2F: u32 = 61440;
pub const TIM_CCMR1_IC2F_0: u32 = 4096;
pub const TIM_CCMR1_IC2F_1: u32 = 8192;
pub const TIM_CCMR1_IC2F_2: u32 = 16384;
pub const TIM_CCMR1_IC2F_3: u32 = 32768;
pub const TIM_CCMR2_CC3S_Pos: u32 = 0;
pub const TIM_CCMR2_CC3S_Msk: u32 = 3;
pub const TIM_CCMR2_CC3S: u32 = 3;
pub const TIM_CCMR2_CC3S_0: u32 = 1;
pub const TIM_CCMR2_CC3S_1: u32 = 2;
pub const TIM_CCMR2_OC3FE_Pos: u32 = 2;
pub const TIM_CCMR2_OC3FE_Msk: u32 = 4;
pub const TIM_CCMR2_OC3FE: u32 = 4;
pub const TIM_CCMR2_OC3PE_Pos: u32 = 3;
pub const TIM_CCMR2_OC3PE_Msk: u32 = 8;
pub const TIM_CCMR2_OC3PE: u32 = 8;
pub const TIM_CCMR2_OC3M_Pos: u32 = 4;
pub const TIM_CCMR2_OC3M_Msk: u32 = 65648;
pub const TIM_CCMR2_OC3M: u32 = 65648;
pub const TIM_CCMR2_OC3M_0: u32 = 16;
pub const TIM_CCMR2_OC3M_1: u32 = 32;
pub const TIM_CCMR2_OC3M_2: u32 = 64;
pub const TIM_CCMR2_OC3M_3: u32 = 65536;
pub const TIM_CCMR2_OC3CE_Pos: u32 = 7;
pub const TIM_CCMR2_OC3CE_Msk: u32 = 128;
pub const TIM_CCMR2_OC3CE: u32 = 128;
pub const TIM_CCMR2_CC4S_Pos: u32 = 8;
pub const TIM_CCMR2_CC4S_Msk: u32 = 768;
pub const TIM_CCMR2_CC4S: u32 = 768;
pub const TIM_CCMR2_CC4S_0: u32 = 256;
pub const TIM_CCMR2_CC4S_1: u32 = 512;
pub const TIM_CCMR2_OC4FE_Pos: u32 = 10;
pub const TIM_CCMR2_OC4FE_Msk: u32 = 1024;
pub const TIM_CCMR2_OC4FE: u32 = 1024;
pub const TIM_CCMR2_OC4PE_Pos: u32 = 11;
pub const TIM_CCMR2_OC4PE_Msk: u32 = 2048;
pub const TIM_CCMR2_OC4PE: u32 = 2048;
pub const TIM_CCMR2_OC4M_Pos: u32 = 12;
pub const TIM_CCMR2_OC4M_Msk: u32 = 16805888;
pub const TIM_CCMR2_OC4M: u32 = 16805888;
pub const TIM_CCMR2_OC4M_0: u32 = 4096;
pub const TIM_CCMR2_OC4M_1: u32 = 8192;
pub const TIM_CCMR2_OC4M_2: u32 = 16384;
pub const TIM_CCMR2_OC4M_3: u32 = 16777216;
pub const TIM_CCMR2_OC4CE_Pos: u32 = 15;
pub const TIM_CCMR2_OC4CE_Msk: u32 = 32768;
pub const TIM_CCMR2_OC4CE: u32 = 32768;
pub const TIM_CCMR2_IC3PSC_Pos: u32 = 2;
pub const TIM_CCMR2_IC3PSC_Msk: u32 = 12;
pub const TIM_CCMR2_IC3PSC: u32 = 12;
pub const TIM_CCMR2_IC3PSC_0: u32 = 4;
pub const TIM_CCMR2_IC3PSC_1: u32 = 8;
pub const TIM_CCMR2_IC3F_Pos: u32 = 4;
pub const TIM_CCMR2_IC3F_Msk: u32 = 240;
pub const TIM_CCMR2_IC3F: u32 = 240;
pub const TIM_CCMR2_IC3F_0: u32 = 16;
pub const TIM_CCMR2_IC3F_1: u32 = 32;
pub const TIM_CCMR2_IC3F_2: u32 = 64;
pub const TIM_CCMR2_IC3F_3: u32 = 128;
pub const TIM_CCMR2_IC4PSC_Pos: u32 = 10;
pub const TIM_CCMR2_IC4PSC_Msk: u32 = 3072;
pub const TIM_CCMR2_IC4PSC: u32 = 3072;
pub const TIM_CCMR2_IC4PSC_0: u32 = 1024;
pub const TIM_CCMR2_IC4PSC_1: u32 = 2048;
pub const TIM_CCMR2_IC4F_Pos: u32 = 12;
pub const TIM_CCMR2_IC4F_Msk: u32 = 61440;
pub const TIM_CCMR2_IC4F: u32 = 61440;
pub const TIM_CCMR2_IC4F_0: u32 = 4096;
pub const TIM_CCMR2_IC4F_1: u32 = 8192;
pub const TIM_CCMR2_IC4F_2: u32 = 16384;
pub const TIM_CCMR2_IC4F_3: u32 = 32768;
pub const TIM_CCMR3_OC5FE_Pos: u32 = 2;
pub const TIM_CCMR3_OC5FE_Msk: u32 = 4;
pub const TIM_CCMR3_OC5FE: u32 = 4;
pub const TIM_CCMR3_OC5PE_Pos: u32 = 3;
pub const TIM_CCMR3_OC5PE_Msk: u32 = 8;
pub const TIM_CCMR3_OC5PE: u32 = 8;
pub const TIM_CCMR3_OC5M_Pos: u32 = 4;
pub const TIM_CCMR3_OC5M_Msk: u32 = 65648;
pub const TIM_CCMR3_OC5M: u32 = 65648;
pub const TIM_CCMR3_OC5M_0: u32 = 16;
pub const TIM_CCMR3_OC5M_1: u32 = 32;
pub const TIM_CCMR3_OC5M_2: u32 = 64;
pub const TIM_CCMR3_OC5M_3: u32 = 65536;
pub const TIM_CCMR3_OC5CE_Pos: u32 = 7;
pub const TIM_CCMR3_OC5CE_Msk: u32 = 128;
pub const TIM_CCMR3_OC5CE: u32 = 128;
pub const TIM_CCMR3_OC6FE_Pos: u32 = 10;
pub const TIM_CCMR3_OC6FE_Msk: u32 = 1024;
pub const TIM_CCMR3_OC6FE: u32 = 1024;
pub const TIM_CCMR3_OC6PE_Pos: u32 = 11;
pub const TIM_CCMR3_OC6PE_Msk: u32 = 2048;
pub const TIM_CCMR3_OC6PE: u32 = 2048;
pub const TIM_CCMR3_OC6M_Pos: u32 = 12;
pub const TIM_CCMR3_OC6M_Msk: u32 = 16805888;
pub const TIM_CCMR3_OC6M: u32 = 16805888;
pub const TIM_CCMR3_OC6M_0: u32 = 4096;
pub const TIM_CCMR3_OC6M_1: u32 = 8192;
pub const TIM_CCMR3_OC6M_2: u32 = 16384;
pub const TIM_CCMR3_OC6M_3: u32 = 16777216;
pub const TIM_CCMR3_OC6CE_Pos: u32 = 15;
pub const TIM_CCMR3_OC6CE_Msk: u32 = 32768;
pub const TIM_CCMR3_OC6CE: u32 = 32768;
pub const TIM_CCER_CC1E_Pos: u32 = 0;
pub const TIM_CCER_CC1E_Msk: u32 = 1;
pub const TIM_CCER_CC1E: u32 = 1;
pub const TIM_CCER_CC1P_Pos: u32 = 1;
pub const TIM_CCER_CC1P_Msk: u32 = 2;
pub const TIM_CCER_CC1P: u32 = 2;
pub const TIM_CCER_CC1NE_Pos: u32 = 2;
pub const TIM_CCER_CC1NE_Msk: u32 = 4;
pub const TIM_CCER_CC1NE: u32 = 4;
pub const TIM_CCER_CC1NP_Pos: u32 = 3;
pub const TIM_CCER_CC1NP_Msk: u32 = 8;
pub const TIM_CCER_CC1NP: u32 = 8;
pub const TIM_CCER_CC2E_Pos: u32 = 4;
pub const TIM_CCER_CC2E_Msk: u32 = 16;
pub const TIM_CCER_CC2E: u32 = 16;
pub const TIM_CCER_CC2P_Pos: u32 = 5;
pub const TIM_CCER_CC2P_Msk: u32 = 32;
pub const TIM_CCER_CC2P: u32 = 32;
pub const TIM_CCER_CC2NE_Pos: u32 = 6;
pub const TIM_CCER_CC2NE_Msk: u32 = 64;
pub const TIM_CCER_CC2NE: u32 = 64;
pub const TIM_CCER_CC2NP_Pos: u32 = 7;
pub const TIM_CCER_CC2NP_Msk: u32 = 128;
pub const TIM_CCER_CC2NP: u32 = 128;
pub const TIM_CCER_CC3E_Pos: u32 = 8;
pub const TIM_CCER_CC3E_Msk: u32 = 256;
pub const TIM_CCER_CC3E: u32 = 256;
pub const TIM_CCER_CC3P_Pos: u32 = 9;
pub const TIM_CCER_CC3P_Msk: u32 = 512;
pub const TIM_CCER_CC3P: u32 = 512;
pub const TIM_CCER_CC3NE_Pos: u32 = 10;
pub const TIM_CCER_CC3NE_Msk: u32 = 1024;
pub const TIM_CCER_CC3NE: u32 = 1024;
pub const TIM_CCER_CC3NP_Pos: u32 = 11;
pub const TIM_CCER_CC3NP_Msk: u32 = 2048;
pub const TIM_CCER_CC3NP: u32 = 2048;
pub const TIM_CCER_CC4E_Pos: u32 = 12;
pub const TIM_CCER_CC4E_Msk: u32 = 4096;
pub const TIM_CCER_CC4E: u32 = 4096;
pub const TIM_CCER_CC4P_Pos: u32 = 13;
pub const TIM_CCER_CC4P_Msk: u32 = 8192;
pub const TIM_CCER_CC4P: u32 = 8192;
pub const TIM_CCER_CC4NP_Pos: u32 = 15;
pub const TIM_CCER_CC4NP_Msk: u32 = 32768;
pub const TIM_CCER_CC4NP: u32 = 32768;
pub const TIM_CCER_CC5E_Pos: u32 = 16;
pub const TIM_CCER_CC5E_Msk: u32 = 65536;
pub const TIM_CCER_CC5E: u32 = 65536;
pub const TIM_CCER_CC5P_Pos: u32 = 17;
pub const TIM_CCER_CC5P_Msk: u32 = 131072;
pub const TIM_CCER_CC5P: u32 = 131072;
pub const TIM_CCER_CC6E_Pos: u32 = 20;
pub const TIM_CCER_CC6E_Msk: u32 = 1048576;
pub const TIM_CCER_CC6E: u32 = 1048576;
pub const TIM_CCER_CC6P_Pos: u32 = 21;
pub const TIM_CCER_CC6P_Msk: u32 = 2097152;
pub const TIM_CCER_CC6P: u32 = 2097152;
pub const TIM_CNT_CNT_Pos: u32 = 0;
pub const TIM_CNT_CNT_Msk: u32 = 4294967295;
pub const TIM_CNT_CNT: u32 = 4294967295;
pub const TIM_CNT_UIFCPY_Pos: u32 = 31;
pub const TIM_CNT_UIFCPY_Msk: u32 = 2147483648;
pub const TIM_CNT_UIFCPY: u32 = 2147483648;
pub const TIM_PSC_PSC_Pos: u32 = 0;
pub const TIM_PSC_PSC_Msk: u32 = 65535;
pub const TIM_PSC_PSC: u32 = 65535;
pub const TIM_ARR_ARR_Pos: u32 = 0;
pub const TIM_ARR_ARR_Msk: u32 = 4294967295;
pub const TIM_ARR_ARR: u32 = 4294967295;
pub const TIM_RCR_REP_Pos: u32 = 0;
pub const TIM_RCR_REP_Msk: u32 = 65535;
pub const TIM_RCR_REP: u32 = 65535;
pub const TIM_CCR1_CCR1_Pos: u32 = 0;
pub const TIM_CCR1_CCR1_Msk: u32 = 65535;
pub const TIM_CCR1_CCR1: u32 = 65535;
pub const TIM_CCR2_CCR2_Pos: u32 = 0;
pub const TIM_CCR2_CCR2_Msk: u32 = 65535;
pub const TIM_CCR2_CCR2: u32 = 65535;
pub const TIM_CCR3_CCR3_Pos: u32 = 0;
pub const TIM_CCR3_CCR3_Msk: u32 = 65535;
pub const TIM_CCR3_CCR3: u32 = 65535;
pub const TIM_CCR4_CCR4_Pos: u32 = 0;
pub const TIM_CCR4_CCR4_Msk: u32 = 65535;
pub const TIM_CCR4_CCR4: u32 = 65535;
pub const TIM_CCR5_CCR5_Pos: u32 = 0;
pub const TIM_CCR5_CCR5_Msk: u32 = 4294967295;
pub const TIM_CCR5_CCR5: u32 = 4294967295;
pub const TIM_CCR5_GC5C1_Pos: u32 = 29;
pub const TIM_CCR5_GC5C1_Msk: u32 = 536870912;
pub const TIM_CCR5_GC5C1: u32 = 536870912;
pub const TIM_CCR5_GC5C2_Pos: u32 = 30;
pub const TIM_CCR5_GC5C2_Msk: u32 = 1073741824;
pub const TIM_CCR5_GC5C2: u32 = 1073741824;
pub const TIM_CCR5_GC5C3_Pos: u32 = 31;
pub const TIM_CCR5_GC5C3_Msk: u32 = 2147483648;
pub const TIM_CCR5_GC5C3: u32 = 2147483648;
pub const TIM_CCR6_CCR6_Pos: u32 = 0;
pub const TIM_CCR6_CCR6_Msk: u32 = 65535;
pub const TIM_CCR6_CCR6: u32 = 65535;
pub const TIM_BDTR_DTG_Pos: u32 = 0;
pub const TIM_BDTR_DTG_Msk: u32 = 255;
pub const TIM_BDTR_DTG: u32 = 255;
pub const TIM_BDTR_DTG_0: u32 = 1;
pub const TIM_BDTR_DTG_1: u32 = 2;
pub const TIM_BDTR_DTG_2: u32 = 4;
pub const TIM_BDTR_DTG_3: u32 = 8;
pub const TIM_BDTR_DTG_4: u32 = 16;
pub const TIM_BDTR_DTG_5: u32 = 32;
pub const TIM_BDTR_DTG_6: u32 = 64;
pub const TIM_BDTR_DTG_7: u32 = 128;
pub const TIM_BDTR_LOCK_Pos: u32 = 8;
pub const TIM_BDTR_LOCK_Msk: u32 = 768;
pub const TIM_BDTR_LOCK: u32 = 768;
pub const TIM_BDTR_LOCK_0: u32 = 256;
pub const TIM_BDTR_LOCK_1: u32 = 512;
pub const TIM_BDTR_OSSI_Pos: u32 = 10;
pub const TIM_BDTR_OSSI_Msk: u32 = 1024;
pub const TIM_BDTR_OSSI: u32 = 1024;
pub const TIM_BDTR_OSSR_Pos: u32 = 11;
pub const TIM_BDTR_OSSR_Msk: u32 = 2048;
pub const TIM_BDTR_OSSR: u32 = 2048;
pub const TIM_BDTR_BKE_Pos: u32 = 12;
pub const TIM_BDTR_BKE_Msk: u32 = 4096;
pub const TIM_BDTR_BKE: u32 = 4096;
pub const TIM_BDTR_BKP_Pos: u32 = 13;
pub const TIM_BDTR_BKP_Msk: u32 = 8192;
pub const TIM_BDTR_BKP: u32 = 8192;
pub const TIM_BDTR_AOE_Pos: u32 = 14;
pub const TIM_BDTR_AOE_Msk: u32 = 16384;
pub const TIM_BDTR_AOE: u32 = 16384;
pub const TIM_BDTR_MOE_Pos: u32 = 15;
pub const TIM_BDTR_MOE_Msk: u32 = 32768;
pub const TIM_BDTR_MOE: u32 = 32768;
pub const TIM_BDTR_BKF_Pos: u32 = 16;
pub const TIM_BDTR_BKF_Msk: u32 = 983040;
pub const TIM_BDTR_BKF: u32 = 983040;
pub const TIM_BDTR_BK2F_Pos: u32 = 20;
pub const TIM_BDTR_BK2F_Msk: u32 = 15728640;
pub const TIM_BDTR_BK2F: u32 = 15728640;
pub const TIM_BDTR_BK2E_Pos: u32 = 24;
pub const TIM_BDTR_BK2E_Msk: u32 = 16777216;
pub const TIM_BDTR_BK2E: u32 = 16777216;
pub const TIM_BDTR_BK2P_Pos: u32 = 25;
pub const TIM_BDTR_BK2P_Msk: u32 = 33554432;
pub const TIM_BDTR_BK2P: u32 = 33554432;
pub const TIM_DCR_DBA_Pos: u32 = 0;
pub const TIM_DCR_DBA_Msk: u32 = 31;
pub const TIM_DCR_DBA: u32 = 31;
pub const TIM_DCR_DBA_0: u32 = 1;
pub const TIM_DCR_DBA_1: u32 = 2;
pub const TIM_DCR_DBA_2: u32 = 4;
pub const TIM_DCR_DBA_3: u32 = 8;
pub const TIM_DCR_DBA_4: u32 = 16;
pub const TIM_DCR_DBL_Pos: u32 = 8;
pub const TIM_DCR_DBL_Msk: u32 = 7936;
pub const TIM_DCR_DBL: u32 = 7936;
pub const TIM_DCR_DBL_0: u32 = 256;
pub const TIM_DCR_DBL_1: u32 = 512;
pub const TIM_DCR_DBL_2: u32 = 1024;
pub const TIM_DCR_DBL_3: u32 = 2048;
pub const TIM_DCR_DBL_4: u32 = 4096;
pub const TIM_DMAR_DMAB_Pos: u32 = 0;
pub const TIM_DMAR_DMAB_Msk: u32 = 65535;
pub const TIM_DMAR_DMAB: u32 = 65535;
pub const TIM1_OR1_ETR_ADC1_RMP_Pos: u32 = 0;
pub const TIM1_OR1_ETR_ADC1_RMP_Msk: u32 = 3;
pub const TIM1_OR1_ETR_ADC1_RMP: u32 = 3;
pub const TIM1_OR1_ETR_ADC1_RMP_0: u32 = 1;
pub const TIM1_OR1_ETR_ADC1_RMP_1: u32 = 2;
pub const TIM1_OR1_ETR_ADC3_RMP_Pos: u32 = 2;
pub const TIM1_OR1_ETR_ADC3_RMP_Msk: u32 = 12;
pub const TIM1_OR1_ETR_ADC3_RMP: u32 = 12;
pub const TIM1_OR1_ETR_ADC3_RMP_0: u32 = 4;
pub const TIM1_OR1_ETR_ADC3_RMP_1: u32 = 8;
pub const TIM1_OR1_TI1_RMP_Pos: u32 = 4;
pub const TIM1_OR1_TI1_RMP_Msk: u32 = 16;
pub const TIM1_OR1_TI1_RMP: u32 = 16;
pub const TIM1_OR2_BKINE_Pos: u32 = 0;
pub const TIM1_OR2_BKINE_Msk: u32 = 1;
pub const TIM1_OR2_BKINE: u32 = 1;
pub const TIM1_OR2_BKCMP1E_Pos: u32 = 1;
pub const TIM1_OR2_BKCMP1E_Msk: u32 = 2;
pub const TIM1_OR2_BKCMP1E: u32 = 2;
pub const TIM1_OR2_BKCMP2E_Pos: u32 = 2;
pub const TIM1_OR2_BKCMP2E_Msk: u32 = 4;
pub const TIM1_OR2_BKCMP2E: u32 = 4;
pub const TIM1_OR2_BKDF1BK0E_Pos: u32 = 8;
pub const TIM1_OR2_BKDF1BK0E_Msk: u32 = 256;
pub const TIM1_OR2_BKDF1BK0E: u32 = 256;
pub const TIM1_OR2_BKINP_Pos: u32 = 9;
pub const TIM1_OR2_BKINP_Msk: u32 = 512;
pub const TIM1_OR2_BKINP: u32 = 512;
pub const TIM1_OR2_BKCMP1P_Pos: u32 = 10;
pub const TIM1_OR2_BKCMP1P_Msk: u32 = 1024;
pub const TIM1_OR2_BKCMP1P: u32 = 1024;
pub const TIM1_OR2_BKCMP2P_Pos: u32 = 11;
pub const TIM1_OR2_BKCMP2P_Msk: u32 = 2048;
pub const TIM1_OR2_BKCMP2P: u32 = 2048;
pub const TIM1_OR2_ETRSEL_Pos: u32 = 14;
pub const TIM1_OR2_ETRSEL_Msk: u32 = 114688;
pub const TIM1_OR2_ETRSEL: u32 = 114688;
pub const TIM1_OR2_ETRSEL_0: u32 = 16384;
pub const TIM1_OR2_ETRSEL_1: u32 = 32768;
pub const TIM1_OR2_ETRSEL_2: u32 = 65536;
pub const TIM1_OR3_BK2INE_Pos: u32 = 0;
pub const TIM1_OR3_BK2INE_Msk: u32 = 1;
pub const TIM1_OR3_BK2INE: u32 = 1;
pub const TIM1_OR3_BK2CMP1E_Pos: u32 = 1;
pub const TIM1_OR3_BK2CMP1E_Msk: u32 = 2;
pub const TIM1_OR3_BK2CMP1E: u32 = 2;
pub const TIM1_OR3_BK2CMP2E_Pos: u32 = 2;
pub const TIM1_OR3_BK2CMP2E_Msk: u32 = 4;
pub const TIM1_OR3_BK2CMP2E: u32 = 4;
pub const TIM1_OR3_BK2DF1BK1E_Pos: u32 = 8;
pub const TIM1_OR3_BK2DF1BK1E_Msk: u32 = 256;
pub const TIM1_OR3_BK2DF1BK1E: u32 = 256;
pub const TIM1_OR3_BK2INP_Pos: u32 = 9;
pub const TIM1_OR3_BK2INP_Msk: u32 = 512;
pub const TIM1_OR3_BK2INP: u32 = 512;
pub const TIM1_OR3_BK2CMP1P_Pos: u32 = 10;
pub const TIM1_OR3_BK2CMP1P_Msk: u32 = 1024;
pub const TIM1_OR3_BK2CMP1P: u32 = 1024;
pub const TIM1_OR3_BK2CMP2P_Pos: u32 = 11;
pub const TIM1_OR3_BK2CMP2P_Msk: u32 = 2048;
pub const TIM1_OR3_BK2CMP2P: u32 = 2048;
pub const TIM8_OR1_ETR_ADC2_RMP_Pos: u32 = 0;
pub const TIM8_OR1_ETR_ADC2_RMP_Msk: u32 = 3;
pub const TIM8_OR1_ETR_ADC2_RMP: u32 = 3;
pub const TIM8_OR1_ETR_ADC2_RMP_0: u32 = 1;
pub const TIM8_OR1_ETR_ADC2_RMP_1: u32 = 2;
pub const TIM8_OR1_ETR_ADC3_RMP_Pos: u32 = 2;
pub const TIM8_OR1_ETR_ADC3_RMP_Msk: u32 = 12;
pub const TIM8_OR1_ETR_ADC3_RMP: u32 = 12;
pub const TIM8_OR1_ETR_ADC3_RMP_0: u32 = 4;
pub const TIM8_OR1_ETR_ADC3_RMP_1: u32 = 8;
pub const TIM8_OR1_TI1_RMP_Pos: u32 = 4;
pub const TIM8_OR1_TI1_RMP_Msk: u32 = 16;
pub const TIM8_OR1_TI1_RMP: u32 = 16;
pub const TIM8_OR2_BKINE_Pos: u32 = 0;
pub const TIM8_OR2_BKINE_Msk: u32 = 1;
pub const TIM8_OR2_BKINE: u32 = 1;
pub const TIM8_OR2_BKCMP1E_Pos: u32 = 1;
pub const TIM8_OR2_BKCMP1E_Msk: u32 = 2;
pub const TIM8_OR2_BKCMP1E: u32 = 2;
pub const TIM8_OR2_BKCMP2E_Pos: u32 = 2;
pub const TIM8_OR2_BKCMP2E_Msk: u32 = 4;
pub const TIM8_OR2_BKCMP2E: u32 = 4;
pub const TIM8_OR2_BKDF1BK2E_Pos: u32 = 8;
pub const TIM8_OR2_BKDF1BK2E_Msk: u32 = 256;
pub const TIM8_OR2_BKDF1BK2E: u32 = 256;
pub const TIM8_OR2_BKINP_Pos: u32 = 9;
pub const TIM8_OR2_BKINP_Msk: u32 = 512;
pub const TIM8_OR2_BKINP: u32 = 512;
pub const TIM8_OR2_BKCMP1P_Pos: u32 = 10;
pub const TIM8_OR2_BKCMP1P_Msk: u32 = 1024;
pub const TIM8_OR2_BKCMP1P: u32 = 1024;
pub const TIM8_OR2_BKCMP2P_Pos: u32 = 11;
pub const TIM8_OR2_BKCMP2P_Msk: u32 = 2048;
pub const TIM8_OR2_BKCMP2P: u32 = 2048;
pub const TIM8_OR2_ETRSEL_Pos: u32 = 14;
pub const TIM8_OR2_ETRSEL_Msk: u32 = 114688;
pub const TIM8_OR2_ETRSEL: u32 = 114688;
pub const TIM8_OR2_ETRSEL_0: u32 = 16384;
pub const TIM8_OR2_ETRSEL_1: u32 = 32768;
pub const TIM8_OR2_ETRSEL_2: u32 = 65536;
pub const TIM8_OR3_BK2INE_Pos: u32 = 0;
pub const TIM8_OR3_BK2INE_Msk: u32 = 1;
pub const TIM8_OR3_BK2INE: u32 = 1;
pub const TIM8_OR3_BK2CMP1E_Pos: u32 = 1;
pub const TIM8_OR3_BK2CMP1E_Msk: u32 = 2;
pub const TIM8_OR3_BK2CMP1E: u32 = 2;
pub const TIM8_OR3_BK2CMP2E_Pos: u32 = 2;
pub const TIM8_OR3_BK2CMP2E_Msk: u32 = 4;
pub const TIM8_OR3_BK2CMP2E: u32 = 4;
pub const TIM8_OR3_BK2DF1BK3E_Pos: u32 = 8;
pub const TIM8_OR3_BK2DF1BK3E_Msk: u32 = 256;
pub const TIM8_OR3_BK2DF1BK3E: u32 = 256;
pub const TIM8_OR3_BK2INP_Pos: u32 = 9;
pub const TIM8_OR3_BK2INP_Msk: u32 = 512;
pub const TIM8_OR3_BK2INP: u32 = 512;
pub const TIM8_OR3_BK2CMP1P_Pos: u32 = 10;
pub const TIM8_OR3_BK2CMP1P_Msk: u32 = 1024;
pub const TIM8_OR3_BK2CMP1P: u32 = 1024;
pub const TIM8_OR3_BK2CMP2P_Pos: u32 = 11;
pub const TIM8_OR3_BK2CMP2P_Msk: u32 = 2048;
pub const TIM8_OR3_BK2CMP2P: u32 = 2048;
pub const TIM2_OR1_ITR1_RMP_Pos: u32 = 0;
pub const TIM2_OR1_ITR1_RMP_Msk: u32 = 1;
pub const TIM2_OR1_ITR1_RMP: u32 = 1;
pub const TIM2_OR1_ETR1_RMP_Pos: u32 = 1;
pub const TIM2_OR1_ETR1_RMP_Msk: u32 = 2;
pub const TIM2_OR1_ETR1_RMP: u32 = 2;
pub const TIM2_OR1_TI4_RMP_Pos: u32 = 2;
pub const TIM2_OR1_TI4_RMP_Msk: u32 = 12;
pub const TIM2_OR1_TI4_RMP: u32 = 12;
pub const TIM2_OR1_TI4_RMP_0: u32 = 4;
pub const TIM2_OR1_TI4_RMP_1: u32 = 8;
pub const TIM2_OR2_ETRSEL_Pos: u32 = 14;
pub const TIM2_OR2_ETRSEL_Msk: u32 = 114688;
pub const TIM2_OR2_ETRSEL: u32 = 114688;
pub const TIM2_OR2_ETRSEL_0: u32 = 16384;
pub const TIM2_OR2_ETRSEL_1: u32 = 32768;
pub const TIM2_OR2_ETRSEL_2: u32 = 65536;
pub const TIM3_OR1_TI1_RMP_Pos: u32 = 0;
pub const TIM3_OR1_TI1_RMP_Msk: u32 = 3;
pub const TIM3_OR1_TI1_RMP: u32 = 3;
pub const TIM3_OR1_TI1_RMP_0: u32 = 1;
pub const TIM3_OR1_TI1_RMP_1: u32 = 2;
pub const TIM3_OR2_ETRSEL_Pos: u32 = 14;
pub const TIM3_OR2_ETRSEL_Msk: u32 = 114688;
pub const TIM3_OR2_ETRSEL: u32 = 114688;
pub const TIM3_OR2_ETRSEL_0: u32 = 16384;
pub const TIM3_OR2_ETRSEL_1: u32 = 32768;
pub const TIM3_OR2_ETRSEL_2: u32 = 65536;
pub const TIM15_OR1_TI1_RMP_Pos: u32 = 0;
pub const TIM15_OR1_TI1_RMP_Msk: u32 = 1;
pub const TIM15_OR1_TI1_RMP: u32 = 1;
pub const TIM15_OR1_ENCODER_MODE_Pos: u32 = 1;
pub const TIM15_OR1_ENCODER_MODE_Msk: u32 = 6;
pub const TIM15_OR1_ENCODER_MODE: u32 = 6;
pub const TIM15_OR1_ENCODER_MODE_0: u32 = 2;
pub const TIM15_OR1_ENCODER_MODE_1: u32 = 4;
pub const TIM15_OR2_BKINE_Pos: u32 = 0;
pub const TIM15_OR2_BKINE_Msk: u32 = 1;
pub const TIM15_OR2_BKINE: u32 = 1;
pub const TIM15_OR2_BKCMP1E_Pos: u32 = 1;
pub const TIM15_OR2_BKCMP1E_Msk: u32 = 2;
pub const TIM15_OR2_BKCMP1E: u32 = 2;
pub const TIM15_OR2_BKCMP2E_Pos: u32 = 2;
pub const TIM15_OR2_BKCMP2E_Msk: u32 = 4;
pub const TIM15_OR2_BKCMP2E: u32 = 4;
pub const TIM15_OR2_BKDF1BK0E_Pos: u32 = 8;
pub const TIM15_OR2_BKDF1BK0E_Msk: u32 = 256;
pub const TIM15_OR2_BKDF1BK0E: u32 = 256;
pub const TIM15_OR2_BKINP_Pos: u32 = 9;
pub const TIM15_OR2_BKINP_Msk: u32 = 512;
pub const TIM15_OR2_BKINP: u32 = 512;
pub const TIM15_OR2_BKCMP1P_Pos: u32 = 10;
pub const TIM15_OR2_BKCMP1P_Msk: u32 = 1024;
pub const TIM15_OR2_BKCMP1P: u32 = 1024;
pub const TIM15_OR2_BKCMP2P_Pos: u32 = 11;
pub const TIM15_OR2_BKCMP2P_Msk: u32 = 2048;
pub const TIM15_OR2_BKCMP2P: u32 = 2048;
pub const TIM16_OR1_TI1_RMP_Pos: u32 = 0;
pub const TIM16_OR1_TI1_RMP_Msk: u32 = 3;
pub const TIM16_OR1_TI1_RMP: u32 = 3;
pub const TIM16_OR1_TI1_RMP_0: u32 = 1;
pub const TIM16_OR1_TI1_RMP_1: u32 = 2;
pub const TIM16_OR2_BKINE_Pos: u32 = 0;
pub const TIM16_OR2_BKINE_Msk: u32 = 1;
pub const TIM16_OR2_BKINE: u32 = 1;
pub const TIM16_OR2_BKCMP1E_Pos: u32 = 1;
pub const TIM16_OR2_BKCMP1E_Msk: u32 = 2;
pub const TIM16_OR2_BKCMP1E: u32 = 2;
pub const TIM16_OR2_BKCMP2E_Pos: u32 = 2;
pub const TIM16_OR2_BKCMP2E_Msk: u32 = 4;
pub const TIM16_OR2_BKCMP2E: u32 = 4;
pub const TIM16_OR2_BKDF1BK1E_Pos: u32 = 8;
pub const TIM16_OR2_BKDF1BK1E_Msk: u32 = 256;
pub const TIM16_OR2_BKDF1BK1E: u32 = 256;
pub const TIM16_OR2_BKINP_Pos: u32 = 9;
pub const TIM16_OR2_BKINP_Msk: u32 = 512;
pub const TIM16_OR2_BKINP: u32 = 512;
pub const TIM16_OR2_BKCMP1P_Pos: u32 = 10;
pub const TIM16_OR2_BKCMP1P_Msk: u32 = 1024;
pub const TIM16_OR2_BKCMP1P: u32 = 1024;
pub const TIM16_OR2_BKCMP2P_Pos: u32 = 11;
pub const TIM16_OR2_BKCMP2P_Msk: u32 = 2048;
pub const TIM16_OR2_BKCMP2P: u32 = 2048;
pub const TIM17_OR1_TI1_RMP_Pos: u32 = 0;
pub const TIM17_OR1_TI1_RMP_Msk: u32 = 3;
pub const TIM17_OR1_TI1_RMP: u32 = 3;
pub const TIM17_OR1_TI1_RMP_0: u32 = 1;
pub const TIM17_OR1_TI1_RMP_1: u32 = 2;
pub const TIM17_OR2_BKINE_Pos: u32 = 0;
pub const TIM17_OR2_BKINE_Msk: u32 = 1;
pub const TIM17_OR2_BKINE: u32 = 1;
pub const TIM17_OR2_BKCMP1E_Pos: u32 = 1;
pub const TIM17_OR2_BKCMP1E_Msk: u32 = 2;
pub const TIM17_OR2_BKCMP1E: u32 = 2;
pub const TIM17_OR2_BKCMP2E_Pos: u32 = 2;
pub const TIM17_OR2_BKCMP2E_Msk: u32 = 4;
pub const TIM17_OR2_BKCMP2E: u32 = 4;
pub const TIM17_OR2_BKDF1BK2E_Pos: u32 = 8;
pub const TIM17_OR2_BKDF1BK2E_Msk: u32 = 256;
pub const TIM17_OR2_BKDF1BK2E: u32 = 256;
pub const TIM17_OR2_BKINP_Pos: u32 = 9;
pub const TIM17_OR2_BKINP_Msk: u32 = 512;
pub const TIM17_OR2_BKINP: u32 = 512;
pub const TIM17_OR2_BKCMP1P_Pos: u32 = 10;
pub const TIM17_OR2_BKCMP1P_Msk: u32 = 1024;
pub const TIM17_OR2_BKCMP1P: u32 = 1024;
pub const TIM17_OR2_BKCMP2P_Pos: u32 = 11;
pub const TIM17_OR2_BKCMP2P_Msk: u32 = 2048;
pub const TIM17_OR2_BKCMP2P: u32 = 2048;
pub const LPTIM_ISR_CMPM_Pos: u32 = 0;
pub const LPTIM_ISR_CMPM_Msk: u32 = 1;
pub const LPTIM_ISR_CMPM: u32 = 1;
pub const LPTIM_ISR_ARRM_Pos: u32 = 1;
pub const LPTIM_ISR_ARRM_Msk: u32 = 2;
pub const LPTIM_ISR_ARRM: u32 = 2;
pub const LPTIM_ISR_EXTTRIG_Pos: u32 = 2;
pub const LPTIM_ISR_EXTTRIG_Msk: u32 = 4;
pub const LPTIM_ISR_EXTTRIG: u32 = 4;
pub const LPTIM_ISR_CMPOK_Pos: u32 = 3;
pub const LPTIM_ISR_CMPOK_Msk: u32 = 8;
pub const LPTIM_ISR_CMPOK: u32 = 8;
pub const LPTIM_ISR_ARROK_Pos: u32 = 4;
pub const LPTIM_ISR_ARROK_Msk: u32 = 16;
pub const LPTIM_ISR_ARROK: u32 = 16;
pub const LPTIM_ISR_UP_Pos: u32 = 5;
pub const LPTIM_ISR_UP_Msk: u32 = 32;
pub const LPTIM_ISR_UP: u32 = 32;
pub const LPTIM_ISR_DOWN_Pos: u32 = 6;
pub const LPTIM_ISR_DOWN_Msk: u32 = 64;
pub const LPTIM_ISR_DOWN: u32 = 64;
pub const LPTIM_ICR_CMPMCF_Pos: u32 = 0;
pub const LPTIM_ICR_CMPMCF_Msk: u32 = 1;
pub const LPTIM_ICR_CMPMCF: u32 = 1;
pub const LPTIM_ICR_ARRMCF_Pos: u32 = 1;
pub const LPTIM_ICR_ARRMCF_Msk: u32 = 2;
pub const LPTIM_ICR_ARRMCF: u32 = 2;
pub const LPTIM_ICR_EXTTRIGCF_Pos: u32 = 2;
pub const LPTIM_ICR_EXTTRIGCF_Msk: u32 = 4;
pub const LPTIM_ICR_EXTTRIGCF: u32 = 4;
pub const LPTIM_ICR_CMPOKCF_Pos: u32 = 3;
pub const LPTIM_ICR_CMPOKCF_Msk: u32 = 8;
pub const LPTIM_ICR_CMPOKCF: u32 = 8;
pub const LPTIM_ICR_ARROKCF_Pos: u32 = 4;
pub const LPTIM_ICR_ARROKCF_Msk: u32 = 16;
pub const LPTIM_ICR_ARROKCF: u32 = 16;
pub const LPTIM_ICR_UPCF_Pos: u32 = 5;
pub const LPTIM_ICR_UPCF_Msk: u32 = 32;
pub const LPTIM_ICR_UPCF: u32 = 32;
pub const LPTIM_ICR_DOWNCF_Pos: u32 = 6;
pub const LPTIM_ICR_DOWNCF_Msk: u32 = 64;
pub const LPTIM_ICR_DOWNCF: u32 = 64;
pub const LPTIM_IER_CMPMIE_Pos: u32 = 0;
pub const LPTIM_IER_CMPMIE_Msk: u32 = 1;
pub const LPTIM_IER_CMPMIE: u32 = 1;
pub const LPTIM_IER_ARRMIE_Pos: u32 = 1;
pub const LPTIM_IER_ARRMIE_Msk: u32 = 2;
pub const LPTIM_IER_ARRMIE: u32 = 2;
pub const LPTIM_IER_EXTTRIGIE_Pos: u32 = 2;
pub const LPTIM_IER_EXTTRIGIE_Msk: u32 = 4;
pub const LPTIM_IER_EXTTRIGIE: u32 = 4;
pub const LPTIM_IER_CMPOKIE_Pos: u32 = 3;
pub const LPTIM_IER_CMPOKIE_Msk: u32 = 8;
pub const LPTIM_IER_CMPOKIE: u32 = 8;
pub const LPTIM_IER_ARROKIE_Pos: u32 = 4;
pub const LPTIM_IER_ARROKIE_Msk: u32 = 16;
pub const LPTIM_IER_ARROKIE: u32 = 16;
pub const LPTIM_IER_UPIE_Pos: u32 = 5;
pub const LPTIM_IER_UPIE_Msk: u32 = 32;
pub const LPTIM_IER_UPIE: u32 = 32;
pub const LPTIM_IER_DOWNIE_Pos: u32 = 6;
pub const LPTIM_IER_DOWNIE_Msk: u32 = 64;
pub const LPTIM_IER_DOWNIE: u32 = 64;
pub const LPTIM_CFGR_CKSEL_Pos: u32 = 0;
pub const LPTIM_CFGR_CKSEL_Msk: u32 = 1;
pub const LPTIM_CFGR_CKSEL: u32 = 1;
pub const LPTIM_CFGR_CKPOL_Pos: u32 = 1;
pub const LPTIM_CFGR_CKPOL_Msk: u32 = 6;
pub const LPTIM_CFGR_CKPOL: u32 = 6;
pub const LPTIM_CFGR_CKPOL_0: u32 = 2;
pub const LPTIM_CFGR_CKPOL_1: u32 = 4;
pub const LPTIM_CFGR_CKFLT_Pos: u32 = 3;
pub const LPTIM_CFGR_CKFLT_Msk: u32 = 24;
pub const LPTIM_CFGR_CKFLT: u32 = 24;
pub const LPTIM_CFGR_CKFLT_0: u32 = 8;
pub const LPTIM_CFGR_CKFLT_1: u32 = 16;
pub const LPTIM_CFGR_TRGFLT_Pos: u32 = 6;
pub const LPTIM_CFGR_TRGFLT_Msk: u32 = 192;
pub const LPTIM_CFGR_TRGFLT: u32 = 192;
pub const LPTIM_CFGR_TRGFLT_0: u32 = 64;
pub const LPTIM_CFGR_TRGFLT_1: u32 = 128;
pub const LPTIM_CFGR_PRESC_Pos: u32 = 9;
pub const LPTIM_CFGR_PRESC_Msk: u32 = 3584;
pub const LPTIM_CFGR_PRESC: u32 = 3584;
pub const LPTIM_CFGR_PRESC_0: u32 = 512;
pub const LPTIM_CFGR_PRESC_1: u32 = 1024;
pub const LPTIM_CFGR_PRESC_2: u32 = 2048;
pub const LPTIM_CFGR_TRIGSEL_Pos: u32 = 13;
pub const LPTIM_CFGR_TRIGSEL_Msk: u32 = 57344;
pub const LPTIM_CFGR_TRIGSEL: u32 = 57344;
pub const LPTIM_CFGR_TRIGSEL_0: u32 = 8192;
pub const LPTIM_CFGR_TRIGSEL_1: u32 = 16384;
pub const LPTIM_CFGR_TRIGSEL_2: u32 = 32768;
pub const LPTIM_CFGR_TRIGEN_Pos: u32 = 17;
pub const LPTIM_CFGR_TRIGEN_Msk: u32 = 393216;
pub const LPTIM_CFGR_TRIGEN: u32 = 393216;
pub const LPTIM_CFGR_TRIGEN_0: u32 = 131072;
pub const LPTIM_CFGR_TRIGEN_1: u32 = 262144;
pub const LPTIM_CFGR_TIMOUT_Pos: u32 = 19;
pub const LPTIM_CFGR_TIMOUT_Msk: u32 = 524288;
pub const LPTIM_CFGR_TIMOUT: u32 = 524288;
pub const LPTIM_CFGR_WAVE_Pos: u32 = 20;
pub const LPTIM_CFGR_WAVE_Msk: u32 = 1048576;
pub const LPTIM_CFGR_WAVE: u32 = 1048576;
pub const LPTIM_CFGR_WAVPOL_Pos: u32 = 21;
pub const LPTIM_CFGR_WAVPOL_Msk: u32 = 2097152;
pub const LPTIM_CFGR_WAVPOL: u32 = 2097152;
pub const LPTIM_CFGR_PRELOAD_Pos: u32 = 22;
pub const LPTIM_CFGR_PRELOAD_Msk: u32 = 4194304;
pub const LPTIM_CFGR_PRELOAD: u32 = 4194304;
pub const LPTIM_CFGR_COUNTMODE_Pos: u32 = 23;
pub const LPTIM_CFGR_COUNTMODE_Msk: u32 = 8388608;
pub const LPTIM_CFGR_COUNTMODE: u32 = 8388608;
pub const LPTIM_CFGR_ENC_Pos: u32 = 24;
pub const LPTIM_CFGR_ENC_Msk: u32 = 16777216;
pub const LPTIM_CFGR_ENC: u32 = 16777216;
pub const LPTIM_CR_ENABLE_Pos: u32 = 0;
pub const LPTIM_CR_ENABLE_Msk: u32 = 1;
pub const LPTIM_CR_ENABLE: u32 = 1;
pub const LPTIM_CR_SNGSTRT_Pos: u32 = 1;
pub const LPTIM_CR_SNGSTRT_Msk: u32 = 2;
pub const LPTIM_CR_SNGSTRT: u32 = 2;
pub const LPTIM_CR_CNTSTRT_Pos: u32 = 2;
pub const LPTIM_CR_CNTSTRT_Msk: u32 = 4;
pub const LPTIM_CR_CNTSTRT: u32 = 4;
pub const LPTIM_CMP_CMP_Pos: u32 = 0;
pub const LPTIM_CMP_CMP_Msk: u32 = 65535;
pub const LPTIM_CMP_CMP: u32 = 65535;
pub const LPTIM_ARR_ARR_Pos: u32 = 0;
pub const LPTIM_ARR_ARR_Msk: u32 = 65535;
pub const LPTIM_ARR_ARR: u32 = 65535;
pub const LPTIM_CNT_CNT_Pos: u32 = 0;
pub const LPTIM_CNT_CNT_Msk: u32 = 65535;
pub const LPTIM_CNT_CNT: u32 = 65535;
pub const LPTIM_OR_OR_Pos: u32 = 0;
pub const LPTIM_OR_OR_Msk: u32 = 3;
pub const LPTIM_OR_OR: u32 = 3;
pub const LPTIM_OR_OR_0: u32 = 1;
pub const LPTIM_OR_OR_1: u32 = 2;
pub const COMP_CSR_EN_Pos: u32 = 0;
pub const COMP_CSR_EN_Msk: u32 = 1;
pub const COMP_CSR_EN: u32 = 1;
pub const COMP_CSR_PWRMODE_Pos: u32 = 2;
pub const COMP_CSR_PWRMODE_Msk: u32 = 12;
pub const COMP_CSR_PWRMODE: u32 = 12;
pub const COMP_CSR_PWRMODE_0: u32 = 4;
pub const COMP_CSR_PWRMODE_1: u32 = 8;
pub const COMP_CSR_INMSEL_Pos: u32 = 4;
pub const COMP_CSR_INMSEL_Msk: u32 = 112;
pub const COMP_CSR_INMSEL: u32 = 112;
pub const COMP_CSR_INMSEL_0: u32 = 16;
pub const COMP_CSR_INMSEL_1: u32 = 32;
pub const COMP_CSR_INMSEL_2: u32 = 64;
pub const COMP_CSR_INPSEL_Pos: u32 = 7;
pub const COMP_CSR_INPSEL_Msk: u32 = 128;
pub const COMP_CSR_INPSEL: u32 = 128;
pub const COMP_CSR_INPSEL_0: u32 = 128;
pub const COMP_CSR_WINMODE_Pos: u32 = 9;
pub const COMP_CSR_WINMODE_Msk: u32 = 512;
pub const COMP_CSR_WINMODE: u32 = 512;
pub const COMP_CSR_POLARITY_Pos: u32 = 15;
pub const COMP_CSR_POLARITY_Msk: u32 = 32768;
pub const COMP_CSR_POLARITY: u32 = 32768;
pub const COMP_CSR_HYST_Pos: u32 = 16;
pub const COMP_CSR_HYST_Msk: u32 = 196608;
pub const COMP_CSR_HYST: u32 = 196608;
pub const COMP_CSR_HYST_0: u32 = 65536;
pub const COMP_CSR_HYST_1: u32 = 131072;
pub const COMP_CSR_BLANKING_Pos: u32 = 18;
pub const COMP_CSR_BLANKING_Msk: u32 = 1835008;
pub const COMP_CSR_BLANKING: u32 = 1835008;
pub const COMP_CSR_BLANKING_0: u32 = 262144;
pub const COMP_CSR_BLANKING_1: u32 = 524288;
pub const COMP_CSR_BLANKING_2: u32 = 1048576;
pub const COMP_CSR_BRGEN_Pos: u32 = 22;
pub const COMP_CSR_BRGEN_Msk: u32 = 4194304;
pub const COMP_CSR_BRGEN: u32 = 4194304;
pub const COMP_CSR_SCALEN_Pos: u32 = 23;
pub const COMP_CSR_SCALEN_Msk: u32 = 8388608;
pub const COMP_CSR_SCALEN: u32 = 8388608;
pub const COMP_CSR_VALUE_Pos: u32 = 30;
pub const COMP_CSR_VALUE_Msk: u32 = 1073741824;
pub const COMP_CSR_VALUE: u32 = 1073741824;
pub const COMP_CSR_LOCK_Pos: u32 = 31;
pub const COMP_CSR_LOCK_Msk: u32 = 2147483648;
pub const COMP_CSR_LOCK: u32 = 2147483648;
pub const OPAMP_CSR_OPAMPxEN_Pos: u32 = 0;
pub const OPAMP_CSR_OPAMPxEN_Msk: u32 = 1;
pub const OPAMP_CSR_OPAMPxEN: u32 = 1;
pub const OPAMP_CSR_OPALPM_Pos: u32 = 1;
pub const OPAMP_CSR_OPALPM_Msk: u32 = 2;
pub const OPAMP_CSR_OPALPM: u32 = 2;
pub const OPAMP_CSR_OPAMODE_Pos: u32 = 2;
pub const OPAMP_CSR_OPAMODE_Msk: u32 = 12;
pub const OPAMP_CSR_OPAMODE: u32 = 12;
pub const OPAMP_CSR_OPAMODE_0: u32 = 4;
pub const OPAMP_CSR_OPAMODE_1: u32 = 8;
pub const OPAMP_CSR_PGGAIN_Pos: u32 = 4;
pub const OPAMP_CSR_PGGAIN_Msk: u32 = 48;
pub const OPAMP_CSR_PGGAIN: u32 = 48;
pub const OPAMP_CSR_PGGAIN_0: u32 = 16;
pub const OPAMP_CSR_PGGAIN_1: u32 = 32;
pub const OPAMP_CSR_VMSEL_Pos: u32 = 8;
pub const OPAMP_CSR_VMSEL_Msk: u32 = 768;
pub const OPAMP_CSR_VMSEL: u32 = 768;
pub const OPAMP_CSR_VMSEL_0: u32 = 256;
pub const OPAMP_CSR_VMSEL_1: u32 = 512;
pub const OPAMP_CSR_VPSEL_Pos: u32 = 10;
pub const OPAMP_CSR_VPSEL_Msk: u32 = 1024;
pub const OPAMP_CSR_VPSEL: u32 = 1024;
pub const OPAMP_CSR_CALON_Pos: u32 = 12;
pub const OPAMP_CSR_CALON_Msk: u32 = 4096;
pub const OPAMP_CSR_CALON: u32 = 4096;
pub const OPAMP_CSR_CALSEL_Pos: u32 = 13;
pub const OPAMP_CSR_CALSEL_Msk: u32 = 8192;
pub const OPAMP_CSR_CALSEL: u32 = 8192;
pub const OPAMP_CSR_USERTRIM_Pos: u32 = 14;
pub const OPAMP_CSR_USERTRIM_Msk: u32 = 16384;
pub const OPAMP_CSR_USERTRIM: u32 = 16384;
pub const OPAMP_CSR_CALOUT_Pos: u32 = 15;
pub const OPAMP_CSR_CALOUT_Msk: u32 = 32768;
pub const OPAMP_CSR_CALOUT: u32 = 32768;
pub const OPAMP1_CSR_OPAEN_Pos: u32 = 0;
pub const OPAMP1_CSR_OPAEN_Msk: u32 = 1;
pub const OPAMP1_CSR_OPAEN: u32 = 1;
pub const OPAMP1_CSR_OPALPM_Pos: u32 = 1;
pub const OPAMP1_CSR_OPALPM_Msk: u32 = 2;
pub const OPAMP1_CSR_OPALPM: u32 = 2;
pub const OPAMP1_CSR_OPAMODE_Pos: u32 = 2;
pub const OPAMP1_CSR_OPAMODE_Msk: u32 = 12;
pub const OPAMP1_CSR_OPAMODE: u32 = 12;
pub const OPAMP1_CSR_OPAMODE_0: u32 = 4;
pub const OPAMP1_CSR_OPAMODE_1: u32 = 8;
pub const OPAMP1_CSR_PGAGAIN_Pos: u32 = 4;
pub const OPAMP1_CSR_PGAGAIN_Msk: u32 = 48;
pub const OPAMP1_CSR_PGAGAIN: u32 = 48;
pub const OPAMP1_CSR_PGAGAIN_0: u32 = 16;
pub const OPAMP1_CSR_PGAGAIN_1: u32 = 32;
pub const OPAMP1_CSR_VMSEL_Pos: u32 = 8;
pub const OPAMP1_CSR_VMSEL_Msk: u32 = 768;
pub const OPAMP1_CSR_VMSEL: u32 = 768;
pub const OPAMP1_CSR_VMSEL_0: u32 = 256;
pub const OPAMP1_CSR_VMSEL_1: u32 = 512;
pub const OPAMP1_CSR_VPSEL_Pos: u32 = 10;
pub const OPAMP1_CSR_VPSEL_Msk: u32 = 1024;
pub const OPAMP1_CSR_VPSEL: u32 = 1024;
pub const OPAMP1_CSR_CALON_Pos: u32 = 12;
pub const OPAMP1_CSR_CALON_Msk: u32 = 4096;
pub const OPAMP1_CSR_CALON: u32 = 4096;
pub const OPAMP1_CSR_CALSEL_Pos: u32 = 13;
pub const OPAMP1_CSR_CALSEL_Msk: u32 = 8192;
pub const OPAMP1_CSR_CALSEL: u32 = 8192;
pub const OPAMP1_CSR_USERTRIM_Pos: u32 = 14;
pub const OPAMP1_CSR_USERTRIM_Msk: u32 = 16384;
pub const OPAMP1_CSR_USERTRIM: u32 = 16384;
pub const OPAMP1_CSR_CALOUT_Pos: u32 = 15;
pub const OPAMP1_CSR_CALOUT_Msk: u32 = 32768;
pub const OPAMP1_CSR_CALOUT: u32 = 32768;
pub const OPAMP1_CSR_OPARANGE_Pos: u32 = 31;
pub const OPAMP1_CSR_OPARANGE_Msk: u32 = 2147483648;
pub const OPAMP1_CSR_OPARANGE: u32 = 2147483648;
pub const OPAMP2_CSR_OPAEN_Pos: u32 = 0;
pub const OPAMP2_CSR_OPAEN_Msk: u32 = 1;
pub const OPAMP2_CSR_OPAEN: u32 = 1;
pub const OPAMP2_CSR_OPALPM_Pos: u32 = 1;
pub const OPAMP2_CSR_OPALPM_Msk: u32 = 2;
pub const OPAMP2_CSR_OPALPM: u32 = 2;
pub const OPAMP2_CSR_OPAMODE_Pos: u32 = 2;
pub const OPAMP2_CSR_OPAMODE_Msk: u32 = 12;
pub const OPAMP2_CSR_OPAMODE: u32 = 12;
pub const OPAMP2_CSR_OPAMODE_0: u32 = 4;
pub const OPAMP2_CSR_OPAMODE_1: u32 = 8;
pub const OPAMP2_CSR_PGAGAIN_Pos: u32 = 4;
pub const OPAMP2_CSR_PGAGAIN_Msk: u32 = 48;
pub const OPAMP2_CSR_PGAGAIN: u32 = 48;
pub const OPAMP2_CSR_PGAGAIN_0: u32 = 16;
pub const OPAMP2_CSR_PGAGAIN_1: u32 = 32;
pub const OPAMP2_CSR_VMSEL_Pos: u32 = 8;
pub const OPAMP2_CSR_VMSEL_Msk: u32 = 768;
pub const OPAMP2_CSR_VMSEL: u32 = 768;
pub const OPAMP2_CSR_VMSEL_0: u32 = 256;
pub const OPAMP2_CSR_VMSEL_1: u32 = 512;
pub const OPAMP2_CSR_VPSEL_Pos: u32 = 10;
pub const OPAMP2_CSR_VPSEL_Msk: u32 = 1024;
pub const OPAMP2_CSR_VPSEL: u32 = 1024;
pub const OPAMP2_CSR_CALON_Pos: u32 = 12;
pub const OPAMP2_CSR_CALON_Msk: u32 = 4096;
pub const OPAMP2_CSR_CALON: u32 = 4096;
pub const OPAMP2_CSR_CALSEL_Pos: u32 = 13;
pub const OPAMP2_CSR_CALSEL_Msk: u32 = 8192;
pub const OPAMP2_CSR_CALSEL: u32 = 8192;
pub const OPAMP2_CSR_USERTRIM_Pos: u32 = 14;
pub const OPAMP2_CSR_USERTRIM_Msk: u32 = 16384;
pub const OPAMP2_CSR_USERTRIM: u32 = 16384;
pub const OPAMP2_CSR_CALOUT_Pos: u32 = 15;
pub const OPAMP2_CSR_CALOUT_Msk: u32 = 32768;
pub const OPAMP2_CSR_CALOUT: u32 = 32768;
pub const OPAMP_OTR_TRIMOFFSETN_Pos: u32 = 0;
pub const OPAMP_OTR_TRIMOFFSETN_Msk: u32 = 31;
pub const OPAMP_OTR_TRIMOFFSETN: u32 = 31;
pub const OPAMP_OTR_TRIMOFFSETP_Pos: u32 = 8;
pub const OPAMP_OTR_TRIMOFFSETP_Msk: u32 = 7936;
pub const OPAMP_OTR_TRIMOFFSETP: u32 = 7936;
pub const OPAMP1_OTR_TRIMOFFSETN_Pos: u32 = 0;
pub const OPAMP1_OTR_TRIMOFFSETN_Msk: u32 = 31;
pub const OPAMP1_OTR_TRIMOFFSETN: u32 = 31;
pub const OPAMP1_OTR_TRIMOFFSETP_Pos: u32 = 8;
pub const OPAMP1_OTR_TRIMOFFSETP_Msk: u32 = 7936;
pub const OPAMP1_OTR_TRIMOFFSETP: u32 = 7936;
pub const OPAMP2_OTR_TRIMOFFSETN_Pos: u32 = 0;
pub const OPAMP2_OTR_TRIMOFFSETN_Msk: u32 = 31;
pub const OPAMP2_OTR_TRIMOFFSETN: u32 = 31;
pub const OPAMP2_OTR_TRIMOFFSETP_Pos: u32 = 8;
pub const OPAMP2_OTR_TRIMOFFSETP_Msk: u32 = 7936;
pub const OPAMP2_OTR_TRIMOFFSETP: u32 = 7936;
pub const OPAMP_LPOTR_TRIMLPOFFSETN_Pos: u32 = 0;
pub const OPAMP_LPOTR_TRIMLPOFFSETN_Msk: u32 = 31;
pub const OPAMP_LPOTR_TRIMLPOFFSETN: u32 = 31;
pub const OPAMP_LPOTR_TRIMLPOFFSETP_Pos: u32 = 8;
pub const OPAMP_LPOTR_TRIMLPOFFSETP_Msk: u32 = 7936;
pub const OPAMP_LPOTR_TRIMLPOFFSETP: u32 = 7936;
pub const OPAMP1_LPOTR_TRIMLPOFFSETN_Pos: u32 = 0;
pub const OPAMP1_LPOTR_TRIMLPOFFSETN_Msk: u32 = 31;
pub const OPAMP1_LPOTR_TRIMLPOFFSETN: u32 = 31;
pub const OPAMP1_LPOTR_TRIMLPOFFSETP_Pos: u32 = 8;
pub const OPAMP1_LPOTR_TRIMLPOFFSETP_Msk: u32 = 7936;
pub const OPAMP1_LPOTR_TRIMLPOFFSETP: u32 = 7936;
pub const OPAMP2_LPOTR_TRIMLPOFFSETN_Pos: u32 = 0;
pub const OPAMP2_LPOTR_TRIMLPOFFSETN_Msk: u32 = 31;
pub const OPAMP2_LPOTR_TRIMLPOFFSETN: u32 = 31;
pub const OPAMP2_LPOTR_TRIMLPOFFSETP_Pos: u32 = 8;
pub const OPAMP2_LPOTR_TRIMLPOFFSETP_Msk: u32 = 7936;
pub const OPAMP2_LPOTR_TRIMLPOFFSETP: u32 = 7936;
pub const TSC_CR_TSCE_Pos: u32 = 0;
pub const TSC_CR_TSCE_Msk: u32 = 1;
pub const TSC_CR_TSCE: u32 = 1;
pub const TSC_CR_START_Pos: u32 = 1;
pub const TSC_CR_START_Msk: u32 = 2;
pub const TSC_CR_START: u32 = 2;
pub const TSC_CR_AM_Pos: u32 = 2;
pub const TSC_CR_AM_Msk: u32 = 4;
pub const TSC_CR_AM: u32 = 4;
pub const TSC_CR_SYNCPOL_Pos: u32 = 3;
pub const TSC_CR_SYNCPOL_Msk: u32 = 8;
pub const TSC_CR_SYNCPOL: u32 = 8;
pub const TSC_CR_IODEF_Pos: u32 = 4;
pub const TSC_CR_IODEF_Msk: u32 = 16;
pub const TSC_CR_IODEF: u32 = 16;
pub const TSC_CR_MCV_Pos: u32 = 5;
pub const TSC_CR_MCV_Msk: u32 = 224;
pub const TSC_CR_MCV: u32 = 224;
pub const TSC_CR_MCV_0: u32 = 32;
pub const TSC_CR_MCV_1: u32 = 64;
pub const TSC_CR_MCV_2: u32 = 128;
pub const TSC_CR_PGPSC_Pos: u32 = 12;
pub const TSC_CR_PGPSC_Msk: u32 = 28672;
pub const TSC_CR_PGPSC: u32 = 28672;
pub const TSC_CR_PGPSC_0: u32 = 4096;
pub const TSC_CR_PGPSC_1: u32 = 8192;
pub const TSC_CR_PGPSC_2: u32 = 16384;
pub const TSC_CR_SSPSC_Pos: u32 = 15;
pub const TSC_CR_SSPSC_Msk: u32 = 32768;
pub const TSC_CR_SSPSC: u32 = 32768;
pub const TSC_CR_SSE_Pos: u32 = 16;
pub const TSC_CR_SSE_Msk: u32 = 65536;
pub const TSC_CR_SSE: u32 = 65536;
pub const TSC_CR_SSD_Pos: u32 = 17;
pub const TSC_CR_SSD_Msk: u32 = 16646144;
pub const TSC_CR_SSD: u32 = 16646144;
pub const TSC_CR_SSD_0: u32 = 131072;
pub const TSC_CR_SSD_1: u32 = 262144;
pub const TSC_CR_SSD_2: u32 = 524288;
pub const TSC_CR_SSD_3: u32 = 1048576;
pub const TSC_CR_SSD_4: u32 = 2097152;
pub const TSC_CR_SSD_5: u32 = 4194304;
pub const TSC_CR_SSD_6: u32 = 8388608;
pub const TSC_CR_CTPL_Pos: u32 = 24;
pub const TSC_CR_CTPL_Msk: u32 = 251658240;
pub const TSC_CR_CTPL: u32 = 251658240;
pub const TSC_CR_CTPL_0: u32 = 16777216;
pub const TSC_CR_CTPL_1: u32 = 33554432;
pub const TSC_CR_CTPL_2: u32 = 67108864;
pub const TSC_CR_CTPL_3: u32 = 134217728;
pub const TSC_CR_CTPH_Pos: u32 = 28;
pub const TSC_CR_CTPH_Msk: u32 = 4026531840;
pub const TSC_CR_CTPH: u32 = 4026531840;
pub const TSC_CR_CTPH_0: u32 = 268435456;
pub const TSC_CR_CTPH_1: u32 = 536870912;
pub const TSC_CR_CTPH_2: u32 = 1073741824;
pub const TSC_CR_CTPH_3: u32 = 2147483648;
pub const TSC_IER_EOAIE_Pos: u32 = 0;
pub const TSC_IER_EOAIE_Msk: u32 = 1;
pub const TSC_IER_EOAIE: u32 = 1;
pub const TSC_IER_MCEIE_Pos: u32 = 1;
pub const TSC_IER_MCEIE_Msk: u32 = 2;
pub const TSC_IER_MCEIE: u32 = 2;
pub const TSC_ICR_EOAIC_Pos: u32 = 0;
pub const TSC_ICR_EOAIC_Msk: u32 = 1;
pub const TSC_ICR_EOAIC: u32 = 1;
pub const TSC_ICR_MCEIC_Pos: u32 = 1;
pub const TSC_ICR_MCEIC_Msk: u32 = 2;
pub const TSC_ICR_MCEIC: u32 = 2;
pub const TSC_ISR_EOAF_Pos: u32 = 0;
pub const TSC_ISR_EOAF_Msk: u32 = 1;
pub const TSC_ISR_EOAF: u32 = 1;
pub const TSC_ISR_MCEF_Pos: u32 = 1;
pub const TSC_ISR_MCEF_Msk: u32 = 2;
pub const TSC_ISR_MCEF: u32 = 2;
pub const TSC_IOHCR_G1_IO1_Pos: u32 = 0;
pub const TSC_IOHCR_G1_IO1_Msk: u32 = 1;
pub const TSC_IOHCR_G1_IO1: u32 = 1;
pub const TSC_IOHCR_G1_IO2_Pos: u32 = 1;
pub const TSC_IOHCR_G1_IO2_Msk: u32 = 2;
pub const TSC_IOHCR_G1_IO2: u32 = 2;
pub const TSC_IOHCR_G1_IO3_Pos: u32 = 2;
pub const TSC_IOHCR_G1_IO3_Msk: u32 = 4;
pub const TSC_IOHCR_G1_IO3: u32 = 4;
pub const TSC_IOHCR_G1_IO4_Pos: u32 = 3;
pub const TSC_IOHCR_G1_IO4_Msk: u32 = 8;
pub const TSC_IOHCR_G1_IO4: u32 = 8;
pub const TSC_IOHCR_G2_IO1_Pos: u32 = 4;
pub const TSC_IOHCR_G2_IO1_Msk: u32 = 16;
pub const TSC_IOHCR_G2_IO1: u32 = 16;
pub const TSC_IOHCR_G2_IO2_Pos: u32 = 5;
pub const TSC_IOHCR_G2_IO2_Msk: u32 = 32;
pub const TSC_IOHCR_G2_IO2: u32 = 32;
pub const TSC_IOHCR_G2_IO3_Pos: u32 = 6;
pub const TSC_IOHCR_G2_IO3_Msk: u32 = 64;
pub const TSC_IOHCR_G2_IO3: u32 = 64;
pub const TSC_IOHCR_G2_IO4_Pos: u32 = 7;
pub const TSC_IOHCR_G2_IO4_Msk: u32 = 128;
pub const TSC_IOHCR_G2_IO4: u32 = 128;
pub const TSC_IOHCR_G3_IO1_Pos: u32 = 8;
pub const TSC_IOHCR_G3_IO1_Msk: u32 = 256;
pub const TSC_IOHCR_G3_IO1: u32 = 256;
pub const TSC_IOHCR_G3_IO2_Pos: u32 = 9;
pub const TSC_IOHCR_G3_IO2_Msk: u32 = 512;
pub const TSC_IOHCR_G3_IO2: u32 = 512;
pub const TSC_IOHCR_G3_IO3_Pos: u32 = 10;
pub const TSC_IOHCR_G3_IO3_Msk: u32 = 1024;
pub const TSC_IOHCR_G3_IO3: u32 = 1024;
pub const TSC_IOHCR_G3_IO4_Pos: u32 = 11;
pub const TSC_IOHCR_G3_IO4_Msk: u32 = 2048;
pub const TSC_IOHCR_G3_IO4: u32 = 2048;
pub const TSC_IOHCR_G4_IO1_Pos: u32 = 12;
pub const TSC_IOHCR_G4_IO1_Msk: u32 = 4096;
pub const TSC_IOHCR_G4_IO1: u32 = 4096;
pub const TSC_IOHCR_G4_IO2_Pos: u32 = 13;
pub const TSC_IOHCR_G4_IO2_Msk: u32 = 8192;
pub const TSC_IOHCR_G4_IO2: u32 = 8192;
pub const TSC_IOHCR_G4_IO3_Pos: u32 = 14;
pub const TSC_IOHCR_G4_IO3_Msk: u32 = 16384;
pub const TSC_IOHCR_G4_IO3: u32 = 16384;
pub const TSC_IOHCR_G4_IO4_Pos: u32 = 15;
pub const TSC_IOHCR_G4_IO4_Msk: u32 = 32768;
pub const TSC_IOHCR_G4_IO4: u32 = 32768;
pub const TSC_IOHCR_G5_IO1_Pos: u32 = 16;
pub const TSC_IOHCR_G5_IO1_Msk: u32 = 65536;
pub const TSC_IOHCR_G5_IO1: u32 = 65536;
pub const TSC_IOHCR_G5_IO2_Pos: u32 = 17;
pub const TSC_IOHCR_G5_IO2_Msk: u32 = 131072;
pub const TSC_IOHCR_G5_IO2: u32 = 131072;
pub const TSC_IOHCR_G5_IO3_Pos: u32 = 18;
pub const TSC_IOHCR_G5_IO3_Msk: u32 = 262144;
pub const TSC_IOHCR_G5_IO3: u32 = 262144;
pub const TSC_IOHCR_G5_IO4_Pos: u32 = 19;
pub const TSC_IOHCR_G5_IO4_Msk: u32 = 524288;
pub const TSC_IOHCR_G5_IO4: u32 = 524288;
pub const TSC_IOHCR_G6_IO1_Pos: u32 = 20;
pub const TSC_IOHCR_G6_IO1_Msk: u32 = 1048576;
pub const TSC_IOHCR_G6_IO1: u32 = 1048576;
pub const TSC_IOHCR_G6_IO2_Pos: u32 = 21;
pub const TSC_IOHCR_G6_IO2_Msk: u32 = 2097152;
pub const TSC_IOHCR_G6_IO2: u32 = 2097152;
pub const TSC_IOHCR_G6_IO3_Pos: u32 = 22;
pub const TSC_IOHCR_G6_IO3_Msk: u32 = 4194304;
pub const TSC_IOHCR_G6_IO3: u32 = 4194304;
pub const TSC_IOHCR_G6_IO4_Pos: u32 = 23;
pub const TSC_IOHCR_G6_IO4_Msk: u32 = 8388608;
pub const TSC_IOHCR_G6_IO4: u32 = 8388608;
pub const TSC_IOHCR_G7_IO1_Pos: u32 = 24;
pub const TSC_IOHCR_G7_IO1_Msk: u32 = 16777216;
pub const TSC_IOHCR_G7_IO1: u32 = 16777216;
pub const TSC_IOHCR_G7_IO2_Pos: u32 = 25;
pub const TSC_IOHCR_G7_IO2_Msk: u32 = 33554432;
pub const TSC_IOHCR_G7_IO2: u32 = 33554432;
pub const TSC_IOHCR_G7_IO3_Pos: u32 = 26;
pub const TSC_IOHCR_G7_IO3_Msk: u32 = 67108864;
pub const TSC_IOHCR_G7_IO3: u32 = 67108864;
pub const TSC_IOHCR_G7_IO4_Pos: u32 = 27;
pub const TSC_IOHCR_G7_IO4_Msk: u32 = 134217728;
pub const TSC_IOHCR_G7_IO4: u32 = 134217728;
pub const TSC_IOHCR_G8_IO1_Pos: u32 = 28;
pub const TSC_IOHCR_G8_IO1_Msk: u32 = 268435456;
pub const TSC_IOHCR_G8_IO1: u32 = 268435456;
pub const TSC_IOHCR_G8_IO2_Pos: u32 = 29;
pub const TSC_IOHCR_G8_IO2_Msk: u32 = 536870912;
pub const TSC_IOHCR_G8_IO2: u32 = 536870912;
pub const TSC_IOHCR_G8_IO3_Pos: u32 = 30;
pub const TSC_IOHCR_G8_IO3_Msk: u32 = 1073741824;
pub const TSC_IOHCR_G8_IO3: u32 = 1073741824;
pub const TSC_IOHCR_G8_IO4_Pos: u32 = 31;
pub const TSC_IOHCR_G8_IO4_Msk: u32 = 2147483648;
pub const TSC_IOHCR_G8_IO4: u32 = 2147483648;
pub const TSC_IOASCR_G1_IO1_Pos: u32 = 0;
pub const TSC_IOASCR_G1_IO1_Msk: u32 = 1;
pub const TSC_IOASCR_G1_IO1: u32 = 1;
pub const TSC_IOASCR_G1_IO2_Pos: u32 = 1;
pub const TSC_IOASCR_G1_IO2_Msk: u32 = 2;
pub const TSC_IOASCR_G1_IO2: u32 = 2;
pub const TSC_IOASCR_G1_IO3_Pos: u32 = 2;
pub const TSC_IOASCR_G1_IO3_Msk: u32 = 4;
pub const TSC_IOASCR_G1_IO3: u32 = 4;
pub const TSC_IOASCR_G1_IO4_Pos: u32 = 3;
pub const TSC_IOASCR_G1_IO4_Msk: u32 = 8;
pub const TSC_IOASCR_G1_IO4: u32 = 8;
pub const TSC_IOASCR_G2_IO1_Pos: u32 = 4;
pub const TSC_IOASCR_G2_IO1_Msk: u32 = 16;
pub const TSC_IOASCR_G2_IO1: u32 = 16;
pub const TSC_IOASCR_G2_IO2_Pos: u32 = 5;
pub const TSC_IOASCR_G2_IO2_Msk: u32 = 32;
pub const TSC_IOASCR_G2_IO2: u32 = 32;
pub const TSC_IOASCR_G2_IO3_Pos: u32 = 6;
pub const TSC_IOASCR_G2_IO3_Msk: u32 = 64;
pub const TSC_IOASCR_G2_IO3: u32 = 64;
pub const TSC_IOASCR_G2_IO4_Pos: u32 = 7;
pub const TSC_IOASCR_G2_IO4_Msk: u32 = 128;
pub const TSC_IOASCR_G2_IO4: u32 = 128;
pub const TSC_IOASCR_G3_IO1_Pos: u32 = 8;
pub const TSC_IOASCR_G3_IO1_Msk: u32 = 256;
pub const TSC_IOASCR_G3_IO1: u32 = 256;
pub const TSC_IOASCR_G3_IO2_Pos: u32 = 9;
pub const TSC_IOASCR_G3_IO2_Msk: u32 = 512;
pub const TSC_IOASCR_G3_IO2: u32 = 512;
pub const TSC_IOASCR_G3_IO3_Pos: u32 = 10;
pub const TSC_IOASCR_G3_IO3_Msk: u32 = 1024;
pub const TSC_IOASCR_G3_IO3: u32 = 1024;
pub const TSC_IOASCR_G3_IO4_Pos: u32 = 11;
pub const TSC_IOASCR_G3_IO4_Msk: u32 = 2048;
pub const TSC_IOASCR_G3_IO4: u32 = 2048;
pub const TSC_IOASCR_G4_IO1_Pos: u32 = 12;
pub const TSC_IOASCR_G4_IO1_Msk: u32 = 4096;
pub const TSC_IOASCR_G4_IO1: u32 = 4096;
pub const TSC_IOASCR_G4_IO2_Pos: u32 = 13;
pub const TSC_IOASCR_G4_IO2_Msk: u32 = 8192;
pub const TSC_IOASCR_G4_IO2: u32 = 8192;
pub const TSC_IOASCR_G4_IO3_Pos: u32 = 14;
pub const TSC_IOASCR_G4_IO3_Msk: u32 = 16384;
pub const TSC_IOASCR_G4_IO3: u32 = 16384;
pub const TSC_IOASCR_G4_IO4_Pos: u32 = 15;
pub const TSC_IOASCR_G4_IO4_Msk: u32 = 32768;
pub const TSC_IOASCR_G4_IO4: u32 = 32768;
pub const TSC_IOASCR_G5_IO1_Pos: u32 = 16;
pub const TSC_IOASCR_G5_IO1_Msk: u32 = 65536;
pub const TSC_IOASCR_G5_IO1: u32 = 65536;
pub const TSC_IOASCR_G5_IO2_Pos: u32 = 17;
pub const TSC_IOASCR_G5_IO2_Msk: u32 = 131072;
pub const TSC_IOASCR_G5_IO2: u32 = 131072;
pub const TSC_IOASCR_G5_IO3_Pos: u32 = 18;
pub const TSC_IOASCR_G5_IO3_Msk: u32 = 262144;
pub const TSC_IOASCR_G5_IO3: u32 = 262144;
pub const TSC_IOASCR_G5_IO4_Pos: u32 = 19;
pub const TSC_IOASCR_G5_IO4_Msk: u32 = 524288;
pub const TSC_IOASCR_G5_IO4: u32 = 524288;
pub const TSC_IOASCR_G6_IO1_Pos: u32 = 20;
pub const TSC_IOASCR_G6_IO1_Msk: u32 = 1048576;
pub const TSC_IOASCR_G6_IO1: u32 = 1048576;
pub const TSC_IOASCR_G6_IO2_Pos: u32 = 21;
pub const TSC_IOASCR_G6_IO2_Msk: u32 = 2097152;
pub const TSC_IOASCR_G6_IO2: u32 = 2097152;
pub const TSC_IOASCR_G6_IO3_Pos: u32 = 22;
pub const TSC_IOASCR_G6_IO3_Msk: u32 = 4194304;
pub const TSC_IOASCR_G6_IO3: u32 = 4194304;
pub const TSC_IOASCR_G6_IO4_Pos: u32 = 23;
pub const TSC_IOASCR_G6_IO4_Msk: u32 = 8388608;
pub const TSC_IOASCR_G6_IO4: u32 = 8388608;
pub const TSC_IOASCR_G7_IO1_Pos: u32 = 24;
pub const TSC_IOASCR_G7_IO1_Msk: u32 = 16777216;
pub const TSC_IOASCR_G7_IO1: u32 = 16777216;
pub const TSC_IOASCR_G7_IO2_Pos: u32 = 25;
pub const TSC_IOASCR_G7_IO2_Msk: u32 = 33554432;
pub const TSC_IOASCR_G7_IO2: u32 = 33554432;
pub const TSC_IOASCR_G7_IO3_Pos: u32 = 26;
pub const TSC_IOASCR_G7_IO3_Msk: u32 = 67108864;
pub const TSC_IOASCR_G7_IO3: u32 = 67108864;
pub const TSC_IOASCR_G7_IO4_Pos: u32 = 27;
pub const TSC_IOASCR_G7_IO4_Msk: u32 = 134217728;
pub const TSC_IOASCR_G7_IO4: u32 = 134217728;
pub const TSC_IOASCR_G8_IO1_Pos: u32 = 28;
pub const TSC_IOASCR_G8_IO1_Msk: u32 = 268435456;
pub const TSC_IOASCR_G8_IO1: u32 = 268435456;
pub const TSC_IOASCR_G8_IO2_Pos: u32 = 29;
pub const TSC_IOASCR_G8_IO2_Msk: u32 = 536870912;
pub const TSC_IOASCR_G8_IO2: u32 = 536870912;
pub const TSC_IOASCR_G8_IO3_Pos: u32 = 30;
pub const TSC_IOASCR_G8_IO3_Msk: u32 = 1073741824;
pub const TSC_IOASCR_G8_IO3: u32 = 1073741824;
pub const TSC_IOASCR_G8_IO4_Pos: u32 = 31;
pub const TSC_IOASCR_G8_IO4_Msk: u32 = 2147483648;
pub const TSC_IOASCR_G8_IO4: u32 = 2147483648;
pub const TSC_IOSCR_G1_IO1_Pos: u32 = 0;
pub const TSC_IOSCR_G1_IO1_Msk: u32 = 1;
pub const TSC_IOSCR_G1_IO1: u32 = 1;
pub const TSC_IOSCR_G1_IO2_Pos: u32 = 1;
pub const TSC_IOSCR_G1_IO2_Msk: u32 = 2;
pub const TSC_IOSCR_G1_IO2: u32 = 2;
pub const TSC_IOSCR_G1_IO3_Pos: u32 = 2;
pub const TSC_IOSCR_G1_IO3_Msk: u32 = 4;
pub const TSC_IOSCR_G1_IO3: u32 = 4;
pub const TSC_IOSCR_G1_IO4_Pos: u32 = 3;
pub const TSC_IOSCR_G1_IO4_Msk: u32 = 8;
pub const TSC_IOSCR_G1_IO4: u32 = 8;
pub const TSC_IOSCR_G2_IO1_Pos: u32 = 4;
pub const TSC_IOSCR_G2_IO1_Msk: u32 = 16;
pub const TSC_IOSCR_G2_IO1: u32 = 16;
pub const TSC_IOSCR_G2_IO2_Pos: u32 = 5;
pub const TSC_IOSCR_G2_IO2_Msk: u32 = 32;
pub const TSC_IOSCR_G2_IO2: u32 = 32;
pub const TSC_IOSCR_G2_IO3_Pos: u32 = 6;
pub const TSC_IOSCR_G2_IO3_Msk: u32 = 64;
pub const TSC_IOSCR_G2_IO3: u32 = 64;
pub const TSC_IOSCR_G2_IO4_Pos: u32 = 7;
pub const TSC_IOSCR_G2_IO4_Msk: u32 = 128;
pub const TSC_IOSCR_G2_IO4: u32 = 128;
pub const TSC_IOSCR_G3_IO1_Pos: u32 = 8;
pub const TSC_IOSCR_G3_IO1_Msk: u32 = 256;
pub const TSC_IOSCR_G3_IO1: u32 = 256;
pub const TSC_IOSCR_G3_IO2_Pos: u32 = 9;
pub const TSC_IOSCR_G3_IO2_Msk: u32 = 512;
pub const TSC_IOSCR_G3_IO2: u32 = 512;
pub const TSC_IOSCR_G3_IO3_Pos: u32 = 10;
pub const TSC_IOSCR_G3_IO3_Msk: u32 = 1024;
pub const TSC_IOSCR_G3_IO3: u32 = 1024;
pub const TSC_IOSCR_G3_IO4_Pos: u32 = 11;
pub const TSC_IOSCR_G3_IO4_Msk: u32 = 2048;
pub const TSC_IOSCR_G3_IO4: u32 = 2048;
pub const TSC_IOSCR_G4_IO1_Pos: u32 = 12;
pub const TSC_IOSCR_G4_IO1_Msk: u32 = 4096;
pub const TSC_IOSCR_G4_IO1: u32 = 4096;
pub const TSC_IOSCR_G4_IO2_Pos: u32 = 13;
pub const TSC_IOSCR_G4_IO2_Msk: u32 = 8192;
pub const TSC_IOSCR_G4_IO2: u32 = 8192;
pub const TSC_IOSCR_G4_IO3_Pos: u32 = 14;
pub const TSC_IOSCR_G4_IO3_Msk: u32 = 16384;
pub const TSC_IOSCR_G4_IO3: u32 = 16384;
pub const TSC_IOSCR_G4_IO4_Pos: u32 = 15;
pub const TSC_IOSCR_G4_IO4_Msk: u32 = 32768;
pub const TSC_IOSCR_G4_IO4: u32 = 32768;
pub const TSC_IOSCR_G5_IO1_Pos: u32 = 16;
pub const TSC_IOSCR_G5_IO1_Msk: u32 = 65536;
pub const TSC_IOSCR_G5_IO1: u32 = 65536;
pub const TSC_IOSCR_G5_IO2_Pos: u32 = 17;
pub const TSC_IOSCR_G5_IO2_Msk: u32 = 131072;
pub const TSC_IOSCR_G5_IO2: u32 = 131072;
pub const TSC_IOSCR_G5_IO3_Pos: u32 = 18;
pub const TSC_IOSCR_G5_IO3_Msk: u32 = 262144;
pub const TSC_IOSCR_G5_IO3: u32 = 262144;
pub const TSC_IOSCR_G5_IO4_Pos: u32 = 19;
pub const TSC_IOSCR_G5_IO4_Msk: u32 = 524288;
pub const TSC_IOSCR_G5_IO4: u32 = 524288;
pub const TSC_IOSCR_G6_IO1_Pos: u32 = 20;
pub const TSC_IOSCR_G6_IO1_Msk: u32 = 1048576;
pub const TSC_IOSCR_G6_IO1: u32 = 1048576;
pub const TSC_IOSCR_G6_IO2_Pos: u32 = 21;
pub const TSC_IOSCR_G6_IO2_Msk: u32 = 2097152;
pub const TSC_IOSCR_G6_IO2: u32 = 2097152;
pub const TSC_IOSCR_G6_IO3_Pos: u32 = 22;
pub const TSC_IOSCR_G6_IO3_Msk: u32 = 4194304;
pub const TSC_IOSCR_G6_IO3: u32 = 4194304;
pub const TSC_IOSCR_G6_IO4_Pos: u32 = 23;
pub const TSC_IOSCR_G6_IO4_Msk: u32 = 8388608;
pub const TSC_IOSCR_G6_IO4: u32 = 8388608;
pub const TSC_IOSCR_G7_IO1_Pos: u32 = 24;
pub const TSC_IOSCR_G7_IO1_Msk: u32 = 16777216;
pub const TSC_IOSCR_G7_IO1: u32 = 16777216;
pub const TSC_IOSCR_G7_IO2_Pos: u32 = 25;
pub const TSC_IOSCR_G7_IO2_Msk: u32 = 33554432;
pub const TSC_IOSCR_G7_IO2: u32 = 33554432;
pub const TSC_IOSCR_G7_IO3_Pos: u32 = 26;
pub const TSC_IOSCR_G7_IO3_Msk: u32 = 67108864;
pub const TSC_IOSCR_G7_IO3: u32 = 67108864;
pub const TSC_IOSCR_G7_IO4_Pos: u32 = 27;
pub const TSC_IOSCR_G7_IO4_Msk: u32 = 134217728;
pub const TSC_IOSCR_G7_IO4: u32 = 134217728;
pub const TSC_IOSCR_G8_IO1_Pos: u32 = 28;
pub const TSC_IOSCR_G8_IO1_Msk: u32 = 268435456;
pub const TSC_IOSCR_G8_IO1: u32 = 268435456;
pub const TSC_IOSCR_G8_IO2_Pos: u32 = 29;
pub const TSC_IOSCR_G8_IO2_Msk: u32 = 536870912;
pub const TSC_IOSCR_G8_IO2: u32 = 536870912;
pub const TSC_IOSCR_G8_IO3_Pos: u32 = 30;
pub const TSC_IOSCR_G8_IO3_Msk: u32 = 1073741824;
pub const TSC_IOSCR_G8_IO3: u32 = 1073741824;
pub const TSC_IOSCR_G8_IO4_Pos: u32 = 31;
pub const TSC_IOSCR_G8_IO4_Msk: u32 = 2147483648;
pub const TSC_IOSCR_G8_IO4: u32 = 2147483648;
pub const TSC_IOCCR_G1_IO1_Pos: u32 = 0;
pub const TSC_IOCCR_G1_IO1_Msk: u32 = 1;
pub const TSC_IOCCR_G1_IO1: u32 = 1;
pub const TSC_IOCCR_G1_IO2_Pos: u32 = 1;
pub const TSC_IOCCR_G1_IO2_Msk: u32 = 2;
pub const TSC_IOCCR_G1_IO2: u32 = 2;
pub const TSC_IOCCR_G1_IO3_Pos: u32 = 2;
pub const TSC_IOCCR_G1_IO3_Msk: u32 = 4;
pub const TSC_IOCCR_G1_IO3: u32 = 4;
pub const TSC_IOCCR_G1_IO4_Pos: u32 = 3;
pub const TSC_IOCCR_G1_IO4_Msk: u32 = 8;
pub const TSC_IOCCR_G1_IO4: u32 = 8;
pub const TSC_IOCCR_G2_IO1_Pos: u32 = 4;
pub const TSC_IOCCR_G2_IO1_Msk: u32 = 16;
pub const TSC_IOCCR_G2_IO1: u32 = 16;
pub const TSC_IOCCR_G2_IO2_Pos: u32 = 5;
pub const TSC_IOCCR_G2_IO2_Msk: u32 = 32;
pub const TSC_IOCCR_G2_IO2: u32 = 32;
pub const TSC_IOCCR_G2_IO3_Pos: u32 = 6;
pub const TSC_IOCCR_G2_IO3_Msk: u32 = 64;
pub const TSC_IOCCR_G2_IO3: u32 = 64;
pub const TSC_IOCCR_G2_IO4_Pos: u32 = 7;
pub const TSC_IOCCR_G2_IO4_Msk: u32 = 128;
pub const TSC_IOCCR_G2_IO4: u32 = 128;
pub const TSC_IOCCR_G3_IO1_Pos: u32 = 8;
pub const TSC_IOCCR_G3_IO1_Msk: u32 = 256;
pub const TSC_IOCCR_G3_IO1: u32 = 256;
pub const TSC_IOCCR_G3_IO2_Pos: u32 = 9;
pub const TSC_IOCCR_G3_IO2_Msk: u32 = 512;
pub const TSC_IOCCR_G3_IO2: u32 = 512;
pub const TSC_IOCCR_G3_IO3_Pos: u32 = 10;
pub const TSC_IOCCR_G3_IO3_Msk: u32 = 1024;
pub const TSC_IOCCR_G3_IO3: u32 = 1024;
pub const TSC_IOCCR_G3_IO4_Pos: u32 = 11;
pub const TSC_IOCCR_G3_IO4_Msk: u32 = 2048;
pub const TSC_IOCCR_G3_IO4: u32 = 2048;
pub const TSC_IOCCR_G4_IO1_Pos: u32 = 12;
pub const TSC_IOCCR_G4_IO1_Msk: u32 = 4096;
pub const TSC_IOCCR_G4_IO1: u32 = 4096;
pub const TSC_IOCCR_G4_IO2_Pos: u32 = 13;
pub const TSC_IOCCR_G4_IO2_Msk: u32 = 8192;
pub const TSC_IOCCR_G4_IO2: u32 = 8192;
pub const TSC_IOCCR_G4_IO3_Pos: u32 = 14;
pub const TSC_IOCCR_G4_IO3_Msk: u32 = 16384;
pub const TSC_IOCCR_G4_IO3: u32 = 16384;
pub const TSC_IOCCR_G4_IO4_Pos: u32 = 15;
pub const TSC_IOCCR_G4_IO4_Msk: u32 = 32768;
pub const TSC_IOCCR_G4_IO4: u32 = 32768;
pub const TSC_IOCCR_G5_IO1_Pos: u32 = 16;
pub const TSC_IOCCR_G5_IO1_Msk: u32 = 65536;
pub const TSC_IOCCR_G5_IO1: u32 = 65536;
pub const TSC_IOCCR_G5_IO2_Pos: u32 = 17;
pub const TSC_IOCCR_G5_IO2_Msk: u32 = 131072;
pub const TSC_IOCCR_G5_IO2: u32 = 131072;
pub const TSC_IOCCR_G5_IO3_Pos: u32 = 18;
pub const TSC_IOCCR_G5_IO3_Msk: u32 = 262144;
pub const TSC_IOCCR_G5_IO3: u32 = 262144;
pub const TSC_IOCCR_G5_IO4_Pos: u32 = 19;
pub const TSC_IOCCR_G5_IO4_Msk: u32 = 524288;
pub const TSC_IOCCR_G5_IO4: u32 = 524288;
pub const TSC_IOCCR_G6_IO1_Pos: u32 = 20;
pub const TSC_IOCCR_G6_IO1_Msk: u32 = 1048576;
pub const TSC_IOCCR_G6_IO1: u32 = 1048576;
pub const TSC_IOCCR_G6_IO2_Pos: u32 = 21;
pub const TSC_IOCCR_G6_IO2_Msk: u32 = 2097152;
pub const TSC_IOCCR_G6_IO2: u32 = 2097152;
pub const TSC_IOCCR_G6_IO3_Pos: u32 = 22;
pub const TSC_IOCCR_G6_IO3_Msk: u32 = 4194304;
pub const TSC_IOCCR_G6_IO3: u32 = 4194304;
pub const TSC_IOCCR_G6_IO4_Pos: u32 = 23;
pub const TSC_IOCCR_G6_IO4_Msk: u32 = 8388608;
pub const TSC_IOCCR_G6_IO4: u32 = 8388608;
pub const TSC_IOCCR_G7_IO1_Pos: u32 = 24;
pub const TSC_IOCCR_G7_IO1_Msk: u32 = 16777216;
pub const TSC_IOCCR_G7_IO1: u32 = 16777216;
pub const TSC_IOCCR_G7_IO2_Pos: u32 = 25;
pub const TSC_IOCCR_G7_IO2_Msk: u32 = 33554432;
pub const TSC_IOCCR_G7_IO2: u32 = 33554432;
pub const TSC_IOCCR_G7_IO3_Pos: u32 = 26;
pub const TSC_IOCCR_G7_IO3_Msk: u32 = 67108864;
pub const TSC_IOCCR_G7_IO3: u32 = 67108864;
pub const TSC_IOCCR_G7_IO4_Pos: u32 = 27;
pub const TSC_IOCCR_G7_IO4_Msk: u32 = 134217728;
pub const TSC_IOCCR_G7_IO4: u32 = 134217728;
pub const TSC_IOCCR_G8_IO1_Pos: u32 = 28;
pub const TSC_IOCCR_G8_IO1_Msk: u32 = 268435456;
pub const TSC_IOCCR_G8_IO1: u32 = 268435456;
pub const TSC_IOCCR_G8_IO2_Pos: u32 = 29;
pub const TSC_IOCCR_G8_IO2_Msk: u32 = 536870912;
pub const TSC_IOCCR_G8_IO2: u32 = 536870912;
pub const TSC_IOCCR_G8_IO3_Pos: u32 = 30;
pub const TSC_IOCCR_G8_IO3_Msk: u32 = 1073741824;
pub const TSC_IOCCR_G8_IO3: u32 = 1073741824;
pub const TSC_IOCCR_G8_IO4_Pos: u32 = 31;
pub const TSC_IOCCR_G8_IO4_Msk: u32 = 2147483648;
pub const TSC_IOCCR_G8_IO4: u32 = 2147483648;
pub const TSC_IOGCSR_G1E_Pos: u32 = 0;
pub const TSC_IOGCSR_G1E_Msk: u32 = 1;
pub const TSC_IOGCSR_G1E: u32 = 1;
pub const TSC_IOGCSR_G2E_Pos: u32 = 1;
pub const TSC_IOGCSR_G2E_Msk: u32 = 2;
pub const TSC_IOGCSR_G2E: u32 = 2;
pub const TSC_IOGCSR_G3E_Pos: u32 = 2;
pub const TSC_IOGCSR_G3E_Msk: u32 = 4;
pub const TSC_IOGCSR_G3E: u32 = 4;
pub const TSC_IOGCSR_G4E_Pos: u32 = 3;
pub const TSC_IOGCSR_G4E_Msk: u32 = 8;
pub const TSC_IOGCSR_G4E: u32 = 8;
pub const TSC_IOGCSR_G5E_Pos: u32 = 4;
pub const TSC_IOGCSR_G5E_Msk: u32 = 16;
pub const TSC_IOGCSR_G5E: u32 = 16;
pub const TSC_IOGCSR_G6E_Pos: u32 = 5;
pub const TSC_IOGCSR_G6E_Msk: u32 = 32;
pub const TSC_IOGCSR_G6E: u32 = 32;
pub const TSC_IOGCSR_G7E_Pos: u32 = 6;
pub const TSC_IOGCSR_G7E_Msk: u32 = 64;
pub const TSC_IOGCSR_G7E: u32 = 64;
pub const TSC_IOGCSR_G8E_Pos: u32 = 7;
pub const TSC_IOGCSR_G8E_Msk: u32 = 128;
pub const TSC_IOGCSR_G8E: u32 = 128;
pub const TSC_IOGCSR_G1S_Pos: u32 = 16;
pub const TSC_IOGCSR_G1S_Msk: u32 = 65536;
pub const TSC_IOGCSR_G1S: u32 = 65536;
pub const TSC_IOGCSR_G2S_Pos: u32 = 17;
pub const TSC_IOGCSR_G2S_Msk: u32 = 131072;
pub const TSC_IOGCSR_G2S: u32 = 131072;
pub const TSC_IOGCSR_G3S_Pos: u32 = 18;
pub const TSC_IOGCSR_G3S_Msk: u32 = 262144;
pub const TSC_IOGCSR_G3S: u32 = 262144;
pub const TSC_IOGCSR_G4S_Pos: u32 = 19;
pub const TSC_IOGCSR_G4S_Msk: u32 = 524288;
pub const TSC_IOGCSR_G4S: u32 = 524288;
pub const TSC_IOGCSR_G5S_Pos: u32 = 20;
pub const TSC_IOGCSR_G5S_Msk: u32 = 1048576;
pub const TSC_IOGCSR_G5S: u32 = 1048576;
pub const TSC_IOGCSR_G6S_Pos: u32 = 21;
pub const TSC_IOGCSR_G6S_Msk: u32 = 2097152;
pub const TSC_IOGCSR_G6S: u32 = 2097152;
pub const TSC_IOGCSR_G7S_Pos: u32 = 22;
pub const TSC_IOGCSR_G7S_Msk: u32 = 4194304;
pub const TSC_IOGCSR_G7S: u32 = 4194304;
pub const TSC_IOGCSR_G8S_Pos: u32 = 23;
pub const TSC_IOGCSR_G8S_Msk: u32 = 8388608;
pub const TSC_IOGCSR_G8S: u32 = 8388608;
pub const TSC_IOGXCR_CNT_Pos: u32 = 0;
pub const TSC_IOGXCR_CNT_Msk: u32 = 16383;
pub const TSC_IOGXCR_CNT: u32 = 16383;
pub const USART_CR1_UE_Pos: u32 = 0;
pub const USART_CR1_UE_Msk: u32 = 1;
pub const USART_CR1_UE: u32 = 1;
pub const USART_CR1_UESM_Pos: u32 = 1;
pub const USART_CR1_UESM_Msk: u32 = 2;
pub const USART_CR1_UESM: u32 = 2;
pub const USART_CR1_RE_Pos: u32 = 2;
pub const USART_CR1_RE_Msk: u32 = 4;
pub const USART_CR1_RE: u32 = 4;
pub const USART_CR1_TE_Pos: u32 = 3;
pub const USART_CR1_TE_Msk: u32 = 8;
pub const USART_CR1_TE: u32 = 8;
pub const USART_CR1_IDLEIE_Pos: u32 = 4;
pub const USART_CR1_IDLEIE_Msk: u32 = 16;
pub const USART_CR1_IDLEIE: u32 = 16;
pub const USART_CR1_RXNEIE_Pos: u32 = 5;
pub const USART_CR1_RXNEIE_Msk: u32 = 32;
pub const USART_CR1_RXNEIE: u32 = 32;
pub const USART_CR1_TCIE_Pos: u32 = 6;
pub const USART_CR1_TCIE_Msk: u32 = 64;
pub const USART_CR1_TCIE: u32 = 64;
pub const USART_CR1_TXEIE_Pos: u32 = 7;
pub const USART_CR1_TXEIE_Msk: u32 = 128;
pub const USART_CR1_TXEIE: u32 = 128;
pub const USART_CR1_PEIE_Pos: u32 = 8;
pub const USART_CR1_PEIE_Msk: u32 = 256;
pub const USART_CR1_PEIE: u32 = 256;
pub const USART_CR1_PS_Pos: u32 = 9;
pub const USART_CR1_PS_Msk: u32 = 512;
pub const USART_CR1_PS: u32 = 512;
pub const USART_CR1_PCE_Pos: u32 = 10;
pub const USART_CR1_PCE_Msk: u32 = 1024;
pub const USART_CR1_PCE: u32 = 1024;
pub const USART_CR1_WAKE_Pos: u32 = 11;
pub const USART_CR1_WAKE_Msk: u32 = 2048;
pub const USART_CR1_WAKE: u32 = 2048;
pub const USART_CR1_M_Pos: u32 = 12;
pub const USART_CR1_M_Msk: u32 = 268439552;
pub const USART_CR1_M: u32 = 268439552;
pub const USART_CR1_M0_Pos: u32 = 12;
pub const USART_CR1_M0_Msk: u32 = 4096;
pub const USART_CR1_M0: u32 = 4096;
pub const USART_CR1_MME_Pos: u32 = 13;
pub const USART_CR1_MME_Msk: u32 = 8192;
pub const USART_CR1_MME: u32 = 8192;
pub const USART_CR1_CMIE_Pos: u32 = 14;
pub const USART_CR1_CMIE_Msk: u32 = 16384;
pub const USART_CR1_CMIE: u32 = 16384;
pub const USART_CR1_OVER8_Pos: u32 = 15;
pub const USART_CR1_OVER8_Msk: u32 = 32768;
pub const USART_CR1_OVER8: u32 = 32768;
pub const USART_CR1_DEDT_Pos: u32 = 16;
pub const USART_CR1_DEDT_Msk: u32 = 2031616;
pub const USART_CR1_DEDT: u32 = 2031616;
pub const USART_CR1_DEDT_0: u32 = 65536;
pub const USART_CR1_DEDT_1: u32 = 131072;
pub const USART_CR1_DEDT_2: u32 = 262144;
pub const USART_CR1_DEDT_3: u32 = 524288;
pub const USART_CR1_DEDT_4: u32 = 1048576;
pub const USART_CR1_DEAT_Pos: u32 = 21;
pub const USART_CR1_DEAT_Msk: u32 = 65011712;
pub const USART_CR1_DEAT: u32 = 65011712;
pub const USART_CR1_DEAT_0: u32 = 2097152;
pub const USART_CR1_DEAT_1: u32 = 4194304;
pub const USART_CR1_DEAT_2: u32 = 8388608;
pub const USART_CR1_DEAT_3: u32 = 16777216;
pub const USART_CR1_DEAT_4: u32 = 33554432;
pub const USART_CR1_RTOIE_Pos: u32 = 26;
pub const USART_CR1_RTOIE_Msk: u32 = 67108864;
pub const USART_CR1_RTOIE: u32 = 67108864;
pub const USART_CR1_EOBIE_Pos: u32 = 27;
pub const USART_CR1_EOBIE_Msk: u32 = 134217728;
pub const USART_CR1_EOBIE: u32 = 134217728;
pub const USART_CR1_M1_Pos: u32 = 28;
pub const USART_CR1_M1_Msk: u32 = 268435456;
pub const USART_CR1_M1: u32 = 268435456;
pub const USART_CR2_ADDM7_Pos: u32 = 4;
pub const USART_CR2_ADDM7_Msk: u32 = 16;
pub const USART_CR2_ADDM7: u32 = 16;
pub const USART_CR2_LBDL_Pos: u32 = 5;
pub const USART_CR2_LBDL_Msk: u32 = 32;
pub const USART_CR2_LBDL: u32 = 32;
pub const USART_CR2_LBDIE_Pos: u32 = 6;
pub const USART_CR2_LBDIE_Msk: u32 = 64;
pub const USART_CR2_LBDIE: u32 = 64;
pub const USART_CR2_LBCL_Pos: u32 = 8;
pub const USART_CR2_LBCL_Msk: u32 = 256;
pub const USART_CR2_LBCL: u32 = 256;
pub const USART_CR2_CPHA_Pos: u32 = 9;
pub const USART_CR2_CPHA_Msk: u32 = 512;
pub const USART_CR2_CPHA: u32 = 512;
pub const USART_CR2_CPOL_Pos: u32 = 10;
pub const USART_CR2_CPOL_Msk: u32 = 1024;
pub const USART_CR2_CPOL: u32 = 1024;
pub const USART_CR2_CLKEN_Pos: u32 = 11;
pub const USART_CR2_CLKEN_Msk: u32 = 2048;
pub const USART_CR2_CLKEN: u32 = 2048;
pub const USART_CR2_STOP_Pos: u32 = 12;
pub const USART_CR2_STOP_Msk: u32 = 12288;
pub const USART_CR2_STOP: u32 = 12288;
pub const USART_CR2_STOP_0: u32 = 4096;
pub const USART_CR2_STOP_1: u32 = 8192;
pub const USART_CR2_LINEN_Pos: u32 = 14;
pub const USART_CR2_LINEN_Msk: u32 = 16384;
pub const USART_CR2_LINEN: u32 = 16384;
pub const USART_CR2_SWAP_Pos: u32 = 15;
pub const USART_CR2_SWAP_Msk: u32 = 32768;
pub const USART_CR2_SWAP: u32 = 32768;
pub const USART_CR2_RXINV_Pos: u32 = 16;
pub const USART_CR2_RXINV_Msk: u32 = 65536;
pub const USART_CR2_RXINV: u32 = 65536;
pub const USART_CR2_TXINV_Pos: u32 = 17;
pub const USART_CR2_TXINV_Msk: u32 = 131072;
pub const USART_CR2_TXINV: u32 = 131072;
pub const USART_CR2_DATAINV_Pos: u32 = 18;
pub const USART_CR2_DATAINV_Msk: u32 = 262144;
pub const USART_CR2_DATAINV: u32 = 262144;
pub const USART_CR2_MSBFIRST_Pos: u32 = 19;
pub const USART_CR2_MSBFIRST_Msk: u32 = 524288;
pub const USART_CR2_MSBFIRST: u32 = 524288;
pub const USART_CR2_ABREN_Pos: u32 = 20;
pub const USART_CR2_ABREN_Msk: u32 = 1048576;
pub const USART_CR2_ABREN: u32 = 1048576;
pub const USART_CR2_ABRMODE_Pos: u32 = 21;
pub const USART_CR2_ABRMODE_Msk: u32 = 6291456;
pub const USART_CR2_ABRMODE: u32 = 6291456;
pub const USART_CR2_ABRMODE_0: u32 = 2097152;
pub const USART_CR2_ABRMODE_1: u32 = 4194304;
pub const USART_CR2_RTOEN_Pos: u32 = 23;
pub const USART_CR2_RTOEN_Msk: u32 = 8388608;
pub const USART_CR2_RTOEN: u32 = 8388608;
pub const USART_CR2_ADD_Pos: u32 = 24;
pub const USART_CR2_ADD_Msk: u32 = 4278190080;
pub const USART_CR2_ADD: u32 = 4278190080;
pub const USART_CR3_EIE_Pos: u32 = 0;
pub const USART_CR3_EIE_Msk: u32 = 1;
pub const USART_CR3_EIE: u32 = 1;
pub const USART_CR3_IREN_Pos: u32 = 1;
pub const USART_CR3_IREN_Msk: u32 = 2;
pub const USART_CR3_IREN: u32 = 2;
pub const USART_CR3_IRLP_Pos: u32 = 2;
pub const USART_CR3_IRLP_Msk: u32 = 4;
pub const USART_CR3_IRLP: u32 = 4;
pub const USART_CR3_HDSEL_Pos: u32 = 3;
pub const USART_CR3_HDSEL_Msk: u32 = 8;
pub const USART_CR3_HDSEL: u32 = 8;
pub const USART_CR3_NACK_Pos: u32 = 4;
pub const USART_CR3_NACK_Msk: u32 = 16;
pub const USART_CR3_NACK: u32 = 16;
pub const USART_CR3_SCEN_Pos: u32 = 5;
pub const USART_CR3_SCEN_Msk: u32 = 32;
pub const USART_CR3_SCEN: u32 = 32;
pub const USART_CR3_DMAR_Pos: u32 = 6;
pub const USART_CR3_DMAR_Msk: u32 = 64;
pub const USART_CR3_DMAR: u32 = 64;
pub const USART_CR3_DMAT_Pos: u32 = 7;
pub const USART_CR3_DMAT_Msk: u32 = 128;
pub const USART_CR3_DMAT: u32 = 128;
pub const USART_CR3_RTSE_Pos: u32 = 8;
pub const USART_CR3_RTSE_Msk: u32 = 256;
pub const USART_CR3_RTSE: u32 = 256;
pub const USART_CR3_CTSE_Pos: u32 = 9;
pub const USART_CR3_CTSE_Msk: u32 = 512;
pub const USART_CR3_CTSE: u32 = 512;
pub const USART_CR3_CTSIE_Pos: u32 = 10;
pub const USART_CR3_CTSIE_Msk: u32 = 1024;
pub const USART_CR3_CTSIE: u32 = 1024;
pub const USART_CR3_ONEBIT_Pos: u32 = 11;
pub const USART_CR3_ONEBIT_Msk: u32 = 2048;
pub const USART_CR3_ONEBIT: u32 = 2048;
pub const USART_CR3_OVRDIS_Pos: u32 = 12;
pub const USART_CR3_OVRDIS_Msk: u32 = 4096;
pub const USART_CR3_OVRDIS: u32 = 4096;
pub const USART_CR3_DDRE_Pos: u32 = 13;
pub const USART_CR3_DDRE_Msk: u32 = 8192;
pub const USART_CR3_DDRE: u32 = 8192;
pub const USART_CR3_DEM_Pos: u32 = 14;
pub const USART_CR3_DEM_Msk: u32 = 16384;
pub const USART_CR3_DEM: u32 = 16384;
pub const USART_CR3_DEP_Pos: u32 = 15;
pub const USART_CR3_DEP_Msk: u32 = 32768;
pub const USART_CR3_DEP: u32 = 32768;
pub const USART_CR3_SCARCNT_Pos: u32 = 17;
pub const USART_CR3_SCARCNT_Msk: u32 = 917504;
pub const USART_CR3_SCARCNT: u32 = 917504;
pub const USART_CR3_SCARCNT_0: u32 = 131072;
pub const USART_CR3_SCARCNT_1: u32 = 262144;
pub const USART_CR3_SCARCNT_2: u32 = 524288;
pub const USART_CR3_WUS_Pos: u32 = 20;
pub const USART_CR3_WUS_Msk: u32 = 3145728;
pub const USART_CR3_WUS: u32 = 3145728;
pub const USART_CR3_WUS_0: u32 = 1048576;
pub const USART_CR3_WUS_1: u32 = 2097152;
pub const USART_CR3_WUFIE_Pos: u32 = 22;
pub const USART_CR3_WUFIE_Msk: u32 = 4194304;
pub const USART_CR3_WUFIE: u32 = 4194304;
pub const USART_CR3_UCESM_Pos: u32 = 23;
pub const USART_CR3_UCESM_Msk: u32 = 8388608;
pub const USART_CR3_UCESM: u32 = 8388608;
pub const USART_BRR_DIV_FRACTION_Pos: u32 = 0;
pub const USART_BRR_DIV_FRACTION_Msk: u32 = 15;
pub const USART_BRR_DIV_FRACTION: u32 = 15;
pub const USART_BRR_DIV_MANTISSA_Pos: u32 = 4;
pub const USART_BRR_DIV_MANTISSA_Msk: u32 = 65520;
pub const USART_BRR_DIV_MANTISSA: u32 = 65520;
pub const USART_GTPR_PSC_Pos: u32 = 0;
pub const USART_GTPR_PSC_Msk: u32 = 255;
pub const USART_GTPR_PSC: u32 = 255;
pub const USART_GTPR_GT_Pos: u32 = 8;
pub const USART_GTPR_GT_Msk: u32 = 65280;
pub const USART_GTPR_GT: u32 = 65280;
pub const USART_RTOR_RTO_Pos: u32 = 0;
pub const USART_RTOR_RTO_Msk: u32 = 16777215;
pub const USART_RTOR_RTO: u32 = 16777215;
pub const USART_RTOR_BLEN_Pos: u32 = 24;
pub const USART_RTOR_BLEN_Msk: u32 = 4278190080;
pub const USART_RTOR_BLEN: u32 = 4278190080;
pub const USART_RQR_ABRRQ_Pos: u32 = 0;
pub const USART_RQR_ABRRQ_Msk: u32 = 1;
pub const USART_RQR_ABRRQ: u32 = 1;
pub const USART_RQR_SBKRQ_Pos: u32 = 1;
pub const USART_RQR_SBKRQ_Msk: u32 = 2;
pub const USART_RQR_SBKRQ: u32 = 2;
pub const USART_RQR_MMRQ_Pos: u32 = 2;
pub const USART_RQR_MMRQ_Msk: u32 = 4;
pub const USART_RQR_MMRQ: u32 = 4;
pub const USART_RQR_RXFRQ_Pos: u32 = 3;
pub const USART_RQR_RXFRQ_Msk: u32 = 8;
pub const USART_RQR_RXFRQ: u32 = 8;
pub const USART_RQR_TXFRQ_Pos: u32 = 4;
pub const USART_RQR_TXFRQ_Msk: u32 = 16;
pub const USART_RQR_TXFRQ: u32 = 16;
pub const USART_ISR_PE_Pos: u32 = 0;
pub const USART_ISR_PE_Msk: u32 = 1;
pub const USART_ISR_PE: u32 = 1;
pub const USART_ISR_FE_Pos: u32 = 1;
pub const USART_ISR_FE_Msk: u32 = 2;
pub const USART_ISR_FE: u32 = 2;
pub const USART_ISR_NE_Pos: u32 = 2;
pub const USART_ISR_NE_Msk: u32 = 4;
pub const USART_ISR_NE: u32 = 4;
pub const USART_ISR_ORE_Pos: u32 = 3;
pub const USART_ISR_ORE_Msk: u32 = 8;
pub const USART_ISR_ORE: u32 = 8;
pub const USART_ISR_IDLE_Pos: u32 = 4;
pub const USART_ISR_IDLE_Msk: u32 = 16;
pub const USART_ISR_IDLE: u32 = 16;
pub const USART_ISR_RXNE_Pos: u32 = 5;
pub const USART_ISR_RXNE_Msk: u32 = 32;
pub const USART_ISR_RXNE: u32 = 32;
pub const USART_ISR_TC_Pos: u32 = 6;
pub const USART_ISR_TC_Msk: u32 = 64;
pub const USART_ISR_TC: u32 = 64;
pub const USART_ISR_TXE_Pos: u32 = 7;
pub const USART_ISR_TXE_Msk: u32 = 128;
pub const USART_ISR_TXE: u32 = 128;
pub const USART_ISR_LBDF_Pos: u32 = 8;
pub const USART_ISR_LBDF_Msk: u32 = 256;
pub const USART_ISR_LBDF: u32 = 256;
pub const USART_ISR_CTSIF_Pos: u32 = 9;
pub const USART_ISR_CTSIF_Msk: u32 = 512;
pub const USART_ISR_CTSIF: u32 = 512;
pub const USART_ISR_CTS_Pos: u32 = 10;
pub const USART_ISR_CTS_Msk: u32 = 1024;
pub const USART_ISR_CTS: u32 = 1024;
pub const USART_ISR_RTOF_Pos: u32 = 11;
pub const USART_ISR_RTOF_Msk: u32 = 2048;
pub const USART_ISR_RTOF: u32 = 2048;
pub const USART_ISR_EOBF_Pos: u32 = 12;
pub const USART_ISR_EOBF_Msk: u32 = 4096;
pub const USART_ISR_EOBF: u32 = 4096;
pub const USART_ISR_ABRE_Pos: u32 = 14;
pub const USART_ISR_ABRE_Msk: u32 = 16384;
pub const USART_ISR_ABRE: u32 = 16384;
pub const USART_ISR_ABRF_Pos: u32 = 15;
pub const USART_ISR_ABRF_Msk: u32 = 32768;
pub const USART_ISR_ABRF: u32 = 32768;
pub const USART_ISR_BUSY_Pos: u32 = 16;
pub const USART_ISR_BUSY_Msk: u32 = 65536;
pub const USART_ISR_BUSY: u32 = 65536;
pub const USART_ISR_CMF_Pos: u32 = 17;
pub const USART_ISR_CMF_Msk: u32 = 131072;
pub const USART_ISR_CMF: u32 = 131072;
pub const USART_ISR_SBKF_Pos: u32 = 18;
pub const USART_ISR_SBKF_Msk: u32 = 262144;
pub const USART_ISR_SBKF: u32 = 262144;
pub const USART_ISR_RWU_Pos: u32 = 19;
pub const USART_ISR_RWU_Msk: u32 = 524288;
pub const USART_ISR_RWU: u32 = 524288;
pub const USART_ISR_WUF_Pos: u32 = 20;
pub const USART_ISR_WUF_Msk: u32 = 1048576;
pub const USART_ISR_WUF: u32 = 1048576;
pub const USART_ISR_TEACK_Pos: u32 = 21;
pub const USART_ISR_TEACK_Msk: u32 = 2097152;
pub const USART_ISR_TEACK: u32 = 2097152;
pub const USART_ISR_REACK_Pos: u32 = 22;
pub const USART_ISR_REACK_Msk: u32 = 4194304;
pub const USART_ISR_REACK: u32 = 4194304;
pub const USART_ICR_PECF_Pos: u32 = 0;
pub const USART_ICR_PECF_Msk: u32 = 1;
pub const USART_ICR_PECF: u32 = 1;
pub const USART_ICR_FECF_Pos: u32 = 1;
pub const USART_ICR_FECF_Msk: u32 = 2;
pub const USART_ICR_FECF: u32 = 2;
pub const USART_ICR_NECF_Pos: u32 = 2;
pub const USART_ICR_NECF_Msk: u32 = 4;
pub const USART_ICR_NECF: u32 = 4;
pub const USART_ICR_ORECF_Pos: u32 = 3;
pub const USART_ICR_ORECF_Msk: u32 = 8;
pub const USART_ICR_ORECF: u32 = 8;
pub const USART_ICR_IDLECF_Pos: u32 = 4;
pub const USART_ICR_IDLECF_Msk: u32 = 16;
pub const USART_ICR_IDLECF: u32 = 16;
pub const USART_ICR_TCCF_Pos: u32 = 6;
pub const USART_ICR_TCCF_Msk: u32 = 64;
pub const USART_ICR_TCCF: u32 = 64;
pub const USART_ICR_LBDCF_Pos: u32 = 8;
pub const USART_ICR_LBDCF_Msk: u32 = 256;
pub const USART_ICR_LBDCF: u32 = 256;
pub const USART_ICR_CTSCF_Pos: u32 = 9;
pub const USART_ICR_CTSCF_Msk: u32 = 512;
pub const USART_ICR_CTSCF: u32 = 512;
pub const USART_ICR_RTOCF_Pos: u32 = 11;
pub const USART_ICR_RTOCF_Msk: u32 = 2048;
pub const USART_ICR_RTOCF: u32 = 2048;
pub const USART_ICR_EOBCF_Pos: u32 = 12;
pub const USART_ICR_EOBCF_Msk: u32 = 4096;
pub const USART_ICR_EOBCF: u32 = 4096;
pub const USART_ICR_CMCF_Pos: u32 = 17;
pub const USART_ICR_CMCF_Msk: u32 = 131072;
pub const USART_ICR_CMCF: u32 = 131072;
pub const USART_ICR_WUCF_Pos: u32 = 20;
pub const USART_ICR_WUCF_Msk: u32 = 1048576;
pub const USART_ICR_WUCF: u32 = 1048576;
pub const USART_ICR_NCF_Pos: u32 = 2;
pub const USART_ICR_NCF_Msk: u32 = 4;
pub const USART_ICR_NCF: u32 = 4;
pub const USART_RDR_RDR_Pos: u32 = 0;
pub const USART_RDR_RDR_Msk: u32 = 511;
pub const USART_RDR_RDR: u32 = 511;
pub const USART_TDR_TDR_Pos: u32 = 0;
pub const USART_TDR_TDR_Msk: u32 = 511;
pub const USART_TDR_TDR: u32 = 511;
pub const SWPMI_CR_RXDMA_Pos: u32 = 0;
pub const SWPMI_CR_RXDMA_Msk: u32 = 1;
pub const SWPMI_CR_RXDMA: u32 = 1;
pub const SWPMI_CR_TXDMA_Pos: u32 = 1;
pub const SWPMI_CR_TXDMA_Msk: u32 = 2;
pub const SWPMI_CR_TXDMA: u32 = 2;
pub const SWPMI_CR_RXMODE_Pos: u32 = 2;
pub const SWPMI_CR_RXMODE_Msk: u32 = 4;
pub const SWPMI_CR_RXMODE: u32 = 4;
pub const SWPMI_CR_TXMODE_Pos: u32 = 3;
pub const SWPMI_CR_TXMODE_Msk: u32 = 8;
pub const SWPMI_CR_TXMODE: u32 = 8;
pub const SWPMI_CR_LPBK_Pos: u32 = 4;
pub const SWPMI_CR_LPBK_Msk: u32 = 16;
pub const SWPMI_CR_LPBK: u32 = 16;
pub const SWPMI_CR_SWPACT_Pos: u32 = 5;
pub const SWPMI_CR_SWPACT_Msk: u32 = 32;
pub const SWPMI_CR_SWPACT: u32 = 32;
pub const SWPMI_CR_DEACT_Pos: u32 = 10;
pub const SWPMI_CR_DEACT_Msk: u32 = 1024;
pub const SWPMI_CR_DEACT: u32 = 1024;
pub const SWPMI_BRR_BR_Pos: u32 = 0;
pub const SWPMI_BRR_BR_Msk: u32 = 63;
pub const SWPMI_BRR_BR: u32 = 63;
pub const SWPMI_ISR_RXBFF_Pos: u32 = 0;
pub const SWPMI_ISR_RXBFF_Msk: u32 = 1;
pub const SWPMI_ISR_RXBFF: u32 = 1;
pub const SWPMI_ISR_TXBEF_Pos: u32 = 1;
pub const SWPMI_ISR_TXBEF_Msk: u32 = 2;
pub const SWPMI_ISR_TXBEF: u32 = 2;
pub const SWPMI_ISR_RXBERF_Pos: u32 = 2;
pub const SWPMI_ISR_RXBERF_Msk: u32 = 4;
pub const SWPMI_ISR_RXBERF: u32 = 4;
pub const SWPMI_ISR_RXOVRF_Pos: u32 = 3;
pub const SWPMI_ISR_RXOVRF_Msk: u32 = 8;
pub const SWPMI_ISR_RXOVRF: u32 = 8;
pub const SWPMI_ISR_TXUNRF_Pos: u32 = 4;
pub const SWPMI_ISR_TXUNRF_Msk: u32 = 16;
pub const SWPMI_ISR_TXUNRF: u32 = 16;
pub const SWPMI_ISR_RXNE_Pos: u32 = 5;
pub const SWPMI_ISR_RXNE_Msk: u32 = 32;
pub const SWPMI_ISR_RXNE: u32 = 32;
pub const SWPMI_ISR_TXE_Pos: u32 = 6;
pub const SWPMI_ISR_TXE_Msk: u32 = 64;
pub const SWPMI_ISR_TXE: u32 = 64;
pub const SWPMI_ISR_TCF_Pos: u32 = 7;
pub const SWPMI_ISR_TCF_Msk: u32 = 128;
pub const SWPMI_ISR_TCF: u32 = 128;
pub const SWPMI_ISR_SRF_Pos: u32 = 8;
pub const SWPMI_ISR_SRF_Msk: u32 = 256;
pub const SWPMI_ISR_SRF: u32 = 256;
pub const SWPMI_ISR_SUSP_Pos: u32 = 9;
pub const SWPMI_ISR_SUSP_Msk: u32 = 512;
pub const SWPMI_ISR_SUSP: u32 = 512;
pub const SWPMI_ISR_DEACTF_Pos: u32 = 10;
pub const SWPMI_ISR_DEACTF_Msk: u32 = 1024;
pub const SWPMI_ISR_DEACTF: u32 = 1024;
pub const SWPMI_ICR_CRXBFF_Pos: u32 = 0;
pub const SWPMI_ICR_CRXBFF_Msk: u32 = 1;
pub const SWPMI_ICR_CRXBFF: u32 = 1;
pub const SWPMI_ICR_CTXBEF_Pos: u32 = 1;
pub const SWPMI_ICR_CTXBEF_Msk: u32 = 2;
pub const SWPMI_ICR_CTXBEF: u32 = 2;
pub const SWPMI_ICR_CRXBERF_Pos: u32 = 2;
pub const SWPMI_ICR_CRXBERF_Msk: u32 = 4;
pub const SWPMI_ICR_CRXBERF: u32 = 4;
pub const SWPMI_ICR_CRXOVRF_Pos: u32 = 3;
pub const SWPMI_ICR_CRXOVRF_Msk: u32 = 8;
pub const SWPMI_ICR_CRXOVRF: u32 = 8;
pub const SWPMI_ICR_CTXUNRF_Pos: u32 = 4;
pub const SWPMI_ICR_CTXUNRF_Msk: u32 = 16;
pub const SWPMI_ICR_CTXUNRF: u32 = 16;
pub const SWPMI_ICR_CTCF_Pos: u32 = 7;
pub const SWPMI_ICR_CTCF_Msk: u32 = 128;
pub const SWPMI_ICR_CTCF: u32 = 128;
pub const SWPMI_ICR_CSRF_Pos: u32 = 8;
pub const SWPMI_ICR_CSRF_Msk: u32 = 256;
pub const SWPMI_ICR_CSRF: u32 = 256;
pub const SWPMI_IER_SRIE_Pos: u32 = 8;
pub const SWPMI_IER_SRIE_Msk: u32 = 256;
pub const SWPMI_IER_SRIE: u32 = 256;
pub const SWPMI_IER_TCIE_Pos: u32 = 7;
pub const SWPMI_IER_TCIE_Msk: u32 = 128;
pub const SWPMI_IER_TCIE: u32 = 128;
pub const SWPMI_IER_TIE_Pos: u32 = 6;
pub const SWPMI_IER_TIE_Msk: u32 = 64;
pub const SWPMI_IER_TIE: u32 = 64;
pub const SWPMI_IER_RIE_Pos: u32 = 5;
pub const SWPMI_IER_RIE_Msk: u32 = 32;
pub const SWPMI_IER_RIE: u32 = 32;
pub const SWPMI_IER_TXUNRIE_Pos: u32 = 4;
pub const SWPMI_IER_TXUNRIE_Msk: u32 = 16;
pub const SWPMI_IER_TXUNRIE: u32 = 16;
pub const SWPMI_IER_RXOVRIE_Pos: u32 = 3;
pub const SWPMI_IER_RXOVRIE_Msk: u32 = 8;
pub const SWPMI_IER_RXOVRIE: u32 = 8;
pub const SWPMI_IER_RXBERIE_Pos: u32 = 2;
pub const SWPMI_IER_RXBERIE_Msk: u32 = 4;
pub const SWPMI_IER_RXBERIE: u32 = 4;
pub const SWPMI_IER_TXBEIE_Pos: u32 = 1;
pub const SWPMI_IER_TXBEIE_Msk: u32 = 2;
pub const SWPMI_IER_TXBEIE: u32 = 2;
pub const SWPMI_IER_RXBFIE_Pos: u32 = 0;
pub const SWPMI_IER_RXBFIE_Msk: u32 = 1;
pub const SWPMI_IER_RXBFIE: u32 = 1;
pub const SWPMI_RFL_RFL_Pos: u32 = 0;
pub const SWPMI_RFL_RFL_Msk: u32 = 31;
pub const SWPMI_RFL_RFL: u32 = 31;
pub const SWPMI_RFL_RFL_0_1_Pos: u32 = 0;
pub const SWPMI_RFL_RFL_0_1_Msk: u32 = 3;
pub const SWPMI_RFL_RFL_0_1: u32 = 3;
pub const SWPMI_TDR_TD_Pos: u32 = 0;
pub const SWPMI_TDR_TD_Msk: u32 = 4294967295;
pub const SWPMI_TDR_TD: u32 = 4294967295;
pub const SWPMI_RDR_RD_Pos: u32 = 0;
pub const SWPMI_RDR_RD_Msk: u32 = 4294967295;
pub const SWPMI_RDR_RD: u32 = 4294967295;
pub const SWPMI_OR_TBYP_Pos: u32 = 0;
pub const SWPMI_OR_TBYP_Msk: u32 = 1;
pub const SWPMI_OR_TBYP: u32 = 1;
pub const SWPMI_OR_CLASS_Pos: u32 = 1;
pub const SWPMI_OR_CLASS_Msk: u32 = 2;
pub const SWPMI_OR_CLASS: u32 = 2;
pub const VREFBUF_CSR_ENVR_Pos: u32 = 0;
pub const VREFBUF_CSR_ENVR_Msk: u32 = 1;
pub const VREFBUF_CSR_ENVR: u32 = 1;
pub const VREFBUF_CSR_HIZ_Pos: u32 = 1;
pub const VREFBUF_CSR_HIZ_Msk: u32 = 2;
pub const VREFBUF_CSR_HIZ: u32 = 2;
pub const VREFBUF_CSR_VRS_Pos: u32 = 2;
pub const VREFBUF_CSR_VRS_Msk: u32 = 4;
pub const VREFBUF_CSR_VRS: u32 = 4;
pub const VREFBUF_CSR_VRR_Pos: u32 = 3;
pub const VREFBUF_CSR_VRR_Msk: u32 = 8;
pub const VREFBUF_CSR_VRR: u32 = 8;
pub const VREFBUF_CCR_TRIM_Pos: u32 = 0;
pub const VREFBUF_CCR_TRIM_Msk: u32 = 63;
pub const VREFBUF_CCR_TRIM: u32 = 63;
pub const WWDG_CR_T_Pos: u32 = 0;
pub const WWDG_CR_T_Msk: u32 = 127;
pub const WWDG_CR_T: u32 = 127;
pub const WWDG_CR_T_0: u32 = 1;
pub const WWDG_CR_T_1: u32 = 2;
pub const WWDG_CR_T_2: u32 = 4;
pub const WWDG_CR_T_3: u32 = 8;
pub const WWDG_CR_T_4: u32 = 16;
pub const WWDG_CR_T_5: u32 = 32;
pub const WWDG_CR_T_6: u32 = 64;
pub const WWDG_CR_WDGA_Pos: u32 = 7;
pub const WWDG_CR_WDGA_Msk: u32 = 128;
pub const WWDG_CR_WDGA: u32 = 128;
pub const WWDG_CFR_W_Pos: u32 = 0;
pub const WWDG_CFR_W_Msk: u32 = 127;
pub const WWDG_CFR_W: u32 = 127;
pub const WWDG_CFR_W_0: u32 = 1;
pub const WWDG_CFR_W_1: u32 = 2;
pub const WWDG_CFR_W_2: u32 = 4;
pub const WWDG_CFR_W_3: u32 = 8;
pub const WWDG_CFR_W_4: u32 = 16;
pub const WWDG_CFR_W_5: u32 = 32;
pub const WWDG_CFR_W_6: u32 = 64;
pub const WWDG_CFR_WDGTB_Pos: u32 = 7;
pub const WWDG_CFR_WDGTB_Msk: u32 = 384;
pub const WWDG_CFR_WDGTB: u32 = 384;
pub const WWDG_CFR_WDGTB_0: u32 = 128;
pub const WWDG_CFR_WDGTB_1: u32 = 256;
pub const WWDG_CFR_EWI_Pos: u32 = 9;
pub const WWDG_CFR_EWI_Msk: u32 = 512;
pub const WWDG_CFR_EWI: u32 = 512;
pub const WWDG_SR_EWIF_Pos: u32 = 0;
pub const WWDG_SR_EWIF_Msk: u32 = 1;
pub const WWDG_SR_EWIF: u32 = 1;
pub const DBGMCU_IDCODE_DEV_ID_Pos: u32 = 0;
pub const DBGMCU_IDCODE_DEV_ID_Msk: u32 = 4095;
pub const DBGMCU_IDCODE_DEV_ID: u32 = 4095;
pub const DBGMCU_IDCODE_REV_ID_Pos: u32 = 16;
pub const DBGMCU_IDCODE_REV_ID_Msk: u32 = 4294901760;
pub const DBGMCU_IDCODE_REV_ID: u32 = 4294901760;
pub const DBGMCU_CR_DBG_SLEEP_Pos: u32 = 0;
pub const DBGMCU_CR_DBG_SLEEP_Msk: u32 = 1;
pub const DBGMCU_CR_DBG_SLEEP: u32 = 1;
pub const DBGMCU_CR_DBG_STOP_Pos: u32 = 1;
pub const DBGMCU_CR_DBG_STOP_Msk: u32 = 2;
pub const DBGMCU_CR_DBG_STOP: u32 = 2;
pub const DBGMCU_CR_DBG_STANDBY_Pos: u32 = 2;
pub const DBGMCU_CR_DBG_STANDBY_Msk: u32 = 4;
pub const DBGMCU_CR_DBG_STANDBY: u32 = 4;
pub const DBGMCU_CR_TRACE_IOEN_Pos: u32 = 5;
pub const DBGMCU_CR_TRACE_IOEN_Msk: u32 = 32;
pub const DBGMCU_CR_TRACE_IOEN: u32 = 32;
pub const DBGMCU_CR_TRACE_MODE_Pos: u32 = 6;
pub const DBGMCU_CR_TRACE_MODE_Msk: u32 = 192;
pub const DBGMCU_CR_TRACE_MODE: u32 = 192;
pub const DBGMCU_CR_TRACE_MODE_0: u32 = 64;
pub const DBGMCU_CR_TRACE_MODE_1: u32 = 128;
pub const DBGMCU_APB1FZR1_DBG_TIM2_STOP_Pos: u32 = 0;
pub const DBGMCU_APB1FZR1_DBG_TIM2_STOP_Msk: u32 = 1;
pub const DBGMCU_APB1FZR1_DBG_TIM2_STOP: u32 = 1;
pub const DBGMCU_APB1FZR1_DBG_TIM3_STOP_Pos: u32 = 1;
pub const DBGMCU_APB1FZR1_DBG_TIM3_STOP_Msk: u32 = 2;
pub const DBGMCU_APB1FZR1_DBG_TIM3_STOP: u32 = 2;
pub const DBGMCU_APB1FZR1_DBG_TIM4_STOP_Pos: u32 = 2;
pub const DBGMCU_APB1FZR1_DBG_TIM4_STOP_Msk: u32 = 4;
pub const DBGMCU_APB1FZR1_DBG_TIM4_STOP: u32 = 4;
pub const DBGMCU_APB1FZR1_DBG_TIM5_STOP_Pos: u32 = 3;
pub const DBGMCU_APB1FZR1_DBG_TIM5_STOP_Msk: u32 = 8;
pub const DBGMCU_APB1FZR1_DBG_TIM5_STOP: u32 = 8;
pub const DBGMCU_APB1FZR1_DBG_TIM6_STOP_Pos: u32 = 4;
pub const DBGMCU_APB1FZR1_DBG_TIM6_STOP_Msk: u32 = 16;
pub const DBGMCU_APB1FZR1_DBG_TIM6_STOP: u32 = 16;
pub const DBGMCU_APB1FZR1_DBG_TIM7_STOP_Pos: u32 = 5;
pub const DBGMCU_APB1FZR1_DBG_TIM7_STOP_Msk: u32 = 32;
pub const DBGMCU_APB1FZR1_DBG_TIM7_STOP: u32 = 32;
pub const DBGMCU_APB1FZR1_DBG_RTC_STOP_Pos: u32 = 10;
pub const DBGMCU_APB1FZR1_DBG_RTC_STOP_Msk: u32 = 1024;
pub const DBGMCU_APB1FZR1_DBG_RTC_STOP: u32 = 1024;
pub const DBGMCU_APB1FZR1_DBG_WWDG_STOP_Pos: u32 = 11;
pub const DBGMCU_APB1FZR1_DBG_WWDG_STOP_Msk: u32 = 2048;
pub const DBGMCU_APB1FZR1_DBG_WWDG_STOP: u32 = 2048;
pub const DBGMCU_APB1FZR1_DBG_IWDG_STOP_Pos: u32 = 12;
pub const DBGMCU_APB1FZR1_DBG_IWDG_STOP_Msk: u32 = 4096;
pub const DBGMCU_APB1FZR1_DBG_IWDG_STOP: u32 = 4096;
pub const DBGMCU_APB1FZR1_DBG_I2C1_STOP_Pos: u32 = 21;
pub const DBGMCU_APB1FZR1_DBG_I2C1_STOP_Msk: u32 = 2097152;
pub const DBGMCU_APB1FZR1_DBG_I2C1_STOP: u32 = 2097152;
pub const DBGMCU_APB1FZR1_DBG_I2C2_STOP_Pos: u32 = 22;
pub const DBGMCU_APB1FZR1_DBG_I2C2_STOP_Msk: u32 = 4194304;
pub const DBGMCU_APB1FZR1_DBG_I2C2_STOP: u32 = 4194304;
pub const DBGMCU_APB1FZR1_DBG_I2C3_STOP_Pos: u32 = 23;
pub const DBGMCU_APB1FZR1_DBG_I2C3_STOP_Msk: u32 = 8388608;
pub const DBGMCU_APB1FZR1_DBG_I2C3_STOP: u32 = 8388608;
pub const DBGMCU_APB1FZR1_DBG_CAN_STOP_Pos: u32 = 25;
pub const DBGMCU_APB1FZR1_DBG_CAN_STOP_Msk: u32 = 33554432;
pub const DBGMCU_APB1FZR1_DBG_CAN_STOP: u32 = 33554432;
pub const DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Pos: u32 = 31;
pub const DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Msk: u32 = 2147483648;
pub const DBGMCU_APB1FZR1_DBG_LPTIM1_STOP: u32 = 2147483648;
pub const DBGMCU_APB1FZR2_DBG_LPTIM2_STOP_Pos: u32 = 5;
pub const DBGMCU_APB1FZR2_DBG_LPTIM2_STOP_Msk: u32 = 32;
pub const DBGMCU_APB1FZR2_DBG_LPTIM2_STOP: u32 = 32;
pub const DBGMCU_APB2FZ_DBG_TIM1_STOP_Pos: u32 = 11;
pub const DBGMCU_APB2FZ_DBG_TIM1_STOP_Msk: u32 = 2048;
pub const DBGMCU_APB2FZ_DBG_TIM1_STOP: u32 = 2048;
pub const DBGMCU_APB2FZ_DBG_TIM8_STOP_Pos: u32 = 13;
pub const DBGMCU_APB2FZ_DBG_TIM8_STOP_Msk: u32 = 8192;
pub const DBGMCU_APB2FZ_DBG_TIM8_STOP: u32 = 8192;
pub const DBGMCU_APB2FZ_DBG_TIM15_STOP_Pos: u32 = 16;
pub const DBGMCU_APB2FZ_DBG_TIM15_STOP_Msk: u32 = 65536;
pub const DBGMCU_APB2FZ_DBG_TIM15_STOP: u32 = 65536;
pub const DBGMCU_APB2FZ_DBG_TIM16_STOP_Pos: u32 = 17;
pub const DBGMCU_APB2FZ_DBG_TIM16_STOP_Msk: u32 = 131072;
pub const DBGMCU_APB2FZ_DBG_TIM16_STOP: u32 = 131072;
pub const DBGMCU_APB2FZ_DBG_TIM17_STOP_Pos: u32 = 18;
pub const DBGMCU_APB2FZ_DBG_TIM17_STOP_Msk: u32 = 262144;
pub const DBGMCU_APB2FZ_DBG_TIM17_STOP: u32 = 262144;
pub const USB_OTG_GOTGCTL_SRQSCS_Pos: u32 = 0;
pub const USB_OTG_GOTGCTL_SRQSCS_Msk: u32 = 1;
pub const USB_OTG_GOTGCTL_SRQSCS: u32 = 1;
pub const USB_OTG_GOTGCTL_SRQ_Pos: u32 = 1;
pub const USB_OTG_GOTGCTL_SRQ_Msk: u32 = 2;
pub const USB_OTG_GOTGCTL_SRQ: u32 = 2;
pub const USB_OTG_GOTGCTL_VBVALOEN_Pos: u32 = 2;
pub const USB_OTG_GOTGCTL_VBVALOEN_Msk: u32 = 4;
pub const USB_OTG_GOTGCTL_VBVALOEN: u32 = 4;
pub const USB_OTG_GOTGCTL_VBVALOVAL_Pos: u32 = 3;
pub const USB_OTG_GOTGCTL_VBVALOVAL_Msk: u32 = 8;
pub const USB_OTG_GOTGCTL_VBVALOVAL: u32 = 8;
pub const USB_OTG_GOTGCTL_AVALOEN_Pos: u32 = 4;
pub const USB_OTG_GOTGCTL_AVALOEN_Msk: u32 = 16;
pub const USB_OTG_GOTGCTL_AVALOEN: u32 = 16;
pub const USB_OTG_GOTGCTL_AVALOVAL_Pos: u32 = 5;
pub const USB_OTG_GOTGCTL_AVALOVAL_Msk: u32 = 32;
pub const USB_OTG_GOTGCTL_AVALOVAL: u32 = 32;
pub const USB_OTG_GOTGCTL_BVALOEN_Pos: u32 = 6;
pub const USB_OTG_GOTGCTL_BVALOEN_Msk: u32 = 64;
pub const USB_OTG_GOTGCTL_BVALOEN: u32 = 64;
pub const USB_OTG_GOTGCTL_BVALOVAL_Pos: u32 = 7;
pub const USB_OTG_GOTGCTL_BVALOVAL_Msk: u32 = 128;
pub const USB_OTG_GOTGCTL_BVALOVAL: u32 = 128;
pub const USB_OTG_GOTGCTL_BSESVLD_Pos: u32 = 19;
pub const USB_OTG_GOTGCTL_BSESVLD_Msk: u32 = 524288;
pub const USB_OTG_GOTGCTL_BSESVLD: u32 = 524288;
pub const USB_OTG_GOTGINT_SEDET_Pos: u32 = 2;
pub const USB_OTG_GOTGINT_SEDET_Msk: u32 = 4;
pub const USB_OTG_GOTGINT_SEDET: u32 = 4;
pub const USB_OTG_GOTGINT_SRSSCHG_Pos: u32 = 8;
pub const USB_OTG_GOTGINT_SRSSCHG_Msk: u32 = 256;
pub const USB_OTG_GOTGINT_SRSSCHG: u32 = 256;
pub const USB_OTG_GOTGINT_HNSSCHG_Pos: u32 = 9;
pub const USB_OTG_GOTGINT_HNSSCHG_Msk: u32 = 512;
pub const USB_OTG_GOTGINT_HNSSCHG: u32 = 512;
pub const USB_OTG_GOTGINT_HNGDET_Pos: u32 = 17;
pub const USB_OTG_GOTGINT_HNGDET_Msk: u32 = 131072;
pub const USB_OTG_GOTGINT_HNGDET: u32 = 131072;
pub const USB_OTG_GOTGINT_ADTOCHG_Pos: u32 = 18;
pub const USB_OTG_GOTGINT_ADTOCHG_Msk: u32 = 262144;
pub const USB_OTG_GOTGINT_ADTOCHG: u32 = 262144;
pub const USB_OTG_GOTGINT_DBCDNE_Pos: u32 = 19;
pub const USB_OTG_GOTGINT_DBCDNE_Msk: u32 = 524288;
pub const USB_OTG_GOTGINT_DBCDNE: u32 = 524288;
pub const USB_OTG_GAHBCFG_GINT_Pos: u32 = 0;
pub const USB_OTG_GAHBCFG_GINT_Msk: u32 = 1;
pub const USB_OTG_GAHBCFG_GINT: u32 = 1;
pub const USB_OTG_GAHBCFG_HBSTLEN_Pos: u32 = 1;
pub const USB_OTG_GAHBCFG_HBSTLEN_Msk: u32 = 30;
pub const USB_OTG_GAHBCFG_HBSTLEN: u32 = 30;
pub const USB_OTG_GAHBCFG_HBSTLEN_0: u32 = 2;
pub const USB_OTG_GAHBCFG_HBSTLEN_1: u32 = 4;
pub const USB_OTG_GAHBCFG_HBSTLEN_2: u32 = 8;
pub const USB_OTG_GAHBCFG_HBSTLEN_3: u32 = 16;
pub const USB_OTG_GAHBCFG_DMAEN_Pos: u32 = 5;
pub const USB_OTG_GAHBCFG_DMAEN_Msk: u32 = 32;
pub const USB_OTG_GAHBCFG_DMAEN: u32 = 32;
pub const USB_OTG_GAHBCFG_TXFELVL_Pos: u32 = 7;
pub const USB_OTG_GAHBCFG_TXFELVL_Msk: u32 = 128;
pub const USB_OTG_GAHBCFG_TXFELVL: u32 = 128;
pub const USB_OTG_GAHBCFG_PTXFELVL_Pos: u32 = 8;
pub const USB_OTG_GAHBCFG_PTXFELVL_Msk: u32 = 256;
pub const USB_OTG_GAHBCFG_PTXFELVL: u32 = 256;
pub const USB_OTG_GUSBCFG_TOCAL_Pos: u32 = 0;
pub const USB_OTG_GUSBCFG_TOCAL_Msk: u32 = 7;
pub const USB_OTG_GUSBCFG_TOCAL: u32 = 7;
pub const USB_OTG_GUSBCFG_TOCAL_0: u32 = 1;
pub const USB_OTG_GUSBCFG_TOCAL_1: u32 = 2;
pub const USB_OTG_GUSBCFG_TOCAL_2: u32 = 4;
pub const USB_OTG_GUSBCFG_PHYSEL_Pos: u32 = 6;
pub const USB_OTG_GUSBCFG_PHYSEL_Msk: u32 = 64;
pub const USB_OTG_GUSBCFG_PHYSEL: u32 = 64;
pub const USB_OTG_GUSBCFG_SRPCAP_Pos: u32 = 8;
pub const USB_OTG_GUSBCFG_SRPCAP_Msk: u32 = 256;
pub const USB_OTG_GUSBCFG_SRPCAP: u32 = 256;
pub const USB_OTG_GUSBCFG_HNPCAP_Pos: u32 = 9;
pub const USB_OTG_GUSBCFG_HNPCAP_Msk: u32 = 512;
pub const USB_OTG_GUSBCFG_HNPCAP: u32 = 512;
pub const USB_OTG_GUSBCFG_TRDT_Pos: u32 = 10;
pub const USB_OTG_GUSBCFG_TRDT_Msk: u32 = 15360;
pub const USB_OTG_GUSBCFG_TRDT: u32 = 15360;
pub const USB_OTG_GUSBCFG_TRDT_0: u32 = 1024;
pub const USB_OTG_GUSBCFG_TRDT_1: u32 = 2048;
pub const USB_OTG_GUSBCFG_TRDT_2: u32 = 4096;
pub const USB_OTG_GUSBCFG_TRDT_3: u32 = 8192;
pub const USB_OTG_GUSBCFG_PHYLPCS_Pos: u32 = 15;
pub const USB_OTG_GUSBCFG_PHYLPCS_Msk: u32 = 32768;
pub const USB_OTG_GUSBCFG_PHYLPCS: u32 = 32768;
pub const USB_OTG_GUSBCFG_ULPIFSLS_Pos: u32 = 17;
pub const USB_OTG_GUSBCFG_ULPIFSLS_Msk: u32 = 131072;
pub const USB_OTG_GUSBCFG_ULPIFSLS: u32 = 131072;
pub const USB_OTG_GUSBCFG_ULPIAR_Pos: u32 = 18;
pub const USB_OTG_GUSBCFG_ULPIAR_Msk: u32 = 262144;
pub const USB_OTG_GUSBCFG_ULPIAR: u32 = 262144;
pub const USB_OTG_GUSBCFG_ULPICSM_Pos: u32 = 19;
pub const USB_OTG_GUSBCFG_ULPICSM_Msk: u32 = 524288;
pub const USB_OTG_GUSBCFG_ULPICSM: u32 = 524288;
pub const USB_OTG_GUSBCFG_ULPIEVBUSD_Pos: u32 = 20;
pub const USB_OTG_GUSBCFG_ULPIEVBUSD_Msk: u32 = 1048576;
pub const USB_OTG_GUSBCFG_ULPIEVBUSD: u32 = 1048576;
pub const USB_OTG_GUSBCFG_ULPIEVBUSI_Pos: u32 = 21;
pub const USB_OTG_GUSBCFG_ULPIEVBUSI_Msk: u32 = 2097152;
pub const USB_OTG_GUSBCFG_ULPIEVBUSI: u32 = 2097152;
pub const USB_OTG_GUSBCFG_TSDPS_Pos: u32 = 22;
pub const USB_OTG_GUSBCFG_TSDPS_Msk: u32 = 4194304;
pub const USB_OTG_GUSBCFG_TSDPS: u32 = 4194304;
pub const USB_OTG_GUSBCFG_PCCI_Pos: u32 = 23;
pub const USB_OTG_GUSBCFG_PCCI_Msk: u32 = 8388608;
pub const USB_OTG_GUSBCFG_PCCI: u32 = 8388608;
pub const USB_OTG_GUSBCFG_PTCI_Pos: u32 = 24;
pub const USB_OTG_GUSBCFG_PTCI_Msk: u32 = 16777216;
pub const USB_OTG_GUSBCFG_PTCI: u32 = 16777216;
pub const USB_OTG_GUSBCFG_ULPIIPD_Pos: u32 = 25;
pub const USB_OTG_GUSBCFG_ULPIIPD_Msk: u32 = 33554432;
pub const USB_OTG_GUSBCFG_ULPIIPD: u32 = 33554432;
pub const USB_OTG_GUSBCFG_FHMOD_Pos: u32 = 29;
pub const USB_OTG_GUSBCFG_FHMOD_Msk: u32 = 536870912;
pub const USB_OTG_GUSBCFG_FHMOD: u32 = 536870912;
pub const USB_OTG_GUSBCFG_FDMOD_Pos: u32 = 30;
pub const USB_OTG_GUSBCFG_FDMOD_Msk: u32 = 1073741824;
pub const USB_OTG_GUSBCFG_FDMOD: u32 = 1073741824;
pub const USB_OTG_GUSBCFG_CTXPKT_Pos: u32 = 31;
pub const USB_OTG_GUSBCFG_CTXPKT_Msk: u32 = 2147483648;
pub const USB_OTG_GUSBCFG_CTXPKT: u32 = 2147483648;
pub const USB_OTG_GRSTCTL_CSRST_Pos: u32 = 0;
pub const USB_OTG_GRSTCTL_CSRST_Msk: u32 = 1;
pub const USB_OTG_GRSTCTL_CSRST: u32 = 1;
pub const USB_OTG_GRSTCTL_HSRST_Pos: u32 = 1;
pub const USB_OTG_GRSTCTL_HSRST_Msk: u32 = 2;
pub const USB_OTG_GRSTCTL_HSRST: u32 = 2;
pub const USB_OTG_GRSTCTL_FCRST_Pos: u32 = 2;
pub const USB_OTG_GRSTCTL_FCRST_Msk: u32 = 4;
pub const USB_OTG_GRSTCTL_FCRST: u32 = 4;
pub const USB_OTG_GRSTCTL_RXFFLSH_Pos: u32 = 4;
pub const USB_OTG_GRSTCTL_RXFFLSH_Msk: u32 = 16;
pub const USB_OTG_GRSTCTL_RXFFLSH: u32 = 16;
pub const USB_OTG_GRSTCTL_TXFFLSH_Pos: u32 = 5;
pub const USB_OTG_GRSTCTL_TXFFLSH_Msk: u32 = 32;
pub const USB_OTG_GRSTCTL_TXFFLSH: u32 = 32;
pub const USB_OTG_GRSTCTL_TXFNUM_Pos: u32 = 6;
pub const USB_OTG_GRSTCTL_TXFNUM_Msk: u32 = 1984;
pub const USB_OTG_GRSTCTL_TXFNUM: u32 = 1984;
pub const USB_OTG_GRSTCTL_TXFNUM_0: u32 = 64;
pub const USB_OTG_GRSTCTL_TXFNUM_1: u32 = 128;
pub const USB_OTG_GRSTCTL_TXFNUM_2: u32 = 256;
pub const USB_OTG_GRSTCTL_TXFNUM_3: u32 = 512;
pub const USB_OTG_GRSTCTL_TXFNUM_4: u32 = 1024;
pub const USB_OTG_GRSTCTL_DMAREQ_Pos: u32 = 30;
pub const USB_OTG_GRSTCTL_DMAREQ_Msk: u32 = 1073741824;
pub const USB_OTG_GRSTCTL_DMAREQ: u32 = 1073741824;
pub const USB_OTG_GRSTCTL_AHBIDL_Pos: u32 = 31;
pub const USB_OTG_GRSTCTL_AHBIDL_Msk: u32 = 2147483648;
pub const USB_OTG_GRSTCTL_AHBIDL: u32 = 2147483648;
pub const USB_OTG_GINTSTS_CMOD_Pos: u32 = 0;
pub const USB_OTG_GINTSTS_CMOD_Msk: u32 = 1;
pub const USB_OTG_GINTSTS_CMOD: u32 = 1;
pub const USB_OTG_GINTSTS_MMIS_Pos: u32 = 1;
pub const USB_OTG_GINTSTS_MMIS_Msk: u32 = 2;
pub const USB_OTG_GINTSTS_MMIS: u32 = 2;
pub const USB_OTG_GINTSTS_OTGINT_Pos: u32 = 2;
pub const USB_OTG_GINTSTS_OTGINT_Msk: u32 = 4;
pub const USB_OTG_GINTSTS_OTGINT: u32 = 4;
pub const USB_OTG_GINTSTS_SOF_Pos: u32 = 3;
pub const USB_OTG_GINTSTS_SOF_Msk: u32 = 8;
pub const USB_OTG_GINTSTS_SOF: u32 = 8;
pub const USB_OTG_GINTSTS_RXFLVL_Pos: u32 = 4;
pub const USB_OTG_GINTSTS_RXFLVL_Msk: u32 = 16;
pub const USB_OTG_GINTSTS_RXFLVL: u32 = 16;
pub const USB_OTG_GINTSTS_NPTXFE_Pos: u32 = 5;
pub const USB_OTG_GINTSTS_NPTXFE_Msk: u32 = 32;
pub const USB_OTG_GINTSTS_NPTXFE: u32 = 32;
pub const USB_OTG_GINTSTS_GINAKEFF_Pos: u32 = 6;
pub const USB_OTG_GINTSTS_GINAKEFF_Msk: u32 = 64;
pub const USB_OTG_GINTSTS_GINAKEFF: u32 = 64;
pub const USB_OTG_GINTSTS_BOUTNAKEFF_Pos: u32 = 7;
pub const USB_OTG_GINTSTS_BOUTNAKEFF_Msk: u32 = 128;
pub const USB_OTG_GINTSTS_BOUTNAKEFF: u32 = 128;
pub const USB_OTG_GINTSTS_ESUSP_Pos: u32 = 10;
pub const USB_OTG_GINTSTS_ESUSP_Msk: u32 = 1024;
pub const USB_OTG_GINTSTS_ESUSP: u32 = 1024;
pub const USB_OTG_GINTSTS_USBSUSP_Pos: u32 = 11;
pub const USB_OTG_GINTSTS_USBSUSP_Msk: u32 = 2048;
pub const USB_OTG_GINTSTS_USBSUSP: u32 = 2048;
pub const USB_OTG_GINTSTS_USBRST_Pos: u32 = 12;
pub const USB_OTG_GINTSTS_USBRST_Msk: u32 = 4096;
pub const USB_OTG_GINTSTS_USBRST: u32 = 4096;
pub const USB_OTG_GINTSTS_ENUMDNE_Pos: u32 = 13;
pub const USB_OTG_GINTSTS_ENUMDNE_Msk: u32 = 8192;
pub const USB_OTG_GINTSTS_ENUMDNE: u32 = 8192;
pub const USB_OTG_GINTSTS_ISOODRP_Pos: u32 = 14;
pub const USB_OTG_GINTSTS_ISOODRP_Msk: u32 = 16384;
pub const USB_OTG_GINTSTS_ISOODRP: u32 = 16384;
pub const USB_OTG_GINTSTS_EOPF_Pos: u32 = 15;
pub const USB_OTG_GINTSTS_EOPF_Msk: u32 = 32768;
pub const USB_OTG_GINTSTS_EOPF: u32 = 32768;
pub const USB_OTG_GINTSTS_IEPINT_Pos: u32 = 18;
pub const USB_OTG_GINTSTS_IEPINT_Msk: u32 = 262144;
pub const USB_OTG_GINTSTS_IEPINT: u32 = 262144;
pub const USB_OTG_GINTSTS_OEPINT_Pos: u32 = 19;
pub const USB_OTG_GINTSTS_OEPINT_Msk: u32 = 524288;
pub const USB_OTG_GINTSTS_OEPINT: u32 = 524288;
pub const USB_OTG_GINTSTS_IISOIXFR_Pos: u32 = 20;
pub const USB_OTG_GINTSTS_IISOIXFR_Msk: u32 = 1048576;
pub const USB_OTG_GINTSTS_IISOIXFR: u32 = 1048576;
pub const USB_OTG_GINTSTS_PXFR_INCOMPISOOUT_Pos: u32 = 21;
pub const USB_OTG_GINTSTS_PXFR_INCOMPISOOUT_Msk: u32 = 2097152;
pub const USB_OTG_GINTSTS_PXFR_INCOMPISOOUT: u32 = 2097152;
pub const USB_OTG_GINTSTS_DATAFSUSP_Pos: u32 = 22;
pub const USB_OTG_GINTSTS_DATAFSUSP_Msk: u32 = 4194304;
pub const USB_OTG_GINTSTS_DATAFSUSP: u32 = 4194304;
pub const USB_OTG_GINTSTS_HPRTINT_Pos: u32 = 24;
pub const USB_OTG_GINTSTS_HPRTINT_Msk: u32 = 16777216;
pub const USB_OTG_GINTSTS_HPRTINT: u32 = 16777216;
pub const USB_OTG_GINTSTS_HCINT_Pos: u32 = 25;
pub const USB_OTG_GINTSTS_HCINT_Msk: u32 = 33554432;
pub const USB_OTG_GINTSTS_HCINT: u32 = 33554432;
pub const USB_OTG_GINTSTS_PTXFE_Pos: u32 = 26;
pub const USB_OTG_GINTSTS_PTXFE_Msk: u32 = 67108864;
pub const USB_OTG_GINTSTS_PTXFE: u32 = 67108864;
pub const USB_OTG_GINTSTS_LPMINT_Pos: u32 = 27;
pub const USB_OTG_GINTSTS_LPMINT_Msk: u32 = 134217728;
pub const USB_OTG_GINTSTS_LPMINT: u32 = 134217728;
pub const USB_OTG_GINTSTS_CIDSCHG_Pos: u32 = 28;
pub const USB_OTG_GINTSTS_CIDSCHG_Msk: u32 = 268435456;
pub const USB_OTG_GINTSTS_CIDSCHG: u32 = 268435456;
pub const USB_OTG_GINTSTS_DISCINT_Pos: u32 = 29;
pub const USB_OTG_GINTSTS_DISCINT_Msk: u32 = 536870912;
pub const USB_OTG_GINTSTS_DISCINT: u32 = 536870912;
pub const USB_OTG_GINTSTS_SRQINT_Pos: u32 = 30;
pub const USB_OTG_GINTSTS_SRQINT_Msk: u32 = 1073741824;
pub const USB_OTG_GINTSTS_SRQINT: u32 = 1073741824;
pub const USB_OTG_GINTSTS_WKUINT_Pos: u32 = 31;
pub const USB_OTG_GINTSTS_WKUINT_Msk: u32 = 2147483648;
pub const USB_OTG_GINTSTS_WKUINT: u32 = 2147483648;
pub const USB_OTG_GINTMSK_MMISM_Pos: u32 = 1;
pub const USB_OTG_GINTMSK_MMISM_Msk: u32 = 2;
pub const USB_OTG_GINTMSK_MMISM: u32 = 2;
pub const USB_OTG_GINTMSK_OTGINT_Pos: u32 = 2;
pub const USB_OTG_GINTMSK_OTGINT_Msk: u32 = 4;
pub const USB_OTG_GINTMSK_OTGINT: u32 = 4;
pub const USB_OTG_GINTMSK_SOFM_Pos: u32 = 3;
pub const USB_OTG_GINTMSK_SOFM_Msk: u32 = 8;
pub const USB_OTG_GINTMSK_SOFM: u32 = 8;
pub const USB_OTG_GINTMSK_RXFLVLM_Pos: u32 = 4;
pub const USB_OTG_GINTMSK_RXFLVLM_Msk: u32 = 16;
pub const USB_OTG_GINTMSK_RXFLVLM: u32 = 16;
pub const USB_OTG_GINTMSK_NPTXFEM_Pos: u32 = 5;
pub const USB_OTG_GINTMSK_NPTXFEM_Msk: u32 = 32;
pub const USB_OTG_GINTMSK_NPTXFEM: u32 = 32;
pub const USB_OTG_GINTMSK_GINAKEFFM_Pos: u32 = 6;
pub const USB_OTG_GINTMSK_GINAKEFFM_Msk: u32 = 64;
pub const USB_OTG_GINTMSK_GINAKEFFM: u32 = 64;
pub const USB_OTG_GINTMSK_GONAKEFFM_Pos: u32 = 7;
pub const USB_OTG_GINTMSK_GONAKEFFM_Msk: u32 = 128;
pub const USB_OTG_GINTMSK_GONAKEFFM: u32 = 128;
pub const USB_OTG_GINTMSK_ESUSPM_Pos: u32 = 10;
pub const USB_OTG_GINTMSK_ESUSPM_Msk: u32 = 1024;
pub const USB_OTG_GINTMSK_ESUSPM: u32 = 1024;
pub const USB_OTG_GINTMSK_USBSUSPM_Pos: u32 = 11;
pub const USB_OTG_GINTMSK_USBSUSPM_Msk: u32 = 2048;
pub const USB_OTG_GINTMSK_USBSUSPM: u32 = 2048;
pub const USB_OTG_GINTMSK_USBRST_Pos: u32 = 12;
pub const USB_OTG_GINTMSK_USBRST_Msk: u32 = 4096;
pub const USB_OTG_GINTMSK_USBRST: u32 = 4096;
pub const USB_OTG_GINTMSK_ENUMDNEM_Pos: u32 = 13;
pub const USB_OTG_GINTMSK_ENUMDNEM_Msk: u32 = 8192;
pub const USB_OTG_GINTMSK_ENUMDNEM: u32 = 8192;
pub const USB_OTG_GINTMSK_ISOODRPM_Pos: u32 = 14;
pub const USB_OTG_GINTMSK_ISOODRPM_Msk: u32 = 16384;
pub const USB_OTG_GINTMSK_ISOODRPM: u32 = 16384;
pub const USB_OTG_GINTMSK_EOPFM_Pos: u32 = 15;
pub const USB_OTG_GINTMSK_EOPFM_Msk: u32 = 32768;
pub const USB_OTG_GINTMSK_EOPFM: u32 = 32768;
pub const USB_OTG_GINTMSK_EPMISM_Pos: u32 = 17;
pub const USB_OTG_GINTMSK_EPMISM_Msk: u32 = 131072;
pub const USB_OTG_GINTMSK_EPMISM: u32 = 131072;
pub const USB_OTG_GINTMSK_IEPINT_Pos: u32 = 18;
pub const USB_OTG_GINTMSK_IEPINT_Msk: u32 = 262144;
pub const USB_OTG_GINTMSK_IEPINT: u32 = 262144;
pub const USB_OTG_GINTMSK_OEPINT_Pos: u32 = 19;
pub const USB_OTG_GINTMSK_OEPINT_Msk: u32 = 524288;
pub const USB_OTG_GINTMSK_OEPINT: u32 = 524288;
pub const USB_OTG_GINTMSK_IISOIXFRM_Pos: u32 = 20;
pub const USB_OTG_GINTMSK_IISOIXFRM_Msk: u32 = 1048576;
pub const USB_OTG_GINTMSK_IISOIXFRM: u32 = 1048576;
pub const USB_OTG_GINTMSK_PXFRM_IISOOXFRM_Pos: u32 = 21;
pub const USB_OTG_GINTMSK_PXFRM_IISOOXFRM_Msk: u32 = 2097152;
pub const USB_OTG_GINTMSK_PXFRM_IISOOXFRM: u32 = 2097152;
pub const USB_OTG_GINTMSK_FSUSPM_Pos: u32 = 22;
pub const USB_OTG_GINTMSK_FSUSPM_Msk: u32 = 4194304;
pub const USB_OTG_GINTMSK_FSUSPM: u32 = 4194304;
pub const USB_OTG_GINTMSK_PRTIM_Pos: u32 = 24;
pub const USB_OTG_GINTMSK_PRTIM_Msk: u32 = 16777216;
pub const USB_OTG_GINTMSK_PRTIM: u32 = 16777216;
pub const USB_OTG_GINTMSK_HCIM_Pos: u32 = 25;
pub const USB_OTG_GINTMSK_HCIM_Msk: u32 = 33554432;
pub const USB_OTG_GINTMSK_HCIM: u32 = 33554432;
pub const USB_OTG_GINTMSK_PTXFEM_Pos: u32 = 26;
pub const USB_OTG_GINTMSK_PTXFEM_Msk: u32 = 67108864;
pub const USB_OTG_GINTMSK_PTXFEM: u32 = 67108864;
pub const USB_OTG_GINTMSK_LPMINTM_Pos: u32 = 27;
pub const USB_OTG_GINTMSK_LPMINTM_Msk: u32 = 134217728;
pub const USB_OTG_GINTMSK_LPMINTM: u32 = 134217728;
pub const USB_OTG_GINTMSK_CIDSCHGM_Pos: u32 = 28;
pub const USB_OTG_GINTMSK_CIDSCHGM_Msk: u32 = 268435456;
pub const USB_OTG_GINTMSK_CIDSCHGM: u32 = 268435456;
pub const USB_OTG_GINTMSK_DISCINT_Pos: u32 = 29;
pub const USB_OTG_GINTMSK_DISCINT_Msk: u32 = 536870912;
pub const USB_OTG_GINTMSK_DISCINT: u32 = 536870912;
pub const USB_OTG_GINTMSK_SRQIM_Pos: u32 = 30;
pub const USB_OTG_GINTMSK_SRQIM_Msk: u32 = 1073741824;
pub const USB_OTG_GINTMSK_SRQIM: u32 = 1073741824;
pub const USB_OTG_GINTMSK_WUIM_Pos: u32 = 31;
pub const USB_OTG_GINTMSK_WUIM_Msk: u32 = 2147483648;
pub const USB_OTG_GINTMSK_WUIM: u32 = 2147483648;
pub const USB_OTG_CHNUM_Pos: u32 = 0;
pub const USB_OTG_CHNUM_Msk: u32 = 15;
pub const USB_OTG_CHNUM: u32 = 15;
pub const USB_OTG_CHNUM_0: u32 = 1;
pub const USB_OTG_CHNUM_1: u32 = 2;
pub const USB_OTG_CHNUM_2: u32 = 4;
pub const USB_OTG_CHNUM_3: u32 = 8;
pub const USB_OTG_EPNUM_Pos: u32 = 0;
pub const USB_OTG_EPNUM_Msk: u32 = 15;
pub const USB_OTG_EPNUM: u32 = 15;
pub const USB_OTG_EPNUM_0: u32 = 1;
pub const USB_OTG_EPNUM_1: u32 = 2;
pub const USB_OTG_EPNUM_2: u32 = 4;
pub const USB_OTG_EPNUM_3: u32 = 8;
pub const USB_OTG_FRMNUM_Pos: u32 = 21;
pub const USB_OTG_FRMNUM_Msk: u32 = 31457280;
pub const USB_OTG_FRMNUM: u32 = 31457280;
pub const USB_OTG_FRMNUM_0: u32 = 2097152;
pub const USB_OTG_FRMNUM_1: u32 = 4194304;
pub const USB_OTG_FRMNUM_2: u32 = 8388608;
pub const USB_OTG_FRMNUM_3: u32 = 16777216;
pub const USB_OTG_BCNT_Pos: u32 = 4;
pub const USB_OTG_BCNT_Msk: u32 = 32752;
pub const USB_OTG_BCNT: u32 = 32752;
pub const USB_OTG_DPID_Pos: u32 = 15;
pub const USB_OTG_DPID_Msk: u32 = 98304;
pub const USB_OTG_DPID: u32 = 98304;
pub const USB_OTG_DPID_0: u32 = 32768;
pub const USB_OTG_DPID_1: u32 = 65536;
pub const USB_OTG_PKTSTS_Pos: u32 = 17;
pub const USB_OTG_PKTSTS_Msk: u32 = 1966080;
pub const USB_OTG_PKTSTS: u32 = 1966080;
pub const USB_OTG_PKTSTS_0: u32 = 131072;
pub const USB_OTG_PKTSTS_1: u32 = 262144;
pub const USB_OTG_PKTSTS_2: u32 = 524288;
pub const USB_OTG_PKTSTS_3: u32 = 1048576;
pub const USB_OTG_GRXSTSP_EPNUM_Pos: u32 = 0;
pub const USB_OTG_GRXSTSP_EPNUM_Msk: u32 = 15;
pub const USB_OTG_GRXSTSP_EPNUM: u32 = 15;
pub const USB_OTG_GRXSTSP_BCNT_Pos: u32 = 4;
pub const USB_OTG_GRXSTSP_BCNT_Msk: u32 = 32752;
pub const USB_OTG_GRXSTSP_BCNT: u32 = 32752;
pub const USB_OTG_GRXSTSP_DPID_Pos: u32 = 15;
pub const USB_OTG_GRXSTSP_DPID_Msk: u32 = 98304;
pub const USB_OTG_GRXSTSP_DPID: u32 = 98304;
pub const USB_OTG_GRXSTSP_PKTSTS_Pos: u32 = 17;
pub const USB_OTG_GRXSTSP_PKTSTS_Msk: u32 = 1966080;
pub const USB_OTG_GRXSTSP_PKTSTS: u32 = 1966080;
pub const USB_OTG_GRXFSIZ_RXFD_Pos: u32 = 0;
pub const USB_OTG_GRXFSIZ_RXFD_Msk: u32 = 65535;
pub const USB_OTG_GRXFSIZ_RXFD: u32 = 65535;
pub const USB_OTG_NPTXFSA_Pos: u32 = 0;
pub const USB_OTG_NPTXFSA_Msk: u32 = 65535;
pub const USB_OTG_NPTXFSA: u32 = 65535;
pub const USB_OTG_NPTXFD_Pos: u32 = 16;
pub const USB_OTG_NPTXFD_Msk: u32 = 4294901760;
pub const USB_OTG_NPTXFD: u32 = 4294901760;
pub const USB_OTG_TX0FSA_Pos: u32 = 0;
pub const USB_OTG_TX0FSA_Msk: u32 = 65535;
pub const USB_OTG_TX0FSA: u32 = 65535;
pub const USB_OTG_TX0FD_Pos: u32 = 16;
pub const USB_OTG_TX0FD_Msk: u32 = 4294901760;
pub const USB_OTG_TX0FD: u32 = 4294901760;
pub const USB_OTG_GNPTXSTS_NPTXFSAV_Pos: u32 = 0;
pub const USB_OTG_GNPTXSTS_NPTXFSAV_Msk: u32 = 65535;
pub const USB_OTG_GNPTXSTS_NPTXFSAV: u32 = 65535;
pub const USB_OTG_GNPTXSTS_NPTQXSAV_Pos: u32 = 16;
pub const USB_OTG_GNPTXSTS_NPTQXSAV_Msk: u32 = 16711680;
pub const USB_OTG_GNPTXSTS_NPTQXSAV: u32 = 16711680;
pub const USB_OTG_GNPTXSTS_NPTQXSAV_0: u32 = 65536;
pub const USB_OTG_GNPTXSTS_NPTQXSAV_1: u32 = 131072;
pub const USB_OTG_GNPTXSTS_NPTQXSAV_2: u32 = 262144;
pub const USB_OTG_GNPTXSTS_NPTQXSAV_3: u32 = 524288;
pub const USB_OTG_GNPTXSTS_NPTQXSAV_4: u32 = 1048576;
pub const USB_OTG_GNPTXSTS_NPTQXSAV_5: u32 = 2097152;
pub const USB_OTG_GNPTXSTS_NPTQXSAV_6: u32 = 4194304;
pub const USB_OTG_GNPTXSTS_NPTQXSAV_7: u32 = 8388608;
pub const USB_OTG_GNPTXSTS_NPTXQTOP_Pos: u32 = 24;
pub const USB_OTG_GNPTXSTS_NPTXQTOP_Msk: u32 = 2130706432;
pub const USB_OTG_GNPTXSTS_NPTXQTOP: u32 = 2130706432;
pub const USB_OTG_GNPTXSTS_NPTXQTOP_0: u32 = 16777216;
pub const USB_OTG_GNPTXSTS_NPTXQTOP_1: u32 = 33554432;
pub const USB_OTG_GNPTXSTS_NPTXQTOP_2: u32 = 67108864;
pub const USB_OTG_GNPTXSTS_NPTXQTOP_3: u32 = 134217728;
pub const USB_OTG_GNPTXSTS_NPTXQTOP_4: u32 = 268435456;
pub const USB_OTG_GNPTXSTS_NPTXQTOP_5: u32 = 536870912;
pub const USB_OTG_GNPTXSTS_NPTXQTOP_6: u32 = 1073741824;
pub const USB_OTG_GCCFG_DCDET_Pos: u32 = 0;
pub const USB_OTG_GCCFG_DCDET_Msk: u32 = 1;
pub const USB_OTG_GCCFG_DCDET: u32 = 1;
pub const USB_OTG_GCCFG_PDET_Pos: u32 = 1;
pub const USB_OTG_GCCFG_PDET_Msk: u32 = 2;
pub const USB_OTG_GCCFG_PDET: u32 = 2;
pub const USB_OTG_GCCFG_SDET_Pos: u32 = 2;
pub const USB_OTG_GCCFG_SDET_Msk: u32 = 4;
pub const USB_OTG_GCCFG_SDET: u32 = 4;
pub const USB_OTG_GCCFG_PS2DET_Pos: u32 = 3;
pub const USB_OTG_GCCFG_PS2DET_Msk: u32 = 8;
pub const USB_OTG_GCCFG_PS2DET: u32 = 8;
pub const USB_OTG_GCCFG_PWRDWN_Pos: u32 = 16;
pub const USB_OTG_GCCFG_PWRDWN_Msk: u32 = 65536;
pub const USB_OTG_GCCFG_PWRDWN: u32 = 65536;
pub const USB_OTG_GCCFG_BCDEN_Pos: u32 = 17;
pub const USB_OTG_GCCFG_BCDEN_Msk: u32 = 131072;
pub const USB_OTG_GCCFG_BCDEN: u32 = 131072;
pub const USB_OTG_GCCFG_DCDEN_Pos: u32 = 18;
pub const USB_OTG_GCCFG_DCDEN_Msk: u32 = 262144;
pub const USB_OTG_GCCFG_DCDEN: u32 = 262144;
pub const USB_OTG_GCCFG_PDEN_Pos: u32 = 19;
pub const USB_OTG_GCCFG_PDEN_Msk: u32 = 524288;
pub const USB_OTG_GCCFG_PDEN: u32 = 524288;
pub const USB_OTG_GCCFG_SDEN_Pos: u32 = 20;
pub const USB_OTG_GCCFG_SDEN_Msk: u32 = 1048576;
pub const USB_OTG_GCCFG_SDEN: u32 = 1048576;
pub const USB_OTG_GCCFG_VBDEN_Pos: u32 = 21;
pub const USB_OTG_GCCFG_VBDEN_Msk: u32 = 2097152;
pub const USB_OTG_GCCFG_VBDEN: u32 = 2097152;
pub const USB_OTG_CID_PRODUCT_ID_Pos: u32 = 0;
pub const USB_OTG_CID_PRODUCT_ID_Msk: u32 = 4294967295;
pub const USB_OTG_CID_PRODUCT_ID: u32 = 4294967295;
pub const USB_OTG_GLPMCFG_ENBESL_Pos: u32 = 28;
pub const USB_OTG_GLPMCFG_ENBESL_Msk: u32 = 268435456;
pub const USB_OTG_GLPMCFG_ENBESL: u32 = 268435456;
pub const USB_OTG_GLPMCFG_LPMRCNTSTS_Pos: u32 = 25;
pub const USB_OTG_GLPMCFG_LPMRCNTSTS_Msk: u32 = 234881024;
pub const USB_OTG_GLPMCFG_LPMRCNTSTS: u32 = 234881024;
pub const USB_OTG_GLPMCFG_SNDLPM_Pos: u32 = 24;
pub const USB_OTG_GLPMCFG_SNDLPM_Msk: u32 = 16777216;
pub const USB_OTG_GLPMCFG_SNDLPM: u32 = 16777216;
pub const USB_OTG_GLPMCFG_LPMRCNT_Pos: u32 = 21;
pub const USB_OTG_GLPMCFG_LPMRCNT_Msk: u32 = 14680064;
pub const USB_OTG_GLPMCFG_LPMRCNT: u32 = 14680064;
pub const USB_OTG_GLPMCFG_LPMCHIDX_Pos: u32 = 17;
pub const USB_OTG_GLPMCFG_LPMCHIDX_Msk: u32 = 1966080;
pub const USB_OTG_GLPMCFG_LPMCHIDX: u32 = 1966080;
pub const USB_OTG_GLPMCFG_L1RSMOK_Pos: u32 = 16;
pub const USB_OTG_GLPMCFG_L1RSMOK_Msk: u32 = 65536;
pub const USB_OTG_GLPMCFG_L1RSMOK: u32 = 65536;
pub const USB_OTG_GLPMCFG_SLPSTS_Pos: u32 = 15;
pub const USB_OTG_GLPMCFG_SLPSTS_Msk: u32 = 32768;
pub const USB_OTG_GLPMCFG_SLPSTS: u32 = 32768;
pub const USB_OTG_GLPMCFG_LPMRSP_Pos: u32 = 13;
pub const USB_OTG_GLPMCFG_LPMRSP_Msk: u32 = 24576;
pub const USB_OTG_GLPMCFG_LPMRSP: u32 = 24576;
pub const USB_OTG_GLPMCFG_L1DSEN_Pos: u32 = 12;
pub const USB_OTG_GLPMCFG_L1DSEN_Msk: u32 = 4096;
pub const USB_OTG_GLPMCFG_L1DSEN: u32 = 4096;
pub const USB_OTG_GLPMCFG_BESLTHRS_Pos: u32 = 8;
pub const USB_OTG_GLPMCFG_BESLTHRS_Msk: u32 = 3840;
pub const USB_OTG_GLPMCFG_BESLTHRS: u32 = 3840;
pub const USB_OTG_GLPMCFG_L1SSEN_Pos: u32 = 7;
pub const USB_OTG_GLPMCFG_L1SSEN_Msk: u32 = 128;
pub const USB_OTG_GLPMCFG_L1SSEN: u32 = 128;
pub const USB_OTG_GLPMCFG_REMWAKE_Pos: u32 = 6;
pub const USB_OTG_GLPMCFG_REMWAKE_Msk: u32 = 64;
pub const USB_OTG_GLPMCFG_REMWAKE: u32 = 64;
pub const USB_OTG_GLPMCFG_BESL_Pos: u32 = 2;
pub const USB_OTG_GLPMCFG_BESL_Msk: u32 = 60;
pub const USB_OTG_GLPMCFG_BESL: u32 = 60;
pub const USB_OTG_GLPMCFG_LPMACK_Pos: u32 = 1;
pub const USB_OTG_GLPMCFG_LPMACK_Msk: u32 = 2;
pub const USB_OTG_GLPMCFG_LPMACK: u32 = 2;
pub const USB_OTG_GLPMCFG_LPMEN_Pos: u32 = 0;
pub const USB_OTG_GLPMCFG_LPMEN_Msk: u32 = 1;
pub const USB_OTG_GLPMCFG_LPMEN: u32 = 1;
pub const USB_OTG_GLPMCFG_L1ResumeOK_Pos: u32 = 16;
pub const USB_OTG_GLPMCFG_L1ResumeOK_Msk: u32 = 65536;
pub const USB_OTG_GLPMCFG_L1ResumeOK: u32 = 65536;
pub const USB_OTG_GPWRDN_DISABLEVBUS_Pos: u32 = 6;
pub const USB_OTG_GPWRDN_DISABLEVBUS_Msk: u32 = 64;
pub const USB_OTG_GPWRDN_DISABLEVBUS: u32 = 64;
pub const USB_OTG_HPTXFSIZ_PTXSA_Pos: u32 = 0;
pub const USB_OTG_HPTXFSIZ_PTXSA_Msk: u32 = 65535;
pub const USB_OTG_HPTXFSIZ_PTXSA: u32 = 65535;
pub const USB_OTG_HPTXFSIZ_PTXFD_Pos: u32 = 16;
pub const USB_OTG_HPTXFSIZ_PTXFD_Msk: u32 = 4294901760;
pub const USB_OTG_HPTXFSIZ_PTXFD: u32 = 4294901760;
pub const USB_OTG_DIEPTXF_INEPTXSA_Pos: u32 = 0;
pub const USB_OTG_DIEPTXF_INEPTXSA_Msk: u32 = 65535;
pub const USB_OTG_DIEPTXF_INEPTXSA: u32 = 65535;
pub const USB_OTG_DIEPTXF_INEPTXFD_Pos: u32 = 16;
pub const USB_OTG_DIEPTXF_INEPTXFD_Msk: u32 = 4294901760;
pub const USB_OTG_DIEPTXF_INEPTXFD: u32 = 4294901760;
pub const USB_OTG_HCFG_FSLSPCS_Pos: u32 = 0;
pub const USB_OTG_HCFG_FSLSPCS_Msk: u32 = 3;
pub const USB_OTG_HCFG_FSLSPCS: u32 = 3;
pub const USB_OTG_HCFG_FSLSPCS_0: u32 = 1;
pub const USB_OTG_HCFG_FSLSPCS_1: u32 = 2;
pub const USB_OTG_HCFG_FSLSS_Pos: u32 = 2;
pub const USB_OTG_HCFG_FSLSS_Msk: u32 = 4;
pub const USB_OTG_HCFG_FSLSS: u32 = 4;
pub const USB_OTG_HFIR_FRIVL_Pos: u32 = 0;
pub const USB_OTG_HFIR_FRIVL_Msk: u32 = 65535;
pub const USB_OTG_HFIR_FRIVL: u32 = 65535;
pub const USB_OTG_HFNUM_FRNUM_Pos: u32 = 0;
pub const USB_OTG_HFNUM_FRNUM_Msk: u32 = 65535;
pub const USB_OTG_HFNUM_FRNUM: u32 = 65535;
pub const USB_OTG_HFNUM_FTREM_Pos: u32 = 16;
pub const USB_OTG_HFNUM_FTREM_Msk: u32 = 4294901760;
pub const USB_OTG_HFNUM_FTREM: u32 = 4294901760;
pub const USB_OTG_HPTXSTS_PTXFSAVL_Pos: u32 = 0;
pub const USB_OTG_HPTXSTS_PTXFSAVL_Msk: u32 = 65535;
pub const USB_OTG_HPTXSTS_PTXFSAVL: u32 = 65535;
pub const USB_OTG_HPTXSTS_PTXQSAV_Pos: u32 = 16;
pub const USB_OTG_HPTXSTS_PTXQSAV_Msk: u32 = 16711680;
pub const USB_OTG_HPTXSTS_PTXQSAV: u32 = 16711680;
pub const USB_OTG_HPTXSTS_PTXQSAV_0: u32 = 65536;
pub const USB_OTG_HPTXSTS_PTXQSAV_1: u32 = 131072;
pub const USB_OTG_HPTXSTS_PTXQSAV_2: u32 = 262144;
pub const USB_OTG_HPTXSTS_PTXQSAV_3: u32 = 524288;
pub const USB_OTG_HPTXSTS_PTXQSAV_4: u32 = 1048576;
pub const USB_OTG_HPTXSTS_PTXQSAV_5: u32 = 2097152;
pub const USB_OTG_HPTXSTS_PTXQSAV_6: u32 = 4194304;
pub const USB_OTG_HPTXSTS_PTXQSAV_7: u32 = 8388608;
pub const USB_OTG_HPTXSTS_PTXQTOP_Pos: u32 = 24;
pub const USB_OTG_HPTXSTS_PTXQTOP_Msk: u32 = 4278190080;
pub const USB_OTG_HPTXSTS_PTXQTOP: u32 = 4278190080;
pub const USB_OTG_HPTXSTS_PTXQTOP_0: u32 = 16777216;
pub const USB_OTG_HPTXSTS_PTXQTOP_1: u32 = 33554432;
pub const USB_OTG_HPTXSTS_PTXQTOP_2: u32 = 67108864;
pub const USB_OTG_HPTXSTS_PTXQTOP_3: u32 = 134217728;
pub const USB_OTG_HPTXSTS_PTXQTOP_4: u32 = 268435456;
pub const USB_OTG_HPTXSTS_PTXQTOP_5: u32 = 536870912;
pub const USB_OTG_HPTXSTS_PTXQTOP_6: u32 = 1073741824;
pub const USB_OTG_HPTXSTS_PTXQTOP_7: u32 = 2147483648;
pub const USB_OTG_HAINT_HAINT_Pos: u32 = 0;
pub const USB_OTG_HAINT_HAINT_Msk: u32 = 65535;
pub const USB_OTG_HAINT_HAINT: u32 = 65535;
pub const USB_OTG_HAINTMSK_HAINTM_Pos: u32 = 0;
pub const USB_OTG_HAINTMSK_HAINTM_Msk: u32 = 65535;
pub const USB_OTG_HAINTMSK_HAINTM: u32 = 65535;
pub const USB_OTG_HPRT_PCSTS_Pos: u32 = 0;
pub const USB_OTG_HPRT_PCSTS_Msk: u32 = 1;
pub const USB_OTG_HPRT_PCSTS: u32 = 1;
pub const USB_OTG_HPRT_PCDET_Pos: u32 = 1;
pub const USB_OTG_HPRT_PCDET_Msk: u32 = 2;
pub const USB_OTG_HPRT_PCDET: u32 = 2;
pub const USB_OTG_HPRT_PENA_Pos: u32 = 2;
pub const USB_OTG_HPRT_PENA_Msk: u32 = 4;
pub const USB_OTG_HPRT_PENA: u32 = 4;
pub const USB_OTG_HPRT_PENCHNG_Pos: u32 = 3;
pub const USB_OTG_HPRT_PENCHNG_Msk: u32 = 8;
pub const USB_OTG_HPRT_PENCHNG: u32 = 8;
pub const USB_OTG_HPRT_POCA_Pos: u32 = 4;
pub const USB_OTG_HPRT_POCA_Msk: u32 = 16;
pub const USB_OTG_HPRT_POCA: u32 = 16;
pub const USB_OTG_HPRT_POCCHNG_Pos: u32 = 5;
pub const USB_OTG_HPRT_POCCHNG_Msk: u32 = 32;
pub const USB_OTG_HPRT_POCCHNG: u32 = 32;
pub const USB_OTG_HPRT_PRES_Pos: u32 = 6;
pub const USB_OTG_HPRT_PRES_Msk: u32 = 64;
pub const USB_OTG_HPRT_PRES: u32 = 64;
pub const USB_OTG_HPRT_PSUSP_Pos: u32 = 7;
pub const USB_OTG_HPRT_PSUSP_Msk: u32 = 128;
pub const USB_OTG_HPRT_PSUSP: u32 = 128;
pub const USB_OTG_HPRT_PRST_Pos: u32 = 8;
pub const USB_OTG_HPRT_PRST_Msk: u32 = 256;
pub const USB_OTG_HPRT_PRST: u32 = 256;
pub const USB_OTG_HPRT_PLSTS_Pos: u32 = 10;
pub const USB_OTG_HPRT_PLSTS_Msk: u32 = 3072;
pub const USB_OTG_HPRT_PLSTS: u32 = 3072;
pub const USB_OTG_HPRT_PLSTS_0: u32 = 1024;
pub const USB_OTG_HPRT_PLSTS_1: u32 = 2048;
pub const USB_OTG_HPRT_PPWR_Pos: u32 = 12;
pub const USB_OTG_HPRT_PPWR_Msk: u32 = 4096;
pub const USB_OTG_HPRT_PPWR: u32 = 4096;
pub const USB_OTG_HPRT_PTCTL_Pos: u32 = 13;
pub const USB_OTG_HPRT_PTCTL_Msk: u32 = 122880;
pub const USB_OTG_HPRT_PTCTL: u32 = 122880;
pub const USB_OTG_HPRT_PTCTL_0: u32 = 8192;
pub const USB_OTG_HPRT_PTCTL_1: u32 = 16384;
pub const USB_OTG_HPRT_PTCTL_2: u32 = 32768;
pub const USB_OTG_HPRT_PTCTL_3: u32 = 65536;
pub const USB_OTG_HPRT_PSPD_Pos: u32 = 17;
pub const USB_OTG_HPRT_PSPD_Msk: u32 = 393216;
pub const USB_OTG_HPRT_PSPD: u32 = 393216;
pub const USB_OTG_HPRT_PSPD_0: u32 = 131072;
pub const USB_OTG_HPRT_PSPD_1: u32 = 262144;
pub const USB_OTG_HCCHAR_MPSIZ_Pos: u32 = 0;
pub const USB_OTG_HCCHAR_MPSIZ_Msk: u32 = 2047;
pub const USB_OTG_HCCHAR_MPSIZ: u32 = 2047;
pub const USB_OTG_HCCHAR_EPNUM_Pos: u32 = 11;
pub const USB_OTG_HCCHAR_EPNUM_Msk: u32 = 30720;
pub const USB_OTG_HCCHAR_EPNUM: u32 = 30720;
pub const USB_OTG_HCCHAR_EPNUM_0: u32 = 2048;
pub const USB_OTG_HCCHAR_EPNUM_1: u32 = 4096;
pub const USB_OTG_HCCHAR_EPNUM_2: u32 = 8192;
pub const USB_OTG_HCCHAR_EPNUM_3: u32 = 16384;
pub const USB_OTG_HCCHAR_EPDIR_Pos: u32 = 15;
pub const USB_OTG_HCCHAR_EPDIR_Msk: u32 = 32768;
pub const USB_OTG_HCCHAR_EPDIR: u32 = 32768;
pub const USB_OTG_HCCHAR_LSDEV_Pos: u32 = 17;
pub const USB_OTG_HCCHAR_LSDEV_Msk: u32 = 131072;
pub const USB_OTG_HCCHAR_LSDEV: u32 = 131072;
pub const USB_OTG_HCCHAR_EPTYP_Pos: u32 = 18;
pub const USB_OTG_HCCHAR_EPTYP_Msk: u32 = 786432;
pub const USB_OTG_HCCHAR_EPTYP: u32 = 786432;
pub const USB_OTG_HCCHAR_EPTYP_0: u32 = 262144;
pub const USB_OTG_HCCHAR_EPTYP_1: u32 = 524288;
pub const USB_OTG_HCCHAR_MC_Pos: u32 = 20;
pub const USB_OTG_HCCHAR_MC_Msk: u32 = 3145728;
pub const USB_OTG_HCCHAR_MC: u32 = 3145728;
pub const USB_OTG_HCCHAR_MC_0: u32 = 1048576;
pub const USB_OTG_HCCHAR_MC_1: u32 = 2097152;
pub const USB_OTG_HCCHAR_DAD_Pos: u32 = 22;
pub const USB_OTG_HCCHAR_DAD_Msk: u32 = 532676608;
pub const USB_OTG_HCCHAR_DAD: u32 = 532676608;
pub const USB_OTG_HCCHAR_DAD_0: u32 = 4194304;
pub const USB_OTG_HCCHAR_DAD_1: u32 = 8388608;
pub const USB_OTG_HCCHAR_DAD_2: u32 = 16777216;
pub const USB_OTG_HCCHAR_DAD_3: u32 = 33554432;
pub const USB_OTG_HCCHAR_DAD_4: u32 = 67108864;
pub const USB_OTG_HCCHAR_DAD_5: u32 = 134217728;
pub const USB_OTG_HCCHAR_DAD_6: u32 = 268435456;
pub const USB_OTG_HCCHAR_ODDFRM_Pos: u32 = 29;
pub const USB_OTG_HCCHAR_ODDFRM_Msk: u32 = 536870912;
pub const USB_OTG_HCCHAR_ODDFRM: u32 = 536870912;
pub const USB_OTG_HCCHAR_CHDIS_Pos: u32 = 30;
pub const USB_OTG_HCCHAR_CHDIS_Msk: u32 = 1073741824;
pub const USB_OTG_HCCHAR_CHDIS: u32 = 1073741824;
pub const USB_OTG_HCCHAR_CHENA_Pos: u32 = 31;
pub const USB_OTG_HCCHAR_CHENA_Msk: u32 = 2147483648;
pub const USB_OTG_HCCHAR_CHENA: u32 = 2147483648;
pub const USB_OTG_HCINT_XFRC_Pos: u32 = 0;
pub const USB_OTG_HCINT_XFRC_Msk: u32 = 1;
pub const USB_OTG_HCINT_XFRC: u32 = 1;
pub const USB_OTG_HCINT_CHH_Pos: u32 = 1;
pub const USB_OTG_HCINT_CHH_Msk: u32 = 2;
pub const USB_OTG_HCINT_CHH: u32 = 2;
pub const USB_OTG_HCINT_AHBERR_Pos: u32 = 2;
pub const USB_OTG_HCINT_AHBERR_Msk: u32 = 4;
pub const USB_OTG_HCINT_AHBERR: u32 = 4;
pub const USB_OTG_HCINT_STALL_Pos: u32 = 3;
pub const USB_OTG_HCINT_STALL_Msk: u32 = 8;
pub const USB_OTG_HCINT_STALL: u32 = 8;
pub const USB_OTG_HCINT_NAK_Pos: u32 = 4;
pub const USB_OTG_HCINT_NAK_Msk: u32 = 16;
pub const USB_OTG_HCINT_NAK: u32 = 16;
pub const USB_OTG_HCINT_ACK_Pos: u32 = 5;
pub const USB_OTG_HCINT_ACK_Msk: u32 = 32;
pub const USB_OTG_HCINT_ACK: u32 = 32;
pub const USB_OTG_HCINT_NYET_Pos: u32 = 6;
pub const USB_OTG_HCINT_NYET_Msk: u32 = 64;
pub const USB_OTG_HCINT_NYET: u32 = 64;
pub const USB_OTG_HCINT_TXERR_Pos: u32 = 7;
pub const USB_OTG_HCINT_TXERR_Msk: u32 = 128;
pub const USB_OTG_HCINT_TXERR: u32 = 128;
pub const USB_OTG_HCINT_BBERR_Pos: u32 = 8;
pub const USB_OTG_HCINT_BBERR_Msk: u32 = 256;
pub const USB_OTG_HCINT_BBERR: u32 = 256;
pub const USB_OTG_HCINT_FRMOR_Pos: u32 = 9;
pub const USB_OTG_HCINT_FRMOR_Msk: u32 = 512;
pub const USB_OTG_HCINT_FRMOR: u32 = 512;
pub const USB_OTG_HCINT_DTERR_Pos: u32 = 10;
pub const USB_OTG_HCINT_DTERR_Msk: u32 = 1024;
pub const USB_OTG_HCINT_DTERR: u32 = 1024;
pub const USB_OTG_HCINTMSK_XFRCM_Pos: u32 = 0;
pub const USB_OTG_HCINTMSK_XFRCM_Msk: u32 = 1;
pub const USB_OTG_HCINTMSK_XFRCM: u32 = 1;
pub const USB_OTG_HCINTMSK_CHHM_Pos: u32 = 1;
pub const USB_OTG_HCINTMSK_CHHM_Msk: u32 = 2;
pub const USB_OTG_HCINTMSK_CHHM: u32 = 2;
pub const USB_OTG_HCINTMSK_AHBERR_Pos: u32 = 2;
pub const USB_OTG_HCINTMSK_AHBERR_Msk: u32 = 4;
pub const USB_OTG_HCINTMSK_AHBERR: u32 = 4;
pub const USB_OTG_HCINTMSK_STALLM_Pos: u32 = 3;
pub const USB_OTG_HCINTMSK_STALLM_Msk: u32 = 8;
pub const USB_OTG_HCINTMSK_STALLM: u32 = 8;
pub const USB_OTG_HCINTMSK_NAKM_Pos: u32 = 4;
pub const USB_OTG_HCINTMSK_NAKM_Msk: u32 = 16;
pub const USB_OTG_HCINTMSK_NAKM: u32 = 16;
pub const USB_OTG_HCINTMSK_ACKM_Pos: u32 = 5;
pub const USB_OTG_HCINTMSK_ACKM_Msk: u32 = 32;
pub const USB_OTG_HCINTMSK_ACKM: u32 = 32;
pub const USB_OTG_HCINTMSK_NYET_Pos: u32 = 6;
pub const USB_OTG_HCINTMSK_NYET_Msk: u32 = 64;
pub const USB_OTG_HCINTMSK_NYET: u32 = 64;
pub const USB_OTG_HCINTMSK_TXERRM_Pos: u32 = 7;
pub const USB_OTG_HCINTMSK_TXERRM_Msk: u32 = 128;
pub const USB_OTG_HCINTMSK_TXERRM: u32 = 128;
pub const USB_OTG_HCINTMSK_BBERRM_Pos: u32 = 8;
pub const USB_OTG_HCINTMSK_BBERRM_Msk: u32 = 256;
pub const USB_OTG_HCINTMSK_BBERRM: u32 = 256;
pub const USB_OTG_HCINTMSK_FRMORM_Pos: u32 = 9;
pub const USB_OTG_HCINTMSK_FRMORM_Msk: u32 = 512;
pub const USB_OTG_HCINTMSK_FRMORM: u32 = 512;
pub const USB_OTG_HCINTMSK_DTERRM_Pos: u32 = 10;
pub const USB_OTG_HCINTMSK_DTERRM_Msk: u32 = 1024;
pub const USB_OTG_HCINTMSK_DTERRM: u32 = 1024;
pub const USB_OTG_HCTSIZ_XFRSIZ_Pos: u32 = 0;
pub const USB_OTG_HCTSIZ_XFRSIZ_Msk: u32 = 524287;
pub const USB_OTG_HCTSIZ_XFRSIZ: u32 = 524287;
pub const USB_OTG_HCTSIZ_PKTCNT_Pos: u32 = 19;
pub const USB_OTG_HCTSIZ_PKTCNT_Msk: u32 = 536346624;
pub const USB_OTG_HCTSIZ_PKTCNT: u32 = 536346624;
pub const USB_OTG_HCTSIZ_DOPING_Pos: u32 = 31;
pub const USB_OTG_HCTSIZ_DOPING_Msk: u32 = 2147483648;
pub const USB_OTG_HCTSIZ_DOPING: u32 = 2147483648;
pub const USB_OTG_HCTSIZ_DPID_Pos: u32 = 29;
pub const USB_OTG_HCTSIZ_DPID_Msk: u32 = 1610612736;
pub const USB_OTG_HCTSIZ_DPID: u32 = 1610612736;
pub const USB_OTG_HCTSIZ_DPID_0: u32 = 536870912;
pub const USB_OTG_HCTSIZ_DPID_1: u32 = 1073741824;
pub const USB_OTG_HCDMA_DMAADDR_Pos: u32 = 0;
pub const USB_OTG_HCDMA_DMAADDR_Msk: u32 = 4294967295;
pub const USB_OTG_HCDMA_DMAADDR: u32 = 4294967295;
pub const USB_OTG_DCFG_DSPD_Pos: u32 = 0;
pub const USB_OTG_DCFG_DSPD_Msk: u32 = 3;
pub const USB_OTG_DCFG_DSPD: u32 = 3;
pub const USB_OTG_DCFG_DSPD_0: u32 = 1;
pub const USB_OTG_DCFG_DSPD_1: u32 = 2;
pub const USB_OTG_DCFG_NZLSOHSK_Pos: u32 = 2;
pub const USB_OTG_DCFG_NZLSOHSK_Msk: u32 = 4;
pub const USB_OTG_DCFG_NZLSOHSK: u32 = 4;
pub const USB_OTG_DCFG_DAD_Pos: u32 = 4;
pub const USB_OTG_DCFG_DAD_Msk: u32 = 2032;
pub const USB_OTG_DCFG_DAD: u32 = 2032;
pub const USB_OTG_DCFG_DAD_0: u32 = 16;
pub const USB_OTG_DCFG_DAD_1: u32 = 32;
pub const USB_OTG_DCFG_DAD_2: u32 = 64;
pub const USB_OTG_DCFG_DAD_3: u32 = 128;
pub const USB_OTG_DCFG_DAD_4: u32 = 256;
pub const USB_OTG_DCFG_DAD_5: u32 = 512;
pub const USB_OTG_DCFG_DAD_6: u32 = 1024;
pub const USB_OTG_DCFG_PFIVL_Pos: u32 = 11;
pub const USB_OTG_DCFG_PFIVL_Msk: u32 = 6144;
pub const USB_OTG_DCFG_PFIVL: u32 = 6144;
pub const USB_OTG_DCFG_PFIVL_0: u32 = 2048;
pub const USB_OTG_DCFG_PFIVL_1: u32 = 4096;
pub const USB_OTG_DCFG_PERSCHIVL_Pos: u32 = 24;
pub const USB_OTG_DCFG_PERSCHIVL_Msk: u32 = 50331648;
pub const USB_OTG_DCFG_PERSCHIVL: u32 = 50331648;
pub const USB_OTG_DCFG_PERSCHIVL_0: u32 = 16777216;
pub const USB_OTG_DCFG_PERSCHIVL_1: u32 = 33554432;
pub const USB_OTG_DCTL_RWUSIG_Pos: u32 = 0;
pub const USB_OTG_DCTL_RWUSIG_Msk: u32 = 1;
pub const USB_OTG_DCTL_RWUSIG: u32 = 1;
pub const USB_OTG_DCTL_SDIS_Pos: u32 = 1;
pub const USB_OTG_DCTL_SDIS_Msk: u32 = 2;
pub const USB_OTG_DCTL_SDIS: u32 = 2;
pub const USB_OTG_DCTL_GINSTS_Pos: u32 = 2;
pub const USB_OTG_DCTL_GINSTS_Msk: u32 = 4;
pub const USB_OTG_DCTL_GINSTS: u32 = 4;
pub const USB_OTG_DCTL_GONSTS_Pos: u32 = 3;
pub const USB_OTG_DCTL_GONSTS_Msk: u32 = 8;
pub const USB_OTG_DCTL_GONSTS: u32 = 8;
pub const USB_OTG_DCTL_TCTL_Pos: u32 = 4;
pub const USB_OTG_DCTL_TCTL_Msk: u32 = 112;
pub const USB_OTG_DCTL_TCTL: u32 = 112;
pub const USB_OTG_DCTL_TCTL_0: u32 = 16;
pub const USB_OTG_DCTL_TCTL_1: u32 = 32;
pub const USB_OTG_DCTL_TCTL_2: u32 = 64;
pub const USB_OTG_DCTL_SGINAK_Pos: u32 = 7;
pub const USB_OTG_DCTL_SGINAK_Msk: u32 = 128;
pub const USB_OTG_DCTL_SGINAK: u32 = 128;
pub const USB_OTG_DCTL_CGINAK_Pos: u32 = 8;
pub const USB_OTG_DCTL_CGINAK_Msk: u32 = 256;
pub const USB_OTG_DCTL_CGINAK: u32 = 256;
pub const USB_OTG_DCTL_SGONAK_Pos: u32 = 9;
pub const USB_OTG_DCTL_SGONAK_Msk: u32 = 512;
pub const USB_OTG_DCTL_SGONAK: u32 = 512;
pub const USB_OTG_DCTL_CGONAK_Pos: u32 = 10;
pub const USB_OTG_DCTL_CGONAK_Msk: u32 = 1024;
pub const USB_OTG_DCTL_CGONAK: u32 = 1024;
pub const USB_OTG_DCTL_POPRGDNE_Pos: u32 = 11;
pub const USB_OTG_DCTL_POPRGDNE_Msk: u32 = 2048;
pub const USB_OTG_DCTL_POPRGDNE: u32 = 2048;
pub const USB_OTG_DSTS_SUSPSTS_Pos: u32 = 0;
pub const USB_OTG_DSTS_SUSPSTS_Msk: u32 = 1;
pub const USB_OTG_DSTS_SUSPSTS: u32 = 1;
pub const USB_OTG_DSTS_ENUMSPD_Pos: u32 = 1;
pub const USB_OTG_DSTS_ENUMSPD_Msk: u32 = 6;
pub const USB_OTG_DSTS_ENUMSPD: u32 = 6;
pub const USB_OTG_DSTS_ENUMSPD_0: u32 = 2;
pub const USB_OTG_DSTS_ENUMSPD_1: u32 = 4;
pub const USB_OTG_DSTS_EERR_Pos: u32 = 3;
pub const USB_OTG_DSTS_EERR_Msk: u32 = 8;
pub const USB_OTG_DSTS_EERR: u32 = 8;
pub const USB_OTG_DSTS_FNSOF_Pos: u32 = 8;
pub const USB_OTG_DSTS_FNSOF_Msk: u32 = 4194048;
pub const USB_OTG_DSTS_FNSOF: u32 = 4194048;
pub const USB_OTG_DIEPMSK_XFRCM_Pos: u32 = 0;
pub const USB_OTG_DIEPMSK_XFRCM_Msk: u32 = 1;
pub const USB_OTG_DIEPMSK_XFRCM: u32 = 1;
pub const USB_OTG_DIEPMSK_EPDM_Pos: u32 = 1;
pub const USB_OTG_DIEPMSK_EPDM_Msk: u32 = 2;
pub const USB_OTG_DIEPMSK_EPDM: u32 = 2;
pub const USB_OTG_DIEPMSK_TOM_Pos: u32 = 3;
pub const USB_OTG_DIEPMSK_TOM_Msk: u32 = 8;
pub const USB_OTG_DIEPMSK_TOM: u32 = 8;
pub const USB_OTG_DIEPMSK_ITTXFEMSK_Pos: u32 = 4;
pub const USB_OTG_DIEPMSK_ITTXFEMSK_Msk: u32 = 16;
pub const USB_OTG_DIEPMSK_ITTXFEMSK: u32 = 16;
pub const USB_OTG_DIEPMSK_INEPNMM_Pos: u32 = 5;
pub const USB_OTG_DIEPMSK_INEPNMM_Msk: u32 = 32;
pub const USB_OTG_DIEPMSK_INEPNMM: u32 = 32;
pub const USB_OTG_DIEPMSK_INEPNEM_Pos: u32 = 6;
pub const USB_OTG_DIEPMSK_INEPNEM_Msk: u32 = 64;
pub const USB_OTG_DIEPMSK_INEPNEM: u32 = 64;
pub const USB_OTG_DIEPMSK_TXFURM_Pos: u32 = 8;
pub const USB_OTG_DIEPMSK_TXFURM_Msk: u32 = 256;
pub const USB_OTG_DIEPMSK_TXFURM: u32 = 256;
pub const USB_OTG_DIEPMSK_BIM_Pos: u32 = 9;
pub const USB_OTG_DIEPMSK_BIM_Msk: u32 = 512;
pub const USB_OTG_DIEPMSK_BIM: u32 = 512;
pub const USB_OTG_DIEPEACHMSK1_XFRCM_Pos: u32 = 0;
pub const USB_OTG_DIEPEACHMSK1_XFRCM_Msk: u32 = 1;
pub const USB_OTG_DIEPEACHMSK1_XFRCM: u32 = 1;
pub const USB_OTG_DIEPEACHMSK1_EPDM_Pos: u32 = 1;
pub const USB_OTG_DIEPEACHMSK1_EPDM_Msk: u32 = 2;
pub const USB_OTG_DIEPEACHMSK1_EPDM: u32 = 2;
pub const USB_OTG_DIEPEACHMSK1_TOM_Pos: u32 = 3;
pub const USB_OTG_DIEPEACHMSK1_TOM_Msk: u32 = 8;
pub const USB_OTG_DIEPEACHMSK1_TOM: u32 = 8;
pub const USB_OTG_DIEPEACHMSK1_ITTXFEMSK_Pos: u32 = 4;
pub const USB_OTG_DIEPEACHMSK1_ITTXFEMSK_Msk: u32 = 16;
pub const USB_OTG_DIEPEACHMSK1_ITTXFEMSK: u32 = 16;
pub const USB_OTG_DIEPEACHMSK1_INEPNMM_Pos: u32 = 5;
pub const USB_OTG_DIEPEACHMSK1_INEPNMM_Msk: u32 = 32;
pub const USB_OTG_DIEPEACHMSK1_INEPNMM: u32 = 32;
pub const USB_OTG_DIEPEACHMSK1_INEPNEM_Pos: u32 = 6;
pub const USB_OTG_DIEPEACHMSK1_INEPNEM_Msk: u32 = 6;
pub const USB_OTG_DIEPEACHMSK1_INEPNEM: u32 = 64;
pub const USB_OTG_DIEPEACHMSK1_TXFURM_Pos: u32 = 8;
pub const USB_OTG_DIEPEACHMSK1_TXFURM_Msk: u32 = 256;
pub const USB_OTG_DIEPEACHMSK1_TXFURM: u32 = 256;
pub const USB_OTG_DIEPEACHMSK1_BIM_Pos: u32 = 9;
pub const USB_OTG_DIEPEACHMSK1_BIM_Msk: u32 = 512;
pub const USB_OTG_DIEPEACHMSK1_BIM: u32 = 512;
pub const USB_OTG_DIEPEACHMSK1_NAKM_Pos: u32 = 13;
pub const USB_OTG_DIEPEACHMSK1_NAKM_Msk: u32 = 8192;
pub const USB_OTG_DIEPEACHMSK1_NAKM: u32 = 8192;
pub const USB_OTG_DOEPMSK_XFRCM_Pos: u32 = 0;
pub const USB_OTG_DOEPMSK_XFRCM_Msk: u32 = 1;
pub const USB_OTG_DOEPMSK_XFRCM: u32 = 1;
pub const USB_OTG_DOEPMSK_EPDM_Pos: u32 = 1;
pub const USB_OTG_DOEPMSK_EPDM_Msk: u32 = 2;
pub const USB_OTG_DOEPMSK_EPDM: u32 = 2;
pub const USB_OTG_DOEPMSK_STUPM_Pos: u32 = 3;
pub const USB_OTG_DOEPMSK_STUPM_Msk: u32 = 8;
pub const USB_OTG_DOEPMSK_STUPM: u32 = 8;
pub const USB_OTG_DOEPMSK_OTEPDM_Pos: u32 = 4;
pub const USB_OTG_DOEPMSK_OTEPDM_Msk: u32 = 16;
pub const USB_OTG_DOEPMSK_OTEPDM: u32 = 16;
pub const USB_OTG_DOEPMSK_B2BSTUP_Pos: u32 = 6;
pub const USB_OTG_DOEPMSK_B2BSTUP_Msk: u32 = 64;
pub const USB_OTG_DOEPMSK_B2BSTUP: u32 = 64;
pub const USB_OTG_DOEPMSK_OPEM_Pos: u32 = 8;
pub const USB_OTG_DOEPMSK_OPEM_Msk: u32 = 256;
pub const USB_OTG_DOEPMSK_OPEM: u32 = 256;
pub const USB_OTG_DOEPMSK_BOIM_Pos: u32 = 9;
pub const USB_OTG_DOEPMSK_BOIM_Msk: u32 = 512;
pub const USB_OTG_DOEPMSK_BOIM: u32 = 512;
pub const USB_OTG_DOEPEACHMSK1_XFRCM_Pos: u32 = 0;
pub const USB_OTG_DOEPEACHMSK1_XFRCM_Msk: u32 = 1;
pub const USB_OTG_DOEPEACHMSK1_XFRCM: u32 = 1;
pub const USB_OTG_DOEPEACHMSK1_EPDM_Pos: u32 = 1;
pub const USB_OTG_DOEPEACHMSK1_EPDM_Msk: u32 = 2;
pub const USB_OTG_DOEPEACHMSK1_EPDM: u32 = 2;
pub const USB_OTG_DOEPEACHMSK1_TOM_Pos: u32 = 3;
pub const USB_OTG_DOEPEACHMSK1_TOM_Msk: u32 = 8;
pub const USB_OTG_DOEPEACHMSK1_TOM: u32 = 8;
pub const USB_OTG_DOEPEACHMSK1_ITTXFEMSK_Pos: u32 = 4;
pub const USB_OTG_DOEPEACHMSK1_ITTXFEMSK_Msk: u32 = 16;
pub const USB_OTG_DOEPEACHMSK1_ITTXFEMSK: u32 = 16;
pub const USB_OTG_DOEPEACHMSK1_INEPNMM_Pos: u32 = 5;
pub const USB_OTG_DOEPEACHMSK1_INEPNMM_Msk: u32 = 32;
pub const USB_OTG_DOEPEACHMSK1_INEPNMM: u32 = 32;
pub const USB_OTG_DOEPEACHMSK1_INEPNEM_Pos: u32 = 6;
pub const USB_OTG_DOEPEACHMSK1_INEPNEM_Msk: u32 = 64;
pub const USB_OTG_DOEPEACHMSK1_INEPNEM: u32 = 64;
pub const USB_OTG_DOEPEACHMSK1_TXFURM_Pos: u32 = 8;
pub const USB_OTG_DOEPEACHMSK1_TXFURM_Msk: u32 = 256;
pub const USB_OTG_DOEPEACHMSK1_TXFURM: u32 = 256;
pub const USB_OTG_DOEPEACHMSK1_BIM_Pos: u32 = 9;
pub const USB_OTG_DOEPEACHMSK1_BIM_Msk: u32 = 512;
pub const USB_OTG_DOEPEACHMSK1_BIM: u32 = 512;
pub const USB_OTG_DOEPEACHMSK1_BERRM_Pos: u32 = 12;
pub const USB_OTG_DOEPEACHMSK1_BERRM_Msk: u32 = 4096;
pub const USB_OTG_DOEPEACHMSK1_BERRM: u32 = 4096;
pub const USB_OTG_DOEPEACHMSK1_NAKM_Pos: u32 = 13;
pub const USB_OTG_DOEPEACHMSK1_NAKM_Msk: u32 = 8192;
pub const USB_OTG_DOEPEACHMSK1_NAKM: u32 = 8192;
pub const USB_OTG_DOEPEACHMSK1_NYETM_Pos: u32 = 14;
pub const USB_OTG_DOEPEACHMSK1_NYETM_Msk: u32 = 16384;
pub const USB_OTG_DOEPEACHMSK1_NYETM: u32 = 16384;
pub const USB_OTG_DAINT_IEPINT_Pos: u32 = 0;
pub const USB_OTG_DAINT_IEPINT_Msk: u32 = 65535;
pub const USB_OTG_DAINT_IEPINT: u32 = 65535;
pub const USB_OTG_DAINT_OEPINT_Pos: u32 = 16;
pub const USB_OTG_DAINT_OEPINT_Msk: u32 = 4294901760;
pub const USB_OTG_DAINT_OEPINT: u32 = 4294901760;
pub const USB_OTG_DAINTMSK_IEPM_Pos: u32 = 0;
pub const USB_OTG_DAINTMSK_IEPM_Msk: u32 = 65535;
pub const USB_OTG_DAINTMSK_IEPM: u32 = 65535;
pub const USB_OTG_DAINTMSK_OEPM_Pos: u32 = 16;
pub const USB_OTG_DAINTMSK_OEPM_Msk: u32 = 4294901760;
pub const USB_OTG_DAINTMSK_OEPM: u32 = 4294901760;
pub const USB_OTG_DVBUSDIS_VBUSDT_Pos: u32 = 0;
pub const USB_OTG_DVBUSDIS_VBUSDT_Msk: u32 = 65535;
pub const USB_OTG_DVBUSDIS_VBUSDT: u32 = 65535;
pub const USB_OTG_DVBUSPULSE_DVBUSP_Pos: u32 = 0;
pub const USB_OTG_DVBUSPULSE_DVBUSP_Msk: u32 = 4095;
pub const USB_OTG_DVBUSPULSE_DVBUSP: u32 = 4095;
pub const USB_OTG_DTHRCTL_NONISOTHREN_Pos: u32 = 0;
pub const USB_OTG_DTHRCTL_NONISOTHREN_Msk: u32 = 1;
pub const USB_OTG_DTHRCTL_NONISOTHREN: u32 = 1;
pub const USB_OTG_DTHRCTL_ISOTHREN_Pos: u32 = 1;
pub const USB_OTG_DTHRCTL_ISOTHREN_Msk: u32 = 2;
pub const USB_OTG_DTHRCTL_ISOTHREN: u32 = 2;
pub const USB_OTG_DTHRCTL_TXTHRLEN_Pos: u32 = 2;
pub const USB_OTG_DTHRCTL_TXTHRLEN_Msk: u32 = 2044;
pub const USB_OTG_DTHRCTL_TXTHRLEN: u32 = 2044;
pub const USB_OTG_DTHRCTL_TXTHRLEN_0: u32 = 4;
pub const USB_OTG_DTHRCTL_TXTHRLEN_1: u32 = 8;
pub const USB_OTG_DTHRCTL_TXTHRLEN_2: u32 = 16;
pub const USB_OTG_DTHRCTL_TXTHRLEN_3: u32 = 32;
pub const USB_OTG_DTHRCTL_TXTHRLEN_4: u32 = 64;
pub const USB_OTG_DTHRCTL_TXTHRLEN_5: u32 = 128;
pub const USB_OTG_DTHRCTL_TXTHRLEN_6: u32 = 256;
pub const USB_OTG_DTHRCTL_TXTHRLEN_7: u32 = 512;
pub const USB_OTG_DTHRCTL_TXTHRLEN_8: u32 = 1024;
pub const USB_OTG_DTHRCTL_RXTHREN_Pos: u32 = 16;
pub const USB_OTG_DTHRCTL_RXTHREN_Msk: u32 = 65536;
pub const USB_OTG_DTHRCTL_RXTHREN: u32 = 65536;
pub const USB_OTG_DTHRCTL_RXTHRLEN_Pos: u32 = 17;
pub const USB_OTG_DTHRCTL_RXTHRLEN_Msk: u32 = 66977792;
pub const USB_OTG_DTHRCTL_RXTHRLEN: u32 = 66977792;
pub const USB_OTG_DTHRCTL_RXTHRLEN_0: u32 = 131072;
pub const USB_OTG_DTHRCTL_RXTHRLEN_1: u32 = 262144;
pub const USB_OTG_DTHRCTL_RXTHRLEN_2: u32 = 524288;
pub const USB_OTG_DTHRCTL_RXTHRLEN_3: u32 = 1048576;
pub const USB_OTG_DTHRCTL_RXTHRLEN_4: u32 = 2097152;
pub const USB_OTG_DTHRCTL_RXTHRLEN_5: u32 = 4194304;
pub const USB_OTG_DTHRCTL_RXTHRLEN_6: u32 = 8388608;
pub const USB_OTG_DTHRCTL_RXTHRLEN_7: u32 = 16777216;
pub const USB_OTG_DTHRCTL_RXTHRLEN_8: u32 = 33554432;
pub const USB_OTG_DTHRCTL_ARPEN_Pos: u32 = 27;
pub const USB_OTG_DTHRCTL_ARPEN_Msk: u32 = 134217728;
pub const USB_OTG_DTHRCTL_ARPEN: u32 = 134217728;
pub const USB_OTG_DIEPEMPMSK_INEPTXFEM_Pos: u32 = 0;
pub const USB_OTG_DIEPEMPMSK_INEPTXFEM_Msk: u32 = 65535;
pub const USB_OTG_DIEPEMPMSK_INEPTXFEM: u32 = 65535;
pub const USB_OTG_DEACHINT_IEP1INT_Pos: u32 = 1;
pub const USB_OTG_DEACHINT_IEP1INT_Msk: u32 = 2;
pub const USB_OTG_DEACHINT_IEP1INT: u32 = 2;
pub const USB_OTG_DEACHINT_OEP1INT_Pos: u32 = 17;
pub const USB_OTG_DEACHINT_OEP1INT_Msk: u32 = 131072;
pub const USB_OTG_DEACHINT_OEP1INT: u32 = 131072;
pub const USB_OTG_DEACHINTMSK_IEP1INTM_Pos: u32 = 1;
pub const USB_OTG_DEACHINTMSK_IEP1INTM_Msk: u32 = 2;
pub const USB_OTG_DEACHINTMSK_IEP1INTM: u32 = 2;
pub const USB_OTG_DEACHINTMSK_OEP1INTM_Pos: u32 = 17;
pub const USB_OTG_DEACHINTMSK_OEP1INTM_Msk: u32 = 131072;
pub const USB_OTG_DEACHINTMSK_OEP1INTM: u32 = 131072;
pub const USB_OTG_DIEPCTL_MPSIZ_Pos: u32 = 0;
pub const USB_OTG_DIEPCTL_MPSIZ_Msk: u32 = 2047;
pub const USB_OTG_DIEPCTL_MPSIZ: u32 = 2047;
pub const USB_OTG_DIEPCTL_USBAEP_Pos: u32 = 15;
pub const USB_OTG_DIEPCTL_USBAEP_Msk: u32 = 32768;
pub const USB_OTG_DIEPCTL_USBAEP: u32 = 32768;
pub const USB_OTG_DIEPCTL_EONUM_DPID_Pos: u32 = 16;
pub const USB_OTG_DIEPCTL_EONUM_DPID_Msk: u32 = 65536;
pub const USB_OTG_DIEPCTL_EONUM_DPID: u32 = 65536;
pub const USB_OTG_DIEPCTL_NAKSTS_Pos: u32 = 17;
pub const USB_OTG_DIEPCTL_NAKSTS_Msk: u32 = 131072;
pub const USB_OTG_DIEPCTL_NAKSTS: u32 = 131072;
pub const USB_OTG_DIEPCTL_EPTYP_Pos: u32 = 18;
pub const USB_OTG_DIEPCTL_EPTYP_Msk: u32 = 786432;
pub const USB_OTG_DIEPCTL_EPTYP: u32 = 786432;
pub const USB_OTG_DIEPCTL_EPTYP_0: u32 = 262144;
pub const USB_OTG_DIEPCTL_EPTYP_1: u32 = 524288;
pub const USB_OTG_DIEPCTL_STALL_Pos: u32 = 21;
pub const USB_OTG_DIEPCTL_STALL_Msk: u32 = 2097152;
pub const USB_OTG_DIEPCTL_STALL: u32 = 2097152;
pub const USB_OTG_DIEPCTL_TXFNUM_Pos: u32 = 22;
pub const USB_OTG_DIEPCTL_TXFNUM_Msk: u32 = 62914560;
pub const USB_OTG_DIEPCTL_TXFNUM: u32 = 62914560;
pub const USB_OTG_DIEPCTL_TXFNUM_0: u32 = 4194304;
pub const USB_OTG_DIEPCTL_TXFNUM_1: u32 = 8388608;
pub const USB_OTG_DIEPCTL_TXFNUM_2: u32 = 16777216;
pub const USB_OTG_DIEPCTL_TXFNUM_3: u32 = 33554432;
pub const USB_OTG_DIEPCTL_CNAK_Pos: u32 = 26;
pub const USB_OTG_DIEPCTL_CNAK_Msk: u32 = 67108864;
pub const USB_OTG_DIEPCTL_CNAK: u32 = 67108864;
pub const USB_OTG_DIEPCTL_SNAK_Pos: u32 = 27;
pub const USB_OTG_DIEPCTL_SNAK_Msk: u32 = 134217728;
pub const USB_OTG_DIEPCTL_SNAK: u32 = 134217728;
pub const USB_OTG_DIEPCTL_SD0PID_SEVNFRM_Pos: u32 = 28;
pub const USB_OTG_DIEPCTL_SD0PID_SEVNFRM_Msk: u32 = 268435456;
pub const USB_OTG_DIEPCTL_SD0PID_SEVNFRM: u32 = 268435456;
pub const USB_OTG_DIEPCTL_SODDFRM_Pos: u32 = 29;
pub const USB_OTG_DIEPCTL_SODDFRM_Msk: u32 = 536870912;
pub const USB_OTG_DIEPCTL_SODDFRM: u32 = 536870912;
pub const USB_OTG_DIEPCTL_EPDIS_Pos: u32 = 30;
pub const USB_OTG_DIEPCTL_EPDIS_Msk: u32 = 1073741824;
pub const USB_OTG_DIEPCTL_EPDIS: u32 = 1073741824;
pub const USB_OTG_DIEPCTL_EPENA_Pos: u32 = 31;
pub const USB_OTG_DIEPCTL_EPENA_Msk: u32 = 2147483648;
pub const USB_OTG_DIEPCTL_EPENA: u32 = 2147483648;
pub const USB_OTG_DIEPINT_XFRC_Pos: u32 = 0;
pub const USB_OTG_DIEPINT_XFRC_Msk: u32 = 1;
pub const USB_OTG_DIEPINT_XFRC: u32 = 1;
pub const USB_OTG_DIEPINT_EPDISD_Pos: u32 = 1;
pub const USB_OTG_DIEPINT_EPDISD_Msk: u32 = 2;
pub const USB_OTG_DIEPINT_EPDISD: u32 = 2;
pub const USB_OTG_DIEPINT_TOC_Pos: u32 = 3;
pub const USB_OTG_DIEPINT_TOC_Msk: u32 = 8;
pub const USB_OTG_DIEPINT_TOC: u32 = 8;
pub const USB_OTG_DIEPINT_ITTXFE_Pos: u32 = 4;
pub const USB_OTG_DIEPINT_ITTXFE_Msk: u32 = 16;
pub const USB_OTG_DIEPINT_ITTXFE: u32 = 16;
pub const USB_OTG_DIEPINT_INEPNE_Pos: u32 = 6;
pub const USB_OTG_DIEPINT_INEPNE_Msk: u32 = 64;
pub const USB_OTG_DIEPINT_INEPNE: u32 = 64;
pub const USB_OTG_DIEPINT_TXFE_Pos: u32 = 7;
pub const USB_OTG_DIEPINT_TXFE_Msk: u32 = 128;
pub const USB_OTG_DIEPINT_TXFE: u32 = 128;
pub const USB_OTG_DIEPINT_TXFIFOUDRN_Pos: u32 = 8;
pub const USB_OTG_DIEPINT_TXFIFOUDRN_Msk: u32 = 256;
pub const USB_OTG_DIEPINT_TXFIFOUDRN: u32 = 256;
pub const USB_OTG_DIEPINT_BNA_Pos: u32 = 9;
pub const USB_OTG_DIEPINT_BNA_Msk: u32 = 512;
pub const USB_OTG_DIEPINT_BNA: u32 = 512;
pub const USB_OTG_DIEPINT_PKTDRPSTS_Pos: u32 = 11;
pub const USB_OTG_DIEPINT_PKTDRPSTS_Msk: u32 = 2048;
pub const USB_OTG_DIEPINT_PKTDRPSTS: u32 = 2048;
pub const USB_OTG_DIEPINT_BERR_Pos: u32 = 12;
pub const USB_OTG_DIEPINT_BERR_Msk: u32 = 4096;
pub const USB_OTG_DIEPINT_BERR: u32 = 4096;
pub const USB_OTG_DIEPINT_NAK_Pos: u32 = 13;
pub const USB_OTG_DIEPINT_NAK_Msk: u32 = 8192;
pub const USB_OTG_DIEPINT_NAK: u32 = 8192;
pub const USB_OTG_DIEPTSIZ_XFRSIZ_Pos: u32 = 0;
pub const USB_OTG_DIEPTSIZ_XFRSIZ_Msk: u32 = 524287;
pub const USB_OTG_DIEPTSIZ_XFRSIZ: u32 = 524287;
pub const USB_OTG_DIEPTSIZ_PKTCNT_Pos: u32 = 19;
pub const USB_OTG_DIEPTSIZ_PKTCNT_Msk: u32 = 536346624;
pub const USB_OTG_DIEPTSIZ_PKTCNT: u32 = 536346624;
pub const USB_OTG_DIEPTSIZ_MULCNT_Pos: u32 = 29;
pub const USB_OTG_DIEPTSIZ_MULCNT_Msk: u32 = 1610612736;
pub const USB_OTG_DIEPTSIZ_MULCNT: u32 = 1610612736;
pub const USB_OTG_DIEPDMA_DMAADDR_Pos: u32 = 0;
pub const USB_OTG_DIEPDMA_DMAADDR_Msk: u32 = 4294967295;
pub const USB_OTG_DIEPDMA_DMAADDR: u32 = 4294967295;
pub const USB_OTG_DTXFSTS_INEPTFSAV_Pos: u32 = 0;
pub const USB_OTG_DTXFSTS_INEPTFSAV_Msk: u32 = 65535;
pub const USB_OTG_DTXFSTS_INEPTFSAV: u32 = 65535;
pub const USB_OTG_DOEPCTL_MPSIZ_Pos: u32 = 0;
pub const USB_OTG_DOEPCTL_MPSIZ_Msk: u32 = 2047;
pub const USB_OTG_DOEPCTL_MPSIZ: u32 = 2047;
pub const USB_OTG_DOEPCTL_USBAEP_Pos: u32 = 15;
pub const USB_OTG_DOEPCTL_USBAEP_Msk: u32 = 32768;
pub const USB_OTG_DOEPCTL_USBAEP: u32 = 32768;
pub const USB_OTG_DOEPCTL_NAKSTS_Pos: u32 = 17;
pub const USB_OTG_DOEPCTL_NAKSTS_Msk: u32 = 131072;
pub const USB_OTG_DOEPCTL_NAKSTS: u32 = 131072;
pub const USB_OTG_DOEPCTL_SD0PID_SEVNFRM_Pos: u32 = 28;
pub const USB_OTG_DOEPCTL_SD0PID_SEVNFRM_Msk: u32 = 268435456;
pub const USB_OTG_DOEPCTL_SD0PID_SEVNFRM: u32 = 268435456;
pub const USB_OTG_DOEPCTL_SODDFRM_Pos: u32 = 29;
pub const USB_OTG_DOEPCTL_SODDFRM_Msk: u32 = 536870912;
pub const USB_OTG_DOEPCTL_SODDFRM: u32 = 536870912;
pub const USB_OTG_DOEPCTL_EPTYP_Pos: u32 = 18;
pub const USB_OTG_DOEPCTL_EPTYP_Msk: u32 = 786432;
pub const USB_OTG_DOEPCTL_EPTYP: u32 = 786432;
pub const USB_OTG_DOEPCTL_EPTYP_0: u32 = 262144;
pub const USB_OTG_DOEPCTL_EPTYP_1: u32 = 524288;
pub const USB_OTG_DOEPCTL_SNPM_Pos: u32 = 20;
pub const USB_OTG_DOEPCTL_SNPM_Msk: u32 = 1048576;
pub const USB_OTG_DOEPCTL_SNPM: u32 = 1048576;
pub const USB_OTG_DOEPCTL_STALL_Pos: u32 = 21;
pub const USB_OTG_DOEPCTL_STALL_Msk: u32 = 2097152;
pub const USB_OTG_DOEPCTL_STALL: u32 = 2097152;
pub const USB_OTG_DOEPCTL_CNAK_Pos: u32 = 26;
pub const USB_OTG_DOEPCTL_CNAK_Msk: u32 = 67108864;
pub const USB_OTG_DOEPCTL_CNAK: u32 = 67108864;
pub const USB_OTG_DOEPCTL_SNAK_Pos: u32 = 27;
pub const USB_OTG_DOEPCTL_SNAK_Msk: u32 = 134217728;
pub const USB_OTG_DOEPCTL_SNAK: u32 = 134217728;
pub const USB_OTG_DOEPCTL_EPDIS_Pos: u32 = 30;
pub const USB_OTG_DOEPCTL_EPDIS_Msk: u32 = 1073741824;
pub const USB_OTG_DOEPCTL_EPDIS: u32 = 1073741824;
pub const USB_OTG_DOEPCTL_EPENA_Pos: u32 = 31;
pub const USB_OTG_DOEPCTL_EPENA_Msk: u32 = 2147483648;
pub const USB_OTG_DOEPCTL_EPENA: u32 = 2147483648;
pub const USB_OTG_DOEPINT_XFRC_Pos: u32 = 0;
pub const USB_OTG_DOEPINT_XFRC_Msk: u32 = 1;
pub const USB_OTG_DOEPINT_XFRC: u32 = 1;
pub const USB_OTG_DOEPINT_EPDISD_Pos: u32 = 1;
pub const USB_OTG_DOEPINT_EPDISD_Msk: u32 = 2;
pub const USB_OTG_DOEPINT_EPDISD: u32 = 2;
pub const USB_OTG_DOEPINT_STUP_Pos: u32 = 3;
pub const USB_OTG_DOEPINT_STUP_Msk: u32 = 8;
pub const USB_OTG_DOEPINT_STUP: u32 = 8;
pub const USB_OTG_DOEPINT_OTEPDIS_Pos: u32 = 4;
pub const USB_OTG_DOEPINT_OTEPDIS_Msk: u32 = 16;
pub const USB_OTG_DOEPINT_OTEPDIS: u32 = 16;
pub const USB_OTG_DOEPINT_B2BSTUP_Pos: u32 = 6;
pub const USB_OTG_DOEPINT_B2BSTUP_Msk: u32 = 64;
pub const USB_OTG_DOEPINT_B2BSTUP: u32 = 64;
pub const USB_OTG_DOEPINT_NYET_Pos: u32 = 14;
pub const USB_OTG_DOEPINT_NYET_Msk: u32 = 16384;
pub const USB_OTG_DOEPINT_NYET: u32 = 16384;
pub const USB_OTG_DOEPTSIZ_XFRSIZ_Pos: u32 = 0;
pub const USB_OTG_DOEPTSIZ_XFRSIZ_Msk: u32 = 524287;
pub const USB_OTG_DOEPTSIZ_XFRSIZ: u32 = 524287;
pub const USB_OTG_DOEPTSIZ_PKTCNT_Pos: u32 = 19;
pub const USB_OTG_DOEPTSIZ_PKTCNT_Msk: u32 = 536346624;
pub const USB_OTG_DOEPTSIZ_PKTCNT: u32 = 536346624;
pub const USB_OTG_DOEPTSIZ_STUPCNT_Pos: u32 = 29;
pub const USB_OTG_DOEPTSIZ_STUPCNT_Msk: u32 = 1610612736;
pub const USB_OTG_DOEPTSIZ_STUPCNT: u32 = 1610612736;
pub const USB_OTG_DOEPTSIZ_STUPCNT_0: u32 = 536870912;
pub const USB_OTG_DOEPTSIZ_STUPCNT_1: u32 = 1073741824;
pub const USB_OTG_PCGCCTL_STPPCLK_Pos: u32 = 0;
pub const USB_OTG_PCGCCTL_STPPCLK_Msk: u32 = 1;
pub const USB_OTG_PCGCCTL_STPPCLK: u32 = 1;
pub const USB_OTG_PCGCCTL_GATEHCLK_Pos: u32 = 1;
pub const USB_OTG_PCGCCTL_GATEHCLK_Msk: u32 = 2;
pub const USB_OTG_PCGCCTL_GATEHCLK: u32 = 2;
pub const USB_OTG_PCGCCTL_PHYSUSP_Pos: u32 = 4;
pub const USB_OTG_PCGCCTL_PHYSUSP_Msk: u32 = 16;
pub const USB_OTG_PCGCCTL_PHYSUSP: u32 = 16;
pub const USB_OTG_PCGCCTL_STOPCLK_Pos: u32 = 0;
pub const USB_OTG_PCGCCTL_STOPCLK_Msk: u32 = 1;
pub const USB_OTG_PCGCCTL_STOPCLK: u32 = 1;
pub const USB_OTG_PCGCCTL_GATECLK_Pos: u32 = 1;
pub const USB_OTG_PCGCCTL_GATECLK_Msk: u32 = 2;
pub const USB_OTG_PCGCCTL_GATECLK: u32 = 2;
pub const USB_OTG_PCGCR_STPPCLK_Pos: u32 = 0;
pub const USB_OTG_PCGCR_STPPCLK_Msk: u32 = 1;
pub const USB_OTG_PCGCR_STPPCLK: u32 = 1;
pub const USB_OTG_PCGCR_GATEHCLK_Pos: u32 = 1;
pub const USB_OTG_PCGCR_GATEHCLK_Msk: u32 = 2;
pub const USB_OTG_PCGCR_GATEHCLK: u32 = 2;
pub const USB_OTG_PCGCR_PHYSUSP_Pos: u32 = 4;
pub const USB_OTG_PCGCR_PHYSUSP_Msk: u32 = 16;
pub const USB_OTG_PCGCR_PHYSUSP: u32 = 16;
pub const USB_OTG_GHWCFG3_LPMMode_Pos: u32 = 14;
pub const USB_OTG_GHWCFG3_LPMMode_Msk: u32 = 16384;
pub const USB_OTG_GHWCFG3_LPMMode: u32 = 16384;
pub const USB_OTG_HCSPLT_PRTADDR_Pos: u32 = 0;
pub const USB_OTG_HCSPLT_PRTADDR_Msk: u32 = 127;
pub const USB_OTG_HCSPLT_PRTADDR: u32 = 127;
pub const USB_OTG_HCSPLT_PRTADDR_0: u32 = 1;
pub const USB_OTG_HCSPLT_PRTADDR_1: u32 = 2;
pub const USB_OTG_HCSPLT_PRTADDR_2: u32 = 4;
pub const USB_OTG_HCSPLT_PRTADDR_3: u32 = 8;
pub const USB_OTG_HCSPLT_PRTADDR_4: u32 = 16;
pub const USB_OTG_HCSPLT_PRTADDR_5: u32 = 32;
pub const USB_OTG_HCSPLT_PRTADDR_6: u32 = 64;
pub const USB_OTG_HCSPLT_HUBADDR_Pos: u32 = 7;
pub const USB_OTG_HCSPLT_HUBADDR_Msk: u32 = 16256;
pub const USB_OTG_HCSPLT_HUBADDR: u32 = 16256;
pub const USB_OTG_HCSPLT_HUBADDR_0: u32 = 128;
pub const USB_OTG_HCSPLT_HUBADDR_1: u32 = 256;
pub const USB_OTG_HCSPLT_HUBADDR_2: u32 = 512;
pub const USB_OTG_HCSPLT_HUBADDR_3: u32 = 1024;
pub const USB_OTG_HCSPLT_HUBADDR_4: u32 = 2048;
pub const USB_OTG_HCSPLT_HUBADDR_5: u32 = 4096;
pub const USB_OTG_HCSPLT_HUBADDR_6: u32 = 8192;
pub const USB_OTG_HCSPLT_XACTPOS_Pos: u32 = 14;
pub const USB_OTG_HCSPLT_XACTPOS_Msk: u32 = 49152;
pub const USB_OTG_HCSPLT_XACTPOS: u32 = 49152;
pub const USB_OTG_HCSPLT_XACTPOS_0: u32 = 16384;
pub const USB_OTG_HCSPLT_XACTPOS_1: u32 = 32768;
pub const USB_OTG_HCSPLT_COMPLSPLT_Pos: u32 = 16;
pub const USB_OTG_HCSPLT_COMPLSPLT_Msk: u32 = 65536;
pub const USB_OTG_HCSPLT_COMPLSPLT: u32 = 65536;
pub const USB_OTG_HCSPLT_SPLITEN_Pos: u32 = 31;
pub const USB_OTG_HCSPLT_SPLITEN_Msk: u32 = 2147483648;
pub const USB_OTG_HCSPLT_SPLITEN: u32 = 2147483648;
pub const COMP_FLAG_LOCK: u32 = 2147483648;
pub const DAC_WAVE_NONE: u32 = 0;
pub const DAC_WAVE_NOISE: u32 = 64;
pub const DAC_WAVE_TRIANGLE: u32 = 128;
pub const DAC_WAVEGENERATION_NONE: u32 = 0;
pub const DAC_WAVEGENERATION_NOISE: u32 = 64;
pub const DAC_WAVEGENERATION_TRIANGLE: u32 = 128;
pub const ETH_MMCCR: u32 = 256;
pub const ETH_MMCRIR: u32 = 260;
pub const ETH_MMCTIR: u32 = 264;
pub const ETH_MMCRIMR: u32 = 268;
pub const ETH_MMCTIMR: u32 = 272;
pub const ETH_MMCTGFSCCR: u32 = 332;
pub const ETH_MMCTGFMSCCR: u32 = 336;
pub const ETH_MMCTGFCR: u32 = 360;
pub const ETH_MMCRFCECR: u32 = 404;
pub const ETH_MMCRFAECR: u32 = 408;
pub const ETH_MMCRGUFCR: u32 = 452;
pub const ETH_MAC_TXFIFO_FULL: u32 = 33554432;
pub const ETH_MAC_TXFIFONOT_EMPTY: u32 = 16777216;
pub const ETH_MAC_TXFIFO_WRITE_ACTIVE: u32 = 4194304;
pub const ETH_MAC_TXFIFO_IDLE: u32 = 0;
pub const ETH_MAC_TXFIFO_READ: u32 = 1048576;
pub const ETH_MAC_TXFIFO_WAITING: u32 = 2097152;
pub const ETH_MAC_TXFIFO_WRITING: u32 = 3145728;
pub const ETH_MAC_TRANSMISSION_PAUSE: u32 = 524288;
pub const ETH_MAC_TRANSMITFRAMECONTROLLER_IDLE: u32 = 0;
pub const ETH_MAC_TRANSMITFRAMECONTROLLER_WAITING: u32 = 131072;
pub const ETH_MAC_TRANSMITFRAMECONTROLLER_GENRATING_PCF: u32 = 262144;
pub const ETH_MAC_TRANSMITFRAMECONTROLLER_TRANSFERRING: u32 = 393216;
pub const ETH_MAC_MII_TRANSMIT_ACTIVE: u32 = 65536;
pub const ETH_MAC_RXFIFO_EMPTY: u32 = 0;
pub const ETH_MAC_RXFIFO_BELOW_THRESHOLD: u32 = 256;
pub const ETH_MAC_RXFIFO_ABOVE_THRESHOLD: u32 = 512;
pub const ETH_MAC_RXFIFO_FULL: u32 = 768;
pub const ETH_MAC_READCONTROLLER_IDLE: u32 = 0;
pub const ETH_MAC_READCONTROLLER_READING_DATA: u32 = 32;
pub const ETH_MAC_READCONTROLLER_READING_STATUS: u32 = 64;
pub const ETH_MAC_READCONTROLLER_FLUSHING: u32 = 96;
pub const ETH_MAC_RXFIFO_WRITE_ACTIVE: u32 = 16;
pub const ETH_MAC_SMALL_FIFO_NOTACTIVE: u32 = 0;
pub const ETH_MAC_SMALL_FIFO_READ_ACTIVE: u32 = 2;
pub const ETH_MAC_SMALL_FIFO_WRITE_ACTIVE: u32 = 4;
pub const ETH_MAC_SMALL_FIFO_RW_ACTIVE: u32 = 6;
pub const ETH_MAC_MII_RECEIVE_PROTOCOL_ACTIVE: u32 = 1;
pub const HAL_MAX_DELAY: u32 = 4294967295;
pub const RCC_DBP_TIMEOUT_VALUE: u32 = 2;
pub const RCC_LSE_TIMEOUT_VALUE: u32 = 5000;
pub const RCC_OSCILLATORTYPE_NONE: u32 = 0;
pub const RCC_OSCILLATORTYPE_HSE: u32 = 1;
pub const RCC_OSCILLATORTYPE_HSI: u32 = 2;
pub const RCC_OSCILLATORTYPE_LSE: u32 = 4;
pub const RCC_OSCILLATORTYPE_LSI: u32 = 8;
pub const RCC_OSCILLATORTYPE_MSI: u32 = 16;
pub const RCC_HSE_OFF: u32 = 0;
pub const RCC_HSE_ON: u32 = 65536;
pub const RCC_HSE_BYPASS: u32 = 327680;
pub const RCC_LSE_OFF: u32 = 0;
pub const RCC_LSE_ON: u32 = 1;
pub const RCC_LSE_BYPASS: u32 = 5;
pub const RCC_HSI_OFF: u32 = 0;
pub const RCC_HSI_ON: u32 = 256;
pub const RCC_HSICALIBRATION_DEFAULT: u32 = 16;
pub const RCC_LSI_OFF: u32 = 0;
pub const RCC_LSI_ON: u32 = 1;
pub const RCC_MSI_OFF: u32 = 0;
pub const RCC_MSI_ON: u32 = 1;
pub const RCC_MSICALIBRATION_DEFAULT: u32 = 0;
pub const RCC_HSI48_OFF: u32 = 0;
pub const RCC_PLL_NONE: u32 = 0;
pub const RCC_PLL_OFF: u32 = 1;
pub const RCC_PLL_ON: u32 = 2;
pub const RCC_PLLP_DIV7: u32 = 7;
pub const RCC_PLLP_DIV17: u32 = 17;
pub const RCC_PLLQ_DIV2: u32 = 2;
pub const RCC_PLLQ_DIV4: u32 = 4;
pub const RCC_PLLQ_DIV6: u32 = 6;
pub const RCC_PLLQ_DIV8: u32 = 8;
pub const RCC_PLLR_DIV2: u32 = 2;
pub const RCC_PLLR_DIV4: u32 = 4;
pub const RCC_PLLR_DIV6: u32 = 6;
pub const RCC_PLLR_DIV8: u32 = 8;
pub const RCC_PLLSOURCE_NONE: u32 = 0;
pub const RCC_PLLSOURCE_MSI: u32 = 1;
pub const RCC_PLLSOURCE_HSI: u32 = 2;
pub const RCC_PLLSOURCE_HSE: u32 = 3;
pub const RCC_PLL_SAI3CLK: u32 = 65536;
pub const RCC_PLL_48M1CLK: u32 = 1048576;
pub const RCC_PLL_SYSCLK: u32 = 16777216;
pub const RCC_PLLSAI1_SAI1CLK: u32 = 65536;
pub const RCC_PLLSAI1_48M2CLK: u32 = 1048576;
pub const RCC_PLLSAI1_ADC1CLK: u32 = 16777216;
pub const RCC_PLLSAI2_SAI2CLK: u32 = 65536;
pub const RCC_PLLSAI2_ADC2CLK: u32 = 16777216;
pub const RCC_MSIRANGE_0: u32 = 0;
pub const RCC_MSIRANGE_1: u32 = 16;
pub const RCC_MSIRANGE_2: u32 = 32;
pub const RCC_MSIRANGE_3: u32 = 48;
pub const RCC_MSIRANGE_4: u32 = 64;
pub const RCC_MSIRANGE_5: u32 = 80;
pub const RCC_MSIRANGE_6: u32 = 96;
pub const RCC_MSIRANGE_7: u32 = 112;
pub const RCC_MSIRANGE_8: u32 = 128;
pub const RCC_MSIRANGE_9: u32 = 144;
pub const RCC_MSIRANGE_10: u32 = 160;
pub const RCC_MSIRANGE_11: u32 = 176;
pub const RCC_CLOCKTYPE_SYSCLK: u32 = 1;
pub const RCC_CLOCKTYPE_HCLK: u32 = 2;
pub const RCC_CLOCKTYPE_PCLK1: u32 = 4;
pub const RCC_CLOCKTYPE_PCLK2: u32 = 8;
pub const RCC_SYSCLKSOURCE_MSI: u32 = 0;
pub const RCC_SYSCLKSOURCE_HSI: u32 = 1;
pub const RCC_SYSCLKSOURCE_HSE: u32 = 2;
pub const RCC_SYSCLKSOURCE_PLLCLK: u32 = 3;
pub const RCC_SYSCLKSOURCE_STATUS_MSI: u32 = 0;
pub const RCC_SYSCLKSOURCE_STATUS_HSI: u32 = 4;
pub const RCC_SYSCLKSOURCE_STATUS_HSE: u32 = 8;
pub const RCC_SYSCLKSOURCE_STATUS_PLLCLK: u32 = 12;
pub const RCC_SYSCLK_DIV1: u32 = 0;
pub const RCC_SYSCLK_DIV2: u32 = 128;
pub const RCC_SYSCLK_DIV4: u32 = 144;
pub const RCC_SYSCLK_DIV8: u32 = 160;
pub const RCC_SYSCLK_DIV16: u32 = 176;
pub const RCC_SYSCLK_DIV64: u32 = 192;
pub const RCC_SYSCLK_DIV128: u32 = 208;
pub const RCC_SYSCLK_DIV256: u32 = 224;
pub const RCC_SYSCLK_DIV512: u32 = 240;
pub const RCC_HCLK_DIV1: u32 = 0;
pub const RCC_HCLK_DIV2: u32 = 1024;
pub const RCC_HCLK_DIV4: u32 = 1280;
pub const RCC_HCLK_DIV8: u32 = 1536;
pub const RCC_HCLK_DIV16: u32 = 1792;
pub const RCC_RTCCLKSOURCE_NONE: u32 = 0;
pub const RCC_RTCCLKSOURCE_LSE: u32 = 256;
pub const RCC_RTCCLKSOURCE_LSI: u32 = 512;
pub const RCC_RTCCLKSOURCE_HSE_DIV32: u32 = 768;
pub const RCC_MCO1: u32 = 0;
pub const RCC_MCO: u32 = 0;
pub const RCC_MCO1SOURCE_NOCLOCK: u32 = 0;
pub const RCC_MCO1SOURCE_SYSCLK: u32 = 16777216;
pub const RCC_MCO1SOURCE_MSI: u32 = 33554432;
pub const RCC_MCO1SOURCE_HSI: u32 = 50331648;
pub const RCC_MCO1SOURCE_HSE: u32 = 67108864;
pub const RCC_MCO1SOURCE_PLLCLK: u32 = 83886080;
pub const RCC_MCO1SOURCE_LSI: u32 = 100663296;
pub const RCC_MCO1SOURCE_LSE: u32 = 117440512;
pub const RCC_MCODIV_1: u32 = 0;
pub const RCC_MCODIV_2: u32 = 268435456;
pub const RCC_MCODIV_4: u32 = 536870912;
pub const RCC_MCODIV_8: u32 = 805306368;
pub const RCC_MCODIV_16: u32 = 1073741824;
pub const RCC_IT_LSIRDY: u32 = 1;
pub const RCC_IT_LSERDY: u32 = 2;
pub const RCC_IT_MSIRDY: u32 = 4;
pub const RCC_IT_HSIRDY: u32 = 8;
pub const RCC_IT_HSERDY: u32 = 16;
pub const RCC_IT_PLLRDY: u32 = 32;
pub const RCC_IT_PLLSAI1RDY: u32 = 64;
pub const RCC_IT_PLLSAI2RDY: u32 = 128;
pub const RCC_IT_CSS: u32 = 256;
pub const RCC_IT_LSECSS: u32 = 512;
pub const RCC_LSEDRIVE_LOW: u32 = 0;
pub const RCC_LSEDRIVE_MEDIUMLOW: u32 = 8;
pub const RCC_LSEDRIVE_MEDIUMHIGH: u32 = 16;
pub const RCC_LSEDRIVE_HIGH: u32 = 24;
pub const RCC_STOP_WAKEUPCLOCK_MSI: u32 = 0;
pub const RCC_STOP_WAKEUPCLOCK_HSI: u32 = 32768;
pub const CR_REG_INDEX: u32 = 1;
pub const BDCR_REG_INDEX: u32 = 2;
pub const CSR_REG_INDEX: u32 = 3;
pub const RCC_FLAG_MASK: u32 = 31;
pub const RCC_LSCOSOURCE_LSI: u32 = 0;
pub const RCC_LSCOSOURCE_LSE: u32 = 33554432;
pub const RCC_PERIPHCLK_USART1: u32 = 1;
pub const RCC_PERIPHCLK_USART2: u32 = 2;
pub const RCC_PERIPHCLK_USART3: u32 = 4;
pub const RCC_PERIPHCLK_UART4: u32 = 8;
pub const RCC_PERIPHCLK_UART5: u32 = 16;
pub const RCC_PERIPHCLK_LPUART1: u32 = 32;
pub const RCC_PERIPHCLK_I2C1: u32 = 64;
pub const RCC_PERIPHCLK_I2C2: u32 = 128;
pub const RCC_PERIPHCLK_I2C3: u32 = 256;
pub const RCC_PERIPHCLK_LPTIM1: u32 = 512;
pub const RCC_PERIPHCLK_LPTIM2: u32 = 1024;
pub const RCC_PERIPHCLK_SAI1: u32 = 2048;
pub const RCC_PERIPHCLK_SAI2: u32 = 4096;
pub const RCC_PERIPHCLK_USB: u32 = 8192;
pub const RCC_PERIPHCLK_ADC: u32 = 16384;
pub const RCC_PERIPHCLK_SWPMI1: u32 = 32768;
pub const RCC_PERIPHCLK_DFSDM1: u32 = 65536;
pub const RCC_PERIPHCLK_RTC: u32 = 131072;
pub const RCC_PERIPHCLK_RNG: u32 = 262144;
pub const RCC_PERIPHCLK_SDMMC1: u32 = 524288;
pub const RCC_USART1CLKSOURCE_PCLK2: u32 = 0;
pub const RCC_USART1CLKSOURCE_SYSCLK: u32 = 1;
pub const RCC_USART1CLKSOURCE_HSI: u32 = 2;
pub const RCC_USART1CLKSOURCE_LSE: u32 = 3;
pub const RCC_USART2CLKSOURCE_PCLK1: u32 = 0;
pub const RCC_USART2CLKSOURCE_SYSCLK: u32 = 4;
pub const RCC_USART2CLKSOURCE_HSI: u32 = 8;
pub const RCC_USART2CLKSOURCE_LSE: u32 = 12;
pub const RCC_USART3CLKSOURCE_PCLK1: u32 = 0;
pub const RCC_USART3CLKSOURCE_SYSCLK: u32 = 16;
pub const RCC_USART3CLKSOURCE_HSI: u32 = 32;
pub const RCC_USART3CLKSOURCE_LSE: u32 = 48;
pub const RCC_UART4CLKSOURCE_PCLK1: u32 = 0;
pub const RCC_UART4CLKSOURCE_SYSCLK: u32 = 64;
pub const RCC_UART4CLKSOURCE_HSI: u32 = 128;
pub const RCC_UART4CLKSOURCE_LSE: u32 = 192;
pub const RCC_UART5CLKSOURCE_PCLK1: u32 = 0;
pub const RCC_UART5CLKSOURCE_SYSCLK: u32 = 256;
pub const RCC_UART5CLKSOURCE_HSI: u32 = 512;
pub const RCC_UART5CLKSOURCE_LSE: u32 = 768;
pub const RCC_LPUART1CLKSOURCE_PCLK1: u32 = 0;
pub const RCC_LPUART1CLKSOURCE_SYSCLK: u32 = 1024;
pub const RCC_LPUART1CLKSOURCE_HSI: u32 = 2048;
pub const RCC_LPUART1CLKSOURCE_LSE: u32 = 3072;
pub const RCC_I2C1CLKSOURCE_PCLK1: u32 = 0;
pub const RCC_I2C1CLKSOURCE_SYSCLK: u32 = 4096;
pub const RCC_I2C1CLKSOURCE_HSI: u32 = 8192;
pub const RCC_I2C2CLKSOURCE_PCLK1: u32 = 0;
pub const RCC_I2C2CLKSOURCE_SYSCLK: u32 = 16384;
pub const RCC_I2C2CLKSOURCE_HSI: u32 = 32768;
pub const RCC_I2C3CLKSOURCE_PCLK1: u32 = 0;
pub const RCC_I2C3CLKSOURCE_SYSCLK: u32 = 65536;
pub const RCC_I2C3CLKSOURCE_HSI: u32 = 131072;
pub const RCC_SAI1CLKSOURCE_PLLSAI1: u32 = 0;
pub const RCC_SAI1CLKSOURCE_PLLSAI2: u32 = 4194304;
pub const RCC_SAI1CLKSOURCE_PLL: u32 = 8388608;
pub const RCC_SAI1CLKSOURCE_PIN: u32 = 12582912;
pub const RCC_SAI2CLKSOURCE_PLLSAI1: u32 = 0;
pub const RCC_SAI2CLKSOURCE_PLLSAI2: u32 = 16777216;
pub const RCC_SAI2CLKSOURCE_PLL: u32 = 33554432;
pub const RCC_SAI2CLKSOURCE_PIN: u32 = 50331648;
pub const RCC_LPTIM1CLKSOURCE_PCLK1: u32 = 0;
pub const RCC_LPTIM1CLKSOURCE_LSI: u32 = 262144;
pub const RCC_LPTIM1CLKSOURCE_HSI: u32 = 524288;
pub const RCC_LPTIM1CLKSOURCE_LSE: u32 = 786432;
pub const RCC_LPTIM2CLKSOURCE_PCLK1: u32 = 0;
pub const RCC_LPTIM2CLKSOURCE_LSI: u32 = 1048576;
pub const RCC_LPTIM2CLKSOURCE_HSI: u32 = 2097152;
pub const RCC_LPTIM2CLKSOURCE_LSE: u32 = 3145728;
pub const RCC_SDMMC1CLKSOURCE_NONE: u32 = 0;
pub const RCC_SDMMC1CLKSOURCE_PLLSAI1: u32 = 67108864;
pub const RCC_SDMMC1CLKSOURCE_PLL: u32 = 134217728;
pub const RCC_SDMMC1CLKSOURCE_MSI: u32 = 201326592;
pub const RCC_RNGCLKSOURCE_NONE: u32 = 0;
pub const RCC_RNGCLKSOURCE_PLLSAI1: u32 = 67108864;
pub const RCC_RNGCLKSOURCE_PLL: u32 = 134217728;
pub const RCC_RNGCLKSOURCE_MSI: u32 = 201326592;
pub const RCC_USBCLKSOURCE_NONE: u32 = 0;
pub const RCC_USBCLKSOURCE_PLLSAI1: u32 = 67108864;
pub const RCC_USBCLKSOURCE_PLL: u32 = 134217728;
pub const RCC_USBCLKSOURCE_MSI: u32 = 201326592;
pub const RCC_ADCCLKSOURCE_NONE: u32 = 0;
pub const RCC_ADCCLKSOURCE_PLLSAI1: u32 = 268435456;
pub const RCC_ADCCLKSOURCE_PLLSAI2: u32 = 536870912;
pub const RCC_ADCCLKSOURCE_SYSCLK: u32 = 805306368;
pub const RCC_SWPMI1CLKSOURCE_PCLK1: u32 = 0;
pub const RCC_SWPMI1CLKSOURCE_HSI: u32 = 1073741824;
pub const RCC_DFSDM1CLKSOURCE_PCLK2: u32 = 0;
pub const RCC_DFSDM1CLKSOURCE_SYSCLK: u32 = 2147483648;
pub const RCC_EXTI_LINE_LSECSS: u32 = 524288;
pub const GPIO_PIN_MASK: u32 = 65535;
pub const GPIO_MODE_INPUT: u32 = 0;
pub const GPIO_MODE_OUTPUT_PP: u32 = 1;
pub const GPIO_MODE_OUTPUT_OD: u32 = 17;
pub const GPIO_MODE_AF_PP: u32 = 2;
pub const GPIO_MODE_AF_OD: u32 = 18;
pub const GPIO_MODE_ANALOG: u32 = 3;
pub const GPIO_MODE_ANALOG_ADC_CONTROL: u32 = 11;
pub const GPIO_MODE_IT_RISING: u32 = 269549568;
pub const GPIO_MODE_IT_FALLING: u32 = 270598144;
pub const GPIO_MODE_IT_RISING_FALLING: u32 = 271646720;
pub const GPIO_MODE_EVT_RISING: u32 = 269615104;
pub const GPIO_MODE_EVT_FALLING: u32 = 270663680;
pub const GPIO_MODE_EVT_RISING_FALLING: u32 = 271712256;
pub const GPIO_SPEED_FREQ_LOW: u32 = 0;
pub const GPIO_SPEED_FREQ_MEDIUM: u32 = 1;
pub const GPIO_SPEED_FREQ_HIGH: u32 = 2;
pub const GPIO_SPEED_FREQ_VERY_HIGH: u32 = 3;
pub const GPIO_NOPULL: u32 = 0;
pub const GPIO_PULLUP: u32 = 1;
pub const GPIO_PULLDOWN: u32 = 2;
pub const HAL_DMA_ERROR_NONE: u32 = 0;
pub const HAL_DMA_ERROR_TE: u32 = 1;
pub const HAL_DMA_ERROR_NO_XFER: u32 = 4;
pub const HAL_DMA_ERROR_TIMEOUT: u32 = 32;
pub const HAL_DMA_ERROR_NOT_SUPPORTED: u32 = 256;
pub const HAL_DMA_ERROR_SYNC: u32 = 512;
pub const HAL_DMA_ERROR_REQGEN: u32 = 1024;
pub const DMA_REQUEST_0: u32 = 0;
pub const DMA_REQUEST_1: u32 = 1;
pub const DMA_REQUEST_2: u32 = 2;
pub const DMA_REQUEST_3: u32 = 3;
pub const DMA_REQUEST_4: u32 = 4;
pub const DMA_REQUEST_5: u32 = 5;
pub const DMA_REQUEST_6: u32 = 6;
pub const DMA_REQUEST_7: u32 = 7;
pub const DMA_PERIPH_TO_MEMORY: u32 = 0;
pub const DMA_MEMORY_TO_PERIPH: u32 = 16;
pub const DMA_MEMORY_TO_MEMORY: u32 = 16384;
pub const DMA_PINC_ENABLE: u32 = 64;
pub const DMA_PINC_DISABLE: u32 = 0;
pub const DMA_MINC_ENABLE: u32 = 128;
pub const DMA_MINC_DISABLE: u32 = 0;
pub const DMA_PDATAALIGN_BYTE: u32 = 0;
pub const DMA_PDATAALIGN_HALFWORD: u32 = 256;
pub const DMA_PDATAALIGN_WORD: u32 = 512;
pub const DMA_MDATAALIGN_BYTE: u32 = 0;
pub const DMA_MDATAALIGN_HALFWORD: u32 = 1024;
pub const DMA_MDATAALIGN_WORD: u32 = 2048;
pub const DMA_NORMAL: u32 = 0;
pub const DMA_CIRCULAR: u32 = 32;
pub const DMA_PRIORITY_LOW: u32 = 0;
pub const DMA_PRIORITY_MEDIUM: u32 = 4096;
pub const DMA_PRIORITY_HIGH: u32 = 8192;
pub const DMA_PRIORITY_VERY_HIGH: u32 = 12288;
pub const DMA_IT_TC: u32 = 2;
pub const DMA_IT_HT: u32 = 4;
pub const DMA_IT_TE: u32 = 8;
pub const DMA_FLAG_GL1: u32 = 1;
pub const DMA_FLAG_TC1: u32 = 2;
pub const DMA_FLAG_HT1: u32 = 4;
pub const DMA_FLAG_TE1: u32 = 8;
pub const DMA_FLAG_GL2: u32 = 16;
pub const DMA_FLAG_TC2: u32 = 32;
pub const DMA_FLAG_HT2: u32 = 64;
pub const DMA_FLAG_TE2: u32 = 128;
pub const DMA_FLAG_GL3: u32 = 256;
pub const DMA_FLAG_TC3: u32 = 512;
pub const DMA_FLAG_HT3: u32 = 1024;
pub const DMA_FLAG_TE3: u32 = 2048;
pub const DMA_FLAG_GL4: u32 = 4096;
pub const DMA_FLAG_TC4: u32 = 8192;
pub const DMA_FLAG_HT4: u32 = 16384;
pub const DMA_FLAG_TE4: u32 = 32768;
pub const DMA_FLAG_GL5: u32 = 65536;
pub const DMA_FLAG_TC5: u32 = 131072;
pub const DMA_FLAG_HT5: u32 = 262144;
pub const DMA_FLAG_TE5: u32 = 524288;
pub const DMA_FLAG_GL6: u32 = 1048576;
pub const DMA_FLAG_TC6: u32 = 2097152;
pub const DMA_FLAG_HT6: u32 = 4194304;
pub const DMA_FLAG_TE6: u32 = 8388608;
pub const DMA_FLAG_GL7: u32 = 16777216;
pub const DMA_FLAG_TC7: u32 = 33554432;
pub const DMA_FLAG_HT7: u32 = 67108864;
pub const DMA_FLAG_TE7: u32 = 134217728;
pub const DFSDM_CHANNEL_OUTPUT_CLOCK_SYSTEM: u32 = 0;
pub const DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO: u32 = 1073741824;
pub const DFSDM_CHANNEL_EXTERNAL_INPUTS: u32 = 0;
pub const DFSDM_CHANNEL_INTERNAL_REGISTER: u32 = 8192;
pub const DFSDM_CHANNEL_STANDARD_MODE: u32 = 0;
pub const DFSDM_CHANNEL_INTERLEAVED_MODE: u32 = 16384;
pub const DFSDM_CHANNEL_DUAL_MODE: u32 = 32768;
pub const DFSDM_CHANNEL_SAME_CHANNEL_PINS: u32 = 0;
pub const DFSDM_CHANNEL_FOLLOWING_CHANNEL_PINS: u32 = 256;
pub const DFSDM_CHANNEL_SPI_RISING: u32 = 0;
pub const DFSDM_CHANNEL_SPI_FALLING: u32 = 1;
pub const DFSDM_CHANNEL_MANCHESTER_RISING: u32 = 2;
pub const DFSDM_CHANNEL_MANCHESTER_FALLING: u32 = 3;
pub const DFSDM_CHANNEL_SPI_CLOCK_EXTERNAL: u32 = 0;
pub const DFSDM_CHANNEL_SPI_CLOCK_INTERNAL: u32 = 4;
pub const DFSDM_CHANNEL_SPI_CLOCK_INTERNAL_DIV2_FALLING: u32 = 8;
pub const DFSDM_CHANNEL_SPI_CLOCK_INTERNAL_DIV2_RISING: u32 = 12;
pub const DFSDM_CHANNEL_FASTSINC_ORDER: u32 = 0;
pub const DFSDM_CHANNEL_SINC1_ORDER: u32 = 4194304;
pub const DFSDM_CHANNEL_SINC2_ORDER: u32 = 8388608;
pub const DFSDM_CHANNEL_SINC3_ORDER: u32 = 12582912;
pub const DFSDM_FILTER_SW_TRIGGER: u32 = 0;
pub const DFSDM_FILTER_SYNC_TRIGGER: u32 = 1;
pub const DFSDM_FILTER_EXT_TRIGGER: u32 = 2;
pub const DFSDM_FILTER_EXT_TRIG_TIM1_TRGO: u32 = 0;
pub const DFSDM_FILTER_EXT_TRIG_TIM1_TRGO2: u32 = 256;
pub const DFSDM_FILTER_EXT_TRIG_TIM8_TRGO: u32 = 512;
pub const DFSDM_FILTER_EXT_TRIG_TIM8_TRGO2: u32 = 768;
pub const DFSDM_FILTER_EXT_TRIG_TIM3_TRGO: u32 = 768;
pub const DFSDM_FILTER_EXT_TRIG_TIM4_TRGO: u32 = 1024;
pub const DFSDM_FILTER_EXT_TRIG_TIM16_OC1: u32 = 1024;
pub const DFSDM_FILTER_EXT_TRIG_TIM6_TRGO: u32 = 1280;
pub const DFSDM_FILTER_EXT_TRIG_TIM7_TRGO: u32 = 1280;
pub const DFSDM_FILTER_EXT_TRIG_EXTI11: u32 = 1536;
pub const DFSDM_FILTER_EXT_TRIG_EXTI15: u32 = 1792;
pub const DFSDM_FILTER_EXT_TRIG_RISING_EDGE: u32 = 8192;
pub const DFSDM_FILTER_EXT_TRIG_FALLING_EDGE: u32 = 16384;
pub const DFSDM_FILTER_EXT_TRIG_BOTH_EDGES: u32 = 24576;
pub const DFSDM_FILTER_FASTSINC_ORDER: u32 = 0;
pub const DFSDM_FILTER_SINC1_ORDER: u32 = 536870912;
pub const DFSDM_FILTER_SINC2_ORDER: u32 = 1073741824;
pub const DFSDM_FILTER_SINC3_ORDER: u32 = 1610612736;
pub const DFSDM_FILTER_SINC4_ORDER: u32 = 2147483648;
pub const DFSDM_FILTER_SINC5_ORDER: u32 = 2684354560;
pub const DFSDM_FILTER_AWD_FILTER_DATA: u32 = 0;
pub const DFSDM_FILTER_AWD_CHANNEL_DATA: u32 = 1073741824;
pub const DFSDM_FILTER_ERROR_NONE: u32 = 0;
pub const DFSDM_FILTER_ERROR_REGULAR_OVERRUN: u32 = 1;
pub const DFSDM_FILTER_ERROR_INJECTED_OVERRUN: u32 = 2;
pub const DFSDM_FILTER_ERROR_DMA: u32 = 3;
pub const DFSDM_NO_BREAK_SIGNAL: u32 = 0;
pub const DFSDM_BREAK_SIGNAL_0: u32 = 1;
pub const DFSDM_BREAK_SIGNAL_1: u32 = 2;
pub const DFSDM_BREAK_SIGNAL_2: u32 = 4;
pub const DFSDM_BREAK_SIGNAL_3: u32 = 8;
pub const DFSDM_CHANNEL_0: u32 = 1;
pub const DFSDM_CHANNEL_1: u32 = 65538;
pub const DFSDM_CHANNEL_2: u32 = 131076;
pub const DFSDM_CHANNEL_3: u32 = 196616;
pub const DFSDM_CHANNEL_4: u32 = 262160;
pub const DFSDM_CHANNEL_5: u32 = 327712;
pub const DFSDM_CHANNEL_6: u32 = 393280;
pub const DFSDM_CHANNEL_7: u32 = 458880;
pub const DFSDM_CONTINUOUS_CONV_OFF: u32 = 0;
pub const DFSDM_CONTINUOUS_CONV_ON: u32 = 1;
pub const DFSDM_AWD_HIGH_THRESHOLD: u32 = 0;
pub const DFSDM_AWD_LOW_THRESHOLD: u32 = 1;
pub const SYSTICK_CLKSOURCE_HCLK_DIV8: u32 = 0;
pub const SYSTICK_CLKSOURCE_HCLK: u32 = 4;
pub const MPU_HFNMI_PRIVDEF_NONE: u32 = 0;
pub const MPU_HARDFAULT_NMI: u32 = 2;
pub const MPU_PRIVILEGED_DEFAULT: u32 = 4;
pub const MPU_HFNMI_PRIVDEF: u32 = 6;
pub const ADC_SQR1_REGOFFSET: u32 = 0;
pub const ADC_SQR2_REGOFFSET: u32 = 256;
pub const ADC_SQR3_REGOFFSET: u32 = 512;
pub const ADC_SQR4_REGOFFSET: u32 = 768;
pub const ADC_REG_SQRX_REGOFFSET_MASK: u32 = 768;
pub const ADC_SQRX_REGOFFSET_POS: u32 = 8;
pub const ADC_REG_RANK_1_SQRX_BITOFFSET_POS: u32 = 6;
pub const ADC_REG_RANK_2_SQRX_BITOFFSET_POS: u32 = 12;
pub const ADC_REG_RANK_3_SQRX_BITOFFSET_POS: u32 = 18;
pub const ADC_REG_RANK_4_SQRX_BITOFFSET_POS: u32 = 24;
pub const ADC_REG_RANK_5_SQRX_BITOFFSET_POS: u32 = 0;
pub const ADC_REG_RANK_6_SQRX_BITOFFSET_POS: u32 = 6;
pub const ADC_REG_RANK_7_SQRX_BITOFFSET_POS: u32 = 12;
pub const ADC_REG_RANK_8_SQRX_BITOFFSET_POS: u32 = 18;
pub const ADC_REG_RANK_9_SQRX_BITOFFSET_POS: u32 = 24;
pub const ADC_REG_RANK_10_SQRX_BITOFFSET_POS: u32 = 0;
pub const ADC_REG_RANK_11_SQRX_BITOFFSET_POS: u32 = 6;
pub const ADC_REG_RANK_12_SQRX_BITOFFSET_POS: u32 = 12;
pub const ADC_REG_RANK_13_SQRX_BITOFFSET_POS: u32 = 18;
pub const ADC_REG_RANK_14_SQRX_BITOFFSET_POS: u32 = 24;
pub const ADC_REG_RANK_15_SQRX_BITOFFSET_POS: u32 = 0;
pub const ADC_REG_RANK_16_SQRX_BITOFFSET_POS: u32 = 6;
pub const ADC_JDR1_REGOFFSET: u32 = 0;
pub const ADC_JDR2_REGOFFSET: u32 = 256;
pub const ADC_JDR3_REGOFFSET: u32 = 512;
pub const ADC_JDR4_REGOFFSET: u32 = 768;
pub const ADC_INJ_JDRX_REGOFFSET_MASK: u32 = 768;
pub const ADC_JDRX_REGOFFSET_POS: u32 = 8;
pub const ADC_INJ_RANK_1_JSQR_BITOFFSET_POS: u32 = 8;
pub const ADC_INJ_RANK_2_JSQR_BITOFFSET_POS: u32 = 14;
pub const ADC_INJ_RANK_3_JSQR_BITOFFSET_POS: u32 = 20;
pub const ADC_INJ_RANK_4_JSQR_BITOFFSET_POS: u32 = 26;
pub const ADC_REG_TRIG_EXT_EDGE_DEFAULT: u32 = 1024;
pub const ADC_REG_TRIG_EXTSEL_BITOFFSET_POS: u32 = 6;
pub const ADC_REG_TRIG_EXTEN_BITOFFSET_POS: u32 = 10;
pub const ADC_INJ_TRIG_EXT_EDGE_DEFAULT: u32 = 64;
pub const ADC_INJ_TRIG_EXTSEL_BITOFFSET_POS: u32 = 2;
pub const ADC_INJ_TRIG_EXTEN_BITOFFSET_POS: u32 = 6;
pub const ADC_CHANNEL_ID_NUMBER_MASK: u32 = 2080374784;
pub const ADC_CHANNEL_ID_BITFIELD_MASK: u32 = 524287;
pub const ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS: u32 = 26;
pub const ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0: u32 = 31;
pub const ADC_CHANNEL_ID_INTERNAL_CH: u32 = 2147483648;
pub const ADC_CHANNEL_ID_INTERNAL_CH_2: u32 = 524288;
pub const ADC_CHANNEL_ID_INTERNAL_CH_MASK: u32 = 2148007936;
pub const ADC_SMPR1_REGOFFSET: u32 = 0;
pub const ADC_SMPR2_REGOFFSET: u32 = 33554432;
pub const ADC_CHANNEL_SMPRX_REGOFFSET_MASK: u32 = 33554432;
pub const ADC_SMPRX_REGOFFSET_POS: u32 = 25;
pub const ADC_CHANNEL_SMPx_BITOFFSET_MASK: u32 = 32505856;
pub const ADC_CHANNEL_SMPx_BITOFFSET_POS: u32 = 20;
pub const ADC_CHANNEL_0_NUMBER: u32 = 0;
pub const ADC_CHANNEL_1_NUMBER: u32 = 67108864;
pub const ADC_CHANNEL_2_NUMBER: u32 = 134217728;
pub const ADC_CHANNEL_3_NUMBER: u32 = 201326592;
pub const ADC_CHANNEL_4_NUMBER: u32 = 268435456;
pub const ADC_CHANNEL_5_NUMBER: u32 = 335544320;
pub const ADC_CHANNEL_6_NUMBER: u32 = 402653184;
pub const ADC_CHANNEL_7_NUMBER: u32 = 469762048;
pub const ADC_CHANNEL_8_NUMBER: u32 = 536870912;
pub const ADC_CHANNEL_9_NUMBER: u32 = 603979776;
pub const ADC_CHANNEL_10_NUMBER: u32 = 671088640;
pub const ADC_CHANNEL_11_NUMBER: u32 = 738197504;
pub const ADC_CHANNEL_12_NUMBER: u32 = 805306368;
pub const ADC_CHANNEL_13_NUMBER: u32 = 872415232;
pub const ADC_CHANNEL_14_NUMBER: u32 = 939524096;
pub const ADC_CHANNEL_15_NUMBER: u32 = 1006632960;
pub const ADC_CHANNEL_16_NUMBER: u32 = 1073741824;
pub const ADC_CHANNEL_17_NUMBER: u32 = 1140850688;
pub const ADC_CHANNEL_18_NUMBER: u32 = 1207959552;
pub const ADC_CHANNEL_0_BITFIELD: u32 = 1;
pub const ADC_CHANNEL_1_BITFIELD: u32 = 2;
pub const ADC_CHANNEL_2_BITFIELD: u32 = 4;
pub const ADC_CHANNEL_3_BITFIELD: u32 = 8;
pub const ADC_CHANNEL_4_BITFIELD: u32 = 16;
pub const ADC_CHANNEL_5_BITFIELD: u32 = 32;
pub const ADC_CHANNEL_6_BITFIELD: u32 = 64;
pub const ADC_CHANNEL_7_BITFIELD: u32 = 128;
pub const ADC_CHANNEL_8_BITFIELD: u32 = 256;
pub const ADC_CHANNEL_9_BITFIELD: u32 = 512;
pub const ADC_CHANNEL_10_BITFIELD: u32 = 1024;
pub const ADC_CHANNEL_11_BITFIELD: u32 = 2048;
pub const ADC_CHANNEL_12_BITFIELD: u32 = 4096;
pub const ADC_CHANNEL_13_BITFIELD: u32 = 8192;
pub const ADC_CHANNEL_14_BITFIELD: u32 = 16384;
pub const ADC_CHANNEL_15_BITFIELD: u32 = 32768;
pub const ADC_CHANNEL_16_BITFIELD: u32 = 65536;
pub const ADC_CHANNEL_17_BITFIELD: u32 = 131072;
pub const ADC_CHANNEL_18_BITFIELD: u32 = 262144;
pub const ADC_CHANNEL_0_SMP: u32 = 0;
pub const ADC_CHANNEL_1_SMP: u32 = 3145728;
pub const ADC_CHANNEL_2_SMP: u32 = 6291456;
pub const ADC_CHANNEL_3_SMP: u32 = 9437184;
pub const ADC_CHANNEL_4_SMP: u32 = 12582912;
pub const ADC_CHANNEL_5_SMP: u32 = 15728640;
pub const ADC_CHANNEL_6_SMP: u32 = 18874368;
pub const ADC_CHANNEL_7_SMP: u32 = 22020096;
pub const ADC_CHANNEL_8_SMP: u32 = 25165824;
pub const ADC_CHANNEL_9_SMP: u32 = 28311552;
pub const ADC_CHANNEL_10_SMP: u32 = 33554432;
pub const ADC_CHANNEL_11_SMP: u32 = 36700160;
pub const ADC_CHANNEL_12_SMP: u32 = 39845888;
pub const ADC_CHANNEL_13_SMP: u32 = 42991616;
pub const ADC_CHANNEL_14_SMP: u32 = 46137344;
pub const ADC_CHANNEL_15_SMP: u32 = 49283072;
pub const ADC_CHANNEL_16_SMP: u32 = 52428800;
pub const ADC_CHANNEL_17_SMP: u32 = 55574528;
pub const ADC_CHANNEL_18_SMP: u32 = 58720256;
pub const ADC_SINGLEDIFF_CALIB_START_MASK: u32 = 1073741824;
pub const ADC_SINGLEDIFF_CALIB_FACTOR_MASK: u32 = 8323199;
pub const ADC_SINGLEDIFF_CHANNEL_MASK: u32 = 524287;
pub const ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK: u32 = 24;
pub const ADC_SINGLEDIFF_CALIB_F_BIT_D_MASK: u32 = 65536;
pub const ADC_SINGLEDIFF_CALIB_F_BIT_D_POS: u32 = 16;
pub const ADC_SINGLEDIFF_CALIB_F_BIT_D_SHIFT4: u32 = 12;
pub const ADC_AWD_CR1_REGOFFSET: u32 = 0;
pub const ADC_AWD_CR2_REGOFFSET: u32 = 1048576;
pub const ADC_AWD_CR3_REGOFFSET: u32 = 2097152;
pub const ADC_AWD_CR12_REGOFFSETGAP_MASK: u32 = 1;
pub const ADC_AWD_CR12_REGOFFSETGAP_VAL: u32 = 36;
pub const ADC_AWD_CRX_REGOFFSET_MASK: u32 = 3145728;
pub const ADC_AWD_CR1_CHANNEL_MASK: u32 = 2109734912;
pub const ADC_AWD_CR23_CHANNEL_MASK: u32 = 524287;
pub const ADC_AWD_CR_ALL_CHANNEL_MASK: u32 = 2110259199;
pub const ADC_AWD_CRX_REGOFFSET_POS: u32 = 20;
pub const ADC_AWD_TR1_REGOFFSET: u32 = 0;
pub const ADC_AWD_TR2_REGOFFSET: u32 = 1048576;
pub const ADC_AWD_TR3_REGOFFSET: u32 = 2097152;
pub const ADC_AWD_TRX_REGOFFSET_MASK: u32 = 3145728;
pub const ADC_AWD_TRX_REGOFFSET_POS: u32 = 20;
pub const ADC_AWD_TRX_BIT_HIGH_MASK: u32 = 65536;
pub const ADC_AWD_TRX_BIT_HIGH_POS: u32 = 16;
pub const ADC_AWD_TRX_BIT_HIGH_SHIFT4: u32 = 12;
pub const ADC_OFR1_REGOFFSET: u32 = 0;
pub const ADC_OFR2_REGOFFSET: u32 = 1;
pub const ADC_OFR3_REGOFFSET: u32 = 2;
pub const ADC_OFR4_REGOFFSET: u32 = 3;
pub const ADC_OFRx_REGOFFSET_MASK: u32 = 3;
pub const ADC_CFGR_RES_BITOFFSET_POS: u32 = 3;
pub const ADC_CFGR_AWD1SGL_BITOFFSET_POS: u32 = 22;
pub const ADC_CFGR_AWD1EN_BITOFFSET_POS: u32 = 23;
pub const ADC_CFGR_JAWD1EN_BITOFFSET_POS: u32 = 24;
pub const ADC_TR1_HT1_BITOFFSET_POS: u32 = 16;
pub const ADC_CR_BITS_PROPERTY_RS: u32 = 2147483711;
pub const VREFINT_CAL_VREF: u32 = 3000;
pub const TEMPSENSOR_CAL2_TEMP: u32 = 110;
pub const TEMPSENSOR_CAL_VREFANALOG: u32 = 3000;
pub const LL_ADC_FLAG_ADRDY: u32 = 1;
pub const LL_ADC_FLAG_EOC: u32 = 4;
pub const LL_ADC_FLAG_EOS: u32 = 8;
pub const LL_ADC_FLAG_OVR: u32 = 16;
pub const LL_ADC_FLAG_EOSMP: u32 = 2;
pub const LL_ADC_FLAG_JEOC: u32 = 32;
pub const LL_ADC_FLAG_JEOS: u32 = 64;
pub const LL_ADC_FLAG_JQOVF: u32 = 1024;
pub const LL_ADC_FLAG_AWD1: u32 = 128;
pub const LL_ADC_FLAG_AWD2: u32 = 256;
pub const LL_ADC_FLAG_AWD3: u32 = 512;
pub const LL_ADC_FLAG_ADRDY_MST: u32 = 1;
pub const LL_ADC_FLAG_ADRDY_SLV: u32 = 65536;
pub const LL_ADC_FLAG_EOC_MST: u32 = 4;
pub const LL_ADC_FLAG_EOC_SLV: u32 = 262144;
pub const LL_ADC_FLAG_EOS_MST: u32 = 8;
pub const LL_ADC_FLAG_EOS_SLV: u32 = 524288;
pub const LL_ADC_FLAG_OVR_MST: u32 = 16;
pub const LL_ADC_FLAG_OVR_SLV: u32 = 1048576;
pub const LL_ADC_FLAG_EOSMP_MST: u32 = 2;
pub const LL_ADC_FLAG_EOSMP_SLV: u32 = 131072;
pub const LL_ADC_FLAG_JEOC_MST: u32 = 32;
pub const LL_ADC_FLAG_JEOC_SLV: u32 = 2097152;
pub const LL_ADC_FLAG_JEOS_MST: u32 = 64;
pub const LL_ADC_FLAG_JEOS_SLV: u32 = 4194304;
pub const LL_ADC_FLAG_JQOVF_MST: u32 = 1024;
pub const LL_ADC_FLAG_JQOVF_SLV: u32 = 67108864;
pub const LL_ADC_FLAG_AWD1_MST: u32 = 128;
pub const LL_ADC_FLAG_AWD1_SLV: u32 = 8388608;
pub const LL_ADC_FLAG_AWD2_MST: u32 = 256;
pub const LL_ADC_FLAG_AWD2_SLV: u32 = 16777216;
pub const LL_ADC_FLAG_AWD3_MST: u32 = 512;
pub const LL_ADC_FLAG_AWD3_SLV: u32 = 33554432;
pub const LL_ADC_IT_ADRDY: u32 = 1;
pub const LL_ADC_IT_EOC: u32 = 4;
pub const LL_ADC_IT_EOS: u32 = 8;
pub const LL_ADC_IT_OVR: u32 = 16;
pub const LL_ADC_IT_EOSMP: u32 = 2;
pub const LL_ADC_IT_JEOC: u32 = 32;
pub const LL_ADC_IT_JEOS: u32 = 64;
pub const LL_ADC_IT_JQOVF: u32 = 1024;
pub const LL_ADC_IT_AWD1: u32 = 128;
pub const LL_ADC_IT_AWD2: u32 = 256;
pub const LL_ADC_IT_AWD3: u32 = 512;
pub const LL_ADC_DMA_REG_REGULAR_DATA: u32 = 0;
pub const LL_ADC_DMA_REG_REGULAR_DATA_MULTI: u32 = 1;
pub const LL_ADC_CLOCK_SYNC_PCLK_DIV1: u32 = 65536;
pub const LL_ADC_CLOCK_SYNC_PCLK_DIV2: u32 = 131072;
pub const LL_ADC_CLOCK_SYNC_PCLK_DIV4: u32 = 196608;
pub const LL_ADC_CLOCK_ASYNC_DIV1: u32 = 0;
pub const LL_ADC_CLOCK_ASYNC_DIV2: u32 = 262144;
pub const LL_ADC_CLOCK_ASYNC_DIV4: u32 = 524288;
pub const LL_ADC_CLOCK_ASYNC_DIV6: u32 = 786432;
pub const LL_ADC_CLOCK_ASYNC_DIV8: u32 = 1048576;
pub const LL_ADC_CLOCK_ASYNC_DIV10: u32 = 1310720;
pub const LL_ADC_CLOCK_ASYNC_DIV12: u32 = 1572864;
pub const LL_ADC_CLOCK_ASYNC_DIV16: u32 = 1835008;
pub const LL_ADC_CLOCK_ASYNC_DIV32: u32 = 2097152;
pub const LL_ADC_CLOCK_ASYNC_DIV64: u32 = 2359296;
pub const LL_ADC_CLOCK_ASYNC_DIV128: u32 = 2621440;
pub const LL_ADC_CLOCK_ASYNC_DIV256: u32 = 2883584;
pub const LL_ADC_PATH_INTERNAL_NONE: u32 = 0;
pub const LL_ADC_PATH_INTERNAL_VREFINT: u32 = 4194304;
pub const LL_ADC_PATH_INTERNAL_TEMPSENSOR: u32 = 8388608;
pub const LL_ADC_PATH_INTERNAL_VBAT: u32 = 16777216;
pub const LL_ADC_RESOLUTION_12B: u32 = 0;
pub const LL_ADC_RESOLUTION_10B: u32 = 8;
pub const LL_ADC_RESOLUTION_8B: u32 = 16;
pub const LL_ADC_RESOLUTION_6B: u32 = 24;
pub const LL_ADC_DATA_ALIGN_RIGHT: u32 = 0;
pub const LL_ADC_DATA_ALIGN_LEFT: u32 = 32;
pub const LL_ADC_LP_MODE_NONE: u32 = 0;
pub const LL_ADC_LP_AUTOWAIT: u32 = 16384;
pub const LL_ADC_OFFSET_1: u32 = 0;
pub const LL_ADC_OFFSET_2: u32 = 1;
pub const LL_ADC_OFFSET_3: u32 = 2;
pub const LL_ADC_OFFSET_4: u32 = 3;
pub const LL_ADC_OFFSET_DISABLE: u32 = 0;
pub const LL_ADC_OFFSET_ENABLE: u32 = 2147483648;
pub const LL_ADC_GROUP_REGULAR: u32 = 1;
pub const LL_ADC_GROUP_INJECTED: u32 = 2;
pub const LL_ADC_GROUP_REGULAR_INJECTED: u32 = 3;
pub const LL_ADC_CHANNEL_0: u32 = 1;
pub const LL_ADC_CHANNEL_1: u32 = 70254594;
pub const LL_ADC_CHANNEL_2: u32 = 140509188;
pub const LL_ADC_CHANNEL_3: u32 = 210763784;
pub const LL_ADC_CHANNEL_4: u32 = 281018384;
pub const LL_ADC_CHANNEL_5: u32 = 351272992;
pub const LL_ADC_CHANNEL_6: u32 = 421527616;
pub const LL_ADC_CHANNEL_7: u32 = 491782272;
pub const LL_ADC_CHANNEL_8: u32 = 562036992;
pub const LL_ADC_CHANNEL_9: u32 = 632291840;
pub const LL_ADC_CHANNEL_10: u32 = 704644096;
pub const LL_ADC_CHANNEL_11: u32 = 774899712;
pub const LL_ADC_CHANNEL_12: u32 = 845156352;
pub const LL_ADC_CHANNEL_13: u32 = 915415040;
pub const LL_ADC_CHANNEL_14: u32 = 985677824;
pub const LL_ADC_CHANNEL_15: u32 = 1055948800;
pub const LL_ADC_CHANNEL_16: u32 = 1126236160;
pub const LL_ADC_CHANNEL_17: u32 = 1196556288;
pub const LL_ADC_CHANNEL_18: u32 = 1266941952;
pub const LL_ADC_CHANNEL_VREFINT: u32 = 2147483649;
pub const LL_ADC_CHANNEL_TEMPSENSOR: u32 = 3344039936;
pub const LL_ADC_CHANNEL_VBAT: u32 = 3414425600;
pub const LL_ADC_CHANNEL_DAC1CH1_ADC2: u32 = 3344564224;
pub const LL_ADC_CHANNEL_DAC1CH2_ADC2: u32 = 3414949888;
pub const LL_ADC_CHANNEL_DAC1CH1_ADC3: u32 = 3133161472;
pub const LL_ADC_CHANNEL_DAC1CH2_ADC3: u32 = 3203432448;
pub const LL_ADC_REG_TRIG_SOFTWARE: u32 = 0;
pub const LL_ADC_REG_TRIG_EXT_TIM1_TRGO: u32 = 1600;
pub const LL_ADC_REG_TRIG_EXT_TIM1_TRGO2: u32 = 1664;
pub const LL_ADC_REG_TRIG_EXT_TIM1_CH1: u32 = 1024;
pub const LL_ADC_REG_TRIG_EXT_TIM1_CH2: u32 = 1088;
pub const LL_ADC_REG_TRIG_EXT_TIM1_CH3: u32 = 1152;
pub const LL_ADC_REG_TRIG_EXT_TIM2_TRGO: u32 = 1728;
pub const LL_ADC_REG_TRIG_EXT_TIM2_CH2: u32 = 1216;
pub const LL_ADC_REG_TRIG_EXT_TIM3_TRGO: u32 = 1280;
pub const LL_ADC_REG_TRIG_EXT_TIM3_CH4: u32 = 1984;
pub const LL_ADC_REG_TRIG_EXT_TIM4_TRGO: u32 = 1792;
pub const LL_ADC_REG_TRIG_EXT_TIM4_CH4: u32 = 1344;
pub const LL_ADC_REG_TRIG_EXT_TIM6_TRGO: u32 = 1856;
pub const LL_ADC_REG_TRIG_EXT_TIM8_TRGO: u32 = 1472;
pub const LL_ADC_REG_TRIG_EXT_TIM8_TRGO2: u32 = 1536;
pub const LL_ADC_REG_TRIG_EXT_TIM15_TRGO: u32 = 1920;
pub const LL_ADC_REG_TRIG_EXT_EXTI_LINE11: u32 = 1408;
pub const LL_ADC_REG_TRIG_EXT_RISING: u32 = 1024;
pub const LL_ADC_REG_TRIG_EXT_FALLING: u32 = 2048;
pub const LL_ADC_REG_TRIG_EXT_RISINGFALLING: u32 = 3072;
pub const LL_ADC_REG_CONV_SINGLE: u32 = 0;
pub const LL_ADC_REG_CONV_CONTINUOUS: u32 = 8192;
pub const LL_ADC_REG_DMA_TRANSFER_NONE: u32 = 0;
pub const LL_ADC_REG_DMA_TRANSFER_LIMITED: u32 = 1;
pub const LL_ADC_REG_DMA_TRANSFER_UNLIMITED: u32 = 3;
pub const LL_ADC_REG_OVR_DATA_PRESERVED: u32 = 0;
pub const LL_ADC_REG_OVR_DATA_OVERWRITTEN: u32 = 4096;
pub const LL_ADC_REG_SEQ_SCAN_DISABLE: u32 = 0;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS: u32 = 1;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS: u32 = 2;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS: u32 = 3;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS: u32 = 4;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS: u32 = 5;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS: u32 = 6;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS: u32 = 7;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS: u32 = 8;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS: u32 = 9;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS: u32 = 10;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS: u32 = 11;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS: u32 = 12;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS: u32 = 13;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS: u32 = 14;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS: u32 = 15;
pub const LL_ADC_REG_SEQ_DISCONT_DISABLE: u32 = 0;
pub const LL_ADC_REG_SEQ_DISCONT_1RANK: u32 = 65536;
pub const LL_ADC_REG_SEQ_DISCONT_2RANKS: u32 = 196608;
pub const LL_ADC_REG_SEQ_DISCONT_3RANKS: u32 = 327680;
pub const LL_ADC_REG_SEQ_DISCONT_4RANKS: u32 = 458752;
pub const LL_ADC_REG_SEQ_DISCONT_5RANKS: u32 = 589824;
pub const LL_ADC_REG_SEQ_DISCONT_6RANKS: u32 = 720896;
pub const LL_ADC_REG_SEQ_DISCONT_7RANKS: u32 = 851968;
pub const LL_ADC_REG_SEQ_DISCONT_8RANKS: u32 = 983040;
pub const LL_ADC_REG_RANK_1: u32 = 6;
pub const LL_ADC_REG_RANK_2: u32 = 12;
pub const LL_ADC_REG_RANK_3: u32 = 18;
pub const LL_ADC_REG_RANK_4: u32 = 24;
pub const LL_ADC_REG_RANK_5: u32 = 256;
pub const LL_ADC_REG_RANK_6: u32 = 262;
pub const LL_ADC_REG_RANK_7: u32 = 268;
pub const LL_ADC_REG_RANK_8: u32 = 274;
pub const LL_ADC_REG_RANK_9: u32 = 280;
pub const LL_ADC_REG_RANK_10: u32 = 512;
pub const LL_ADC_REG_RANK_11: u32 = 518;
pub const LL_ADC_REG_RANK_12: u32 = 524;
pub const LL_ADC_REG_RANK_13: u32 = 530;
pub const LL_ADC_REG_RANK_14: u32 = 536;
pub const LL_ADC_REG_RANK_15: u32 = 768;
pub const LL_ADC_REG_RANK_16: u32 = 774;
pub const LL_ADC_INJ_TRIG_SOFTWARE: u32 = 0;
pub const LL_ADC_INJ_TRIG_EXT_TIM1_TRGO: u32 = 64;
pub const LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2: u32 = 96;
pub const LL_ADC_INJ_TRIG_EXT_TIM1_CH4: u32 = 68;
pub const LL_ADC_INJ_TRIG_EXT_TIM2_TRGO: u32 = 72;
pub const LL_ADC_INJ_TRIG_EXT_TIM2_CH1: u32 = 76;
pub const LL_ADC_INJ_TRIG_EXT_TIM3_TRGO: u32 = 112;
pub const LL_ADC_INJ_TRIG_EXT_TIM3_CH1: u32 = 116;
pub const LL_ADC_INJ_TRIG_EXT_TIM3_CH3: u32 = 108;
pub const LL_ADC_INJ_TRIG_EXT_TIM3_CH4: u32 = 80;
pub const LL_ADC_INJ_TRIG_EXT_TIM4_TRGO: u32 = 84;
pub const LL_ADC_INJ_TRIG_EXT_TIM6_TRGO: u32 = 120;
pub const LL_ADC_INJ_TRIG_EXT_TIM8_CH4: u32 = 92;
pub const LL_ADC_INJ_TRIG_EXT_TIM8_TRGO: u32 = 100;
pub const LL_ADC_INJ_TRIG_EXT_TIM8_TRGO2: u32 = 104;
pub const LL_ADC_INJ_TRIG_EXT_TIM15_TRGO: u32 = 124;
pub const LL_ADC_INJ_TRIG_EXT_EXTI_LINE15: u32 = 88;
pub const LL_ADC_INJ_TRIG_EXT_RISING: u32 = 64;
pub const LL_ADC_INJ_TRIG_EXT_FALLING: u32 = 128;
pub const LL_ADC_INJ_TRIG_EXT_RISINGFALLING: u32 = 192;
pub const LL_ADC_INJ_TRIG_INDEPENDENT: u32 = 0;
pub const LL_ADC_INJ_TRIG_FROM_GRP_REGULAR: u32 = 33554432;
pub const LL_ADC_INJ_QUEUE_2CONTEXTS_LAST_ACTIVE: u32 = 0;
pub const LL_ADC_INJ_QUEUE_2CONTEXTS_END_EMPTY: u32 = 2097152;
pub const LL_ADC_INJ_QUEUE_DISABLE: u32 = 2147483648;
pub const LL_ADC_INJ_SEQ_SCAN_DISABLE: u32 = 0;
pub const LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS: u32 = 1;
pub const LL_ADC_INJ_SEQ_SCAN_ENABLE_3RANKS: u32 = 2;
pub const LL_ADC_INJ_SEQ_SCAN_ENABLE_4RANKS: u32 = 3;
pub const LL_ADC_INJ_SEQ_DISCONT_DISABLE: u32 = 0;
pub const LL_ADC_INJ_SEQ_DISCONT_1RANK: u32 = 1048576;
pub const LL_ADC_INJ_RANK_1: u32 = 8;
pub const LL_ADC_INJ_RANK_2: u32 = 270;
pub const LL_ADC_INJ_RANK_3: u32 = 532;
pub const LL_ADC_INJ_RANK_4: u32 = 794;
pub const LL_ADC_SAMPLINGTIME_2CYCLES_5: u32 = 0;
pub const LL_ADC_SAMPLINGTIME_6CYCLES_5: u32 = 1;
pub const LL_ADC_SAMPLINGTIME_12CYCLES_5: u32 = 2;
pub const LL_ADC_SAMPLINGTIME_24CYCLES_5: u32 = 3;
pub const LL_ADC_SAMPLINGTIME_47CYCLES_5: u32 = 4;
pub const LL_ADC_SAMPLINGTIME_92CYCLES_5: u32 = 5;
pub const LL_ADC_SAMPLINGTIME_247CYCLES_5: u32 = 6;
pub const LL_ADC_SAMPLINGTIME_640CYCLES_5: u32 = 7;
pub const LL_ADC_SINGLE_ENDED: u32 = 127;
pub const LL_ADC_DIFFERENTIAL_ENDED: u32 = 1082064896;
pub const LL_ADC_BOTH_SINGLE_DIFF_ENDED: u32 = 1082065023;
pub const LL_ADC_AWD1: u32 = 2109734912;
pub const LL_ADC_AWD2: u32 = 1572863;
pub const LL_ADC_AWD3: u32 = 2621439;
pub const LL_ADC_AWD_DISABLE: u32 = 0;
pub const LL_ADC_AWD_ALL_CHANNELS_REG: u32 = 8912895;
pub const LL_ADC_AWD_ALL_CHANNELS_INJ: u32 = 17301503;
pub const LL_ADC_AWD_ALL_CHANNELS_REG_INJ: u32 = 25690111;
pub const LL_ADC_AWD_THRESHOLD_HIGH: u32 = 268369920;
pub const LL_ADC_AWD_THRESHOLD_LOW: u32 = 4095;
pub const LL_ADC_AWD_THRESHOLDS_HIGH_LOW: u32 = 268374015;
pub const LL_ADC_OVS_DISABLE: u32 = 0;
pub const LL_ADC_OVS_GRP_REGULAR_CONTINUED: u32 = 1;
pub const LL_ADC_OVS_GRP_REGULAR_RESUMED: u32 = 1025;
pub const LL_ADC_OVS_GRP_INJECTED: u32 = 2;
pub const LL_ADC_OVS_GRP_INJ_REG_RESUMED: u32 = 3;
pub const LL_ADC_OVS_REG_CONT: u32 = 0;
pub const LL_ADC_OVS_REG_DISCONT: u32 = 512;
pub const LL_ADC_OVS_RATIO_2: u32 = 0;
pub const LL_ADC_OVS_RATIO_4: u32 = 4;
pub const LL_ADC_OVS_RATIO_8: u32 = 8;
pub const LL_ADC_OVS_RATIO_16: u32 = 12;
pub const LL_ADC_OVS_RATIO_32: u32 = 16;
pub const LL_ADC_OVS_RATIO_64: u32 = 20;
pub const LL_ADC_OVS_RATIO_128: u32 = 24;
pub const LL_ADC_OVS_RATIO_256: u32 = 28;
pub const LL_ADC_OVS_SHIFT_NONE: u32 = 0;
pub const LL_ADC_OVS_SHIFT_RIGHT_1: u32 = 32;
pub const LL_ADC_OVS_SHIFT_RIGHT_2: u32 = 64;
pub const LL_ADC_OVS_SHIFT_RIGHT_3: u32 = 96;
pub const LL_ADC_OVS_SHIFT_RIGHT_4: u32 = 128;
pub const LL_ADC_OVS_SHIFT_RIGHT_5: u32 = 160;
pub const LL_ADC_OVS_SHIFT_RIGHT_6: u32 = 192;
pub const LL_ADC_OVS_SHIFT_RIGHT_7: u32 = 224;
pub const LL_ADC_OVS_SHIFT_RIGHT_8: u32 = 256;
pub const LL_ADC_MULTI_INDEPENDENT: u32 = 0;
pub const LL_ADC_MULTI_DUAL_REG_SIMULT: u32 = 6;
pub const LL_ADC_MULTI_DUAL_REG_INTERL: u32 = 7;
pub const LL_ADC_MULTI_DUAL_INJ_SIMULT: u32 = 5;
pub const LL_ADC_MULTI_DUAL_INJ_ALTERN: u32 = 9;
pub const LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM: u32 = 1;
pub const LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT: u32 = 2;
pub const LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM: u32 = 3;
pub const LL_ADC_MULTI_REG_DMA_EACH_ADC: u32 = 0;
pub const LL_ADC_MULTI_REG_DMA_LIMIT_RES12_10B: u32 = 32768;
pub const LL_ADC_MULTI_REG_DMA_LIMIT_RES8_6B: u32 = 49152;
pub const LL_ADC_MULTI_REG_DMA_UNLMT_RES12_10B: u32 = 40960;
pub const LL_ADC_MULTI_REG_DMA_UNLMT_RES8_6B: u32 = 57344;
pub const LL_ADC_MULTI_TWOSMP_DELAY_1CYCLE: u32 = 0;
pub const LL_ADC_MULTI_TWOSMP_DELAY_2CYCLES: u32 = 256;
pub const LL_ADC_MULTI_TWOSMP_DELAY_3CYCLES: u32 = 512;
pub const LL_ADC_MULTI_TWOSMP_DELAY_4CYCLES: u32 = 768;
pub const LL_ADC_MULTI_TWOSMP_DELAY_5CYCLES: u32 = 1024;
pub const LL_ADC_MULTI_TWOSMP_DELAY_6CYCLES: u32 = 1280;
pub const LL_ADC_MULTI_TWOSMP_DELAY_7CYCLES: u32 = 1536;
pub const LL_ADC_MULTI_TWOSMP_DELAY_8CYCLES: u32 = 1792;
pub const LL_ADC_MULTI_TWOSMP_DELAY_9CYCLES: u32 = 2048;
pub const LL_ADC_MULTI_TWOSMP_DELAY_10CYCLES: u32 = 2304;
pub const LL_ADC_MULTI_TWOSMP_DELAY_11CYCLES: u32 = 2560;
pub const LL_ADC_MULTI_TWOSMP_DELAY_12CYCLES: u32 = 2816;
pub const LL_ADC_MULTI_MASTER: u32 = 65535;
pub const LL_ADC_MULTI_SLAVE: u32 = 4294901760;
pub const LL_ADC_MULTI_MASTER_SLAVE: u32 = 4294967295;
pub const LL_ADC_REG_TRIG_SW_START: u32 = 0;
pub const LL_ADC_REG_TRIG_EXT_TIM1_CC1: u32 = 1024;
pub const LL_ADC_REG_TRIG_EXT_TIM1_CC2: u32 = 1088;
pub const LL_ADC_REG_TRIG_EXT_TIM1_CC3: u32 = 1152;
pub const LL_ADC_REG_TRIG_EXT_TIM2_CC2: u32 = 1216;
pub const LL_ADC_REG_TRIG_EXT_TIM3_CC4: u32 = 1984;
pub const LL_ADC_REG_TRIG_EXT_TIM4_CC4: u32 = 1344;
pub const LL_ADC_INJ_TRIG_SW_START: u32 = 0;
pub const LL_ADC_INJ_TRIG_EXT_TIM1_CC4: u32 = 68;
pub const LL_ADC_INJ_TRIG_EXT_TIM2_CC1: u32 = 76;
pub const LL_ADC_INJ_TRIG_EXT_TIM3_CC1: u32 = 116;
pub const LL_ADC_INJ_TRIG_EXT_TIM3_CC3: u32 = 108;
pub const LL_ADC_INJ_TRIG_EXT_TIM3_CC4: u32 = 80;
pub const LL_ADC_INJ_TRIG_EXT_TIM8_CC4: u32 = 92;
pub const LL_ADC_OVS_DATA_SHIFT_NONE: u32 = 0;
pub const LL_ADC_OVS_DATA_SHIFT_1: u32 = 32;
pub const LL_ADC_OVS_DATA_SHIFT_2: u32 = 64;
pub const LL_ADC_OVS_DATA_SHIFT_3: u32 = 96;
pub const LL_ADC_OVS_DATA_SHIFT_4: u32 = 128;
pub const LL_ADC_OVS_DATA_SHIFT_5: u32 = 160;
pub const LL_ADC_OVS_DATA_SHIFT_6: u32 = 192;
pub const LL_ADC_OVS_DATA_SHIFT_7: u32 = 224;
pub const LL_ADC_OVS_DATA_SHIFT_8: u32 = 256;
pub const LL_ADC_DELAY_INTERNAL_REGUL_STAB_US: u32 = 20;
pub const LL_ADC_DELAY_VREFINT_STAB_US: u32 = 12;
pub const LL_ADC_DELAY_TEMPSENSOR_STAB_US: u32 = 120;
pub const LL_ADC_DELAY_CALIB_ENABLE_ADC_CYCLES: u32 = 4;
pub const HAL_ADC_STATE_RESET: u32 = 0;
pub const HAL_ADC_STATE_READY: u32 = 1;
pub const HAL_ADC_STATE_BUSY_INTERNAL: u32 = 2;
pub const HAL_ADC_STATE_TIMEOUT: u32 = 4;
pub const HAL_ADC_STATE_ERROR_INTERNAL: u32 = 16;
pub const HAL_ADC_STATE_ERROR_CONFIG: u32 = 32;
pub const HAL_ADC_STATE_ERROR_DMA: u32 = 64;
pub const HAL_ADC_STATE_REG_BUSY: u32 = 256;
pub const HAL_ADC_STATE_REG_EOC: u32 = 512;
pub const HAL_ADC_STATE_REG_OVR: u32 = 1024;
pub const HAL_ADC_STATE_REG_EOSMP: u32 = 2048;
pub const HAL_ADC_STATE_INJ_BUSY: u32 = 4096;
pub const HAL_ADC_STATE_INJ_EOC: u32 = 8192;
pub const HAL_ADC_STATE_INJ_JQOVF: u32 = 16384;
pub const HAL_ADC_STATE_AWD1: u32 = 65536;
pub const HAL_ADC_STATE_AWD2: u32 = 131072;
pub const HAL_ADC_STATE_AWD3: u32 = 262144;
pub const HAL_ADC_STATE_MULTIMODE_SLAVE: u32 = 1048576;
pub const HAL_ADC_ERROR_NONE: u32 = 0;
pub const HAL_ADC_ERROR_INTERNAL: u32 = 1;
pub const HAL_ADC_ERROR_OVR: u32 = 2;
pub const HAL_ADC_ERROR_DMA: u32 = 4;
pub const HAL_ADC_ERROR_JQOVF: u32 = 8;
pub const ADC_CLOCK_SYNC_PCLK_DIV1: u32 = 65536;
pub const ADC_CLOCK_SYNC_PCLK_DIV2: u32 = 131072;
pub const ADC_CLOCK_SYNC_PCLK_DIV4: u32 = 196608;
pub const ADC_CLOCK_ASYNC_DIV1: u32 = 0;
pub const ADC_CLOCK_ASYNC_DIV2: u32 = 262144;
pub const ADC_CLOCK_ASYNC_DIV4: u32 = 524288;
pub const ADC_CLOCK_ASYNC_DIV6: u32 = 786432;
pub const ADC_CLOCK_ASYNC_DIV8: u32 = 1048576;
pub const ADC_CLOCK_ASYNC_DIV10: u32 = 1310720;
pub const ADC_CLOCK_ASYNC_DIV12: u32 = 1572864;
pub const ADC_CLOCK_ASYNC_DIV16: u32 = 1835008;
pub const ADC_CLOCK_ASYNC_DIV32: u32 = 2097152;
pub const ADC_CLOCK_ASYNC_DIV64: u32 = 2359296;
pub const ADC_CLOCK_ASYNC_DIV128: u32 = 2621440;
pub const ADC_CLOCK_ASYNC_DIV256: u32 = 2883584;
pub const ADC_RESOLUTION_12B: u32 = 0;
pub const ADC_RESOLUTION_10B: u32 = 8;
pub const ADC_RESOLUTION_8B: u32 = 16;
pub const ADC_RESOLUTION_6B: u32 = 24;
pub const ADC_DATAALIGN_RIGHT: u32 = 0;
pub const ADC_DATAALIGN_LEFT: u32 = 32;
pub const ADC_SCAN_DISABLE: u32 = 0;
pub const ADC_SCAN_ENABLE: u32 = 1;
pub const ADC_SOFTWARE_START: u32 = 0;
pub const ADC_EXTERNALTRIG_T1_TRGO: u32 = 1600;
pub const ADC_EXTERNALTRIG_T1_TRGO2: u32 = 1664;
pub const ADC_EXTERNALTRIG_T1_CC1: u32 = 1024;
pub const ADC_EXTERNALTRIG_T1_CC2: u32 = 1088;
pub const ADC_EXTERNALTRIG_T1_CC3: u32 = 1152;
pub const ADC_EXTERNALTRIG_T2_TRGO: u32 = 1728;
pub const ADC_EXTERNALTRIG_T2_CC2: u32 = 1216;
pub const ADC_EXTERNALTRIG_T3_TRGO: u32 = 1280;
pub const ADC_EXTERNALTRIG_T3_CC4: u32 = 1984;
pub const ADC_EXTERNALTRIG_T4_TRGO: u32 = 1792;
pub const ADC_EXTERNALTRIG_T4_CC4: u32 = 1344;
pub const ADC_EXTERNALTRIG_T6_TRGO: u32 = 1856;
pub const ADC_EXTERNALTRIG_T8_TRGO: u32 = 1472;
pub const ADC_EXTERNALTRIG_T8_TRGO2: u32 = 1536;
pub const ADC_EXTERNALTRIG_T15_TRGO: u32 = 1920;
pub const ADC_EXTERNALTRIG_EXT_IT11: u32 = 1408;
pub const ADC_EXTERNALTRIGCONVEDGE_NONE: u32 = 0;
pub const ADC_EXTERNALTRIGCONVEDGE_RISING: u32 = 1024;
pub const ADC_EXTERNALTRIGCONVEDGE_FALLING: u32 = 2048;
pub const ADC_EXTERNALTRIGCONVEDGE_RISINGFALLING: u32 = 3072;
pub const ADC_EOC_SINGLE_CONV: u32 = 4;
pub const ADC_EOC_SEQ_CONV: u32 = 8;
pub const ADC_OVR_DATA_PRESERVED: u32 = 0;
pub const ADC_OVR_DATA_OVERWRITTEN: u32 = 4096;
pub const ADC_REGULAR_RANK_1: u32 = 6;
pub const ADC_REGULAR_RANK_2: u32 = 12;
pub const ADC_REGULAR_RANK_3: u32 = 18;
pub const ADC_REGULAR_RANK_4: u32 = 24;
pub const ADC_REGULAR_RANK_5: u32 = 256;
pub const ADC_REGULAR_RANK_6: u32 = 262;
pub const ADC_REGULAR_RANK_7: u32 = 268;
pub const ADC_REGULAR_RANK_8: u32 = 274;
pub const ADC_REGULAR_RANK_9: u32 = 280;
pub const ADC_REGULAR_RANK_10: u32 = 512;
pub const ADC_REGULAR_RANK_11: u32 = 518;
pub const ADC_REGULAR_RANK_12: u32 = 524;
pub const ADC_REGULAR_RANK_13: u32 = 530;
pub const ADC_REGULAR_RANK_14: u32 = 536;
pub const ADC_REGULAR_RANK_15: u32 = 768;
pub const ADC_REGULAR_RANK_16: u32 = 774;
pub const ADC_SAMPLETIME_2CYCLES_5: u32 = 0;
pub const ADC_SAMPLETIME_6CYCLES_5: u32 = 1;
pub const ADC_SAMPLETIME_12CYCLES_5: u32 = 2;
pub const ADC_SAMPLETIME_24CYCLES_5: u32 = 3;
pub const ADC_SAMPLETIME_47CYCLES_5: u32 = 4;
pub const ADC_SAMPLETIME_92CYCLES_5: u32 = 5;
pub const ADC_SAMPLETIME_247CYCLES_5: u32 = 6;
pub const ADC_SAMPLETIME_640CYCLES_5: u32 = 7;
pub const ADC_CHANNEL_0: u32 = 1;
pub const ADC_CHANNEL_1: u32 = 70254594;
pub const ADC_CHANNEL_2: u32 = 140509188;
pub const ADC_CHANNEL_3: u32 = 210763784;
pub const ADC_CHANNEL_4: u32 = 281018384;
pub const ADC_CHANNEL_5: u32 = 351272992;
pub const ADC_CHANNEL_6: u32 = 421527616;
pub const ADC_CHANNEL_7: u32 = 491782272;
pub const ADC_CHANNEL_8: u32 = 562036992;
pub const ADC_CHANNEL_9: u32 = 632291840;
pub const ADC_CHANNEL_10: u32 = 704644096;
pub const ADC_CHANNEL_11: u32 = 774899712;
pub const ADC_CHANNEL_12: u32 = 845156352;
pub const ADC_CHANNEL_13: u32 = 915415040;
pub const ADC_CHANNEL_14: u32 = 985677824;
pub const ADC_CHANNEL_15: u32 = 1055948800;
pub const ADC_CHANNEL_16: u32 = 1126236160;
pub const ADC_CHANNEL_17: u32 = 1196556288;
pub const ADC_CHANNEL_18: u32 = 1266941952;
pub const ADC_CHANNEL_VREFINT: u32 = 2147483649;
pub const ADC_CHANNEL_TEMPSENSOR: u32 = 3344039936;
pub const ADC_CHANNEL_VBAT: u32 = 3414425600;
pub const ADC_CHANNEL_DAC1CH1_ADC2: u32 = 3344564224;
pub const ADC_CHANNEL_DAC1CH2_ADC2: u32 = 3414949888;
pub const ADC_CHANNEL_DAC1CH1_ADC3: u32 = 3133161472;
pub const ADC_CHANNEL_DAC1CH2_ADC3: u32 = 3203432448;
pub const ADC_ANALOGWATCHDOG_1: u32 = 2109734912;
pub const ADC_ANALOGWATCHDOG_2: u32 = 1572863;
pub const ADC_ANALOGWATCHDOG_3: u32 = 2621439;
pub const ADC_ANALOGWATCHDOG_NONE: u32 = 0;
pub const ADC_ANALOGWATCHDOG_SINGLE_REG: u32 = 12582912;
pub const ADC_ANALOGWATCHDOG_SINGLE_INJEC: u32 = 20971520;
pub const ADC_ANALOGWATCHDOG_SINGLE_REGINJEC: u32 = 29360128;
pub const ADC_ANALOGWATCHDOG_ALL_REG: u32 = 8388608;
pub const ADC_ANALOGWATCHDOG_ALL_INJEC: u32 = 16777216;
pub const ADC_ANALOGWATCHDOG_ALL_REGINJEC: u32 = 25165824;
pub const ADC_OVERSAMPLING_RATIO_2: u32 = 0;
pub const ADC_OVERSAMPLING_RATIO_4: u32 = 4;
pub const ADC_OVERSAMPLING_RATIO_8: u32 = 8;
pub const ADC_OVERSAMPLING_RATIO_16: u32 = 12;
pub const ADC_OVERSAMPLING_RATIO_32: u32 = 16;
pub const ADC_OVERSAMPLING_RATIO_64: u32 = 20;
pub const ADC_OVERSAMPLING_RATIO_128: u32 = 24;
pub const ADC_OVERSAMPLING_RATIO_256: u32 = 28;
pub const ADC_RIGHTBITSHIFT_NONE: u32 = 0;
pub const ADC_RIGHTBITSHIFT_1: u32 = 32;
pub const ADC_RIGHTBITSHIFT_2: u32 = 64;
pub const ADC_RIGHTBITSHIFT_3: u32 = 96;
pub const ADC_RIGHTBITSHIFT_4: u32 = 128;
pub const ADC_RIGHTBITSHIFT_5: u32 = 160;
pub const ADC_RIGHTBITSHIFT_6: u32 = 192;
pub const ADC_RIGHTBITSHIFT_7: u32 = 224;
pub const ADC_RIGHTBITSHIFT_8: u32 = 256;
pub const ADC_TRIGGEREDMODE_SINGLE_TRIGGER: u32 = 0;
pub const ADC_TRIGGEREDMODE_MULTI_TRIGGER: u32 = 512;
pub const ADC_REGOVERSAMPLING_CONTINUED_MODE: u32 = 1;
pub const ADC_REGOVERSAMPLING_RESUMED_MODE: u32 = 1025;
pub const ADC_IT_RDY: u32 = 1;
pub const ADC_IT_EOSMP: u32 = 2;
pub const ADC_IT_EOC: u32 = 4;
pub const ADC_IT_EOS: u32 = 8;
pub const ADC_IT_OVR: u32 = 16;
pub const ADC_IT_JEOC: u32 = 32;
pub const ADC_IT_JEOS: u32 = 64;
pub const ADC_IT_AWD1: u32 = 128;
pub const ADC_IT_AWD2: u32 = 256;
pub const ADC_IT_AWD3: u32 = 512;
pub const ADC_IT_JQOVF: u32 = 1024;
pub const ADC_IT_AWD: u32 = 128;
pub const ADC_FLAG_RDY: u32 = 1;
pub const ADC_FLAG_EOSMP: u32 = 2;
pub const ADC_FLAG_EOC: u32 = 4;
pub const ADC_FLAG_EOS: u32 = 8;
pub const ADC_FLAG_OVR: u32 = 16;
pub const ADC_FLAG_JEOC: u32 = 32;
pub const ADC_FLAG_JEOS: u32 = 64;
pub const ADC_FLAG_AWD1: u32 = 128;
pub const ADC_FLAG_AWD2: u32 = 256;
pub const ADC_FLAG_AWD3: u32 = 512;
pub const ADC_FLAG_JQOVF: u32 = 1024;
pub const ADC_FLAG_AWD: u32 = 128;
pub const ADC_FLAG_ALL: u32 = 2047;
pub const ADC_FLAG_POSTCONV_ALL: u32 = 2044;
pub const ADC_STOP_CONVERSION_TIMEOUT: u32 = 5;
pub const ADC_TEMPSENSOR_DELAY_US: u32 = 120;
pub const ADC_INJECTED_SOFTWARE_START: u32 = 0;
pub const ADC_EXTERNALTRIGINJEC_T1_TRGO: u32 = 64;
pub const ADC_EXTERNALTRIGINJEC_T1_TRGO2: u32 = 96;
pub const ADC_EXTERNALTRIGINJEC_T1_CC4: u32 = 68;
pub const ADC_EXTERNALTRIGINJEC_T2_TRGO: u32 = 72;
pub const ADC_EXTERNALTRIGINJEC_T2_CC1: u32 = 76;
pub const ADC_EXTERNALTRIGINJEC_T3_TRGO: u32 = 112;
pub const ADC_EXTERNALTRIGINJEC_T3_CC1: u32 = 116;
pub const ADC_EXTERNALTRIGINJEC_T3_CC3: u32 = 108;
pub const ADC_EXTERNALTRIGINJEC_T3_CC4: u32 = 80;
pub const ADC_EXTERNALTRIGINJEC_T4_TRGO: u32 = 84;
pub const ADC_EXTERNALTRIGINJEC_T6_TRGO: u32 = 120;
pub const ADC_EXTERNALTRIGINJEC_T8_CC4: u32 = 92;
pub const ADC_EXTERNALTRIGINJEC_T8_TRGO: u32 = 100;
pub const ADC_EXTERNALTRIGINJEC_T8_TRGO2: u32 = 104;
pub const ADC_EXTERNALTRIGINJEC_T15_TRGO: u32 = 124;
pub const ADC_EXTERNALTRIGINJEC_EXT_IT15: u32 = 88;
pub const ADC_EXTERNALTRIGINJECCONV_EDGE_NONE: u32 = 0;
pub const ADC_EXTERNALTRIGINJECCONV_EDGE_RISING: u32 = 64;
pub const ADC_EXTERNALTRIGINJECCONV_EDGE_FALLING: u32 = 128;
pub const ADC_EXTERNALTRIGINJECCONV_EDGE_RISINGFALLING: u32 = 192;
pub const ADC_SINGLE_ENDED: u32 = 127;
pub const ADC_DIFFERENTIAL_ENDED: u32 = 1082064896;
pub const ADC_OFFSET_1: u32 = 0;
pub const ADC_OFFSET_2: u32 = 1;
pub const ADC_OFFSET_3: u32 = 2;
pub const ADC_OFFSET_4: u32 = 3;
pub const ADC_INJECTED_RANK_1: u32 = 8;
pub const ADC_INJECTED_RANK_2: u32 = 270;
pub const ADC_INJECTED_RANK_3: u32 = 532;
pub const ADC_INJECTED_RANK_4: u32 = 794;
pub const ADC_MODE_INDEPENDENT: u32 = 0;
pub const ADC_DUALMODE_REGSIMULT: u32 = 6;
pub const ADC_DUALMODE_INTERL: u32 = 7;
pub const ADC_DUALMODE_INJECSIMULT: u32 = 5;
pub const ADC_DUALMODE_ALTERTRIG: u32 = 9;
pub const ADC_DUALMODE_REGSIMULT_INJECSIMULT: u32 = 1;
pub const ADC_DUALMODE_REGSIMULT_ALTERTRIG: u32 = 2;
pub const ADC_DUALMODE_REGINTERL_INJECSIMULT: u32 = 3;
pub const ADC_DMAACCESSMODE_DISABLED: u32 = 0;
pub const ADC_DMAACCESSMODE_12_10_BITS: u32 = 32768;
pub const ADC_DMAACCESSMODE_8_6_BITS: u32 = 49152;
pub const ADC_TWOSAMPLINGDELAY_1CYCLE: u32 = 0;
pub const ADC_TWOSAMPLINGDELAY_2CYCLES: u32 = 256;
pub const ADC_TWOSAMPLINGDELAY_3CYCLES: u32 = 512;
pub const ADC_TWOSAMPLINGDELAY_4CYCLES: u32 = 768;
pub const ADC_TWOSAMPLINGDELAY_5CYCLES: u32 = 1024;
pub const ADC_TWOSAMPLINGDELAY_6CYCLES: u32 = 1280;
pub const ADC_TWOSAMPLINGDELAY_7CYCLES: u32 = 1536;
pub const ADC_TWOSAMPLINGDELAY_8CYCLES: u32 = 1792;
pub const ADC_TWOSAMPLINGDELAY_9CYCLES: u32 = 2048;
pub const ADC_TWOSAMPLINGDELAY_10CYCLES: u32 = 2304;
pub const ADC_TWOSAMPLINGDELAY_11CYCLES: u32 = 2560;
pub const ADC_TWOSAMPLINGDELAY_12CYCLES: u32 = 2816;
pub const ADC_REGULAR_GROUP: u32 = 1;
pub const ADC_INJECTED_GROUP: u32 = 2;
pub const ADC_REGULAR_INJECTED_GROUP: u32 = 3;
pub const ADC_CFGR_FIELDS: u32 = 2147450875;
pub const ADC_SMPR1_FIELDS: u32 = 1073741823;
pub const ADC_CFGR_FIELDS_2: u32 = 16386;
pub const HAL_CAN_ERROR_NONE: u32 = 0;
pub const HAL_CAN_ERROR_EWG: u32 = 1;
pub const HAL_CAN_ERROR_EPV: u32 = 2;
pub const HAL_CAN_ERROR_BOF: u32 = 4;
pub const HAL_CAN_ERROR_STF: u32 = 8;
pub const HAL_CAN_ERROR_FOR: u32 = 16;
pub const HAL_CAN_ERROR_ACK: u32 = 32;
pub const HAL_CAN_ERROR_BR: u32 = 64;
pub const HAL_CAN_ERROR_BD: u32 = 128;
pub const HAL_CAN_ERROR_CRC: u32 = 256;
pub const HAL_CAN_ERROR_RX_FOV0: u32 = 512;
pub const HAL_CAN_ERROR_RX_FOV1: u32 = 1024;
pub const HAL_CAN_ERROR_TX_ALST0: u32 = 2048;
pub const HAL_CAN_ERROR_TX_TERR0: u32 = 4096;
pub const HAL_CAN_ERROR_TX_ALST1: u32 = 8192;
pub const HAL_CAN_ERROR_TX_TERR1: u32 = 16384;
pub const HAL_CAN_ERROR_TX_ALST2: u32 = 32768;
pub const HAL_CAN_ERROR_TX_TERR2: u32 = 65536;
pub const HAL_CAN_ERROR_TIMEOUT: u32 = 131072;
pub const HAL_CAN_ERROR_NOT_INITIALIZED: u32 = 262144;
pub const HAL_CAN_ERROR_NOT_READY: u32 = 524288;
pub const HAL_CAN_ERROR_NOT_STARTED: u32 = 1048576;
pub const HAL_CAN_ERROR_PARAM: u32 = 2097152;
pub const HAL_CAN_ERROR_INTERNAL: u32 = 8388608;
pub const CAN_INITSTATUS_FAILED: u32 = 0;
pub const CAN_INITSTATUS_SUCCESS: u32 = 1;
pub const CAN_MODE_NORMAL: u32 = 0;
pub const CAN_SJW_1TQ: u32 = 0;
pub const CAN_BS1_1TQ: u32 = 0;
pub const CAN_BS2_1TQ: u32 = 0;
pub const CAN_FILTERMODE_IDMASK: u32 = 0;
pub const CAN_FILTERMODE_IDLIST: u32 = 1;
pub const CAN_FILTERSCALE_16BIT: u32 = 0;
pub const CAN_FILTERSCALE_32BIT: u32 = 1;
pub const CAN_FILTER_DISABLE: u32 = 0;
pub const CAN_FILTER_ENABLE: u32 = 1;
pub const CAN_FILTER_FIFO0: u32 = 0;
pub const CAN_FILTER_FIFO1: u32 = 1;
pub const CAN_ID_STD: u32 = 0;
pub const CAN_ID_EXT: u32 = 4;
pub const CAN_RTR_DATA: u32 = 0;
pub const CAN_RTR_REMOTE: u32 = 2;
pub const CAN_RX_FIFO0: u32 = 0;
pub const CAN_RX_FIFO1: u32 = 1;
pub const CAN_TX_MAILBOX0: u32 = 1;
pub const CAN_TX_MAILBOX1: u32 = 2;
pub const CAN_TX_MAILBOX2: u32 = 4;
pub const CAN_FLAG_RQCP0: u32 = 1280;
pub const CAN_FLAG_TXOK0: u32 = 1281;
pub const CAN_FLAG_ALST0: u32 = 1282;
pub const CAN_FLAG_TERR0: u32 = 1283;
pub const CAN_FLAG_RQCP1: u32 = 1288;
pub const CAN_FLAG_TXOK1: u32 = 1289;
pub const CAN_FLAG_ALST1: u32 = 1290;
pub const CAN_FLAG_TERR1: u32 = 1291;
pub const CAN_FLAG_RQCP2: u32 = 1296;
pub const CAN_FLAG_TXOK2: u32 = 1297;
pub const CAN_FLAG_ALST2: u32 = 1298;
pub const CAN_FLAG_TERR2: u32 = 1299;
pub const CAN_FLAG_TME0: u32 = 1306;
pub const CAN_FLAG_TME1: u32 = 1307;
pub const CAN_FLAG_TME2: u32 = 1308;
pub const CAN_FLAG_LOW0: u32 = 1309;
pub const CAN_FLAG_LOW1: u32 = 1310;
pub const CAN_FLAG_LOW2: u32 = 1311;
pub const CAN_FLAG_FF0: u32 = 515;
pub const CAN_FLAG_FOV0: u32 = 516;
pub const CAN_FLAG_FF1: u32 = 1027;
pub const CAN_FLAG_FOV1: u32 = 1028;
pub const CAN_FLAG_INAK: u32 = 256;
pub const CAN_FLAG_SLAK: u32 = 257;
pub const CAN_FLAG_ERRI: u32 = 258;
pub const CAN_FLAG_WKU: u32 = 259;
pub const CAN_FLAG_SLAKI: u32 = 260;
pub const CAN_FLAG_EWG: u32 = 768;
pub const CAN_FLAG_EPV: u32 = 769;
pub const CAN_FLAG_BOF: u32 = 770;
pub const CAN_FLAG_MASK: u32 = 255;
pub const LL_EXTI_LINE_0: u32 = 1;
pub const LL_EXTI_LINE_1: u32 = 2;
pub const LL_EXTI_LINE_2: u32 = 4;
pub const LL_EXTI_LINE_3: u32 = 8;
pub const LL_EXTI_LINE_4: u32 = 16;
pub const LL_EXTI_LINE_5: u32 = 32;
pub const LL_EXTI_LINE_6: u32 = 64;
pub const LL_EXTI_LINE_7: u32 = 128;
pub const LL_EXTI_LINE_8: u32 = 256;
pub const LL_EXTI_LINE_9: u32 = 512;
pub const LL_EXTI_LINE_10: u32 = 1024;
pub const LL_EXTI_LINE_11: u32 = 2048;
pub const LL_EXTI_LINE_12: u32 = 4096;
pub const LL_EXTI_LINE_13: u32 = 8192;
pub const LL_EXTI_LINE_14: u32 = 16384;
pub const LL_EXTI_LINE_15: u32 = 32768;
pub const LL_EXTI_LINE_16: u32 = 65536;
pub const LL_EXTI_LINE_17: u32 = 131072;
pub const LL_EXTI_LINE_18: u32 = 262144;
pub const LL_EXTI_LINE_19: u32 = 524288;
pub const LL_EXTI_LINE_20: u32 = 1048576;
pub const LL_EXTI_LINE_21: u32 = 2097152;
pub const LL_EXTI_LINE_22: u32 = 4194304;
pub const LL_EXTI_LINE_23: u32 = 8388608;
pub const LL_EXTI_LINE_24: u32 = 16777216;
pub const LL_EXTI_LINE_25: u32 = 33554432;
pub const LL_EXTI_LINE_26: u32 = 67108864;
pub const LL_EXTI_LINE_27: u32 = 134217728;
pub const LL_EXTI_LINE_28: u32 = 268435456;
pub const LL_EXTI_LINE_29: u32 = 536870912;
pub const LL_EXTI_LINE_30: u32 = 1073741824;
pub const LL_EXTI_LINE_31: u32 = 2147483648;
pub const LL_EXTI_LINE_ALL_0_31: u32 = 4294967295;
pub const LL_EXTI_LINE_32: u32 = 1;
pub const LL_EXTI_LINE_33: u32 = 2;
pub const LL_EXTI_LINE_34: u32 = 4;
pub const LL_EXTI_LINE_35: u32 = 8;
pub const LL_EXTI_LINE_36: u32 = 16;
pub const LL_EXTI_LINE_37: u32 = 32;
pub const LL_EXTI_LINE_38: u32 = 64;
pub const LL_EXTI_LINE_ALL_32_63: u32 = 127;
pub const LL_EXTI_LINE_ALL: u32 = 4294967295;
pub const COMP_STATE_BITFIELD_LOCK: u32 = 16;
pub const HAL_COMP_ERROR_NONE: u32 = 0;
pub const COMP_WINDOWMODE_DISABLE: u32 = 0;
pub const COMP_WINDOWMODE_COMP1_INPUT_PLUS_COMMON: u32 = 512;
pub const COMP_POWERMODE_HIGHSPEED: u32 = 0;
pub const COMP_POWERMODE_MEDIUMSPEED: u32 = 4;
pub const COMP_POWERMODE_ULTRALOWPOWER: u32 = 12;
pub const COMP_INPUT_PLUS_IO1: u32 = 0;
pub const COMP_INPUT_PLUS_IO2: u32 = 128;
pub const COMP_INPUT_MINUS_1_4VREFINT: u32 = 12582912;
pub const COMP_INPUT_MINUS_1_2VREFINT: u32 = 12582928;
pub const COMP_INPUT_MINUS_3_4VREFINT: u32 = 12582944;
pub const COMP_INPUT_MINUS_VREFINT: u32 = 8388656;
pub const COMP_INPUT_MINUS_DAC1_CH1: u32 = 64;
pub const COMP_INPUT_MINUS_DAC1_CH2: u32 = 80;
pub const COMP_INPUT_MINUS_IO1: u32 = 96;
pub const COMP_INPUT_MINUS_IO2: u32 = 112;
pub const COMP_HYSTERESIS_NONE: u32 = 0;
pub const COMP_HYSTERESIS_LOW: u32 = 65536;
pub const COMP_HYSTERESIS_MEDIUM: u32 = 131072;
pub const COMP_HYSTERESIS_HIGH: u32 = 196608;
pub const COMP_OUTPUTPOL_NONINVERTED: u32 = 0;
pub const COMP_OUTPUTPOL_INVERTED: u32 = 32768;
pub const COMP_BLANKINGSRC_NONE: u32 = 0;
pub const COMP_BLANKINGSRC_TIM1_OC5_COMP1: u32 = 262144;
pub const COMP_BLANKINGSRC_TIM2_OC3_COMP1: u32 = 524288;
pub const COMP_BLANKINGSRC_TIM3_OC3_COMP1: u32 = 1048576;
pub const COMP_BLANKINGSRC_TIM3_OC4_COMP2: u32 = 262144;
pub const COMP_BLANKINGSRC_TIM8_OC5_COMP2: u32 = 524288;
pub const COMP_BLANKINGSRC_TIM15_OC1_COMP2: u32 = 1048576;
pub const COMP_OUTPUT_LEVEL_LOW: u32 = 0;
pub const COMP_OUTPUT_LEVEL_HIGH: u32 = 1;
pub const COMP_TRIGGERMODE_NONE: u32 = 0;
pub const COMP_EXTI_LINE_COMP1: u32 = 2097152;
pub const COMP_EXTI_LINE_COMP2: u32 = 4194304;
pub const COMP_EXTI_IT: u32 = 1;
pub const COMP_EXTI_EVENT: u32 = 2;
pub const COMP_EXTI_RISING: u32 = 16;
pub const COMP_EXTI_FALLING: u32 = 32;
pub const DEFAULT_CRC32_POLY: u32 = 79764919;
pub const DEFAULT_CRC_INITVALUE: u32 = 4294967295;
pub const CRC_POLYLENGTH_32B: u32 = 0;
pub const CRC_POLYLENGTH_16B: u32 = 8;
pub const CRC_POLYLENGTH_8B: u32 = 16;
pub const CRC_POLYLENGTH_7B: u32 = 24;
pub const HAL_CRC_LENGTH_32B: u32 = 32;
pub const HAL_CRC_LENGTH_16B: u32 = 16;
pub const HAL_CRC_LENGTH_8B: u32 = 8;
pub const HAL_CRC_LENGTH_7B: u32 = 7;
pub const CRC_INPUTDATA_FORMAT_UNDEFINED: u32 = 0;
pub const CRC_INPUTDATA_FORMAT_BYTES: u32 = 1;
pub const CRC_INPUTDATA_FORMAT_HALFWORDS: u32 = 2;
pub const CRC_INPUTDATA_FORMAT_WORDS: u32 = 3;
pub const CRC_INPUTDATA_INVERSION_NONE: u32 = 0;
pub const CRC_INPUTDATA_INVERSION_BYTE: u32 = 32;
pub const CRC_INPUTDATA_INVERSION_HALFWORD: u32 = 64;
pub const CRC_INPUTDATA_INVERSION_WORD: u32 = 96;
pub const CRC_OUTPUTDATA_INVERSION_DISABLE: u32 = 0;
pub const CRC_OUTPUTDATA_INVERSION_ENABLE: u32 = 128;
pub const HAL_DAC_ERROR_NONE: u32 = 0;
pub const HAL_DAC_ERROR_DMAUNDERRUNCH1: u32 = 1;
pub const HAL_DAC_ERROR_DMAUNDERRUNCH2: u32 = 2;
pub const HAL_DAC_ERROR_DMA: u32 = 4;
pub const HAL_DAC_ERROR_TIMEOUT: u32 = 8;
pub const DAC_TRIGGER_NONE: u32 = 0;
pub const DAC_TRIGGER_T2_TRGO: u32 = 36;
pub const DAC_TRIGGER_T4_TRGO: u32 = 44;
pub const DAC_TRIGGER_T5_TRGO: u32 = 28;
pub const DAC_TRIGGER_T6_TRGO: u32 = 4;
pub const DAC_TRIGGER_T7_TRGO: u32 = 20;
pub const DAC_TRIGGER_T8_TRGO: u32 = 12;
pub const DAC_TRIGGER_EXT_IT9: u32 = 52;
pub const DAC_TRIGGER_SOFTWARE: u32 = 60;
pub const DAC_OUTPUTBUFFER_ENABLE: u32 = 0;
pub const DAC_OUTPUTBUFFER_DISABLE: u32 = 2;
pub const DAC_CHANNEL_1: u32 = 0;
pub const DAC_CHANNEL_2: u32 = 16;
pub const DAC_ALIGN_12B_R: u32 = 0;
pub const DAC_ALIGN_12B_L: u32 = 4;
pub const DAC_ALIGN_8B_R: u32 = 8;
pub const DAC_FLAG_DMAUDR1: u32 = 8192;
pub const DAC_FLAG_DMAUDR2: u32 = 536870912;
pub const DAC_IT_DMAUDR1: u32 = 8192;
pub const DAC_IT_DMAUDR2: u32 = 536870912;
pub const DAC_CHIPCONNECT_DISABLE: u32 = 0;
pub const DAC_CHIPCONNECT_ENABLE: u32 = 1;
pub const DAC_TRIMMING_FACTORY: u32 = 0;
pub const DAC_TRIMMING_USER: u32 = 1;
pub const DAC_SAMPLEANDHOLD_DISABLE: u32 = 0;
pub const DAC_SAMPLEANDHOLD_ENABLE: u32 = 4;
pub const DAC_LFSRUNMASK_BIT0: u32 = 0;
pub const DAC_LFSRUNMASK_BITS1_0: u32 = 256;
pub const DAC_LFSRUNMASK_BITS2_0: u32 = 512;
pub const DAC_LFSRUNMASK_BITS3_0: u32 = 768;
pub const DAC_LFSRUNMASK_BITS4_0: u32 = 1024;
pub const DAC_LFSRUNMASK_BITS5_0: u32 = 1280;
pub const DAC_LFSRUNMASK_BITS6_0: u32 = 1536;
pub const DAC_LFSRUNMASK_BITS7_0: u32 = 1792;
pub const DAC_LFSRUNMASK_BITS8_0: u32 = 2048;
pub const DAC_LFSRUNMASK_BITS9_0: u32 = 2304;
pub const DAC_LFSRUNMASK_BITS10_0: u32 = 2560;
pub const DAC_LFSRUNMASK_BITS11_0: u32 = 2816;
pub const DAC_TRIANGLEAMPLITUDE_1: u32 = 0;
pub const DAC_TRIANGLEAMPLITUDE_3: u32 = 256;
pub const DAC_TRIANGLEAMPLITUDE_7: u32 = 512;
pub const DAC_TRIANGLEAMPLITUDE_15: u32 = 768;
pub const DAC_TRIANGLEAMPLITUDE_31: u32 = 1024;
pub const DAC_TRIANGLEAMPLITUDE_63: u32 = 1280;
pub const DAC_TRIANGLEAMPLITUDE_127: u32 = 1536;
pub const DAC_TRIANGLEAMPLITUDE_255: u32 = 1792;
pub const DAC_TRIANGLEAMPLITUDE_511: u32 = 2048;
pub const DAC_TRIANGLEAMPLITUDE_1023: u32 = 2304;
pub const DAC_TRIANGLEAMPLITUDE_2047: u32 = 2560;
pub const DAC_TRIANGLEAMPLITUDE_4095: u32 = 2816;
pub const EXTI_MODE_NONE: u32 = 0;
pub const EXTI_MODE_INTERRUPT: u32 = 1;
pub const EXTI_MODE_EVENT: u32 = 2;
pub const EXTI_TRIGGER_NONE: u32 = 0;
pub const EXTI_TRIGGER_RISING: u32 = 1;
pub const EXTI_TRIGGER_FALLING: u32 = 2;
pub const EXTI_TRIGGER_RISING_FALLING: u32 = 3;
pub const EXTI_GPIOA: u32 = 0;
pub const EXTI_GPIOB: u32 = 1;
pub const EXTI_GPIOC: u32 = 2;
pub const EXTI_GPIOD: u32 = 3;
pub const EXTI_GPIOE: u32 = 4;
pub const EXTI_GPIOF: u32 = 5;
pub const EXTI_GPIOG: u32 = 5;
pub const EXTI_GPIOH: u32 = 7;
pub const EXTI_GPIOI: u32 = 8;
pub const EXTI_PROPERTY_SHIFT: u32 = 24;
pub const EXTI_DIRECT: u32 = 16777216;
pub const EXTI_CONFIG: u32 = 33554432;
pub const EXTI_GPIO: u32 = 100663296;
pub const EXTI_RESERVED: u32 = 134217728;
pub const EXTI_PROPERTY_MASK: u32 = 117440512;
pub const EXTI_EVENT_PRESENCE_SHIFT: u32 = 28;
pub const EXTI_EVENT: u32 = 268435456;
pub const EXTI_EVENT_PRESENCE_MASK: u32 = 268435456;
pub const EXTI_REG_SHIFT: u32 = 16;
pub const EXTI_REG1: u32 = 0;
pub const EXTI_REG2: u32 = 65536;
pub const EXTI_REG_MASK: u32 = 65536;
pub const EXTI_PIN_MASK: u32 = 31;
pub const EXTI_MODE_MASK: u32 = 3;
pub const EXTI_TRIGGER_MASK: u32 = 3;
pub const EXTI_LINE_NB: u32 = 41;
pub const HAL_FLASH_ERROR_NONE: u32 = 0;
pub const FLASH_LATENCY_0: u32 = 0;
pub const FLASH_LATENCY_1: u32 = 1;
pub const FLASH_LATENCY_2: u32 = 2;
pub const FLASH_LATENCY_3: u32 = 3;
pub const FLASH_LATENCY_4: u32 = 4;
pub const FLASH_KEY1: u32 = 1164378403;
pub const FLASH_KEY2: u32 = 3455027627;
pub const FLASH_PDKEY1: u32 = 68494903;
pub const FLASH_PDKEY2: u32 = 4210818301;
pub const FLASH_OPTKEY1: u32 = 135866939;
pub const FLASH_OPTKEY2: u32 = 1281191551;
pub const FLASH_FLAG_EOP: u32 = 1;
pub const FLASH_FLAG_OPERR: u32 = 2;
pub const FLASH_FLAG_PROGERR: u32 = 8;
pub const FLASH_FLAG_WRPERR: u32 = 16;
pub const FLASH_FLAG_PGAERR: u32 = 32;
pub const FLASH_FLAG_SIZERR: u32 = 64;
pub const FLASH_FLAG_PGSERR: u32 = 128;
pub const FLASH_FLAG_MISERR: u32 = 256;
pub const FLASH_FLAG_FASTERR: u32 = 512;
pub const FLASH_FLAG_RDERR: u32 = 16384;
pub const FLASH_FLAG_OPTVERR: u32 = 32768;
pub const FLASH_FLAG_BSY: u32 = 65536;
pub const FLASH_FLAG_SR_ERRORS: u32 = 50170;
pub const FLASH_FLAG_ECCC: u32 = 1073741824;
pub const FLASH_FLAG_ECCD: u32 = 2147483648;
pub const FLASH_FLAG_ECCR_ERRORS: u32 = 3221225472;
pub const FLASH_FLAG_ALL_ERRORS: u32 = 3221275642;
pub const FLASH_IT_EOP: u32 = 16777216;
pub const FLASH_IT_OPERR: u32 = 33554432;
pub const FLASH_IT_RDERR: u32 = 67108864;
pub const FLASH_IT_ECCC: u32 = 1;
pub const USB_OTG_CORE_ID_300A: u32 = 1330917386;
pub const USB_OTG_CORE_ID_310A: u32 = 1330917642;
pub const USB_OTG_MODE_DEVICE: u32 = 0;
pub const USB_OTG_MODE_HOST: u32 = 1;
pub const USB_OTG_MODE_DRD: u32 = 2;
pub const USBD_FS_SPEED: u32 = 2;
pub const USBH_FSLS_SPEED: u32 = 1;
pub const USB_OTG_SPEED_FULL: u32 = 3;
pub const USB_OTG_ULPI_PHY: u32 = 1;
pub const USB_OTG_EMBEDDED_PHY: u32 = 2;
pub const USBD_FS_TRDT_VALUE: u32 = 5;
pub const USBD_DEFAULT_TRDT_VALUE: u32 = 9;
pub const USB_OTG_FS_MAX_PACKET_SIZE: u32 = 64;
pub const USB_OTG_MAX_EP0_SIZE: u32 = 64;
pub const DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ: u32 = 0;
pub const DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ: u32 = 2;
pub const DSTS_ENUMSPD_FS_PHY_48MHZ: u32 = 6;
pub const DCFG_FRAME_INTERVAL_80: u32 = 0;
pub const DCFG_FRAME_INTERVAL_85: u32 = 1;
pub const DCFG_FRAME_INTERVAL_90: u32 = 2;
pub const DCFG_FRAME_INTERVAL_95: u32 = 3;
pub const EP_MPS_64: u32 = 0;
pub const EP_MPS_32: u32 = 1;
pub const EP_MPS_16: u32 = 2;
pub const EP_MPS_8: u32 = 3;
pub const EP_SPEED_LOW: u32 = 0;
pub const EP_SPEED_FULL: u32 = 1;
pub const EP_SPEED_HIGH: u32 = 2;
pub const EP_TYPE_CTRL: u32 = 0;
pub const EP_TYPE_ISOC: u32 = 1;
pub const EP_TYPE_BULK: u32 = 2;
pub const EP_TYPE_INTR: u32 = 3;
pub const EP_TYPE_MSK: u32 = 3;
pub const STS_GOUT_NAK: u32 = 1;
pub const STS_DATA_UPDT: u32 = 2;
pub const STS_XFER_COMP: u32 = 3;
pub const STS_SETUP_COMP: u32 = 4;
pub const STS_SETUP_UPDT: u32 = 6;
pub const HCFG_30_60_MHZ: u32 = 0;
pub const HCFG_48_MHZ: u32 = 1;
pub const HCFG_6_MHZ: u32 = 2;
pub const HPRT0_PRTSPD_HIGH_SPEED: u32 = 0;
pub const HPRT0_PRTSPD_FULL_SPEED: u32 = 1;
pub const HPRT0_PRTSPD_LOW_SPEED: u32 = 2;
pub const HCCHAR_CTRL: u32 = 0;
pub const HCCHAR_ISOC: u32 = 1;
pub const HCCHAR_BULK: u32 = 2;
pub const HCCHAR_INTR: u32 = 3;
pub const HC_PID_DATA0: u32 = 0;
pub const HC_PID_DATA2: u32 = 1;
pub const HC_PID_DATA1: u32 = 2;
pub const HC_PID_SETUP: u32 = 3;
pub const GRXSTS_PKTSTS_IN: u32 = 2;
pub const GRXSTS_PKTSTS_IN_XFER_COMP: u32 = 3;
pub const GRXSTS_PKTSTS_DATA_TOGGLE_ERR: u32 = 5;
pub const GRXSTS_PKTSTS_CH_HALTED: u32 = 7;
pub const EP_ADDR_MSK: u32 = 15;
pub const HCD_SPEED_FULL: u32 = 1;
pub const HCD_SPEED_LOW: u32 = 1;
pub const HCD_DEVICE_SPEED_FULL: u32 = 1;
pub const HCD_DEVICE_SPEED_LOW: u32 = 2;
pub const HCD_PHY_ULPI: u32 = 1;
pub const HCD_PHY_EMBEDDED: u32 = 2;
pub const HAL_I2C_ERROR_NONE: u32 = 0;
pub const HAL_I2C_ERROR_BERR: u32 = 1;
pub const HAL_I2C_ERROR_ARLO: u32 = 2;
pub const HAL_I2C_ERROR_AF: u32 = 4;
pub const HAL_I2C_ERROR_OVR: u32 = 8;
pub const HAL_I2C_ERROR_DMA: u32 = 16;
pub const HAL_I2C_ERROR_TIMEOUT: u32 = 32;
pub const HAL_I2C_ERROR_SIZE: u32 = 64;
pub const HAL_I2C_ERROR_DMA_PARAM: u32 = 128;
pub const HAL_I2C_ERROR_INVALID_PARAM: u32 = 512;
pub const I2C_OTHER_FRAME: u32 = 170;
pub const I2C_OTHER_AND_LAST_FRAME: u32 = 43520;
pub const I2C_ADDRESSINGMODE_7BIT: u32 = 1;
pub const I2C_ADDRESSINGMODE_10BIT: u32 = 2;
pub const I2C_DUALADDRESS_DISABLE: u32 = 0;
pub const I2C_DUALADDRESS_ENABLE: u32 = 32768;
pub const I2C_GENERALCALL_DISABLE: u32 = 0;
pub const I2C_GENERALCALL_ENABLE: u32 = 524288;
pub const I2C_NOSTRETCH_DISABLE: u32 = 0;
pub const I2C_NOSTRETCH_ENABLE: u32 = 131072;
pub const I2C_MEMADD_SIZE_8BIT: u32 = 1;
pub const I2C_MEMADD_SIZE_16BIT: u32 = 2;
pub const I2C_DIRECTION_TRANSMIT: u32 = 0;
pub const I2C_DIRECTION_RECEIVE: u32 = 1;
pub const I2C_RELOAD_MODE: u32 = 16777216;
pub const I2C_AUTOEND_MODE: u32 = 33554432;
pub const I2C_SOFTEND_MODE: u32 = 0;
pub const I2C_NO_STARTSTOP: u32 = 0;
pub const I2C_IT_ERRI: u32 = 128;
pub const I2C_IT_TCI: u32 = 64;
pub const I2C_IT_STOPI: u32 = 32;
pub const I2C_IT_NACKI: u32 = 16;
pub const I2C_IT_ADDRI: u32 = 8;
pub const I2C_IT_RXI: u32 = 4;
pub const I2C_IT_TXI: u32 = 2;
pub const I2C_FLAG_TXE: u32 = 1;
pub const I2C_FLAG_TXIS: u32 = 2;
pub const I2C_FLAG_RXNE: u32 = 4;
pub const I2C_FLAG_ADDR: u32 = 8;
pub const I2C_FLAG_AF: u32 = 16;
pub const I2C_FLAG_STOPF: u32 = 32;
pub const I2C_FLAG_TC: u32 = 64;
pub const I2C_FLAG_TCR: u32 = 128;
pub const I2C_FLAG_BERR: u32 = 256;
pub const I2C_FLAG_ARLO: u32 = 512;
pub const I2C_FLAG_OVR: u32 = 1024;
pub const I2C_FLAG_PECERR: u32 = 2048;
pub const I2C_FLAG_TIMEOUT: u32 = 4096;
pub const I2C_FLAG_ALERT: u32 = 8192;
pub const I2C_FLAG_BUSY: u32 = 32768;
pub const I2C_FLAG_DIR: u32 = 65536;
pub const I2C_FLAG_MASK: u32 = 131071;
pub const I2C_ANALOGFILTER_ENABLE: u32 = 0;
pub const I2C_ANALOGFILTER_DISABLE: u32 = 4096;
pub const I2C_FMP_NOT_SUPPORTED: u32 = 2863267840;
pub const I2C_FASTMODEPLUS_PB6: u32 = 65536;
pub const I2C_FASTMODEPLUS_PB7: u32 = 131072;
pub const I2C_FASTMODEPLUS_PB8: u32 = 262144;
pub const I2C_FASTMODEPLUS_PB9: u32 = 524288;
pub const I2C_FASTMODEPLUS_I2C1: u32 = 1048576;
pub const I2C_FASTMODEPLUS_I2C2: u32 = 2097152;
pub const I2C_FASTMODEPLUS_I2C3: u32 = 4194304;
pub const HAL_IRDA_STATE_RESET: u32 = 0;
pub const HAL_IRDA_STATE_READY: u32 = 32;
pub const HAL_IRDA_STATE_BUSY: u32 = 36;
pub const HAL_IRDA_STATE_BUSY_TX: u32 = 33;
pub const HAL_IRDA_STATE_BUSY_RX: u32 = 34;
pub const HAL_IRDA_STATE_BUSY_TX_RX: u32 = 35;
pub const HAL_IRDA_STATE_TIMEOUT: u32 = 160;
pub const HAL_IRDA_STATE_ERROR: u32 = 224;
pub const IRDA_PARITY_NONE: u32 = 0;
pub const IRDA_PARITY_EVEN: u32 = 1024;
pub const IRDA_PARITY_ODD: u32 = 1536;
pub const IRDA_MODE_RX: u32 = 4;
pub const IRDA_MODE_TX: u32 = 8;
pub const IRDA_MODE_TX_RX: u32 = 12;
pub const IRDA_POWERMODE_NORMAL: u32 = 0;
pub const IRDA_POWERMODE_LOWPOWER: u32 = 4;
pub const IRDA_STATE_DISABLE: u32 = 0;
pub const IRDA_STATE_ENABLE: u32 = 1;
pub const IRDA_MODE_DISABLE: u32 = 0;
pub const IRDA_MODE_ENABLE: u32 = 2;
pub const IRDA_ONE_BIT_SAMPLE_DISABLE: u32 = 0;
pub const IRDA_ONE_BIT_SAMPLE_ENABLE: u32 = 2048;
pub const IRDA_DMA_TX_DISABLE: u32 = 0;
pub const IRDA_DMA_TX_ENABLE: u32 = 128;
pub const IRDA_DMA_RX_DISABLE: u32 = 0;
pub const IRDA_DMA_RX_ENABLE: u32 = 64;
pub const IRDA_AUTOBAUD_REQUEST: u32 = 1;
pub const IRDA_RXDATA_FLUSH_REQUEST: u32 = 8;
pub const IRDA_TXDATA_FLUSH_REQUEST: u32 = 16;
pub const IRDA_FLAG_REACK: u32 = 4194304;
pub const IRDA_FLAG_TEACK: u32 = 2097152;
pub const IRDA_FLAG_BUSY: u32 = 65536;
pub const IRDA_FLAG_ABRF: u32 = 32768;
pub const IRDA_FLAG_ABRE: u32 = 16384;
pub const IRDA_FLAG_TXE: u32 = 128;
pub const IRDA_FLAG_TC: u32 = 64;
pub const IRDA_FLAG_RXNE: u32 = 32;
pub const IRDA_FLAG_ORE: u32 = 8;
pub const IRDA_FLAG_NE: u32 = 4;
pub const IRDA_FLAG_FE: u32 = 2;
pub const IRDA_FLAG_PE: u32 = 1;
pub const IRDA_IT_PE: u32 = 40;
pub const IRDA_IT_TXE: u32 = 1831;
pub const IRDA_IT_TC: u32 = 1574;
pub const IRDA_IT_RXNE: u32 = 1317;
pub const IRDA_IT_IDLE: u32 = 1060;
pub const IRDA_IT_ERR: u32 = 96;
pub const IRDA_IT_ORE: u32 = 768;
pub const IRDA_IT_NE: u32 = 512;
pub const IRDA_IT_FE: u32 = 256;
pub const IRDA_CLEAR_PEF: u32 = 1;
pub const IRDA_CLEAR_FEF: u32 = 2;
pub const IRDA_CLEAR_NEF: u32 = 4;
pub const IRDA_CLEAR_OREF: u32 = 8;
pub const IRDA_CLEAR_IDLEF: u32 = 16;
pub const IRDA_CLEAR_TCF: u32 = 64;
pub const IRDA_IT_MASK: u32 = 31;
pub const IRDA_CR_MASK: u32 = 224;
pub const IRDA_CR_POS: u32 = 5;
pub const IRDA_ISR_MASK: u32 = 7936;
pub const IRDA_ISR_POS: u32 = 8;
pub const IRDA_WORDLENGTH_7B: u32 = 268435456;
pub const IRDA_WORDLENGTH_8B: u32 = 0;
pub const IRDA_WORDLENGTH_9B: u32 = 4096;
pub const IWDG_PRESCALER_4: u32 = 0;
pub const IWDG_PRESCALER_8: u32 = 1;
pub const IWDG_PRESCALER_16: u32 = 2;
pub const IWDG_PRESCALER_32: u32 = 3;
pub const IWDG_PRESCALER_64: u32 = 4;
pub const IWDG_PRESCALER_128: u32 = 5;
pub const IWDG_PRESCALER_256: u32 = 6;
pub const IWDG_WINDOW_DISABLE: u32 = 4095;
pub const IWDG_KEY_RELOAD: u32 = 43690;
pub const IWDG_KEY_ENABLE: u32 = 52428;
pub const IWDG_KEY_WRITE_ACCESS_ENABLE: u32 = 21845;
pub const IWDG_KEY_WRITE_ACCESS_DISABLE: u32 = 0;
pub const LPTIM_EXTI_LINE_LPTIM1: u32 = 1;
pub const LPTIM_EXTI_LINE_LPTIM2: u32 = 2;
pub const LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC: u32 = 0;
pub const LPTIM_CLOCKSOURCE_ULPTIM: u32 = 1;
pub const LPTIM_PRESCALER_DIV1: u32 = 0;
pub const LPTIM_PRESCALER_DIV2: u32 = 512;
pub const LPTIM_PRESCALER_DIV4: u32 = 1024;
pub const LPTIM_PRESCALER_DIV8: u32 = 1536;
pub const LPTIM_PRESCALER_DIV16: u32 = 2048;
pub const LPTIM_PRESCALER_DIV32: u32 = 2560;
pub const LPTIM_PRESCALER_DIV64: u32 = 3072;
pub const LPTIM_PRESCALER_DIV128: u32 = 3584;
pub const LPTIM_OUTPUTPOLARITY_HIGH: u32 = 0;
pub const LPTIM_OUTPUTPOLARITY_LOW: u32 = 2097152;
pub const LPTIM_CLOCKSAMPLETIME_DIRECTTRANSITION: u32 = 0;
pub const LPTIM_CLOCKSAMPLETIME_2TRANSITIONS: u32 = 8;
pub const LPTIM_CLOCKSAMPLETIME_4TRANSITIONS: u32 = 16;
pub const LPTIM_CLOCKSAMPLETIME_8TRANSITIONS: u32 = 24;
pub const LPTIM_CLOCKPOLARITY_RISING: u32 = 0;
pub const LPTIM_CLOCKPOLARITY_FALLING: u32 = 2;
pub const LPTIM_CLOCKPOLARITY_RISING_FALLING: u32 = 4;
pub const LPTIM_TRIGSOURCE_SOFTWARE: u32 = 65535;
pub const LPTIM_TRIGSOURCE_0: u32 = 0;
pub const LPTIM_TRIGSOURCE_1: u32 = 8192;
pub const LPTIM_TRIGSOURCE_2: u32 = 16384;
pub const LPTIM_TRIGSOURCE_3: u32 = 24576;
pub const LPTIM_TRIGSOURCE_4: u32 = 32768;
pub const LPTIM_TRIGSOURCE_5: u32 = 40960;
pub const LPTIM_TRIGSOURCE_6: u32 = 49152;
pub const LPTIM_TRIGSOURCE_7: u32 = 57344;
pub const LPTIM_ACTIVEEDGE_RISING: u32 = 131072;
pub const LPTIM_ACTIVEEDGE_FALLING: u32 = 262144;
pub const LPTIM_ACTIVEEDGE_RISING_FALLING: u32 = 393216;
pub const LPTIM_TRIGSAMPLETIME_DIRECTTRANSITION: u32 = 0;
pub const LPTIM_TRIGSAMPLETIME_2TRANSITIONS: u32 = 64;
pub const LPTIM_TRIGSAMPLETIME_4TRANSITIONS: u32 = 128;
pub const LPTIM_TRIGSAMPLETIME_8TRANSITIONS: u32 = 192;
pub const LPTIM_UPDATE_IMMEDIATE: u32 = 0;
pub const LPTIM_UPDATE_ENDOFPERIOD: u32 = 4194304;
pub const LPTIM_COUNTERSOURCE_INTERNAL: u32 = 0;
pub const LPTIM_COUNTERSOURCE_EXTERNAL: u32 = 8388608;
pub const LPTIM_INPUT1SOURCE_GPIO: u32 = 0;
pub const LPTIM_INPUT1SOURCE_COMP1: u32 = 1;
pub const LPTIM_INPUT1SOURCE_COMP2: u32 = 2;
pub const LPTIM_INPUT1SOURCE_COMP1_COMP2: u32 = 3;
pub const LPTIM_INPUT2SOURCE_GPIO: u32 = 0;
pub const LPTIM_INPUT2SOURCE_COMP2: u32 = 2;
pub const LPTIM_FLAG_DOWN: u32 = 64;
pub const LPTIM_FLAG_UP: u32 = 32;
pub const LPTIM_FLAG_ARROK: u32 = 16;
pub const LPTIM_FLAG_CMPOK: u32 = 8;
pub const LPTIM_FLAG_EXTTRIG: u32 = 4;
pub const LPTIM_FLAG_ARRM: u32 = 2;
pub const LPTIM_FLAG_CMPM: u32 = 1;
pub const LPTIM_IT_DOWN: u32 = 64;
pub const LPTIM_IT_UP: u32 = 32;
pub const LPTIM_IT_ARROK: u32 = 16;
pub const LPTIM_IT_CMPOK: u32 = 8;
pub const LPTIM_IT_EXTTRIG: u32 = 4;
pub const LPTIM_IT_ARRM: u32 = 2;
pub const LPTIM_IT_CMPM: u32 = 1;
pub const SDMMC_CLOCK_EDGE_FALLING: u32 = 8192;
pub const SDMMC_CLOCK_BYPASS_ENABLE: u32 = 1024;
pub const SDMMC_CLOCK_POWER_SAVE_ENABLE: u32 = 512;
pub const SDMMC_BUS_WIDE_4B: u32 = 2048;
pub const SDMMC_BUS_WIDE_8B: u32 = 4096;
pub const SDMMC_HARDWARE_FLOW_CONTROL_ENABLE: u32 = 16384;
pub const SDMMC_RESPONSE_SHORT: u32 = 64;
pub const SDMMC_RESPONSE_LONG: u32 = 192;
pub const SDMMC_WAIT_IT: u32 = 256;
pub const SDMMC_WAIT_PEND: u32 = 512;
pub const SDMMC_CPSM_ENABLE: u32 = 1024;
pub const SDMMC_DATABLOCK_SIZE_2B: u32 = 16;
pub const SDMMC_DATABLOCK_SIZE_4B: u32 = 32;
pub const SDMMC_DATABLOCK_SIZE_8B: u32 = 48;
pub const SDMMC_DATABLOCK_SIZE_16B: u32 = 64;
pub const SDMMC_DATABLOCK_SIZE_32B: u32 = 80;
pub const SDMMC_DATABLOCK_SIZE_64B: u32 = 96;
pub const SDMMC_DATABLOCK_SIZE_128B: u32 = 112;
pub const SDMMC_DATABLOCK_SIZE_256B: u32 = 128;
pub const SDMMC_DATABLOCK_SIZE_512B: u32 = 144;
pub const SDMMC_DATABLOCK_SIZE_1024B: u32 = 160;
pub const SDMMC_DATABLOCK_SIZE_2048B: u32 = 176;
pub const SDMMC_DATABLOCK_SIZE_4096B: u32 = 192;
pub const SDMMC_DATABLOCK_SIZE_8192B: u32 = 208;
pub const SDMMC_DATABLOCK_SIZE_16384B: u32 = 224;
pub const SDMMC_TRANSFER_DIR_TO_SDMMC: u32 = 2;
pub const SDMMC_TRANSFER_MODE_STREAM: u32 = 4;
pub const SDMMC_DPSM_ENABLE: u32 = 1;
pub const SDMMC_READ_WAIT_MODE_CLK: u32 = 1024;
pub const SDMMC_IT_CCRCFAIL: u32 = 1;
pub const SDMMC_IT_DCRCFAIL: u32 = 2;
pub const SDMMC_IT_CTIMEOUT: u32 = 4;
pub const SDMMC_IT_DTIMEOUT: u32 = 8;
pub const SDMMC_IT_TXUNDERR: u32 = 16;
pub const SDMMC_IT_RXOVERR: u32 = 32;
pub const SDMMC_IT_CMDREND: u32 = 64;
pub const SDMMC_IT_CMDSENT: u32 = 128;
pub const SDMMC_IT_DATAEND: u32 = 256;
pub const SDMMC_IT_DBCKEND: u32 = 1024;
pub const SDMMC_IT_CMDACT: u32 = 2048;
pub const SDMMC_IT_TXACT: u32 = 4096;
pub const SDMMC_IT_RXACT: u32 = 8192;
pub const SDMMC_IT_TXFIFOHE: u32 = 16384;
pub const SDMMC_IT_RXFIFOHF: u32 = 32768;
pub const SDMMC_IT_TXFIFOF: u32 = 65536;
pub const SDMMC_IT_RXFIFOF: u32 = 131072;
pub const SDMMC_IT_TXFIFOE: u32 = 262144;
pub const SDMMC_IT_RXFIFOE: u32 = 524288;
pub const SDMMC_IT_TXDAVL: u32 = 1048576;
pub const SDMMC_IT_RXDAVL: u32 = 2097152;
pub const SDMMC_IT_SDIOIT: u32 = 4194304;
pub const SDMMC_FLAG_CCRCFAIL: u32 = 1;
pub const SDMMC_FLAG_DCRCFAIL: u32 = 2;
pub const SDMMC_FLAG_CTIMEOUT: u32 = 4;
pub const SDMMC_FLAG_DTIMEOUT: u32 = 8;
pub const SDMMC_FLAG_TXUNDERR: u32 = 16;
pub const SDMMC_FLAG_RXOVERR: u32 = 32;
pub const SDMMC_FLAG_CMDREND: u32 = 64;
pub const SDMMC_FLAG_CMDSENT: u32 = 128;
pub const SDMMC_FLAG_DATAEND: u32 = 256;
pub const SDMMC_FLAG_DBCKEND: u32 = 1024;
pub const SDMMC_FLAG_CMDACT: u32 = 2048;
pub const SDMMC_FLAG_TXACT: u32 = 4096;
pub const SDMMC_FLAG_RXACT: u32 = 8192;
pub const SDMMC_FLAG_TXFIFOHE: u32 = 16384;
pub const SDMMC_FLAG_RXFIFOHF: u32 = 32768;
pub const SDMMC_FLAG_TXFIFOF: u32 = 65536;
pub const SDMMC_FLAG_RXFIFOF: u32 = 131072;
pub const SDMMC_FLAG_TXFIFOE: u32 = 262144;
pub const SDMMC_FLAG_RXFIFOE: u32 = 524288;
pub const SDMMC_FLAG_TXDAVL: u32 = 1048576;
pub const SDMMC_FLAG_RXDAVL: u32 = 2097152;
pub const SDMMC_FLAG_SDIOIT: u32 = 4194304;
pub const HAL_MMC_CARD_READY: u32 = 1;
pub const HAL_MMC_CARD_IDENTIFICATION: u32 = 2;
pub const HAL_MMC_CARD_STANDBY: u32 = 3;
pub const HAL_MMC_CARD_TRANSFER: u32 = 4;
pub const HAL_MMC_CARD_SENDING: u32 = 5;
pub const HAL_MMC_CARD_RECEIVING: u32 = 6;
pub const HAL_MMC_CARD_PROGRAMMING: u32 = 7;
pub const HAL_MMC_CARD_DISCONNECTED: u32 = 8;
pub const HAL_MMC_CARD_ERROR: u32 = 255;
pub const MMC_HIGH_VOLTAGE_RANGE: u32 = 2164228096;
pub const MMC_DUAL_VOLTAGE_RANGE: u32 = 2164228224;
pub const MMC_LOW_VOLTAGE_RANGE: u32 = 2147483776;
pub const eMMC_HIGH_VOLTAGE_RANGE: u32 = 3237969920;
pub const eMMC_DUAL_VOLTAGE_RANGE: u32 = 3237970048;
pub const eMMC_LOW_VOLTAGE_RANGE: u32 = 3221225600;
pub const MMC_INVALID_VOLTAGE_RANGE: u32 = 130817;
pub const FMC_NORSRAM_BANK1: u32 = 0;
pub const FMC_NORSRAM_BANK2: u32 = 2;
pub const FMC_NORSRAM_BANK3: u32 = 4;
pub const FMC_NORSRAM_BANK4: u32 = 6;
pub const FMC_DATA_ADDRESS_MUX_DISABLE: u32 = 0;
pub const FMC_DATA_ADDRESS_MUX_ENABLE: u32 = 2;
pub const FMC_MEMORY_TYPE_SRAM: u32 = 0;
pub const FMC_MEMORY_TYPE_PSRAM: u32 = 4;
pub const FMC_MEMORY_TYPE_NOR: u32 = 8;
pub const FMC_NORSRAM_MEM_BUS_WIDTH_8: u32 = 0;
pub const FMC_NORSRAM_MEM_BUS_WIDTH_16: u32 = 16;
pub const FMC_NORSRAM_MEM_BUS_WIDTH_32: u32 = 32;
pub const FMC_NORSRAM_FLASH_ACCESS_ENABLE: u32 = 64;
pub const FMC_NORSRAM_FLASH_ACCESS_DISABLE: u32 = 0;
pub const FMC_BURST_ACCESS_MODE_DISABLE: u32 = 0;
pub const FMC_BURST_ACCESS_MODE_ENABLE: u32 = 256;
pub const FMC_WAIT_SIGNAL_POLARITY_LOW: u32 = 0;
pub const FMC_WAIT_SIGNAL_POLARITY_HIGH: u32 = 512;
pub const FMC_WAIT_TIMING_BEFORE_WS: u32 = 0;
pub const FMC_WAIT_TIMING_DURING_WS: u32 = 2048;
pub const FMC_WRITE_OPERATION_DISABLE: u32 = 0;
pub const FMC_WRITE_OPERATION_ENABLE: u32 = 4096;
pub const FMC_WAIT_SIGNAL_DISABLE: u32 = 0;
pub const FMC_WAIT_SIGNAL_ENABLE: u32 = 8192;
pub const FMC_EXTENDED_MODE_DISABLE: u32 = 0;
pub const FMC_EXTENDED_MODE_ENABLE: u32 = 16384;
pub const FMC_ASYNCHRONOUS_WAIT_DISABLE: u32 = 0;
pub const FMC_ASYNCHRONOUS_WAIT_ENABLE: u32 = 32768;
pub const FMC_PAGE_SIZE_NONE: u32 = 0;
pub const FMC_PAGE_SIZE_128: u32 = 65536;
pub const FMC_PAGE_SIZE_256: u32 = 131072;
pub const FMC_PAGE_SIZE_512: u32 = 196608;
pub const FMC_PAGE_SIZE_1024: u32 = 262144;
pub const FMC_WRITE_BURST_DISABLE: u32 = 0;
pub const FMC_WRITE_BURST_ENABLE: u32 = 524288;
pub const FMC_CONTINUOUS_CLOCK_SYNC_ONLY: u32 = 0;
pub const FMC_CONTINUOUS_CLOCK_SYNC_ASYNC: u32 = 1048576;
pub const FMC_WRITE_FIFO_ENABLE: u32 = 0;
pub const FMC_ACCESS_MODE_A: u32 = 0;
pub const FMC_ACCESS_MODE_B: u32 = 268435456;
pub const FMC_ACCESS_MODE_C: u32 = 536870912;
pub const FMC_ACCESS_MODE_D: u32 = 805306368;
pub const FMC_NBL_SETUPTIME_0: u32 = 0;
pub const FMC_NBL_SETUPTIME_1: u32 = 4194304;
pub const FMC_NBL_SETUPTIME_2: u32 = 8388608;
pub const FMC_NBL_SETUPTIME_3: u32 = 12582912;
pub const FMC_NAND_BANK3: u32 = 256;
pub const FMC_NAND_WAIT_FEATURE_DISABLE: u32 = 0;
pub const FMC_NAND_WAIT_FEATURE_ENABLE: u32 = 2;
pub const FMC_PCR_MEMORY_TYPE_NAND: u32 = 8;
pub const FMC_NAND_MEM_BUS_WIDTH_8: u32 = 0;
pub const FMC_NAND_MEM_BUS_WIDTH_16: u32 = 16;
pub const FMC_NAND_ECC_DISABLE: u32 = 0;
pub const FMC_NAND_ECC_ENABLE: u32 = 64;
pub const FMC_NAND_ECC_PAGE_SIZE_256BYTE: u32 = 0;
pub const FMC_NAND_ECC_PAGE_SIZE_512BYTE: u32 = 131072;
pub const FMC_NAND_ECC_PAGE_SIZE_1024BYTE: u32 = 262144;
pub const FMC_NAND_ECC_PAGE_SIZE_2048BYTE: u32 = 393216;
pub const FMC_NAND_ECC_PAGE_SIZE_4096BYTE: u32 = 524288;
pub const FMC_NAND_ECC_PAGE_SIZE_8192BYTE: u32 = 655360;
pub const FMC_IT_RISING_EDGE: u32 = 8;
pub const FMC_IT_LEVEL: u32 = 16;
pub const FMC_IT_FALLING_EDGE: u32 = 32;
pub const FMC_FLAG_RISING_EDGE: u32 = 1;
pub const FMC_FLAG_LEVEL: u32 = 2;
pub const FMC_FLAG_FALLING_EDGE: u32 = 4;
pub const FMC_FLAG_FEMPT: u32 = 64;
pub const NAND_DEVICE: u32 = 2147483648;
pub const NAND_WRITE_TIMEOUT: u32 = 16777216;
pub const CMD_AREA: u32 = 65536;
pub const ADDR_AREA: u32 = 131072;
pub const NAND_VALID_ADDRESS: u32 = 256;
pub const NAND_INVALID_ADDRESS: u32 = 512;
pub const NAND_TIMEOUT_ERROR: u32 = 1024;
pub const NAND_BUSY: u32 = 0;
pub const NAND_ERROR: u32 = 1;
pub const NAND_READY: u32 = 64;
pub const NOR_MEMORY_ADRESS1: u32 = 1610612736;
pub const NOR_MEMORY_ADRESS2: u32 = 1677721600;
pub const NOR_MEMORY_ADRESS3: u32 = 1744830464;
pub const NOR_MEMORY_ADRESS4: u32 = 1811939328;
pub const OPAMP_STANDALONE_MODE: u32 = 0;
pub const OPAMP_PGA_MODE: u32 = 8;
pub const OPAMP_FOLLOWER_MODE: u32 = 12;
pub const OPAMP_NONINVERTINGINPUT_IO0: u32 = 0;
pub const OPAMP_NONINVERTINGINPUT_DAC_CH: u32 = 1024;
pub const OPAMP_INVERTINGINPUT_IO0: u32 = 0;
pub const OPAMP_INVERTINGINPUT_IO1: u32 = 256;
pub const OPAMP_INVERTINGINPUT_CONNECT_NO: u32 = 512;
pub const OPAMP_PGA_GAIN_2: u32 = 0;
pub const OPAMP_PGA_GAIN_4: u32 = 16;
pub const OPAMP_PGA_GAIN_8: u32 = 32;
pub const OPAMP_PGA_GAIN_16: u32 = 48;
pub const OPAMP_POWERMODE_NORMALPOWER: u32 = 0;
pub const OPAMP_POWERMODE_LOWPOWER: u32 = 2;
pub const OPAMP_POWERSUPPLY_LOW: u32 = 0;
pub const OPAMP_POWERSUPPLY_HIGH: u32 = 2147483648;
pub const OPAMP_TRIMMING_FACTORY: u32 = 0;
pub const OPAMP_TRIMMING_USER: u32 = 16384;
pub const OPAMP_FACTORYTRIMMING_DUMMY: u32 = 4294967295;
pub const OPAMP_FACTORYTRIMMING_N: u32 = 0;
pub const OPAMP_FACTORYTRIMMING_P: u32 = 1;
pub const PCD_SPEED_FULL: u32 = 2;
pub const PCD_PHY_ULPI: u32 = 1;
pub const PCD_PHY_EMBEDDED: u32 = 2;
pub const PCD_PHY_UTMI: u32 = 3;
pub const USB_OTG_FS_WAKEUP_EXTI_LINE: u32 = 131072;
pub const USB_OTG_DOEPINT_OTEPSPR: u32 = 32;
pub const USB_OTG_DOEPMSK_OTEPSPRM: u32 = 32;
pub const USB_OTG_DOEPINT_NAK: u32 = 8192;
pub const USB_OTG_DOEPMSK_NAKM: u32 = 8192;
pub const USB_OTG_DOEPINT_STPKTRX: u32 = 32768;
pub const USB_OTG_DOEPMSK_NYETM: u32 = 16384;
pub const PWR_PVDLEVEL_0: u32 = 0;
pub const PWR_PVDLEVEL_1: u32 = 2;
pub const PWR_PVDLEVEL_2: u32 = 4;
pub const PWR_PVDLEVEL_3: u32 = 6;
pub const PWR_PVDLEVEL_4: u32 = 8;
pub const PWR_PVDLEVEL_5: u32 = 10;
pub const PWR_PVDLEVEL_6: u32 = 12;
pub const PWR_PVDLEVEL_7: u32 = 14;
pub const PWR_LOWPOWERREGULATOR_ON: u32 = 16384;
pub const PWR_WUP_POLARITY_SHIFT: u32 = 5;
pub const PWR_WAKEUP_PIN1: u32 = 1;
pub const PWR_WAKEUP_PIN2: u32 = 2;
pub const PWR_WAKEUP_PIN3: u32 = 4;
pub const PWR_WAKEUP_PIN4: u32 = 8;
pub const PWR_WAKEUP_PIN5: u32 = 16;
pub const PWR_WAKEUP_PIN1_HIGH: u32 = 1;
pub const PWR_WAKEUP_PIN2_HIGH: u32 = 2;
pub const PWR_WAKEUP_PIN3_HIGH: u32 = 4;
pub const PWR_WAKEUP_PIN4_HIGH: u32 = 8;
pub const PWR_WAKEUP_PIN5_HIGH: u32 = 16;
pub const PWR_PVM_1: u32 = 16;
pub const PWR_PVM_2: u32 = 32;
pub const PWR_PVM_3: u32 = 64;
pub const PWR_PVM_4: u32 = 128;
pub const PWR_REGULATOR_VOLTAGE_SCALE1: u32 = 512;
pub const PWR_REGULATOR_VOLTAGE_SCALE2: u32 = 1024;
pub const PWR_BATTERY_CHARGING_RESISTOR_1_5: u32 = 512;
pub const PWR_BATTERY_CHARGING_ENABLE: u32 = 256;
pub const PWR_GPIO_BIT_0: u32 = 1;
pub const PWR_GPIO_BIT_1: u32 = 2;
pub const PWR_GPIO_BIT_2: u32 = 4;
pub const PWR_GPIO_BIT_3: u32 = 8;
pub const PWR_GPIO_BIT_4: u32 = 16;
pub const PWR_GPIO_BIT_5: u32 = 32;
pub const PWR_GPIO_BIT_6: u32 = 64;
pub const PWR_GPIO_BIT_7: u32 = 128;
pub const PWR_GPIO_BIT_8: u32 = 256;
pub const PWR_GPIO_BIT_9: u32 = 512;
pub const PWR_GPIO_BIT_10: u32 = 1024;
pub const PWR_GPIO_BIT_11: u32 = 2048;
pub const PWR_GPIO_BIT_12: u32 = 4096;
pub const PWR_GPIO_BIT_13: u32 = 8192;
pub const PWR_GPIO_BIT_14: u32 = 16384;
pub const PWR_GPIO_BIT_15: u32 = 32768;
pub const PWR_GPIO_A: u32 = 0;
pub const PWR_GPIO_B: u32 = 1;
pub const PWR_GPIO_C: u32 = 2;
pub const PWR_GPIO_D: u32 = 3;
pub const PWR_GPIO_E: u32 = 4;
pub const PWR_GPIO_F: u32 = 5;
pub const PWR_GPIO_G: u32 = 6;
pub const PWR_GPIO_H: u32 = 7;
pub const PWR_FLAG_WU: u32 = 31;
pub const PWR_FULL_SRAM2_RETENTION: u32 = 256;
pub const HAL_QSPI_ERROR_NONE: u32 = 0;
pub const HAL_QSPI_ERROR_TIMEOUT: u32 = 1;
pub const HAL_QSPI_ERROR_TRANSFER: u32 = 2;
pub const HAL_QSPI_ERROR_DMA: u32 = 4;
pub const HAL_QSPI_ERROR_INVALID_PARAM: u32 = 8;
pub const QSPI_SAMPLE_SHIFTING_NONE: u32 = 0;
pub const QSPI_CS_HIGH_TIME_1_CYCLE: u32 = 0;
pub const QSPI_CLOCK_MODE_0: u32 = 0;
pub const QSPI_ADDRESS_8_BITS: u32 = 0;
pub const QSPI_ALTERNATE_BYTES_8_BITS: u32 = 0;
pub const QSPI_INSTRUCTION_NONE: u32 = 0;
pub const QSPI_ADDRESS_NONE: u32 = 0;
pub const QSPI_ALTERNATE_BYTES_NONE: u32 = 0;
pub const QSPI_DATA_NONE: u32 = 0;
pub const QSPI_DDR_MODE_DISABLE: u32 = 0;
pub const QSPI_DDR_HHC_ANALOG_DELAY: u32 = 0;
pub const QSPI_SIOO_INST_EVERY_CMD: u32 = 0;
pub const QSPI_MATCH_MODE_AND: u32 = 0;
pub const QSPI_AUTOMATIC_STOP_DISABLE: u32 = 0;
pub const QSPI_TIMEOUT_COUNTER_DISABLE: u32 = 0;
pub const QSPI_FLAG_BUSY: u32 = 32;
pub const QSPI_FLAG_TO: u32 = 16;
pub const QSPI_FLAG_SM: u32 = 8;
pub const QSPI_FLAG_FT: u32 = 4;
pub const QSPI_FLAG_TC: u32 = 2;
pub const QSPI_FLAG_TE: u32 = 1;
pub const QSPI_IT_TO: u32 = 1048576;
pub const QSPI_IT_SM: u32 = 524288;
pub const QSPI_IT_FT: u32 = 262144;
pub const QSPI_IT_TC: u32 = 131072;
pub const QSPI_IT_TE: u32 = 65536;
pub const HAL_QSPI_TIMEOUT_DEFAULT_VALUE: u32 = 5000;
pub const RNG_IT_DRDY: u32 = 1;
pub const RNG_IT_CEI: u32 = 32;
pub const RNG_IT_SEI: u32 = 64;
pub const RNG_FLAG_DRDY: u32 = 1;
pub const RNG_FLAG_CECS: u32 = 2;
pub const RNG_FLAG_SECS: u32 = 4;
pub const HAL_RNG_ERROR_NONE: u32 = 0;
pub const HAL_RNG_ERROR_TIMEOUT: u32 = 2;
pub const HAL_RNG_ERROR_BUSY: u32 = 4;
pub const HAL_RNG_ERROR_SEED: u32 = 8;
pub const HAL_RNG_ERROR_CLOCK: u32 = 16;
pub const RTC_HOURFORMAT_24: u32 = 0;
pub const RTC_HOURFORMAT_12: u32 = 64;
pub const RTC_OUTPUT_DISABLE: u32 = 0;
pub const RTC_OUTPUT_ALARMA: u32 = 2097152;
pub const RTC_OUTPUT_ALARMB: u32 = 4194304;
pub const RTC_OUTPUT_WAKEUP: u32 = 6291456;
pub const RTC_OUTPUT_POLARITY_HIGH: u32 = 0;
pub const RTC_OUTPUT_POLARITY_LOW: u32 = 1048576;
pub const RTC_OUTPUT_TYPE_PUSHPULL: u32 = 1;
pub const RTC_OUTPUT_TYPE_OPENDRAIN: u32 = 0;
pub const RTC_OUTPUT_REMAP_NONE: u32 = 0;
pub const RTC_OUTPUT_REMAP_POS1: u32 = 2;
pub const RTC_DAYLIGHTSAVING_SUB1H: u32 = 131072;
pub const RTC_DAYLIGHTSAVING_ADD1H: u32 = 65536;
pub const RTC_DAYLIGHTSAVING_NONE: u32 = 0;
pub const RTC_STOREOPERATION_RESET: u32 = 0;
pub const RTC_STOREOPERATION_SET: u32 = 262144;
pub const RTC_FORMAT_BIN: u32 = 0;
pub const RTC_FORMAT_BCD: u32 = 1;
pub const RTC_ALARMDATEWEEKDAYSEL_DATE: u32 = 0;
pub const RTC_ALARMDATEWEEKDAYSEL_WEEKDAY: u32 = 1073741824;
pub const RTC_ALARMMASK_NONE: u32 = 0;
pub const RTC_ALARMMASK_DATEWEEKDAY: u32 = 2147483648;
pub const RTC_ALARMMASK_HOURS: u32 = 8388608;
pub const RTC_ALARMMASK_MINUTES: u32 = 32768;
pub const RTC_ALARMMASK_SECONDS: u32 = 128;
pub const RTC_ALARMMASK_ALL: u32 = 2155905152;
pub const RTC_ALARM_A: u32 = 256;
pub const RTC_ALARM_B: u32 = 512;
pub const RTC_ALARMSUBSECONDMASK_ALL: u32 = 0;
pub const RTC_ALARMSUBSECONDMASK_SS14_1: u32 = 16777216;
pub const RTC_ALARMSUBSECONDMASK_SS14_2: u32 = 33554432;
pub const RTC_ALARMSUBSECONDMASK_SS14_3: u32 = 50331648;
pub const RTC_ALARMSUBSECONDMASK_SS14_4: u32 = 67108864;
pub const RTC_ALARMSUBSECONDMASK_SS14_5: u32 = 83886080;
pub const RTC_ALARMSUBSECONDMASK_SS14_6: u32 = 100663296;
pub const RTC_ALARMSUBSECONDMASK_SS14_7: u32 = 117440512;
pub const RTC_ALARMSUBSECONDMASK_SS14_8: u32 = 134217728;
pub const RTC_ALARMSUBSECONDMASK_SS14_9: u32 = 150994944;
pub const RTC_ALARMSUBSECONDMASK_SS14_10: u32 = 167772160;
pub const RTC_ALARMSUBSECONDMASK_SS14_11: u32 = 184549376;
pub const RTC_ALARMSUBSECONDMASK_SS14_12: u32 = 201326592;
pub const RTC_ALARMSUBSECONDMASK_SS14_13: u32 = 218103808;
pub const RTC_ALARMSUBSECONDMASK_SS14: u32 = 234881024;
pub const RTC_ALARMSUBSECONDMASK_NONE: u32 = 251658240;
pub const RTC_IT_TS: u32 = 32768;
pub const RTC_IT_WUT: u32 = 16384;
pub const RTC_IT_ALRA: u32 = 4096;
pub const RTC_IT_ALRB: u32 = 8192;
pub const RTC_FLAG_RECALPF: u32 = 65536;
pub const RTC_FLAG_TSOVF: u32 = 4096;
pub const RTC_FLAG_TSF: u32 = 2048;
pub const RTC_FLAG_ITSF: u32 = 131072;
pub const RTC_FLAG_WUTF: u32 = 1024;
pub const RTC_FLAG_ALRBF: u32 = 512;
pub const RTC_FLAG_ALRAF: u32 = 256;
pub const RTC_FLAG_INITF: u32 = 64;
pub const RTC_FLAG_RSF: u32 = 32;
pub const RTC_FLAG_INITS: u32 = 16;
pub const RTC_FLAG_SHPF: u32 = 8;
pub const RTC_FLAG_WUTWF: u32 = 4;
pub const RTC_FLAG_ALRBWF: u32 = 2;
pub const RTC_FLAG_ALRAWF: u32 = 1;
pub const RTC_TIMESTAMPEDGE_RISING: u32 = 0;
pub const RTC_TIMESTAMPEDGE_FALLING: u32 = 8;
pub const RTC_TIMESTAMPPIN_DEFAULT: u32 = 0;
pub const RTC_WAKEUPCLOCK_RTCCLK_DIV16: u32 = 0;
pub const RTC_WAKEUPCLOCK_RTCCLK_DIV8: u32 = 1;
pub const RTC_WAKEUPCLOCK_RTCCLK_DIV4: u32 = 2;
pub const RTC_WAKEUPCLOCK_RTCCLK_DIV2: u32 = 3;
pub const RTC_WAKEUPCLOCK_CK_SPRE_16BITS: u32 = 4;
pub const RTC_WAKEUPCLOCK_CK_SPRE_17BITS: u32 = 6;
pub const RTC_SMOOTHCALIB_PERIOD_32SEC: u32 = 0;
pub const RTC_SMOOTHCALIB_PERIOD_16SEC: u32 = 8192;
pub const RTC_SMOOTHCALIB_PERIOD_8SEC: u32 = 16384;
pub const RTC_SMOOTHCALIB_PLUSPULSES_SET: u32 = 32768;
pub const RTC_SMOOTHCALIB_PLUSPULSES_RESET: u32 = 0;
pub const RTC_CALIBOUTPUT_512HZ: u32 = 0;
pub const RTC_CALIBOUTPUT_1HZ: u32 = 524288;
pub const RTC_SHIFTADD1S_RESET: u32 = 0;
pub const RTC_SHIFTADD1S_SET: u32 = 2147483648;
pub const RTC_TAMPER_1: u32 = 1;
pub const RTC_TAMPER_2: u32 = 8;
pub const RTC_TAMPER_3: u32 = 32;
pub const RTC_TAMPERMASK_FLAG_DISABLE: u32 = 0;
pub const RTC_TAMPERMASK_FLAG_ENABLE: u32 = 262144;
pub const RTC_TAMPER_ERASE_BACKUP_ENABLE: u32 = 0;
pub const RTC_TAMPER_ERASE_BACKUP_DISABLE: u32 = 131072;
pub const RTC_TAMPERFILTER_DISABLE: u32 = 0;
pub const RTC_TAMPERFILTER_2SAMPLE: u32 = 2048;
pub const RTC_TAMPERFILTER_4SAMPLE: u32 = 4096;
pub const RTC_TAMPERFILTER_8SAMPLE: u32 = 6144;
pub const RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV32768: u32 = 0;
pub const RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV16384: u32 = 256;
pub const RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV8192: u32 = 512;
pub const RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV4096: u32 = 768;
pub const RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV2048: u32 = 1024;
pub const RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV1024: u32 = 1280;
pub const RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV512: u32 = 1536;
pub const RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV256: u32 = 1792;
pub const RTC_TAMPERSAMPLINGFREQ_RTCCLK_MASK: u32 = 1792;
pub const RTC_TAMPERPRECHARGEDURATION_1RTCCLK: u32 = 0;
pub const RTC_TAMPERPRECHARGEDURATION_2RTCCLK: u32 = 8192;
pub const RTC_TAMPERPRECHARGEDURATION_4RTCCLK: u32 = 16384;
pub const RTC_TAMPERPRECHARGEDURATION_8RTCCLK: u32 = 24576;
pub const RTC_TAMPERPRECHARGEDURATION_MASK: u32 = 24576;
pub const RTC_TAMPER_PULLUP_ENABLE: u32 = 0;
pub const RTC_TAMPER_PULLUP_DISABLE: u32 = 32768;
pub const RTC_TIMESTAMPONTAMPERDETECTION_DISABLE: u32 = 0;
pub const RTC_TIMESTAMPONTAMPERDETECTION_ENABLE: u32 = 128;
pub const RTC_IT_TAMP: u32 = 4;
pub const RTC_IT_TAMP1: u32 = 65536;
pub const RTC_IT_TAMP2: u32 = 524288;
pub const RTC_IT_TAMP3: u32 = 4194304;
pub const RTC_IT_TAMPALL: u32 = 4;
pub const RTC_FLAG_TAMP1F: u32 = 8192;
pub const RTC_FLAG_TAMP2F: u32 = 16384;
pub const RTC_FLAG_TAMP3F: u32 = 32768;
pub const BKP_REG_NUMBER: u32 = 32;
pub const RTC_BKP_DR0: u32 = 0;
pub const RTC_BKP_DR1: u32 = 1;
pub const RTC_BKP_DR2: u32 = 2;
pub const RTC_BKP_DR3: u32 = 3;
pub const RTC_BKP_DR4: u32 = 4;
pub const RTC_BKP_DR5: u32 = 5;
pub const RTC_BKP_DR6: u32 = 6;
pub const RTC_BKP_DR7: u32 = 7;
pub const RTC_BKP_DR8: u32 = 8;
pub const RTC_BKP_DR9: u32 = 9;
pub const RTC_BKP_DR10: u32 = 10;
pub const RTC_BKP_DR11: u32 = 11;
pub const RTC_BKP_DR12: u32 = 12;
pub const RTC_BKP_DR13: u32 = 13;
pub const RTC_BKP_DR14: u32 = 14;
pub const RTC_BKP_DR15: u32 = 15;
pub const RTC_BKP_DR16: u32 = 16;
pub const RTC_BKP_DR17: u32 = 17;
pub const RTC_BKP_DR18: u32 = 18;
pub const RTC_BKP_DR19: u32 = 19;
pub const RTC_BKP_DR20: u32 = 20;
pub const RTC_BKP_DR21: u32 = 21;
pub const RTC_BKP_DR22: u32 = 22;
pub const RTC_BKP_DR23: u32 = 23;
pub const RTC_BKP_DR24: u32 = 24;
pub const RTC_BKP_DR25: u32 = 25;
pub const RTC_BKP_DR26: u32 = 26;
pub const RTC_BKP_DR27: u32 = 27;
pub const RTC_BKP_DR28: u32 = 28;
pub const RTC_BKP_DR29: u32 = 29;
pub const RTC_BKP_DR30: u32 = 30;
pub const RTC_BKP_DR31: u32 = 31;
pub const RTC_TAMPER1_INTERRUPT: u32 = 65536;
pub const RTC_TAMPER2_INTERRUPT: u32 = 524288;
pub const RTC_TAMPER3_INTERRUPT: u32 = 4194304;
pub const RTC_ALL_TAMPER_INTERRUPT: u32 = 4;
pub const RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT: u32 = 524288;
pub const RTC_EXTI_LINE_WAKEUPTIMER_EVENT: u32 = 1048576;
pub const RTC_TR_RESERVED_MASK: u32 = 8355711;
pub const RTC_DR_RESERVED_MASK: u32 = 16777023;
pub const RTC_INIT_MASK: u32 = 4294967295;
pub const RTC_RSF_MASK: i32 = -161;
pub const RTC_TIMEOUT_VALUE: u32 = 1000;
pub const RTC_EXTI_LINE_ALARM_EVENT: u32 = 262144;
pub const HAL_SAI_ERROR_NONE: u32 = 0;
pub const HAL_SAI_ERROR_OVR: u32 = 1;
pub const HAL_SAI_ERROR_UDR: u32 = 2;
pub const HAL_SAI_ERROR_AFSDET: u32 = 4;
pub const HAL_SAI_ERROR_LFSDET: u32 = 8;
pub const HAL_SAI_ERROR_CNREADY: u32 = 16;
pub const HAL_SAI_ERROR_WCKCFG: u32 = 32;
pub const HAL_SAI_ERROR_TIMEOUT: u32 = 64;
pub const HAL_SAI_ERROR_DMA: u32 = 128;
pub const SAI_SYNCEXT_DISABLE: u32 = 0;
pub const SAI_SYNCEXT_OUTBLOCKA_ENABLE: u32 = 1;
pub const SAI_SYNCEXT_OUTBLOCKB_ENABLE: u32 = 2;
pub const SAI_I2S_STANDARD: u32 = 0;
pub const SAI_I2S_MSBJUSTIFIED: u32 = 1;
pub const SAI_I2S_LSBJUSTIFIED: u32 = 2;
pub const SAI_PCM_LONG: u32 = 3;
pub const SAI_PCM_SHORT: u32 = 4;
pub const SAI_PROTOCOL_DATASIZE_16BIT: u32 = 0;
pub const SAI_PROTOCOL_DATASIZE_16BITEXTENDED: u32 = 1;
pub const SAI_PROTOCOL_DATASIZE_24BIT: u32 = 2;
pub const SAI_PROTOCOL_DATASIZE_32BIT: u32 = 3;
pub const SAI_AUDIO_FREQUENCY_192K: u32 = 192000;
pub const SAI_AUDIO_FREQUENCY_96K: u32 = 96000;
pub const SAI_AUDIO_FREQUENCY_48K: u32 = 48000;
pub const SAI_AUDIO_FREQUENCY_44K: u32 = 44100;
pub const SAI_AUDIO_FREQUENCY_32K: u32 = 32000;
pub const SAI_AUDIO_FREQUENCY_22K: u32 = 22050;
pub const SAI_AUDIO_FREQUENCY_16K: u32 = 16000;
pub const SAI_AUDIO_FREQUENCY_11K: u32 = 11025;
pub const SAI_AUDIO_FREQUENCY_8K: u32 = 8000;
pub const SAI_AUDIO_FREQUENCY_MCKDIV: u32 = 0;
pub const SAI_MODEMASTER_TX: u32 = 0;
pub const SAI_MODEMASTER_RX: u32 = 1;
pub const SAI_MODESLAVE_TX: u32 = 2;
pub const SAI_MODESLAVE_RX: u32 = 3;
pub const SAI_FREE_PROTOCOL: u32 = 0;
pub const SAI_SPDIF_PROTOCOL: u32 = 4;
pub const SAI_AC97_PROTOCOL: u32 = 8;
pub const SAI_DATASIZE_8: u32 = 64;
pub const SAI_DATASIZE_10: u32 = 96;
pub const SAI_DATASIZE_16: u32 = 128;
pub const SAI_DATASIZE_20: u32 = 160;
pub const SAI_DATASIZE_24: u32 = 192;
pub const SAI_DATASIZE_32: u32 = 224;
pub const SAI_FIRSTBIT_MSB: u32 = 0;
pub const SAI_FIRSTBIT_LSB: u32 = 256;
pub const SAI_CLOCKSTROBING_FALLINGEDGE: u32 = 0;
pub const SAI_CLOCKSTROBING_RISINGEDGE: u32 = 1;
pub const SAI_ASYNCHRONOUS: u32 = 0;
pub const SAI_SYNCHRONOUS: u32 = 1;
pub const SAI_SYNCHRONOUS_EXT_SAI1: u32 = 2;
pub const SAI_SYNCHRONOUS_EXT_SAI2: u32 = 3;
pub const SAI_OUTPUTDRIVE_DISABLE: u32 = 0;
pub const SAI_OUTPUTDRIVE_ENABLE: u32 = 8192;
pub const SAI_MASTERDIVIDER_ENABLE: u32 = 0;
pub const SAI_MASTERDIVIDER_DISABLE: u32 = 524288;
pub const SAI_FS_STARTFRAME: u32 = 0;
pub const SAI_FS_CHANNEL_IDENTIFICATION: u32 = 65536;
pub const SAI_FS_ACTIVE_LOW: u32 = 0;
pub const SAI_FS_ACTIVE_HIGH: u32 = 131072;
pub const SAI_FS_FIRSTBIT: u32 = 0;
pub const SAI_FS_BEFOREFIRSTBIT: u32 = 262144;
pub const SAI_SLOTSIZE_DATASIZE: u32 = 0;
pub const SAI_SLOTSIZE_16B: u32 = 64;
pub const SAI_SLOTSIZE_32B: u32 = 128;
pub const SAI_SLOT_NOTACTIVE: u32 = 0;
pub const SAI_SLOTACTIVE_0: u32 = 1;
pub const SAI_SLOTACTIVE_1: u32 = 2;
pub const SAI_SLOTACTIVE_2: u32 = 4;
pub const SAI_SLOTACTIVE_3: u32 = 8;
pub const SAI_SLOTACTIVE_4: u32 = 16;
pub const SAI_SLOTACTIVE_5: u32 = 32;
pub const SAI_SLOTACTIVE_6: u32 = 64;
pub const SAI_SLOTACTIVE_7: u32 = 128;
pub const SAI_SLOTACTIVE_8: u32 = 256;
pub const SAI_SLOTACTIVE_9: u32 = 512;
pub const SAI_SLOTACTIVE_10: u32 = 1024;
pub const SAI_SLOTACTIVE_11: u32 = 2048;
pub const SAI_SLOTACTIVE_12: u32 = 4096;
pub const SAI_SLOTACTIVE_13: u32 = 8192;
pub const SAI_SLOTACTIVE_14: u32 = 16384;
pub const SAI_SLOTACTIVE_15: u32 = 32768;
pub const SAI_SLOTACTIVE_ALL: u32 = 65535;
pub const SAI_STEREOMODE: u32 = 0;
pub const SAI_MONOMODE: u32 = 4096;
pub const SAI_OUTPUT_NOTRELEASED: u32 = 0;
pub const SAI_OUTPUT_RELEASED: u32 = 16;
pub const SAI_FIFOTHRESHOLD_EMPTY: u32 = 0;
pub const SAI_FIFOTHRESHOLD_1QF: u32 = 1;
pub const SAI_FIFOTHRESHOLD_HF: u32 = 2;
pub const SAI_FIFOTHRESHOLD_3QF: u32 = 3;
pub const SAI_FIFOTHRESHOLD_FULL: u32 = 4;
pub const SAI_NOCOMPANDING: u32 = 0;
pub const SAI_ULAW_1CPL_COMPANDING: u32 = 32768;
pub const SAI_ALAW_1CPL_COMPANDING: u32 = 49152;
pub const SAI_ULAW_2CPL_COMPANDING: u32 = 40960;
pub const SAI_ALAW_2CPL_COMPANDING: u32 = 57344;
pub const SAI_ZERO_VALUE: u32 = 0;
pub const SAI_LAST_SENT_VALUE: u32 = 64;
pub const SAI_IT_OVRUDR: u32 = 1;
pub const SAI_IT_MUTEDET: u32 = 2;
pub const SAI_IT_WCKCFG: u32 = 4;
pub const SAI_IT_FREQ: u32 = 8;
pub const SAI_IT_CNRDY: u32 = 16;
pub const SAI_IT_AFSDET: u32 = 32;
pub const SAI_IT_LFSDET: u32 = 64;
pub const SAI_FLAG_OVRUDR: u32 = 1;
pub const SAI_FLAG_MUTEDET: u32 = 2;
pub const SAI_FLAG_WCKCFG: u32 = 4;
pub const SAI_FLAG_FREQ: u32 = 8;
pub const SAI_FLAG_CNRDY: u32 = 16;
pub const SAI_FLAG_AFSDET: u32 = 32;
pub const SAI_FLAG_LFSDET: u32 = 64;
pub const SAI_FIFOSTATUS_EMPTY: u32 = 0;
pub const SAI_FIFOSTATUS_LESS1QUARTERFULL: u32 = 65536;
pub const SAI_FIFOSTATUS_1QUARTERFULL: u32 = 131072;
pub const SAI_FIFOSTATUS_HALFFULL: u32 = 196608;
pub const SAI_FIFOSTATUS_3QUARTERFULL: u32 = 262144;
pub const SAI_FIFOSTATUS_FULL: u32 = 327680;
pub const HAL_SD_CARD_READY: u32 = 1;
pub const HAL_SD_CARD_IDENTIFICATION: u32 = 2;
pub const HAL_SD_CARD_STANDBY: u32 = 3;
pub const HAL_SD_CARD_TRANSFER: u32 = 4;
pub const HAL_SD_CARD_SENDING: u32 = 5;
pub const HAL_SD_CARD_RECEIVING: u32 = 6;
pub const HAL_SD_CARD_PROGRAMMING: u32 = 7;
pub const HAL_SD_CARD_DISCONNECTED: u32 = 8;
pub const HAL_SD_CARD_ERROR: u32 = 255;
pub const HAL_SMARTCARD_STATE_RESET: u32 = 0;
pub const HAL_SMARTCARD_STATE_READY: u32 = 32;
pub const HAL_SMARTCARD_STATE_BUSY: u32 = 36;
pub const HAL_SMARTCARD_STATE_BUSY_TX: u32 = 33;
pub const HAL_SMARTCARD_STATE_BUSY_RX: u32 = 34;
pub const HAL_SMARTCARD_STATE_BUSY_TX_RX: u32 = 35;
pub const HAL_SMARTCARD_STATE_TIMEOUT: u32 = 160;
pub const HAL_SMARTCARD_STATE_ERROR: u32 = 224;
pub const SMARTCARD_WORDLENGTH_9B: u32 = 4096;
pub const SMARTCARD_STOPBITS_0_5: u32 = 4096;
pub const SMARTCARD_STOPBITS_1_5: u32 = 12288;
pub const SMARTCARD_PARITY_EVEN: u32 = 1024;
pub const SMARTCARD_PARITY_ODD: u32 = 1536;
pub const SMARTCARD_MODE_RX: u32 = 4;
pub const SMARTCARD_MODE_TX: u32 = 8;
pub const SMARTCARD_MODE_TX_RX: u32 = 12;
pub const SMARTCARD_POLARITY_LOW: u32 = 0;
pub const SMARTCARD_POLARITY_HIGH: u32 = 1024;
pub const SMARTCARD_PHASE_1EDGE: u32 = 0;
pub const SMARTCARD_PHASE_2EDGE: u32 = 512;
pub const SMARTCARD_LASTBIT_DISABLE: u32 = 0;
pub const SMARTCARD_LASTBIT_ENABLE: u32 = 256;
pub const SMARTCARD_ONE_BIT_SAMPLE_DISABLE: u32 = 0;
pub const SMARTCARD_ONE_BIT_SAMPLE_ENABLE: u32 = 2048;
pub const SMARTCARD_NACK_DISABLE: u32 = 0;
pub const SMARTCARD_NACK_ENABLE: u32 = 16;
pub const SMARTCARD_TIMEOUT_DISABLE: u32 = 0;
pub const SMARTCARD_TIMEOUT_ENABLE: u32 = 8388608;
pub const SMARTCARD_ADVFEATURE_TXINV_DISABLE: u32 = 0;
pub const SMARTCARD_ADVFEATURE_TXINV_ENABLE: u32 = 131072;
pub const SMARTCARD_ADVFEATURE_RXINV_DISABLE: u32 = 0;
pub const SMARTCARD_ADVFEATURE_RXINV_ENABLE: u32 = 65536;
pub const SMARTCARD_ADVFEATURE_DATAINV_DISABLE: u32 = 0;
pub const SMARTCARD_ADVFEATURE_DATAINV_ENABLE: u32 = 262144;
pub const SMARTCARD_ADVFEATURE_SWAP_DISABLE: u32 = 0;
pub const SMARTCARD_ADVFEATURE_SWAP_ENABLE: u32 = 32768;
pub const SMARTCARD_ADVFEATURE_OVERRUN_ENABLE: u32 = 0;
pub const SMARTCARD_ADVFEATURE_OVERRUN_DISABLE: u32 = 4096;
pub const SMARTCARD_ADVFEATURE_DMA_ENABLEONRXERROR: u32 = 0;
pub const SMARTCARD_ADVFEATURE_DMA_DISABLEONRXERROR: u32 = 8192;
pub const SMARTCARD_ADVFEATURE_MSBFIRST_DISABLE: u32 = 0;
pub const SMARTCARD_ADVFEATURE_MSBFIRST_ENABLE: u32 = 524288;
pub const SMARTCARD_RXDATA_FLUSH_REQUEST: u32 = 8;
pub const SMARTCARD_TXDATA_FLUSH_REQUEST: u32 = 16;
pub const SMARTCARD_IT_MASK: u32 = 31;
pub const SMARTCARD_CR_MASK: u32 = 224;
pub const SMARTCARD_CR_POS: u32 = 5;
pub const SMARTCARD_ISR_MASK: u32 = 7936;
pub const SMARTCARD_ISR_POS: u32 = 8;
pub const SMARTCARD_ADVFEATURE_NO_INIT: u32 = 0;
pub const SMARTCARD_ADVFEATURE_TXINVERT_INIT: u32 = 1;
pub const SMARTCARD_ADVFEATURE_RXINVERT_INIT: u32 = 2;
pub const SMARTCARD_ADVFEATURE_DATAINVERT_INIT: u32 = 4;
pub const SMARTCARD_ADVFEATURE_SWAP_INIT: u32 = 8;
pub const SMARTCARD_ADVFEATURE_RXOVERRUNDISABLE_INIT: u32 = 16;
pub const SMARTCARD_ADVFEATURE_DMADISABLEONERROR_INIT: u32 = 32;
pub const SMARTCARD_ADVFEATURE_MSBFIRST_INIT: u32 = 128;
pub const SMARTCARD_FLAG_REACK: u32 = 4194304;
pub const SMARTCARD_FLAG_TEACK: u32 = 2097152;
pub const SMARTCARD_FLAG_BUSY: u32 = 65536;
pub const SMARTCARD_FLAG_EOBF: u32 = 4096;
pub const SMARTCARD_FLAG_RTOF: u32 = 2048;
pub const SMARTCARD_FLAG_TXE: u32 = 128;
pub const SMARTCARD_FLAG_TC: u32 = 64;
pub const SMARTCARD_FLAG_RXNE: u32 = 32;
pub const SMARTCARD_FLAG_IDLE: u32 = 16;
pub const SMARTCARD_FLAG_ORE: u32 = 8;
pub const SMARTCARD_FLAG_NE: u32 = 4;
pub const SMARTCARD_FLAG_FE: u32 = 2;
pub const SMARTCARD_FLAG_PE: u32 = 1;
pub const SMARTCARD_IT_PE: u32 = 40;
pub const SMARTCARD_IT_TXE: u32 = 1831;
pub const SMARTCARD_IT_TC: u32 = 1574;
pub const SMARTCARD_IT_RXNE: u32 = 1317;
pub const SMARTCARD_IT_IDLE: u32 = 1060;
pub const SMARTCARD_IT_ERR: u32 = 96;
pub const SMARTCARD_IT_ORE: u32 = 768;
pub const SMARTCARD_IT_NE: u32 = 512;
pub const SMARTCARD_IT_FE: u32 = 256;
pub const SMARTCARD_IT_EOB: u32 = 3131;
pub const SMARTCARD_IT_RTO: u32 = 2874;
pub const SMARTCARD_CLEAR_PEF: u32 = 1;
pub const SMARTCARD_CLEAR_FEF: u32 = 2;
pub const SMARTCARD_CLEAR_NEF: u32 = 4;
pub const SMARTCARD_CLEAR_OREF: u32 = 8;
pub const SMARTCARD_CLEAR_IDLEF: u32 = 16;
pub const SMARTCARD_CLEAR_TCF: u32 = 64;
pub const SMARTCARD_CLEAR_RTOF: u32 = 2048;
pub const SMARTCARD_CLEAR_EOBF: u32 = 4096;
pub const SMBUS_FMP_NOT_SUPPORTED: u32 = 2863267840;
pub const SMBUS_FASTMODEPLUS_PB6: u32 = 65536;
pub const SMBUS_FASTMODEPLUS_PB7: u32 = 131072;
pub const SMBUS_FASTMODEPLUS_PB8: u32 = 262144;
pub const SMBUS_FASTMODEPLUS_PB9: u32 = 524288;
pub const SMBUS_FASTMODEPLUS_I2C1: u32 = 1048576;
pub const SMBUS_FASTMODEPLUS_I2C2: u32 = 2097152;
pub const SMBUS_FASTMODEPLUS_I2C3: u32 = 4194304;
pub const HAL_SMBUS_STATE_RESET: u32 = 0;
pub const HAL_SMBUS_STATE_READY: u32 = 1;
pub const HAL_SMBUS_STATE_BUSY: u32 = 2;
pub const HAL_SMBUS_STATE_MASTER_BUSY_TX: u32 = 18;
pub const HAL_SMBUS_STATE_MASTER_BUSY_RX: u32 = 34;
pub const HAL_SMBUS_STATE_SLAVE_BUSY_TX: u32 = 50;
pub const HAL_SMBUS_STATE_SLAVE_BUSY_RX: u32 = 66;
pub const HAL_SMBUS_STATE_TIMEOUT: u32 = 3;
pub const HAL_SMBUS_STATE_ERROR: u32 = 4;
pub const HAL_SMBUS_STATE_LISTEN: u32 = 8;
pub const HAL_SMBUS_ERROR_NONE: u32 = 0;
pub const HAL_SMBUS_ERROR_BERR: u32 = 1;
pub const HAL_SMBUS_ERROR_ARLO: u32 = 2;
pub const HAL_SMBUS_ERROR_ACKF: u32 = 4;
pub const HAL_SMBUS_ERROR_OVR: u32 = 8;
pub const HAL_SMBUS_ERROR_HALTIMEOUT: u32 = 16;
pub const HAL_SMBUS_ERROR_BUSTIMEOUT: u32 = 32;
pub const HAL_SMBUS_ERROR_ALERT: u32 = 64;
pub const HAL_SMBUS_ERROR_PECERR: u32 = 128;
pub const HAL_SMBUS_ERROR_INVALID_PARAM: u32 = 512;
pub const SMBUS_ANALOGFILTER_ENABLE: u32 = 0;
pub const SMBUS_ANALOGFILTER_DISABLE: u32 = 4096;
pub const SMBUS_ADDRESSINGMODE_7BIT: u32 = 1;
pub const SMBUS_ADDRESSINGMODE_10BIT: u32 = 2;
pub const SMBUS_DUALADDRESS_DISABLE: u32 = 0;
pub const SMBUS_DUALADDRESS_ENABLE: u32 = 32768;
pub const SMBUS_GENERALCALL_DISABLE: u32 = 0;
pub const SMBUS_GENERALCALL_ENABLE: u32 = 524288;
pub const SMBUS_NOSTRETCH_DISABLE: u32 = 0;
pub const SMBUS_NOSTRETCH_ENABLE: u32 = 131072;
pub const SMBUS_PEC_DISABLE: u32 = 0;
pub const SMBUS_PEC_ENABLE: u32 = 8388608;
pub const SMBUS_PERIPHERAL_MODE_SMBUS_HOST: u32 = 1048576;
pub const SMBUS_PERIPHERAL_MODE_SMBUS_SLAVE: u32 = 0;
pub const SMBUS_PERIPHERAL_MODE_SMBUS_SLAVE_ARP: u32 = 2097152;
pub const SMBUS_SOFTEND_MODE: u32 = 0;
pub const SMBUS_RELOAD_MODE: u32 = 16777216;
pub const SMBUS_AUTOEND_MODE: u32 = 33554432;
pub const SMBUS_SENDPEC_MODE: u32 = 67108864;
pub const SMBUS_NO_STARTSTOP: u32 = 0;
pub const SMBUS_FIRST_FRAME: u32 = 0;
pub const SMBUS_FIRST_AND_LAST_FRAME_NO_PEC: u32 = 33554432;
pub const SMBUS_LAST_FRAME_NO_PEC: u32 = 33554432;
pub const SMBUS_OTHER_FRAME_NO_PEC: u32 = 170;
pub const SMBUS_OTHER_FRAME_WITH_PEC: u32 = 43520;
pub const SMBUS_OTHER_AND_LAST_FRAME_NO_PEC: u32 = 11141120;
pub const SMBUS_OTHER_AND_LAST_FRAME_WITH_PEC: u32 = 2852126720;
pub const SMBUS_IT_ERRI: u32 = 128;
pub const SMBUS_IT_TCI: u32 = 64;
pub const SMBUS_IT_STOPI: u32 = 32;
pub const SMBUS_IT_NACKI: u32 = 16;
pub const SMBUS_IT_ADDRI: u32 = 8;
pub const SMBUS_IT_RXI: u32 = 4;
pub const SMBUS_IT_TXI: u32 = 2;
pub const SMBUS_IT_TX: u32 = 242;
pub const SMBUS_IT_RX: u32 = 212;
pub const SMBUS_IT_ALERT: u32 = 128;
pub const SMBUS_IT_ADDR: u32 = 56;
pub const SMBUS_FLAG_TXE: u32 = 1;
pub const SMBUS_FLAG_TXIS: u32 = 2;
pub const SMBUS_FLAG_RXNE: u32 = 4;
pub const SMBUS_FLAG_ADDR: u32 = 8;
pub const SMBUS_FLAG_AF: u32 = 16;
pub const SMBUS_FLAG_STOPF: u32 = 32;
pub const SMBUS_FLAG_TC: u32 = 64;
pub const SMBUS_FLAG_TCR: u32 = 128;
pub const SMBUS_FLAG_BERR: u32 = 256;
pub const SMBUS_FLAG_ARLO: u32 = 512;
pub const SMBUS_FLAG_OVR: u32 = 1024;
pub const SMBUS_FLAG_PECERR: u32 = 2048;
pub const SMBUS_FLAG_TIMEOUT: u32 = 4096;
pub const SMBUS_FLAG_ALERT: u32 = 8192;
pub const SMBUS_FLAG_BUSY: u32 = 32768;
pub const SMBUS_FLAG_DIR: u32 = 65536;
pub const SMBUS_FLAG_MASK: u32 = 131071;
pub const HAL_SPI_ERROR_NONE: u32 = 0;
pub const HAL_SPI_ERROR_MODF: u32 = 1;
pub const HAL_SPI_ERROR_CRC: u32 = 2;
pub const HAL_SPI_ERROR_OVR: u32 = 4;
pub const HAL_SPI_ERROR_FRE: u32 = 8;
pub const HAL_SPI_ERROR_DMA: u32 = 16;
pub const HAL_SPI_ERROR_FLAG: u32 = 32;
pub const HAL_SPI_ERROR_ABORT: u32 = 64;
pub const SPI_MODE_SLAVE: u32 = 0;
pub const SPI_MODE_MASTER: u32 = 260;
pub const SPI_DIRECTION_2LINES: u32 = 0;
pub const SPI_DIRECTION_2LINES_RXONLY: u32 = 1024;
pub const SPI_DIRECTION_1LINE: u32 = 32768;
pub const SPI_DATASIZE_4BIT: u32 = 768;
pub const SPI_DATASIZE_5BIT: u32 = 1024;
pub const SPI_DATASIZE_6BIT: u32 = 1280;
pub const SPI_DATASIZE_7BIT: u32 = 1536;
pub const SPI_DATASIZE_8BIT: u32 = 1792;
pub const SPI_DATASIZE_9BIT: u32 = 2048;
pub const SPI_DATASIZE_10BIT: u32 = 2304;
pub const SPI_DATASIZE_11BIT: u32 = 2560;
pub const SPI_DATASIZE_12BIT: u32 = 2816;
pub const SPI_DATASIZE_13BIT: u32 = 3072;
pub const SPI_DATASIZE_14BIT: u32 = 3328;
pub const SPI_DATASIZE_15BIT: u32 = 3584;
pub const SPI_DATASIZE_16BIT: u32 = 3840;
pub const SPI_POLARITY_LOW: u32 = 0;
pub const SPI_POLARITY_HIGH: u32 = 2;
pub const SPI_PHASE_1EDGE: u32 = 0;
pub const SPI_PHASE_2EDGE: u32 = 1;
pub const SPI_NSS_SOFT: u32 = 512;
pub const SPI_NSS_HARD_INPUT: u32 = 0;
pub const SPI_NSS_HARD_OUTPUT: u32 = 262144;
pub const SPI_NSS_PULSE_ENABLE: u32 = 8;
pub const SPI_NSS_PULSE_DISABLE: u32 = 0;
pub const SPI_BAUDRATEPRESCALER_2: u32 = 0;
pub const SPI_BAUDRATEPRESCALER_4: u32 = 8;
pub const SPI_BAUDRATEPRESCALER_8: u32 = 16;
pub const SPI_BAUDRATEPRESCALER_16: u32 = 24;
pub const SPI_BAUDRATEPRESCALER_32: u32 = 32;
pub const SPI_BAUDRATEPRESCALER_64: u32 = 40;
pub const SPI_BAUDRATEPRESCALER_128: u32 = 48;
pub const SPI_BAUDRATEPRESCALER_256: u32 = 56;
pub const SPI_FIRSTBIT_MSB: u32 = 0;
pub const SPI_FIRSTBIT_LSB: u32 = 128;
pub const SPI_TIMODE_DISABLE: u32 = 0;
pub const SPI_TIMODE_ENABLE: u32 = 16;
pub const SPI_CRCCALCULATION_DISABLE: u32 = 0;
pub const SPI_CRCCALCULATION_ENABLE: u32 = 8192;
pub const SPI_CRC_LENGTH_DATASIZE: u32 = 0;
pub const SPI_CRC_LENGTH_8BIT: u32 = 1;
pub const SPI_CRC_LENGTH_16BIT: u32 = 2;
pub const SPI_RXFIFO_THRESHOLD: u32 = 4096;
pub const SPI_RXFIFO_THRESHOLD_QF: u32 = 4096;
pub const SPI_RXFIFO_THRESHOLD_HF: u32 = 0;
pub const SPI_IT_TXE: u32 = 128;
pub const SPI_IT_RXNE: u32 = 64;
pub const SPI_IT_ERR: u32 = 32;
pub const SPI_FLAG_RXNE: u32 = 1;
pub const SPI_FLAG_TXE: u32 = 2;
pub const SPI_FLAG_BSY: u32 = 128;
pub const SPI_FLAG_CRCERR: u32 = 16;
pub const SPI_FLAG_MODF: u32 = 32;
pub const SPI_FLAG_OVR: u32 = 64;
pub const SPI_FLAG_FRE: u32 = 256;
pub const SPI_FLAG_FTLVL: u32 = 6144;
pub const SPI_FLAG_FRLVL: u32 = 1536;
pub const SPI_FLAG_MASK: u32 = 8179;
pub const SPI_FTLVL_EMPTY: u32 = 0;
pub const SPI_FTLVL_QUARTER_FULL: u32 = 2048;
pub const SPI_FTLVL_HALF_FULL: u32 = 4096;
pub const SPI_FTLVL_FULL: u32 = 6144;
pub const SPI_FRLVL_EMPTY: u32 = 0;
pub const SPI_FRLVL_QUARTER_FULL: u32 = 512;
pub const SPI_FRLVL_HALF_FULL: u32 = 1024;
pub const SPI_FRLVL_FULL: u32 = 1536;
pub const SWPMI_VOLTAGE_CLASS_B: u32 = 2;
pub const SWPMI_TX_MULTI_SOFTWAREBUFFER: u32 = 8;
pub const SWPMI_RX_MULTI_SOFTWAREBUFFER: u32 = 4;
pub const SWPMI_FLAG_RXBFF: u32 = 1;
pub const SWPMI_FLAG_TXBEF: u32 = 2;
pub const SWPMI_FLAG_RXBERF: u32 = 4;
pub const SWPMI_FLAG_RXOVRF: u32 = 8;
pub const SWPMI_FLAG_TXUNRF: u32 = 16;
pub const SWPMI_FLAG_RXNE: u32 = 32;
pub const SWPMI_FLAG_TXE: u32 = 64;
pub const SWPMI_FLAG_TCF: u32 = 128;
pub const SWPMI_FLAG_SRF: u32 = 256;
pub const SWPMI_FLAG_SUSP: u32 = 512;
pub const SWPMI_FLAG_DEACTF: u32 = 1024;
pub const SWPMI_IT_SRIE: u32 = 256;
pub const SWPMI_IT_TCIE: u32 = 128;
pub const SWPMI_IT_TIE: u32 = 64;
pub const SWPMI_IT_RIE: u32 = 32;
pub const SWPMI_IT_TXUNRIE: u32 = 16;
pub const SWPMI_IT_RXOVRIE: u32 = 8;
pub const SWPMI_IT_RXBERIE: u32 = 4;
pub const SWPMI_IT_TXBEIE: u32 = 2;
pub const SWPMI_IT_RXBFIE: u32 = 1;
pub const TIM_CLEARINPUTSOURCE_NONE: u32 = 0;
pub const TIM_CLEARINPUTSOURCE_ETR: u32 = 1;
pub const TIM_CLEARINPUTSOURCE_OCREFCLR: u32 = 2;
pub const TIM_DMABASE_CR1: u32 = 0;
pub const TIM_DMABASE_CR2: u32 = 1;
pub const TIM_DMABASE_SMCR: u32 = 2;
pub const TIM_DMABASE_DIER: u32 = 3;
pub const TIM_DMABASE_SR: u32 = 4;
pub const TIM_DMABASE_EGR: u32 = 5;
pub const TIM_DMABASE_CCMR1: u32 = 6;
pub const TIM_DMABASE_CCMR2: u32 = 7;
pub const TIM_DMABASE_CCER: u32 = 8;
pub const TIM_DMABASE_CNT: u32 = 9;
pub const TIM_DMABASE_PSC: u32 = 10;
pub const TIM_DMABASE_ARR: u32 = 11;
pub const TIM_DMABASE_RCR: u32 = 12;
pub const TIM_DMABASE_CCR1: u32 = 13;
pub const TIM_DMABASE_CCR2: u32 = 14;
pub const TIM_DMABASE_CCR3: u32 = 15;
pub const TIM_DMABASE_CCR4: u32 = 16;
pub const TIM_DMABASE_BDTR: u32 = 17;
pub const TIM_DMABASE_DCR: u32 = 18;
pub const TIM_DMABASE_DMAR: u32 = 19;
pub const TIM_DMABASE_OR1: u32 = 20;
pub const TIM_DMABASE_CCMR3: u32 = 21;
pub const TIM_DMABASE_CCR5: u32 = 22;
pub const TIM_DMABASE_CCR6: u32 = 23;
pub const TIM_DMABASE_OR2: u32 = 24;
pub const TIM_DMABASE_OR3: u32 = 25;
pub const TIM_EVENTSOURCE_UPDATE: u32 = 1;
pub const TIM_EVENTSOURCE_CC1: u32 = 2;
pub const TIM_EVENTSOURCE_CC2: u32 = 4;
pub const TIM_EVENTSOURCE_CC3: u32 = 8;
pub const TIM_EVENTSOURCE_CC4: u32 = 16;
pub const TIM_EVENTSOURCE_COM: u32 = 32;
pub const TIM_EVENTSOURCE_TRIGGER: u32 = 64;
pub const TIM_EVENTSOURCE_BREAK: u32 = 128;
pub const TIM_EVENTSOURCE_BREAK2: u32 = 256;
pub const TIM_INPUTCHANNELPOLARITY_RISING: u32 = 0;
pub const TIM_INPUTCHANNELPOLARITY_FALLING: u32 = 2;
pub const TIM_INPUTCHANNELPOLARITY_BOTHEDGE: u32 = 10;
pub const TIM_ETRPOLARITY_INVERTED: u32 = 32768;
pub const TIM_ETRPOLARITY_NONINVERTED: u32 = 0;
pub const TIM_ETRPRESCALER_DIV1: u32 = 0;
pub const TIM_ETRPRESCALER_DIV2: u32 = 4096;
pub const TIM_ETRPRESCALER_DIV4: u32 = 8192;
pub const TIM_ETRPRESCALER_DIV8: u32 = 12288;
pub const TIM_COUNTERMODE_UP: u32 = 0;
pub const TIM_COUNTERMODE_DOWN: u32 = 16;
pub const TIM_COUNTERMODE_CENTERALIGNED1: u32 = 32;
pub const TIM_COUNTERMODE_CENTERALIGNED2: u32 = 64;
pub const TIM_COUNTERMODE_CENTERALIGNED3: u32 = 96;
pub const TIM_UIFREMAP_DISABLE: u32 = 0;
pub const TIM_UIFREMAP_ENABLE: u32 = 2048;
pub const TIM_CLOCKDIVISION_DIV1: u32 = 0;
pub const TIM_CLOCKDIVISION_DIV2: u32 = 256;
pub const TIM_CLOCKDIVISION_DIV4: u32 = 512;
pub const TIM_OUTPUTSTATE_DISABLE: u32 = 0;
pub const TIM_OUTPUTSTATE_ENABLE: u32 = 1;
pub const TIM_AUTORELOAD_PRELOAD_DISABLE: u32 = 0;
pub const TIM_AUTORELOAD_PRELOAD_ENABLE: u32 = 128;
pub const TIM_OCFAST_DISABLE: u32 = 0;
pub const TIM_OCFAST_ENABLE: u32 = 4;
pub const TIM_OUTPUTNSTATE_DISABLE: u32 = 0;
pub const TIM_OUTPUTNSTATE_ENABLE: u32 = 4;
pub const TIM_OCPOLARITY_HIGH: u32 = 0;
pub const TIM_OCPOLARITY_LOW: u32 = 2;
pub const TIM_OCNPOLARITY_HIGH: u32 = 0;
pub const TIM_OCNPOLARITY_LOW: u32 = 8;
pub const TIM_OCIDLESTATE_SET: u32 = 256;
pub const TIM_OCIDLESTATE_RESET: u32 = 0;
pub const TIM_OCNIDLESTATE_SET: u32 = 512;
pub const TIM_OCNIDLESTATE_RESET: u32 = 0;
pub const TIM_ICPOLARITY_RISING: u32 = 0;
pub const TIM_ICPOLARITY_FALLING: u32 = 2;
pub const TIM_ICPOLARITY_BOTHEDGE: u32 = 10;
pub const TIM_ENCODERINPUTPOLARITY_RISING: u32 = 0;
pub const TIM_ENCODERINPUTPOLARITY_FALLING: u32 = 2;
pub const TIM_ICSELECTION_DIRECTTI: u32 = 1;
pub const TIM_ICSELECTION_INDIRECTTI: u32 = 2;
pub const TIM_ICSELECTION_TRC: u32 = 3;
pub const TIM_ICPSC_DIV1: u32 = 0;
pub const TIM_ICPSC_DIV2: u32 = 4;
pub const TIM_ICPSC_DIV4: u32 = 8;
pub const TIM_ICPSC_DIV8: u32 = 12;
pub const TIM_OPMODE_SINGLE: u32 = 8;
pub const TIM_OPMODE_REPETITIVE: u32 = 0;
pub const TIM_ENCODERMODE_TI1: u32 = 1;
pub const TIM_ENCODERMODE_TI2: u32 = 2;
pub const TIM_ENCODERMODE_TI12: u32 = 3;
pub const TIM_IT_UPDATE: u32 = 1;
pub const TIM_IT_CC1: u32 = 2;
pub const TIM_IT_CC2: u32 = 4;
pub const TIM_IT_CC3: u32 = 8;
pub const TIM_IT_CC4: u32 = 16;
pub const TIM_IT_COM: u32 = 32;
pub const TIM_IT_TRIGGER: u32 = 64;
pub const TIM_IT_BREAK: u32 = 128;
pub const TIM_COMMUTATION_TRGI: u32 = 4;
pub const TIM_COMMUTATION_SOFTWARE: u32 = 0;
pub const TIM_DMA_UPDATE: u32 = 256;
pub const TIM_DMA_CC1: u32 = 512;
pub const TIM_DMA_CC2: u32 = 1024;
pub const TIM_DMA_CC3: u32 = 2048;
pub const TIM_DMA_CC4: u32 = 4096;
pub const TIM_DMA_COM: u32 = 8192;
pub const TIM_DMA_TRIGGER: u32 = 16384;
pub const TIM_FLAG_UPDATE: u32 = 1;
pub const TIM_FLAG_CC1: u32 = 2;
pub const TIM_FLAG_CC2: u32 = 4;
pub const TIM_FLAG_CC3: u32 = 8;
pub const TIM_FLAG_CC4: u32 = 16;
pub const TIM_FLAG_CC5: u32 = 65536;
pub const TIM_FLAG_CC6: u32 = 131072;
pub const TIM_FLAG_COM: u32 = 32;
pub const TIM_FLAG_TRIGGER: u32 = 64;
pub const TIM_FLAG_BREAK: u32 = 128;
pub const TIM_FLAG_BREAK2: u32 = 256;
pub const TIM_FLAG_SYSTEM_BREAK: u32 = 8192;
pub const TIM_FLAG_CC1OF: u32 = 512;
pub const TIM_FLAG_CC2OF: u32 = 1024;
pub const TIM_FLAG_CC3OF: u32 = 2048;
pub const TIM_FLAG_CC4OF: u32 = 4096;
pub const TIM_CHANNEL_1: u32 = 0;
pub const TIM_CHANNEL_2: u32 = 4;
pub const TIM_CHANNEL_3: u32 = 8;
pub const TIM_CHANNEL_4: u32 = 12;
pub const TIM_CHANNEL_5: u32 = 16;
pub const TIM_CHANNEL_6: u32 = 20;
pub const TIM_CHANNEL_ALL: u32 = 60;
pub const TIM_CLOCKSOURCE_ETRMODE2: u32 = 8192;
pub const TIM_CLOCKSOURCE_INTERNAL: u32 = 4096;
pub const TIM_CLOCKPOLARITY_INVERTED: u32 = 32768;
pub const TIM_CLOCKPOLARITY_NONINVERTED: u32 = 0;
pub const TIM_CLOCKPOLARITY_RISING: u32 = 0;
pub const TIM_CLOCKPOLARITY_FALLING: u32 = 2;
pub const TIM_CLOCKPOLARITY_BOTHEDGE: u32 = 10;
pub const TIM_CLOCKPRESCALER_DIV1: u32 = 0;
pub const TIM_CLOCKPRESCALER_DIV2: u32 = 4096;
pub const TIM_CLOCKPRESCALER_DIV4: u32 = 8192;
pub const TIM_CLOCKPRESCALER_DIV8: u32 = 12288;
pub const TIM_CLEARINPUTPOLARITY_INVERTED: u32 = 32768;
pub const TIM_CLEARINPUTPOLARITY_NONINVERTED: u32 = 0;
pub const TIM_CLEARINPUTPRESCALER_DIV1: u32 = 0;
pub const TIM_CLEARINPUTPRESCALER_DIV2: u32 = 4096;
pub const TIM_CLEARINPUTPRESCALER_DIV4: u32 = 8192;
pub const TIM_CLEARINPUTPRESCALER_DIV8: u32 = 12288;
pub const TIM_OSSR_ENABLE: u32 = 2048;
pub const TIM_OSSR_DISABLE: u32 = 0;
pub const TIM_OSSI_ENABLE: u32 = 1024;
pub const TIM_OSSI_DISABLE: u32 = 0;
pub const TIM_LOCKLEVEL_OFF: u32 = 0;
pub const TIM_LOCKLEVEL_1: u32 = 256;
pub const TIM_LOCKLEVEL_2: u32 = 512;
pub const TIM_LOCKLEVEL_3: u32 = 768;
pub const TIM_BREAK_ENABLE: u32 = 4096;
pub const TIM_BREAK_DISABLE: u32 = 0;
pub const TIM_BREAKPOLARITY_LOW: u32 = 0;
pub const TIM_BREAKPOLARITY_HIGH: u32 = 8192;
pub const TIM_BREAK2_DISABLE: u32 = 0;
pub const TIM_BREAK2_ENABLE: u32 = 16777216;
pub const TIM_BREAK2POLARITY_LOW: u32 = 0;
pub const TIM_BREAK2POLARITY_HIGH: u32 = 33554432;
pub const TIM_AUTOMATICOUTPUT_DISABLE: u32 = 0;
pub const TIM_AUTOMATICOUTPUT_ENABLE: u32 = 16384;
pub const TIM_GROUPCH5_NONE: u32 = 0;
pub const TIM_GROUPCH5_OC1REFC: u32 = 536870912;
pub const TIM_GROUPCH5_OC2REFC: u32 = 1073741824;
pub const TIM_GROUPCH5_OC3REFC: u32 = 2147483648;
pub const TIM_TRGO_RESET: u32 = 0;
pub const TIM_TRGO_ENABLE: u32 = 16;
pub const TIM_TRGO_UPDATE: u32 = 32;
pub const TIM_TRGO_OC1: u32 = 48;
pub const TIM_TRGO_OC1REF: u32 = 64;
pub const TIM_TRGO_OC2REF: u32 = 80;
pub const TIM_TRGO_OC3REF: u32 = 96;
pub const TIM_TRGO_OC4REF: u32 = 112;
pub const TIM_TRGO2_RESET: u32 = 0;
pub const TIM_TRGO2_ENABLE: u32 = 1048576;
pub const TIM_TRGO2_UPDATE: u32 = 2097152;
pub const TIM_TRGO2_OC1: u32 = 3145728;
pub const TIM_TRGO2_OC1REF: u32 = 4194304;
pub const TIM_TRGO2_OC2REF: u32 = 5242880;
pub const TIM_TRGO2_OC3REF: u32 = 6291456;
pub const TIM_TRGO2_OC4REF: u32 = 7340032;
pub const TIM_TRGO2_OC5REF: u32 = 8388608;
pub const TIM_TRGO2_OC6REF: u32 = 9437184;
pub const TIM_TRGO2_OC4REF_RISINGFALLING: u32 = 10485760;
pub const TIM_TRGO2_OC6REF_RISINGFALLING: u32 = 11534336;
pub const TIM_TRGO2_OC4REF_RISING_OC6REF_RISING: u32 = 12582912;
pub const TIM_TRGO2_OC4REF_RISING_OC6REF_FALLING: u32 = 13631488;
pub const TIM_TRGO2_OC5REF_RISING_OC6REF_RISING: u32 = 14680064;
pub const TIM_TRGO2_OC5REF_RISING_OC6REF_FALLING: u32 = 15728640;
pub const TIM_MASTERSLAVEMODE_ENABLE: u32 = 128;
pub const TIM_MASTERSLAVEMODE_DISABLE: u32 = 0;
pub const TIM_SLAVEMODE_DISABLE: u32 = 0;
pub const TIM_SLAVEMODE_RESET: u32 = 4;
pub const TIM_SLAVEMODE_GATED: u32 = 5;
pub const TIM_SLAVEMODE_TRIGGER: u32 = 6;
pub const TIM_SLAVEMODE_EXTERNAL1: u32 = 7;
pub const TIM_SLAVEMODE_COMBINED_RESETTRIGGER: u32 = 65536;
pub const TIM_OCMODE_TIMING: u32 = 0;
pub const TIM_OCMODE_ACTIVE: u32 = 16;
pub const TIM_OCMODE_INACTIVE: u32 = 32;
pub const TIM_OCMODE_TOGGLE: u32 = 48;
pub const TIM_OCMODE_PWM1: u32 = 96;
pub const TIM_OCMODE_PWM2: u32 = 112;
pub const TIM_OCMODE_FORCED_ACTIVE: u32 = 80;
pub const TIM_OCMODE_FORCED_INACTIVE: u32 = 64;
pub const TIM_OCMODE_RETRIGERRABLE_OPM1: u32 = 65536;
pub const TIM_OCMODE_RETRIGERRABLE_OPM2: u32 = 65552;
pub const TIM_OCMODE_COMBINED_PWM1: u32 = 65600;
pub const TIM_OCMODE_COMBINED_PWM2: u32 = 65616;
pub const TIM_OCMODE_ASSYMETRIC_PWM1: u32 = 65632;
pub const TIM_OCMODE_ASSYMETRIC_PWM2: u32 = 65648;
pub const TIM_TS_ITR0: u32 = 0;
pub const TIM_TS_ITR1: u32 = 16;
pub const TIM_TS_ITR2: u32 = 32;
pub const TIM_TS_ITR3: u32 = 48;
pub const TIM_TS_TI1F_ED: u32 = 64;
pub const TIM_TS_TI1FP1: u32 = 80;
pub const TIM_TS_TI2FP2: u32 = 96;
pub const TIM_TS_ETRF: u32 = 112;
pub const TIM_TS_NONE: u32 = 65535;
pub const TIM_TRIGGERPOLARITY_INVERTED: u32 = 32768;
pub const TIM_TRIGGERPOLARITY_NONINVERTED: u32 = 0;
pub const TIM_TRIGGERPOLARITY_RISING: u32 = 0;
pub const TIM_TRIGGERPOLARITY_FALLING: u32 = 2;
pub const TIM_TRIGGERPOLARITY_BOTHEDGE: u32 = 10;
pub const TIM_TRIGGERPRESCALER_DIV1: u32 = 0;
pub const TIM_TRIGGERPRESCALER_DIV2: u32 = 4096;
pub const TIM_TRIGGERPRESCALER_DIV4: u32 = 8192;
pub const TIM_TRIGGERPRESCALER_DIV8: u32 = 12288;
pub const TIM_TI1SELECTION_CH1: u32 = 0;
pub const TIM_TI1SELECTION_XORCOMBINATION: u32 = 128;
pub const TIM_DMABURSTLENGTH_1TRANSFER: u32 = 0;
pub const TIM_DMABURSTLENGTH_2TRANSFERS: u32 = 256;
pub const TIM_DMABURSTLENGTH_3TRANSFERS: u32 = 512;
pub const TIM_DMABURSTLENGTH_4TRANSFERS: u32 = 768;
pub const TIM_DMABURSTLENGTH_5TRANSFERS: u32 = 1024;
pub const TIM_DMABURSTLENGTH_6TRANSFERS: u32 = 1280;
pub const TIM_DMABURSTLENGTH_7TRANSFERS: u32 = 1536;
pub const TIM_DMABURSTLENGTH_8TRANSFERS: u32 = 1792;
pub const TIM_DMABURSTLENGTH_9TRANSFERS: u32 = 2048;
pub const TIM_DMABURSTLENGTH_10TRANSFERS: u32 = 2304;
pub const TIM_DMABURSTLENGTH_11TRANSFERS: u32 = 2560;
pub const TIM_DMABURSTLENGTH_12TRANSFERS: u32 = 2816;
pub const TIM_DMABURSTLENGTH_13TRANSFERS: u32 = 3072;
pub const TIM_DMABURSTLENGTH_14TRANSFERS: u32 = 3328;
pub const TIM_DMABURSTLENGTH_15TRANSFERS: u32 = 3584;
pub const TIM_DMABURSTLENGTH_16TRANSFERS: u32 = 3840;
pub const TIM_DMABURSTLENGTH_17TRANSFERS: u32 = 4096;
pub const TIM_DMABURSTLENGTH_18TRANSFERS: u32 = 4352;
pub const TIM_CCx_ENABLE: u32 = 1;
pub const TIM_CCx_DISABLE: u32 = 0;
pub const TIM_CCxN_ENABLE: u32 = 4;
pub const TIM_CCxN_DISABLE: u32 = 0;
pub const TIM_BREAK_SYSTEM_ECC: u32 = 8;
pub const TIM_BREAK_SYSTEM_PVD: u32 = 4;
pub const TIM_BREAK_SYSTEM_SRAM2_PARITY_ERROR: u32 = 2;
pub const TIM_BREAK_SYSTEM_LOCKUP: u32 = 1;
pub const TIM_TIM1_ETR_ADC1_NONE: u32 = 0;
pub const TIM_TIM1_ETR_ADC1_AWD1: u32 = 1;
pub const TIM_TIM1_ETR_ADC1_AWD2: u32 = 2;
pub const TIM_TIM1_ETR_ADC1_AWD3: u32 = 3;
pub const TIM_TIM1_ETR_ADC3_NONE: u32 = 0;
pub const TIM_TIM1_ETR_ADC3_AWD1: u32 = 4;
pub const TIM_TIM1_ETR_ADC3_AWD2: u32 = 8;
pub const TIM_TIM1_ETR_ADC3_AWD3: u32 = 12;
pub const TIM_TIM1_TI1_GPIO: u32 = 0;
pub const TIM_TIM1_TI1_COMP1: u32 = 16;
pub const TIM_TIM1_ETR_GPIO: u32 = 0;
pub const TIM_TIM1_ETR_COMP1: u32 = 16384;
pub const TIM_TIM1_ETR_COMP2: u32 = 32768;
pub const TIM_TIM2_ITR1_TIM8_TRGO: u32 = 0;
pub const TIM_TIM2_ITR1_OTG_FS_SOF: u32 = 1;
pub const TIM_TIM2_ETR_GPIO: u32 = 0;
pub const TIM_TIM2_ETR_LSE: u32 = 2;
pub const TIM_TIM2_ETR_COMP1: u32 = 16384;
pub const TIM_TIM2_ETR_COMP2: u32 = 32768;
pub const TIM_TIM2_TI4_GPIO: u32 = 0;
pub const TIM_TIM2_TI4_COMP1: u32 = 4;
pub const TIM_TIM2_TI4_COMP2: u32 = 8;
pub const TIM_TIM2_TI4_COMP1_COMP2: u32 = 12;
pub const TIM_TIM3_TI1_GPIO: u32 = 0;
pub const TIM_TIM3_TI1_COMP1: u32 = 1;
pub const TIM_TIM3_TI1_COMP2: u32 = 2;
pub const TIM_TIM3_TI1_COMP1_COMP2: u32 = 3;
pub const TIM_TIM3_ETR_GPIO: u32 = 0;
pub const TIM_TIM3_ETR_COMP1: u32 = 16384;
pub const TIM_TIM8_ETR_ADC2_NONE: u32 = 0;
pub const TIM_TIM8_ETR_ADC2_AWD1: u32 = 1;
pub const TIM_TIM8_ETR_ADC2_AWD2: u32 = 2;
pub const TIM_TIM8_ETR_ADC2_AWD3: u32 = 3;
pub const TIM_TIM8_ETR_ADC3_NONE: u32 = 0;
pub const TIM_TIM8_ETR_ADC3_AWD1: u32 = 4;
pub const TIM_TIM8_ETR_ADC3_AWD2: u32 = 8;
pub const TIM_TIM8_ETR_ADC3_AWD3: u32 = 12;
pub const TIM_TIM8_TI1_GPIO: u32 = 0;
pub const TIM_TIM8_TI1_COMP2: u32 = 16;
pub const TIM_TIM8_ETR_GPIO: u32 = 0;
pub const TIM_TIM8_ETR_COMP1: u32 = 16384;
pub const TIM_TIM8_ETR_COMP2: u32 = 32768;
pub const TIM_TIM15_TI1_GPIO: u32 = 0;
pub const TIM_TIM15_TI1_LSE: u32 = 1;
pub const TIM_TIM15_ENCODERMODE_NONE: u32 = 0;
pub const TIM_TIM15_ENCODERMODE_TIM2: u32 = 2;
pub const TIM_TIM15_ENCODERMODE_TIM3: u32 = 4;
pub const TIM_TIM15_ENCODERMODE_TIM4: u32 = 6;
pub const TIM_TIM16_TI1_GPIO: u32 = 0;
pub const TIM_TIM16_TI1_LSI: u32 = 1;
pub const TIM_TIM16_TI1_LSE: u32 = 2;
pub const TIM_TIM16_TI1_RTC: u32 = 3;
pub const TIM_TIM17_TI1_GPIO: u32 = 0;
pub const TIM_TIM17_TI1_MSI: u32 = 1;
pub const TIM_TIM17_TI1_HSE_32: u32 = 2;
pub const TIM_TIM17_TI1_MCO: u32 = 3;
pub const TIM_BREAKINPUT_BRK: u32 = 1;
pub const TIM_BREAKINPUT_BRK2: u32 = 2;
pub const TIM_BREAKINPUTSOURCE_BKIN: u32 = 1;
pub const TIM_BREAKINPUTSOURCE_COMP1: u32 = 2;
pub const TIM_BREAKINPUTSOURCE_COMP2: u32 = 4;
pub const TIM_BREAKINPUTSOURCE_DFSDM1: u32 = 8;
pub const TIM_BREAKINPUTSOURCE_DISABLE: u32 = 0;
pub const TIM_BREAKINPUTSOURCE_ENABLE: u32 = 1;
pub const TIM_BREAKINPUTSOURCE_POLARITY_LOW: u32 = 1;
pub const TIM_BREAKINPUTSOURCE_POLARITY_HIGH: u32 = 0;
pub const HAL_TSC_ERROR_NONE: u32 = 0;
pub const TSC_CTPH_1CYCLE: u32 = 0;
pub const TSC_CTPH_2CYCLES: u32 = 268435456;
pub const TSC_CTPH_3CYCLES: u32 = 536870912;
pub const TSC_CTPH_4CYCLES: u32 = 805306368;
pub const TSC_CTPH_5CYCLES: u32 = 1073741824;
pub const TSC_CTPH_6CYCLES: u32 = 1342177280;
pub const TSC_CTPH_7CYCLES: u32 = 1610612736;
pub const TSC_CTPH_8CYCLES: u32 = 1879048192;
pub const TSC_CTPH_9CYCLES: u32 = 2147483648;
pub const TSC_CTPH_10CYCLES: u32 = 2415919104;
pub const TSC_CTPH_11CYCLES: u32 = 2684354560;
pub const TSC_CTPH_12CYCLES: u32 = 2952790016;
pub const TSC_CTPH_13CYCLES: u32 = 3221225472;
pub const TSC_CTPH_14CYCLES: u32 = 3489660928;
pub const TSC_CTPH_15CYCLES: u32 = 3758096384;
pub const TSC_CTPH_16CYCLES: u32 = 4026531840;
pub const TSC_CTPL_1CYCLE: u32 = 0;
pub const TSC_CTPL_2CYCLES: u32 = 16777216;
pub const TSC_CTPL_3CYCLES: u32 = 33554432;
pub const TSC_CTPL_4CYCLES: u32 = 50331648;
pub const TSC_CTPL_5CYCLES: u32 = 67108864;
pub const TSC_CTPL_6CYCLES: u32 = 83886080;
pub const TSC_CTPL_7CYCLES: u32 = 100663296;
pub const TSC_CTPL_8CYCLES: u32 = 117440512;
pub const TSC_CTPL_9CYCLES: u32 = 134217728;
pub const TSC_CTPL_10CYCLES: u32 = 150994944;
pub const TSC_CTPL_11CYCLES: u32 = 167772160;
pub const TSC_CTPL_12CYCLES: u32 = 184549376;
pub const TSC_CTPL_13CYCLES: u32 = 201326592;
pub const TSC_CTPL_14CYCLES: u32 = 218103808;
pub const TSC_CTPL_15CYCLES: u32 = 234881024;
pub const TSC_CTPL_16CYCLES: u32 = 251658240;
pub const TSC_SS_PRESC_DIV1: u32 = 0;
pub const TSC_SS_PRESC_DIV2: u32 = 32768;
pub const TSC_PG_PRESC_DIV1: u32 = 0;
pub const TSC_PG_PRESC_DIV2: u32 = 4096;
pub const TSC_PG_PRESC_DIV4: u32 = 8192;
pub const TSC_PG_PRESC_DIV8: u32 = 12288;
pub const TSC_PG_PRESC_DIV16: u32 = 16384;
pub const TSC_PG_PRESC_DIV32: u32 = 20480;
pub const TSC_PG_PRESC_DIV64: u32 = 24576;
pub const TSC_PG_PRESC_DIV128: u32 = 28672;
pub const TSC_MCV_255: u32 = 0;
pub const TSC_MCV_511: u32 = 32;
pub const TSC_MCV_1023: u32 = 64;
pub const TSC_MCV_2047: u32 = 96;
pub const TSC_MCV_4095: u32 = 128;
pub const TSC_MCV_8191: u32 = 160;
pub const TSC_MCV_16383: u32 = 192;
pub const TSC_IODEF_OUT_PP_LOW: u32 = 0;
pub const TSC_IODEF_IN_FLOAT: u32 = 16;
pub const TSC_SYNC_POLARITY_FALLING: u32 = 0;
pub const TSC_SYNC_POLARITY_RISING: u32 = 8;
pub const TSC_ACQ_MODE_NORMAL: u32 = 0;
pub const TSC_ACQ_MODE_SYNCHRO: u32 = 4;
pub const TSC_IT_EOA: u32 = 1;
pub const TSC_IT_MCE: u32 = 2;
pub const TSC_FLAG_EOA: u32 = 1;
pub const TSC_FLAG_MCE: u32 = 2;
pub const TSC_GROUPX_NOT_SUPPORTED: u32 = 4278190080;
pub const TSC_GROUP1_IO1: u32 = 1;
pub const TSC_GROUP1_IO2: u32 = 2;
pub const TSC_GROUP1_IO3: u32 = 4;
pub const TSC_GROUP1_IO4: u32 = 8;
pub const TSC_GROUP2_IO1: u32 = 16;
pub const TSC_GROUP2_IO2: u32 = 32;
pub const TSC_GROUP2_IO3: u32 = 64;
pub const TSC_GROUP2_IO4: u32 = 128;
pub const TSC_GROUP3_IO1: u32 = 256;
pub const TSC_GROUP3_IO2: u32 = 512;
pub const TSC_GROUP3_IO3: u32 = 1024;
pub const TSC_GROUP3_IO4: u32 = 2048;
pub const TSC_GROUP4_IO1: u32 = 4096;
pub const TSC_GROUP4_IO2: u32 = 8192;
pub const TSC_GROUP4_IO3: u32 = 16384;
pub const TSC_GROUP4_IO4: u32 = 32768;
pub const TSC_GROUP5_IO1: u32 = 65536;
pub const TSC_GROUP5_IO2: u32 = 131072;
pub const TSC_GROUP5_IO3: u32 = 262144;
pub const TSC_GROUP5_IO4: u32 = 524288;
pub const TSC_GROUP6_IO1: u32 = 1048576;
pub const TSC_GROUP6_IO2: u32 = 2097152;
pub const TSC_GROUP6_IO3: u32 = 4194304;
pub const TSC_GROUP6_IO4: u32 = 8388608;
pub const TSC_GROUP7_IO1: u32 = 16777216;
pub const TSC_GROUP7_IO2: u32 = 33554432;
pub const TSC_GROUP7_IO3: u32 = 67108864;
pub const TSC_GROUP7_IO4: u32 = 134217728;
pub const TSC_GROUP8_IO1: u32 = 268435456;
pub const TSC_GROUP8_IO2: u32 = 536870912;
pub const TSC_GROUP8_IO3: u32 = 1073741824;
pub const TSC_GROUP8_IO4: u32 = 2147483648;
pub const HAL_UART_STATE_RESET: u32 = 0;
pub const HAL_UART_STATE_READY: u32 = 32;
pub const HAL_UART_STATE_BUSY: u32 = 36;
pub const HAL_UART_STATE_BUSY_TX: u32 = 33;
pub const HAL_UART_STATE_BUSY_RX: u32 = 34;
pub const HAL_UART_STATE_BUSY_TX_RX: u32 = 35;
pub const HAL_UART_STATE_TIMEOUT: u32 = 160;
pub const HAL_UART_STATE_ERROR: u32 = 224;
pub const HAL_UART_ERROR_NONE: u32 = 0;
pub const HAL_UART_ERROR_PE: u32 = 1;
pub const HAL_UART_ERROR_NE: u32 = 2;
pub const HAL_UART_ERROR_FE: u32 = 4;
pub const HAL_UART_ERROR_ORE: u32 = 8;
pub const HAL_UART_ERROR_DMA: u32 = 16;
pub const HAL_UART_ERROR_RTO: u32 = 32;
pub const UART_STOPBITS_0_5: u32 = 4096;
pub const UART_STOPBITS_1: u32 = 0;
pub const UART_STOPBITS_1_5: u32 = 12288;
pub const UART_STOPBITS_2: u32 = 8192;
pub const UART_PARITY_NONE: u32 = 0;
pub const UART_PARITY_EVEN: u32 = 1024;
pub const UART_PARITY_ODD: u32 = 1536;
pub const UART_HWCONTROL_NONE: u32 = 0;
pub const UART_HWCONTROL_RTS: u32 = 256;
pub const UART_HWCONTROL_CTS: u32 = 512;
pub const UART_HWCONTROL_RTS_CTS: u32 = 768;
pub const UART_MODE_RX: u32 = 4;
pub const UART_MODE_TX: u32 = 8;
pub const UART_MODE_TX_RX: u32 = 12;
pub const UART_STATE_DISABLE: u32 = 0;
pub const UART_STATE_ENABLE: u32 = 1;
pub const UART_OVERSAMPLING_16: u32 = 0;
pub const UART_OVERSAMPLING_8: u32 = 32768;
pub const UART_ONE_BIT_SAMPLE_DISABLE: u32 = 0;
pub const UART_ONE_BIT_SAMPLE_ENABLE: u32 = 2048;
pub const UART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBIT: u32 = 0;
pub const UART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGE: u32 = 2097152;
pub const UART_ADVFEATURE_AUTOBAUDRATE_ON0X7FFRAME: u32 = 4194304;
pub const UART_ADVFEATURE_AUTOBAUDRATE_ON0X55FRAME: u32 = 6291456;
pub const UART_RECEIVER_TIMEOUT_DISABLE: u32 = 0;
pub const UART_RECEIVER_TIMEOUT_ENABLE: u32 = 8388608;
pub const UART_LIN_DISABLE: u32 = 0;
pub const UART_LIN_ENABLE: u32 = 16384;
pub const UART_LINBREAKDETECTLENGTH_10B: u32 = 0;
pub const UART_LINBREAKDETECTLENGTH_11B: u32 = 32;
pub const UART_DMA_TX_DISABLE: u32 = 0;
pub const UART_DMA_TX_ENABLE: u32 = 128;
pub const UART_DMA_RX_DISABLE: u32 = 0;
pub const UART_DMA_RX_ENABLE: u32 = 64;
pub const UART_HALF_DUPLEX_DISABLE: u32 = 0;
pub const UART_HALF_DUPLEX_ENABLE: u32 = 8;
pub const UART_WAKEUPMETHOD_IDLELINE: u32 = 0;
pub const UART_WAKEUPMETHOD_ADDRESSMARK: u32 = 2048;
pub const UART_AUTOBAUD_REQUEST: u32 = 1;
pub const UART_SENDBREAK_REQUEST: u32 = 2;
pub const UART_MUTE_MODE_REQUEST: u32 = 4;
pub const UART_RXDATA_FLUSH_REQUEST: u32 = 8;
pub const UART_TXDATA_FLUSH_REQUEST: u32 = 16;
pub const UART_ADVFEATURE_NO_INIT: u32 = 0;
pub const UART_ADVFEATURE_TXINVERT_INIT: u32 = 1;
pub const UART_ADVFEATURE_RXINVERT_INIT: u32 = 2;
pub const UART_ADVFEATURE_DATAINVERT_INIT: u32 = 4;
pub const UART_ADVFEATURE_SWAP_INIT: u32 = 8;
pub const UART_ADVFEATURE_RXOVERRUNDISABLE_INIT: u32 = 16;
pub const UART_ADVFEATURE_DMADISABLEONERROR_INIT: u32 = 32;
pub const UART_ADVFEATURE_AUTOBAUDRATE_INIT: u32 = 64;
pub const UART_ADVFEATURE_MSBFIRST_INIT: u32 = 128;
pub const UART_ADVFEATURE_TXINV_DISABLE: u32 = 0;
pub const UART_ADVFEATURE_TXINV_ENABLE: u32 = 131072;
pub const UART_ADVFEATURE_RXINV_DISABLE: u32 = 0;
pub const UART_ADVFEATURE_RXINV_ENABLE: u32 = 65536;
pub const UART_ADVFEATURE_DATAINV_DISABLE: u32 = 0;
pub const UART_ADVFEATURE_DATAINV_ENABLE: u32 = 262144;
pub const UART_ADVFEATURE_SWAP_DISABLE: u32 = 0;
pub const UART_ADVFEATURE_SWAP_ENABLE: u32 = 32768;
pub const UART_ADVFEATURE_OVERRUN_ENABLE: u32 = 0;
pub const UART_ADVFEATURE_OVERRUN_DISABLE: u32 = 4096;
pub const UART_ADVFEATURE_AUTOBAUDRATE_DISABLE: u32 = 0;
pub const UART_ADVFEATURE_AUTOBAUDRATE_ENABLE: u32 = 1048576;
pub const UART_ADVFEATURE_DMA_ENABLEONRXERROR: u32 = 0;
pub const UART_ADVFEATURE_DMA_DISABLEONRXERROR: u32 = 8192;
pub const UART_ADVFEATURE_MSBFIRST_DISABLE: u32 = 0;
pub const UART_ADVFEATURE_MSBFIRST_ENABLE: u32 = 524288;
pub const UART_ADVFEATURE_STOPMODE_DISABLE: u32 = 0;
pub const UART_ADVFEATURE_STOPMODE_ENABLE: u32 = 2;
pub const UART_ADVFEATURE_MUTEMODE_DISABLE: u32 = 0;
pub const UART_ADVFEATURE_MUTEMODE_ENABLE: u32 = 8192;
pub const UART_CR2_ADDRESS_LSB_POS: u32 = 24;
pub const UART_WAKEUP_ON_ADDRESS: u32 = 0;
pub const UART_WAKEUP_ON_STARTBIT: u32 = 2097152;
pub const UART_WAKEUP_ON_READDATA_NONEMPTY: u32 = 3145728;
pub const UART_DE_POLARITY_HIGH: u32 = 0;
pub const UART_DE_POLARITY_LOW: u32 = 32768;
pub const UART_CR1_DEAT_ADDRESS_LSB_POS: u32 = 21;
pub const UART_CR1_DEDT_ADDRESS_LSB_POS: u32 = 16;
pub const UART_IT_MASK: u32 = 31;
pub const HAL_UART_TIMEOUT_VALUE: u32 = 33554431;
pub const UART_FLAG_REACK: u32 = 4194304;
pub const UART_FLAG_TEACK: u32 = 2097152;
pub const UART_FLAG_WUF: u32 = 1048576;
pub const UART_FLAG_RWU: u32 = 524288;
pub const UART_FLAG_SBKF: u32 = 262144;
pub const UART_FLAG_CMF: u32 = 131072;
pub const UART_FLAG_BUSY: u32 = 65536;
pub const UART_FLAG_ABRF: u32 = 32768;
pub const UART_FLAG_ABRE: u32 = 16384;
pub const UART_FLAG_RTOF: u32 = 2048;
pub const UART_FLAG_CTS: u32 = 1024;
pub const UART_FLAG_CTSIF: u32 = 512;
pub const UART_FLAG_LBDF: u32 = 256;
pub const UART_FLAG_TXE: u32 = 128;
pub const UART_FLAG_TC: u32 = 64;
pub const UART_FLAG_RXNE: u32 = 32;
pub const UART_FLAG_IDLE: u32 = 16;
pub const UART_FLAG_ORE: u32 = 8;
pub const UART_FLAG_NE: u32 = 4;
pub const UART_FLAG_FE: u32 = 2;
pub const UART_FLAG_PE: u32 = 1;
pub const UART_IT_PE: u32 = 40;
pub const UART_IT_TXE: u32 = 1831;
pub const UART_IT_TC: u32 = 1574;
pub const UART_IT_RXNE: u32 = 1317;
pub const UART_IT_IDLE: u32 = 1060;
pub const UART_IT_LBD: u32 = 2118;
pub const UART_IT_CTS: u32 = 2410;
pub const UART_IT_CM: u32 = 4398;
pub const UART_IT_WUF: u32 = 5238;
pub const UART_IT_RTO: u32 = 2874;
pub const UART_IT_ERR: u32 = 96;
pub const UART_IT_ORE: u32 = 768;
pub const UART_IT_NE: u32 = 512;
pub const UART_IT_FE: u32 = 256;
pub const UART_CLEAR_PEF: u32 = 1;
pub const UART_CLEAR_FEF: u32 = 2;
pub const UART_CLEAR_NEF: u32 = 4;
pub const UART_CLEAR_OREF: u32 = 8;
pub const UART_CLEAR_IDLEF: u32 = 16;
pub const UART_CLEAR_TCF: u32 = 64;
pub const UART_CLEAR_LBDF: u32 = 256;
pub const UART_CLEAR_CTSF: u32 = 512;
pub const UART_CLEAR_CMF: u32 = 131072;
pub const UART_CLEAR_WUF: u32 = 1048576;
pub const UART_CLEAR_RTOF: u32 = 2048;
pub const HAL_UART_RECEPTION_STANDARD: u32 = 0;
pub const HAL_UART_RECEPTION_TOIDLE: u32 = 1;
pub const HAL_UART_RECEPTION_TORTO: u32 = 2;
pub const HAL_UART_RECEPTION_TOCHARMATCH: u32 = 3;
pub const UART_WORDLENGTH_7B: u32 = 268435456;
pub const UART_WORDLENGTH_8B: u32 = 0;
pub const UART_WORDLENGTH_9B: u32 = 4096;
pub const UART_ADDRESS_DETECT_4B: u32 = 0;
pub const UART_ADDRESS_DETECT_7B: u32 = 16;
pub const USART_STOPBITS_0_5: u32 = 4096;
pub const USART_STOPBITS_1: u32 = 0;
pub const USART_STOPBITS_1_5: u32 = 12288;
pub const USART_STOPBITS_2: u32 = 8192;
pub const USART_PARITY_NONE: u32 = 0;
pub const USART_PARITY_EVEN: u32 = 1024;
pub const USART_PARITY_ODD: u32 = 1536;
pub const USART_MODE_RX: u32 = 4;
pub const USART_MODE_TX: u32 = 8;
pub const USART_MODE_TX_RX: u32 = 12;
pub const USART_OVERSAMPLING_16: u32 = 0;
pub const USART_OVERSAMPLING_8: u32 = 32768;
pub const USART_CLOCK_DISABLE: u32 = 0;
pub const USART_CLOCK_ENABLE: u32 = 2048;
pub const USART_POLARITY_LOW: u32 = 0;
pub const USART_POLARITY_HIGH: u32 = 1024;
pub const USART_PHASE_1EDGE: u32 = 0;
pub const USART_PHASE_2EDGE: u32 = 512;
pub const USART_LASTBIT_DISABLE: u32 = 0;
pub const USART_LASTBIT_ENABLE: u32 = 256;
pub const USART_RXDATA_FLUSH_REQUEST: u32 = 8;
pub const USART_TXDATA_FLUSH_REQUEST: u32 = 16;
pub const USART_FLAG_REACK: u32 = 4194304;
pub const USART_FLAG_TEACK: u32 = 2097152;
pub const USART_FLAG_BUSY: u32 = 65536;
pub const USART_FLAG_TXE: u32 = 128;
pub const USART_FLAG_TC: u32 = 64;
pub const USART_FLAG_RXNE: u32 = 32;
pub const USART_FLAG_IDLE: u32 = 16;
pub const USART_FLAG_ORE: u32 = 8;
pub const USART_FLAG_NE: u32 = 4;
pub const USART_FLAG_FE: u32 = 2;
pub const USART_FLAG_PE: u32 = 1;
pub const USART_IT_PE: u32 = 40;
pub const USART_IT_TXE: u32 = 1831;
pub const USART_IT_TC: u32 = 1574;
pub const USART_IT_RXNE: u32 = 1317;
pub const USART_IT_IDLE: u32 = 1060;
pub const USART_IT_ERR: u32 = 96;
pub const USART_IT_ORE: u32 = 768;
pub const USART_IT_NE: u32 = 512;
pub const USART_IT_FE: u32 = 256;
pub const USART_CLEAR_PEF: u32 = 1;
pub const USART_CLEAR_FEF: u32 = 2;
pub const USART_CLEAR_NEF: u32 = 4;
pub const USART_CLEAR_OREF: u32 = 8;
pub const USART_CLEAR_IDLEF: u32 = 16;
pub const USART_CLEAR_TCF: u32 = 64;
pub const USART_IT_MASK: u32 = 31;
pub const USART_CR_MASK: u32 = 224;
pub const USART_CR_POS: u32 = 5;
pub const USART_ISR_MASK: u32 = 7936;
pub const USART_ISR_POS: u32 = 8;
pub const USART_WORDLENGTH_8B: u32 = 0;
pub const WWDG_IT_EWI: u32 = 512;
pub const WWDG_FLAG_EWIF: u32 = 1;
pub const WWDG_PRESCALER_1: u32 = 0;
pub const WWDG_PRESCALER_2: u32 = 128;
pub const WWDG_PRESCALER_4: u32 = 256;
pub const WWDG_PRESCALER_8: u32 = 384;
pub const WWDG_EWI_DISABLE: u32 = 0;
pub const WWDG_EWI_ENABLE: u32 = 512;
pub const SYSCFG_BOOT_MAINFLASH: u32 = 0;
pub const SYSCFG_BOOT_SYSTEMFLASH: u32 = 1;
pub const SYSCFG_BOOT_FMC: u32 = 2;
pub const SYSCFG_BOOT_SRAM: u32 = 3;
pub const SYSCFG_BOOT_QUADSPI: u32 = 6;
pub const SYSCFG_IT_FPU_IOC: u32 = 67108864;
pub const SYSCFG_IT_FPU_DZC: u32 = 134217728;
pub const SYSCFG_IT_FPU_UFC: u32 = 268435456;
pub const SYSCFG_IT_FPU_OFC: u32 = 536870912;
pub const SYSCFG_IT_FPU_IDC: u32 = 1073741824;
pub const SYSCFG_IT_FPU_IXC: u32 = 2147483648;
pub const SYSCFG_SRAM2WRP_PAGE0: u32 = 1;
pub const SYSCFG_SRAM2WRP_PAGE1: u32 = 2;
pub const SYSCFG_SRAM2WRP_PAGE2: u32 = 4;
pub const SYSCFG_SRAM2WRP_PAGE3: u32 = 8;
pub const SYSCFG_SRAM2WRP_PAGE4: u32 = 16;
pub const SYSCFG_SRAM2WRP_PAGE5: u32 = 32;
pub const SYSCFG_SRAM2WRP_PAGE6: u32 = 64;
pub const SYSCFG_SRAM2WRP_PAGE7: u32 = 128;
pub const SYSCFG_SRAM2WRP_PAGE8: u32 = 256;
pub const SYSCFG_SRAM2WRP_PAGE9: u32 = 512;
pub const SYSCFG_SRAM2WRP_PAGE10: u32 = 1024;
pub const SYSCFG_SRAM2WRP_PAGE11: u32 = 2048;
pub const SYSCFG_SRAM2WRP_PAGE12: u32 = 4096;
pub const SYSCFG_SRAM2WRP_PAGE13: u32 = 8192;
pub const SYSCFG_SRAM2WRP_PAGE14: u32 = 16384;
pub const SYSCFG_SRAM2WRP_PAGE15: u32 = 32768;
pub const SYSCFG_SRAM2WRP_PAGE16: u32 = 65536;
pub const SYSCFG_SRAM2WRP_PAGE17: u32 = 131072;
pub const SYSCFG_SRAM2WRP_PAGE18: u32 = 262144;
pub const SYSCFG_SRAM2WRP_PAGE19: u32 = 524288;
pub const SYSCFG_SRAM2WRP_PAGE20: u32 = 1048576;
pub const SYSCFG_SRAM2WRP_PAGE21: u32 = 2097152;
pub const SYSCFG_SRAM2WRP_PAGE22: u32 = 4194304;
pub const SYSCFG_SRAM2WRP_PAGE23: u32 = 8388608;
pub const SYSCFG_SRAM2WRP_PAGE24: u32 = 16777216;
pub const SYSCFG_SRAM2WRP_PAGE25: u32 = 33554432;
pub const SYSCFG_SRAM2WRP_PAGE26: u32 = 67108864;
pub const SYSCFG_SRAM2WRP_PAGE27: u32 = 134217728;
pub const SYSCFG_SRAM2WRP_PAGE28: u32 = 268435456;
pub const SYSCFG_SRAM2WRP_PAGE29: u32 = 536870912;
pub const SYSCFG_SRAM2WRP_PAGE30: u32 = 1073741824;
pub const SYSCFG_SRAM2WRP_PAGE31: u32 = 2147483648;
pub const SYSCFG_VREFBUF_VOLTAGE_SCALE0: u32 = 0;
pub const SYSCFG_VREFBUF_VOLTAGE_SCALE1: u32 = 4;
pub const SYSCFG_VREFBUF_HIGH_IMPEDANCE_DISABLE: u32 = 0;
pub const SYSCFG_VREFBUF_HIGH_IMPEDANCE_ENABLE: u32 = 2;
pub const SYSCFG_FLAG_SRAM2_PE: u32 = 256;
pub const SYSCFG_FLAG_SRAM2_BUSY: u32 = 2;
pub const SYSCFG_FASTMODEPLUS_PB6: u32 = 65536;
pub const SYSCFG_FASTMODEPLUS_PB7: u32 = 131072;
pub const SYSCFG_FASTMODEPLUS_PB8: u32 = 262144;
pub const SYSCFG_FASTMODEPLUS_PB9: u32 = 524288;
#[doc = "< 2 Cortex-M4 Non Maskable Interrupt"]
pub const IRQn_Type_NonMaskableInt_IRQn: IRQn_Type = -14;
#[doc = "< 3 Cortex-M4 Hard Fault Interrupt"]
pub const IRQn_Type_HardFault_IRQn: IRQn_Type = -13;
#[doc = "< 4 Cortex-M4 Memory Management Interrupt"]
pub const IRQn_Type_MemoryManagement_IRQn: IRQn_Type = -12;
#[doc = "< 5 Cortex-M4 Bus Fault Interrupt"]
pub const IRQn_Type_BusFault_IRQn: IRQn_Type = -11;
#[doc = "< 6 Cortex-M4 Usage Fault Interrupt"]
pub const IRQn_Type_UsageFault_IRQn: IRQn_Type = -10;
#[doc = "< 11 Cortex-M4 SV Call Interrupt"]
pub const IRQn_Type_SVCall_IRQn: IRQn_Type = -5;
#[doc = "< 12 Cortex-M4 Debug Monitor Interrupt"]
pub const IRQn_Type_DebugMonitor_IRQn: IRQn_Type = -4;
#[doc = "< 14 Cortex-M4 Pend SV Interrupt"]
pub const IRQn_Type_PendSV_IRQn: IRQn_Type = -2;
#[doc = "< 15 Cortex-M4 System Tick Interrupt"]
pub const IRQn_Type_SysTick_IRQn: IRQn_Type = -1;
#[doc = "< Window WatchDog Interrupt"]
pub const IRQn_Type_WWDG_IRQn: IRQn_Type = 0;
#[doc = "< PVD/PVM1/PVM2/PVM3/PVM4 through EXTI Line detection Interrupts"]
pub const IRQn_Type_PVD_PVM_IRQn: IRQn_Type = 1;
#[doc = "< Tamper and TimeStamp interrupts through the EXTI line"]
pub const IRQn_Type_TAMP_STAMP_IRQn: IRQn_Type = 2;
#[doc = "< RTC Wakeup interrupt through the EXTI line"]
pub const IRQn_Type_RTC_WKUP_IRQn: IRQn_Type = 3;
#[doc = "< FLASH global Interrupt"]
pub const IRQn_Type_FLASH_IRQn: IRQn_Type = 4;
#[doc = "< RCC global Interrupt"]
pub const IRQn_Type_RCC_IRQn: IRQn_Type = 5;
#[doc = "< EXTI Line0 Interrupt"]
pub const IRQn_Type_EXTI0_IRQn: IRQn_Type = 6;
#[doc = "< EXTI Line1 Interrupt"]
pub const IRQn_Type_EXTI1_IRQn: IRQn_Type = 7;
#[doc = "< EXTI Line2 Interrupt"]
pub const IRQn_Type_EXTI2_IRQn: IRQn_Type = 8;
#[doc = "< EXTI Line3 Interrupt"]
pub const IRQn_Type_EXTI3_IRQn: IRQn_Type = 9;
#[doc = "< EXTI Line4 Interrupt"]
pub const IRQn_Type_EXTI4_IRQn: IRQn_Type = 10;
#[doc = "< DMA1 Channel 1 global Interrupt"]
pub const IRQn_Type_DMA1_Channel1_IRQn: IRQn_Type = 11;
#[doc = "< DMA1 Channel 2 global Interrupt"]
pub const IRQn_Type_DMA1_Channel2_IRQn: IRQn_Type = 12;
#[doc = "< DMA1 Channel 3 global Interrupt"]
pub const IRQn_Type_DMA1_Channel3_IRQn: IRQn_Type = 13;
#[doc = "< DMA1 Channel 4 global Interrupt"]
pub const IRQn_Type_DMA1_Channel4_IRQn: IRQn_Type = 14;
#[doc = "< DMA1 Channel 5 global Interrupt"]
pub const IRQn_Type_DMA1_Channel5_IRQn: IRQn_Type = 15;
#[doc = "< DMA1 Channel 6 global Interrupt"]
pub const IRQn_Type_DMA1_Channel6_IRQn: IRQn_Type = 16;
#[doc = "< DMA1 Channel 7 global Interrupt"]
pub const IRQn_Type_DMA1_Channel7_IRQn: IRQn_Type = 17;
#[doc = "< ADC1, ADC2 SAR global Interrupts"]
pub const IRQn_Type_ADC1_2_IRQn: IRQn_Type = 18;
#[doc = "< CAN1 TX Interrupt"]
pub const IRQn_Type_CAN1_TX_IRQn: IRQn_Type = 19;
#[doc = "< CAN1 RX0 Interrupt"]
pub const IRQn_Type_CAN1_RX0_IRQn: IRQn_Type = 20;
#[doc = "< CAN1 RX1 Interrupt"]
pub const IRQn_Type_CAN1_RX1_IRQn: IRQn_Type = 21;
#[doc = "< CAN1 SCE Interrupt"]
pub const IRQn_Type_CAN1_SCE_IRQn: IRQn_Type = 22;
#[doc = "< External Line[9:5] Interrupts"]
pub const IRQn_Type_EXTI9_5_IRQn: IRQn_Type = 23;
#[doc = "< TIM1 Break interrupt and TIM15 global interrupt"]
pub const IRQn_Type_TIM1_BRK_TIM15_IRQn: IRQn_Type = 24;
#[doc = "< TIM1 Update Interrupt and TIM16 global interrupt"]
pub const IRQn_Type_TIM1_UP_TIM16_IRQn: IRQn_Type = 25;
#[doc = "< TIM1 Trigger and Commutation Interrupt and TIM17 global interrupt"]
pub const IRQn_Type_TIM1_TRG_COM_TIM17_IRQn: IRQn_Type = 26;
#[doc = "< TIM1 Capture Compare Interrupt"]
pub const IRQn_Type_TIM1_CC_IRQn: IRQn_Type = 27;
#[doc = "< TIM2 global Interrupt"]
pub const IRQn_Type_TIM2_IRQn: IRQn_Type = 28;
#[doc = "< TIM3 global Interrupt"]
pub const IRQn_Type_TIM3_IRQn: IRQn_Type = 29;
#[doc = "< TIM4 global Interrupt"]
pub const IRQn_Type_TIM4_IRQn: IRQn_Type = 30;
#[doc = "< I2C1 Event Interrupt"]
pub const IRQn_Type_I2C1_EV_IRQn: IRQn_Type = 31;
#[doc = "< I2C1 Error Interrupt"]
pub const IRQn_Type_I2C1_ER_IRQn: IRQn_Type = 32;
#[doc = "< I2C2 Event Interrupt"]
pub const IRQn_Type_I2C2_EV_IRQn: IRQn_Type = 33;
#[doc = "< I2C2 Error Interrupt"]
pub const IRQn_Type_I2C2_ER_IRQn: IRQn_Type = 34;
#[doc = "< SPI1 global Interrupt"]
pub const IRQn_Type_SPI1_IRQn: IRQn_Type = 35;
#[doc = "< SPI2 global Interrupt"]
pub const IRQn_Type_SPI2_IRQn: IRQn_Type = 36;
#[doc = "< USART1 global Interrupt"]
pub const IRQn_Type_USART1_IRQn: IRQn_Type = 37;
#[doc = "< USART2 global Interrupt"]
pub const IRQn_Type_USART2_IRQn: IRQn_Type = 38;
#[doc = "< USART3 global Interrupt"]
pub const IRQn_Type_USART3_IRQn: IRQn_Type = 39;
#[doc = "< External Line[15:10] Interrupts"]
pub const IRQn_Type_EXTI15_10_IRQn: IRQn_Type = 40;
#[doc = "< RTC Alarm (A and B) through EXTI Line Interrupt"]
pub const IRQn_Type_RTC_Alarm_IRQn: IRQn_Type = 41;
#[doc = "< DFSDM1 Filter 3 global Interrupt"]
pub const IRQn_Type_DFSDM1_FLT3_IRQn: IRQn_Type = 42;
#[doc = "< TIM8 Break Interrupt"]
pub const IRQn_Type_TIM8_BRK_IRQn: IRQn_Type = 43;
#[doc = "< TIM8 Update Interrupt"]
pub const IRQn_Type_TIM8_UP_IRQn: IRQn_Type = 44;
#[doc = "< TIM8 Trigger and Commutation Interrupt"]
pub const IRQn_Type_TIM8_TRG_COM_IRQn: IRQn_Type = 45;
#[doc = "< TIM8 Capture Compare Interrupt"]
pub const IRQn_Type_TIM8_CC_IRQn: IRQn_Type = 46;
#[doc = "< ADC3 global  Interrupt"]
pub const IRQn_Type_ADC3_IRQn: IRQn_Type = 47;
#[doc = "< FMC global Interrupt"]
pub const IRQn_Type_FMC_IRQn: IRQn_Type = 48;
#[doc = "< SDMMC1 global Interrupt"]
pub const IRQn_Type_SDMMC1_IRQn: IRQn_Type = 49;
#[doc = "< TIM5 global Interrupt"]
pub const IRQn_Type_TIM5_IRQn: IRQn_Type = 50;
#[doc = "< SPI3 global Interrupt"]
pub const IRQn_Type_SPI3_IRQn: IRQn_Type = 51;
#[doc = "< UART4 global Interrupt"]
pub const IRQn_Type_UART4_IRQn: IRQn_Type = 52;
#[doc = "< UART5 global Interrupt"]
pub const IRQn_Type_UART5_IRQn: IRQn_Type = 53;
#[doc = "< TIM6 global and DAC1&2 underrun error  interrupts"]
pub const IRQn_Type_TIM6_DAC_IRQn: IRQn_Type = 54;
#[doc = "< TIM7 global interrupt"]
pub const IRQn_Type_TIM7_IRQn: IRQn_Type = 55;
#[doc = "< DMA2 Channel 1 global Interrupt"]
pub const IRQn_Type_DMA2_Channel1_IRQn: IRQn_Type = 56;
#[doc = "< DMA2 Channel 2 global Interrupt"]
pub const IRQn_Type_DMA2_Channel2_IRQn: IRQn_Type = 57;
#[doc = "< DMA2 Channel 3 global Interrupt"]
pub const IRQn_Type_DMA2_Channel3_IRQn: IRQn_Type = 58;
#[doc = "< DMA2 Channel 4 global Interrupt"]
pub const IRQn_Type_DMA2_Channel4_IRQn: IRQn_Type = 59;
#[doc = "< DMA2 Channel 5 global Interrupt"]
pub const IRQn_Type_DMA2_Channel5_IRQn: IRQn_Type = 60;
#[doc = "< DFSDM1 Filter 0 global Interrupt"]
pub const IRQn_Type_DFSDM1_FLT0_IRQn: IRQn_Type = 61;
#[doc = "< DFSDM1 Filter 1 global Interrupt"]
pub const IRQn_Type_DFSDM1_FLT1_IRQn: IRQn_Type = 62;
#[doc = "< DFSDM1 Filter 2 global Interrupt"]
pub const IRQn_Type_DFSDM1_FLT2_IRQn: IRQn_Type = 63;
#[doc = "< COMP1 and COMP2 Interrupts"]
pub const IRQn_Type_COMP_IRQn: IRQn_Type = 64;
#[doc = "< LP TIM1 interrupt"]
pub const IRQn_Type_LPTIM1_IRQn: IRQn_Type = 65;
#[doc = "< LP TIM2 interrupt"]
pub const IRQn_Type_LPTIM2_IRQn: IRQn_Type = 66;
#[doc = "< USB OTG FS global Interrupt"]
pub const IRQn_Type_OTG_FS_IRQn: IRQn_Type = 67;
#[doc = "< DMA2 Channel 6 global interrupt"]
pub const IRQn_Type_DMA2_Channel6_IRQn: IRQn_Type = 68;
#[doc = "< DMA2 Channel 7 global interrupt"]
pub const IRQn_Type_DMA2_Channel7_IRQn: IRQn_Type = 69;
#[doc = "< LP UART1 interrupt"]
pub const IRQn_Type_LPUART1_IRQn: IRQn_Type = 70;
#[doc = "< Quad SPI global interrupt"]
pub const IRQn_Type_QUADSPI_IRQn: IRQn_Type = 71;
#[doc = "< I2C3 event interrupt"]
pub const IRQn_Type_I2C3_EV_IRQn: IRQn_Type = 72;
#[doc = "< I2C3 error interrupt"]
pub const IRQn_Type_I2C3_ER_IRQn: IRQn_Type = 73;
#[doc = "< Serial Audio Interface 1 global interrupt"]
pub const IRQn_Type_SAI1_IRQn: IRQn_Type = 74;
#[doc = "< Serial Audio Interface 2 global interrupt"]
pub const IRQn_Type_SAI2_IRQn: IRQn_Type = 75;
#[doc = "< Serial Wire Interface 1 global interrupt"]
pub const IRQn_Type_SWPMI1_IRQn: IRQn_Type = 76;
#[doc = "< Touch Sense Controller global interrupt"]
pub const IRQn_Type_TSC_IRQn: IRQn_Type = 77;
#[doc = "< RNG global interrupt"]
pub const IRQn_Type_RNG_IRQn: IRQn_Type = 80;
#[doc = "< FPU global interrupt"]
pub const IRQn_Type_FPU_IRQn: IRQn_Type = 81;
#[doc = " @brief STM32L4XX Interrupt Number Definition, according to the selected device"]
#[doc = "        in @ref Library_configuration_section"]
pub type IRQn_Type = libc::c_int;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = libc::c_longlong;
pub type uintmax_t = libc::c_ulonglong;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct T_UINT32 {
    pub v: u32,
}
#[test]
fn bindgen_test_layout_T_UINT32() {
    assert_eq!(
        ::core::mem::size_of::<T_UINT32>(),
        4usize,
        concat!("Size of: ", stringify!(T_UINT32))
    );
    assert_eq!(
        ::core::mem::align_of::<T_UINT32>(),
        1usize,
        concat!("Alignment of ", stringify!(T_UINT32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<T_UINT32>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(T_UINT32),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct T_UINT16_WRITE {
    pub v: u16,
}
#[test]
fn bindgen_test_layout_T_UINT16_WRITE() {
    assert_eq!(
        ::core::mem::size_of::<T_UINT16_WRITE>(),
        2usize,
        concat!("Size of: ", stringify!(T_UINT16_WRITE))
    );
    assert_eq!(
        ::core::mem::align_of::<T_UINT16_WRITE>(),
        1usize,
        concat!("Alignment of ", stringify!(T_UINT16_WRITE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<T_UINT16_WRITE>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(T_UINT16_WRITE),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct T_UINT16_READ {
    pub v: u16,
}
#[test]
fn bindgen_test_layout_T_UINT16_READ() {
    assert_eq!(
        ::core::mem::size_of::<T_UINT16_READ>(),
        2usize,
        concat!("Size of: ", stringify!(T_UINT16_READ))
    );
    assert_eq!(
        ::core::mem::align_of::<T_UINT16_READ>(),
        1usize,
        concat!("Alignment of ", stringify!(T_UINT16_READ))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<T_UINT16_READ>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(T_UINT16_READ),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct T_UINT32_WRITE {
    pub v: u32,
}
#[test]
fn bindgen_test_layout_T_UINT32_WRITE() {
    assert_eq!(
        ::core::mem::size_of::<T_UINT32_WRITE>(),
        4usize,
        concat!("Size of: ", stringify!(T_UINT32_WRITE))
    );
    assert_eq!(
        ::core::mem::align_of::<T_UINT32_WRITE>(),
        1usize,
        concat!("Alignment of ", stringify!(T_UINT32_WRITE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<T_UINT32_WRITE>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(T_UINT32_WRITE),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct T_UINT32_READ {
    pub v: u32,
}
#[test]
fn bindgen_test_layout_T_UINT32_READ() {
    assert_eq!(
        ::core::mem::size_of::<T_UINT32_READ>(),
        4usize,
        concat!("Size of: ", stringify!(T_UINT32_READ))
    );
    assert_eq!(
        ::core::mem::align_of::<T_UINT32_READ>(),
        1usize,
        concat!("Alignment of ", stringify!(T_UINT32_READ))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<T_UINT32_READ>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(T_UINT32_READ),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union APSR_Type {
    pub b: APSR_Type__bindgen_ty_1,
    pub w: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct APSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_APSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<APSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(APSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<APSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(APSR_Type__bindgen_ty_1))
    );
}
impl APSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn GE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_GE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set__reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn Q(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Q(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _reserved0: u32,
        GE: u32,
        _reserved1: u32,
        Q: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let GE: u32 = unsafe { ::core::mem::transmute(GE) };
            GE as u64
        });
        __bindgen_bitfield_unit.set(20usize, 7u8, {
            let _reserved1: u32 = unsafe { ::core::mem::transmute(_reserved1) };
            _reserved1 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let Q: u32 = unsafe { ::core::mem::transmute(Q) };
            Q as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_APSR_Type() {
    assert_eq!(
        ::core::mem::size_of::<APSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(APSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<APSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(APSR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<APSR_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(APSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<APSR_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(APSR_Type),
            "::",
            stringify!(w)
        )
    );
}
impl Default for APSR_Type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IPSR_Type {
    pub b: IPSR_Type__bindgen_ty_1,
    pub w: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct IPSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_IPSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<IPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IPSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<IPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(IPSR_Type__bindgen_ty_1))
    );
}
impl IPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ISR: u32, _reserved0: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_IPSR_Type() {
    assert_eq!(
        ::core::mem::size_of::<IPSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(IPSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<IPSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(IPSR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IPSR_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IPSR_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPSR_Type),
            "::",
            stringify!(w)
        )
    );
}
impl Default for IPSR_Type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xPSR_Type {
    pub b: xPSR_Type__bindgen_ty_1,
    pub w: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct xPSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_xPSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<xPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(xPSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<xPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(xPSR_Type__bindgen_ty_1))
    );
}
impl xPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ICI_IT_1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_ICI_IT_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn GE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_GE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set__reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn T(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_T(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ICI_IT_2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ICI_IT_2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Q(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Q(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ISR: u32,
        _reserved0: u32,
        ICI_IT_1: u32,
        GE: u32,
        _reserved1: u32,
        T: u32,
        ICI_IT_2: u32,
        Q: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let ICI_IT_1: u32 = unsafe { ::core::mem::transmute(ICI_IT_1) };
            ICI_IT_1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let GE: u32 = unsafe { ::core::mem::transmute(GE) };
            GE as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let _reserved1: u32 = unsafe { ::core::mem::transmute(_reserved1) };
            _reserved1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let T: u32 = unsafe { ::core::mem::transmute(T) };
            T as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let ICI_IT_2: u32 = unsafe { ::core::mem::transmute(ICI_IT_2) };
            ICI_IT_2 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let Q: u32 = unsafe { ::core::mem::transmute(Q) };
            Q as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_xPSR_Type() {
    assert_eq!(
        ::core::mem::size_of::<xPSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(xPSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<xPSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(xPSR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xPSR_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xPSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xPSR_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xPSR_Type),
            "::",
            stringify!(w)
        )
    );
}
impl Default for xPSR_Type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CONTROL_Type {
    pub b: CONTROL_Type__bindgen_ty_1,
    pub w: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct CONTROL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_CONTROL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<CONTROL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(CONTROL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTROL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(CONTROL_Type__bindgen_ty_1))
    );
}
impl CONTROL_Type__bindgen_ty_1 {
    #[inline]
    pub fn nPRIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nPRIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SPSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FPCA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FPCA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nPRIV: u32,
        SPSEL: u32,
        FPCA: u32,
        _reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let nPRIV: u32 = unsafe { ::core::mem::transmute(nPRIV) };
            nPRIV as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SPSEL: u32 = unsafe { ::core::mem::transmute(SPSEL) };
            SPSEL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FPCA: u32 = unsafe { ::core::mem::transmute(FPCA) };
            FPCA as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CONTROL_Type() {
    assert_eq!(
        ::core::mem::size_of::<CONTROL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(CONTROL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTROL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(CONTROL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CONTROL_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTROL_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CONTROL_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTROL_Type),
            "::",
            stringify!(w)
        )
    );
}
impl Default for CONTROL_Type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NVIC_Type {
    pub ISER: [u32; 8usize],
    pub RESERVED0: [u32; 24usize],
    pub ICER: [u32; 8usize],
    pub RESERVED1: [u32; 24usize],
    pub ISPR: [u32; 8usize],
    pub RESERVED2: [u32; 24usize],
    pub ICPR: [u32; 8usize],
    pub RESERVED3: [u32; 24usize],
    pub IABR: [u32; 8usize],
    pub RESERVED4: [u32; 56usize],
    pub IP: [u8; 240usize],
    pub RESERVED5: [u32; 644usize],
    pub STIR: u32,
}
#[test]
fn bindgen_test_layout_NVIC_Type() {
    assert_eq!(
        ::core::mem::size_of::<NVIC_Type>(),
        3588usize,
        concat!("Size of: ", stringify!(NVIC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVIC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(NVIC_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ISER as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ISER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED0 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ICER as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ICER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED1 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ISPR as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ISPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED2 as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ICPR as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ICPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED3 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).IABR as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(IABR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED4 as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).IP as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(IP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED5 as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).STIR as *const _ as usize },
        3584usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(STIR)
        )
    );
}
impl Default for NVIC_Type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SCB_Type {
    pub CPUID: u32,
    pub ICSR: u32,
    pub VTOR: u32,
    pub AIRCR: u32,
    pub SCR: u32,
    pub CCR: u32,
    pub SHP: [u8; 12usize],
    pub SHCSR: u32,
    pub CFSR: u32,
    pub HFSR: u32,
    pub DFSR: u32,
    pub MMFAR: u32,
    pub BFAR: u32,
    pub AFSR: u32,
    pub PFR: [u32; 2usize],
    pub DFR: u32,
    pub ADR: u32,
    pub MMFR: [u32; 4usize],
    pub ISAR: [u32; 5usize],
    pub RESERVED0: [u32; 5usize],
    pub CPACR: u32,
}
#[test]
fn bindgen_test_layout_SCB_Type() {
    assert_eq!(
        ::core::mem::size_of::<SCB_Type>(),
        140usize,
        concat!("Size of: ", stringify!(SCB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SCB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SCB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).CPUID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CPUID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).ICSR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(ICSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).VTOR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(VTOR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).AIRCR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(AIRCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).SCR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).CCR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).SHP as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SHP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).SHCSR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SHCSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).CFSR as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CFSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).HFSR as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(HFSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).DFSR as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(DFSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).MMFAR as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(MMFAR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).BFAR as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(BFAR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).AFSR as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(AFSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).PFR as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(PFR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).DFR as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(DFR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).ADR as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(ADR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).MMFR as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(MMFR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).ISAR as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(ISAR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).RESERVED0 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).CPACR as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CPACR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SCnSCB_Type {
    pub RESERVED0: [u32; 1usize],
    pub ICTR: u32,
    pub ACTLR: u32,
}
#[test]
fn bindgen_test_layout_SCnSCB_Type() {
    assert_eq!(
        ::core::mem::size_of::<SCnSCB_Type>(),
        12usize,
        concat!("Size of: ", stringify!(SCnSCB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SCnSCB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SCnSCB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCnSCB_Type>())).RESERVED0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCnSCB_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCnSCB_Type>())).ICTR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SCnSCB_Type),
            "::",
            stringify!(ICTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCnSCB_Type>())).ACTLR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCnSCB_Type),
            "::",
            stringify!(ACTLR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SysTick_Type {
    pub CTRL: u32,
    pub LOAD: u32,
    pub VAL: u32,
    pub CALIB: u32,
}
#[test]
fn bindgen_test_layout_SysTick_Type() {
    assert_eq!(
        ::core::mem::size_of::<SysTick_Type>(),
        16usize,
        concat!("Size of: ", stringify!(SysTick_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SysTick_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SysTick_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).CTRL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).LOAD as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(LOAD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).VAL as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(VAL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).CALIB as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(CALIB)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ITM_Type {
    pub PORT: [ITM_Type__bindgen_ty_1; 32usize],
    pub RESERVED0: [u32; 864usize],
    pub TER: u32,
    pub RESERVED1: [u32; 15usize],
    pub TPR: u32,
    pub RESERVED2: [u32; 15usize],
    pub TCR: u32,
    pub RESERVED3: [u32; 32usize],
    pub RESERVED4: [u32; 43usize],
    pub LAR: u32,
    pub LSR: u32,
    pub RESERVED5: [u32; 6usize],
    pub PID4: u32,
    pub PID5: u32,
    pub PID6: u32,
    pub PID7: u32,
    pub PID0: u32,
    pub PID1: u32,
    pub PID2: u32,
    pub PID3: u32,
    pub CID0: u32,
    pub CID1: u32,
    pub CID2: u32,
    pub CID3: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ITM_Type__bindgen_ty_1 {
    pub u8_: u8,
    pub u16_: u16,
    pub u32_: u32,
}
#[test]
fn bindgen_test_layout_ITM_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ITM_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ITM_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ITM_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ITM_Type__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type__bindgen_ty_1>())).u8_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type__bindgen_ty_1),
            "::",
            stringify!(u8_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type__bindgen_ty_1>())).u16_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type__bindgen_ty_1),
            "::",
            stringify!(u16_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type__bindgen_ty_1>())).u32_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type__bindgen_ty_1),
            "::",
            stringify!(u32_)
        )
    );
}
impl Default for ITM_Type__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_ITM_Type() {
    assert_eq!(
        ::core::mem::size_of::<ITM_Type>(),
        4096usize,
        concat!("Size of: ", stringify!(ITM_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ITM_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(ITM_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).PORT as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PORT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).RESERVED0 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).TER as *const _ as usize },
        3584usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(TER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).RESERVED1 as *const _ as usize },
        3588usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).TPR as *const _ as usize },
        3648usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(TPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).RESERVED2 as *const _ as usize },
        3652usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).TCR as *const _ as usize },
        3712usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(TCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).RESERVED3 as *const _ as usize },
        3716usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).RESERVED4 as *const _ as usize },
        3844usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).LAR as *const _ as usize },
        4016usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(LAR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).LSR as *const _ as usize },
        4020usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(LSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).RESERVED5 as *const _ as usize },
        4024usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(RESERVED5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).PID4 as *const _ as usize },
        4048usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).PID5 as *const _ as usize },
        4052usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).PID6 as *const _ as usize },
        4056usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).PID7 as *const _ as usize },
        4060usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).PID0 as *const _ as usize },
        4064usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).PID1 as *const _ as usize },
        4068usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).PID2 as *const _ as usize },
        4072usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).PID3 as *const _ as usize },
        4076usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).CID0 as *const _ as usize },
        4080usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(CID0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).CID1 as *const _ as usize },
        4084usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(CID1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).CID2 as *const _ as usize },
        4088usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(CID2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ITM_Type>())).CID3 as *const _ as usize },
        4092usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(CID3)
        )
    );
}
impl Default for ITM_Type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DWT_Type {
    pub CTRL: u32,
    pub CYCCNT: u32,
    pub CPICNT: u32,
    pub EXCCNT: u32,
    pub SLEEPCNT: u32,
    pub LSUCNT: u32,
    pub FOLDCNT: u32,
    pub PCSR: u32,
    pub COMP0: u32,
    pub MASK0: u32,
    pub FUNCTION0: u32,
    pub RESERVED0: [u32; 1usize],
    pub COMP1: u32,
    pub MASK1: u32,
    pub FUNCTION1: u32,
    pub RESERVED1: [u32; 1usize],
    pub COMP2: u32,
    pub MASK2: u32,
    pub FUNCTION2: u32,
    pub RESERVED2: [u32; 1usize],
    pub COMP3: u32,
    pub MASK3: u32,
    pub FUNCTION3: u32,
}
#[test]
fn bindgen_test_layout_DWT_Type() {
    assert_eq!(
        ::core::mem::size_of::<DWT_Type>(),
        92usize,
        concat!("Size of: ", stringify!(DWT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DWT_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DWT_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).CTRL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).CYCCNT as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(CYCCNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).CPICNT as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(CPICNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).EXCCNT as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(EXCCNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).SLEEPCNT as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(SLEEPCNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).LSUCNT as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(LSUCNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).FOLDCNT as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(FOLDCNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).PCSR as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(PCSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).COMP0 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(COMP0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).MASK0 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(MASK0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).FUNCTION0 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(FUNCTION0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).RESERVED0 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).COMP1 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(COMP1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).MASK1 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(MASK1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).FUNCTION1 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(FUNCTION1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).RESERVED1 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).COMP2 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(COMP2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).MASK2 as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(MASK2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).FUNCTION2 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(FUNCTION2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).RESERVED2 as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).COMP3 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(COMP3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).MASK3 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(MASK3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DWT_Type>())).FUNCTION3 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(FUNCTION3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPI_Type {
    pub SSPSR: u32,
    pub CSPSR: u32,
    pub RESERVED0: [u32; 2usize],
    pub ACPR: u32,
    pub RESERVED1: [u32; 55usize],
    pub SPPR: u32,
    pub RESERVED2: [u32; 131usize],
    pub FFSR: u32,
    pub FFCR: u32,
    pub FSCR: u32,
    pub RESERVED3: [u32; 759usize],
    pub TRIGGER: u32,
    pub FIFO0: u32,
    pub ITATBCTR2: u32,
    pub RESERVED4: [u32; 1usize],
    pub ITATBCTR0: u32,
    pub FIFO1: u32,
    pub ITCTRL: u32,
    pub RESERVED5: [u32; 39usize],
    pub CLAIMSET: u32,
    pub CLAIMCLR: u32,
    pub RESERVED7: [u32; 8usize],
    pub DEVID: u32,
    pub DEVTYPE: u32,
}
#[test]
fn bindgen_test_layout_TPI_Type() {
    assert_eq!(
        ::core::mem::size_of::<TPI_Type>(),
        4048usize,
        concat!("Size of: ", stringify!(TPI_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TPI_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TPI_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).SSPSR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(SSPSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).CSPSR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(CSPSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).RESERVED0 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).ACPR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(ACPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).RESERVED1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).SPPR as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(SPPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).RESERVED2 as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).FFSR as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(FFSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).FFCR as *const _ as usize },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(FFCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).FSCR as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(FSCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).RESERVED3 as *const _ as usize },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).TRIGGER as *const _ as usize },
        3816usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(TRIGGER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).FIFO0 as *const _ as usize },
        3820usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(FIFO0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).ITATBCTR2 as *const _ as usize },
        3824usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(ITATBCTR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).RESERVED4 as *const _ as usize },
        3828usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).ITATBCTR0 as *const _ as usize },
        3832usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(ITATBCTR0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).FIFO1 as *const _ as usize },
        3836usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(FIFO1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).ITCTRL as *const _ as usize },
        3840usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(ITCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).RESERVED5 as *const _ as usize },
        3844usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(RESERVED5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).CLAIMSET as *const _ as usize },
        4000usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(CLAIMSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).CLAIMCLR as *const _ as usize },
        4004usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(CLAIMCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).RESERVED7 as *const _ as usize },
        4008usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(RESERVED7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).DEVID as *const _ as usize },
        4040usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(DEVID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TPI_Type>())).DEVTYPE as *const _ as usize },
        4044usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(DEVTYPE)
        )
    );
}
impl Default for TPI_Type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MPU_Type {
    pub TYPE: u32,
    pub CTRL: u32,
    pub RNR: u32,
    pub RBAR: u32,
    pub RASR: u32,
    pub RBAR_A1: u32,
    pub RASR_A1: u32,
    pub RBAR_A2: u32,
    pub RASR_A2: u32,
    pub RBAR_A3: u32,
    pub RASR_A3: u32,
}
#[test]
fn bindgen_test_layout_MPU_Type() {
    assert_eq!(
        ::core::mem::size_of::<MPU_Type>(),
        44usize,
        concat!("Size of: ", stringify!(MPU_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MPU_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MPU_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPU_Type>())).TYPE as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(TYPE)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPU_Type>())).CTRL as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPU_Type>())).RNR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RNR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPU_Type>())).RBAR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RBAR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPU_Type>())).RASR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RASR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPU_Type>())).RBAR_A1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RBAR_A1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPU_Type>())).RASR_A1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RASR_A1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPU_Type>())).RBAR_A2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RBAR_A2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPU_Type>())).RASR_A2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RASR_A2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPU_Type>())).RBAR_A3 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RBAR_A3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPU_Type>())).RASR_A3 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RASR_A3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FPU_Type {
    pub RESERVED0: [u32; 1usize],
    pub FPCCR: u32,
    pub FPCAR: u32,
    pub FPDSCR: u32,
    pub MVFR0: u32,
    pub MVFR1: u32,
    pub MVFR2: u32,
}
#[test]
fn bindgen_test_layout_FPU_Type() {
    assert_eq!(
        ::core::mem::size_of::<FPU_Type>(),
        28usize,
        concat!("Size of: ", stringify!(FPU_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<FPU_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(FPU_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FPU_Type>())).RESERVED0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPU_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FPU_Type>())).FPCCR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPU_Type),
            "::",
            stringify!(FPCCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FPU_Type>())).FPCAR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPU_Type),
            "::",
            stringify!(FPCAR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FPU_Type>())).FPDSCR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FPU_Type),
            "::",
            stringify!(FPDSCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FPU_Type>())).MVFR0 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPU_Type),
            "::",
            stringify!(MVFR0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FPU_Type>())).MVFR1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FPU_Type),
            "::",
            stringify!(MVFR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FPU_Type>())).MVFR2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPU_Type),
            "::",
            stringify!(MVFR2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CoreDebug_Type {
    pub DHCSR: u32,
    pub DCRSR: u32,
    pub DCRDR: u32,
    pub DEMCR: u32,
}
#[test]
fn bindgen_test_layout_CoreDebug_Type() {
    assert_eq!(
        ::core::mem::size_of::<CoreDebug_Type>(),
        16usize,
        concat!("Size of: ", stringify!(CoreDebug_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<CoreDebug_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(CoreDebug_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CoreDebug_Type>())).DHCSR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CoreDebug_Type),
            "::",
            stringify!(DHCSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CoreDebug_Type>())).DCRSR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CoreDebug_Type),
            "::",
            stringify!(DCRSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CoreDebug_Type>())).DCRDR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CoreDebug_Type),
            "::",
            stringify!(DCRDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CoreDebug_Type>())).DEMCR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CoreDebug_Type),
            "::",
            stringify!(DEMCR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ARM_MPU_Region_t {
    pub RBAR: u32,
    pub RASR: u32,
}
#[test]
fn bindgen_test_layout_ARM_MPU_Region_t() {
    assert_eq!(
        ::core::mem::size_of::<ARM_MPU_Region_t>(),
        8usize,
        concat!("Size of: ", stringify!(ARM_MPU_Region_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ARM_MPU_Region_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ARM_MPU_Region_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ARM_MPU_Region_t>())).RBAR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ARM_MPU_Region_t),
            "::",
            stringify!(RBAR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ARM_MPU_Region_t>())).RASR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ARM_MPU_Region_t),
            "::",
            stringify!(RASR)
        )
    );
}
extern "C" {
    pub static mut ITM_RxBuffer: i32;
}
extern "C" {
    #[doc = "< System Clock Frequency (Core Clock)"]
    pub static mut SystemCoreClock: u32;
}
extern "C" {
    #[doc = "< AHB prescalers table values"]
    pub static AHBPrescTable: [u8; 16usize];
}
extern "C" {
    #[doc = "< APB prescalers table values"]
    pub static APBPrescTable: [u8; 8usize];
}
extern "C" {
    #[doc = "< MSI ranges table values"]
    pub static MSIRangeTable: [u32; 12usize];
}
extern "C" {
    #[doc = " @addtogroup STM32L4xx_System_Exported_Functions"]
    #[doc = " @{"]
    pub fn SystemInit();
}
extern "C" {
    pub fn SystemCoreClockUpdate();
}
#[doc = " @brief Analog to Digital Converter"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ADC_TypeDef {
    #[doc = "< ADC interrupt and status register,             Address offset: 0x00"]
    pub ISR: u32,
    #[doc = "< ADC interrupt enable register,                 Address offset: 0x04"]
    pub IER: u32,
    #[doc = "< ADC control register,                          Address offset: 0x08"]
    pub CR: u32,
    #[doc = "< ADC configuration register 1,                  Address offset: 0x0C"]
    pub CFGR: u32,
    #[doc = "< ADC configuration register 2,                  Address offset: 0x10"]
    pub CFGR2: u32,
    #[doc = "< ADC sampling time register 1,                  Address offset: 0x14"]
    pub SMPR1: u32,
    #[doc = "< ADC sampling time register 2,                  Address offset: 0x18"]
    pub SMPR2: u32,
    #[doc = "< Reserved,                                                      0x1C"]
    pub RESERVED1: u32,
    #[doc = "< ADC analog watchdog 1 threshold register,      Address offset: 0x20"]
    pub TR1: u32,
    #[doc = "< ADC analog watchdog 2 threshold register,      Address offset: 0x24"]
    pub TR2: u32,
    #[doc = "< ADC analog watchdog 3 threshold register,      Address offset: 0x28"]
    pub TR3: u32,
    #[doc = "< Reserved,                                                      0x2C"]
    pub RESERVED2: u32,
    #[doc = "< ADC group regular sequencer register 1,        Address offset: 0x30"]
    pub SQR1: u32,
    #[doc = "< ADC group regular sequencer register 2,        Address offset: 0x34"]
    pub SQR2: u32,
    #[doc = "< ADC group regular sequencer register 3,        Address offset: 0x38"]
    pub SQR3: u32,
    #[doc = "< ADC group regular sequencer register 4,        Address offset: 0x3C"]
    pub SQR4: u32,
    #[doc = "< ADC group regular data register,               Address offset: 0x40"]
    pub DR: u32,
    #[doc = "< Reserved,                                                      0x44"]
    pub RESERVED3: u32,
    #[doc = "< Reserved,                                                      0x48"]
    pub RESERVED4: u32,
    #[doc = "< ADC group injected sequencer register,         Address offset: 0x4C"]
    pub JSQR: u32,
    #[doc = "< Reserved,                                               0x50 - 0x5C"]
    pub RESERVED5: [u32; 4usize],
    #[doc = "< ADC offset register 1,                         Address offset: 0x60"]
    pub OFR1: u32,
    #[doc = "< ADC offset register 2,                         Address offset: 0x64"]
    pub OFR2: u32,
    #[doc = "< ADC offset register 3,                         Address offset: 0x68"]
    pub OFR3: u32,
    #[doc = "< ADC offset register 4,                         Address offset: 0x6C"]
    pub OFR4: u32,
    #[doc = "< Reserved,                                               0x70 - 0x7C"]
    pub RESERVED6: [u32; 4usize],
    #[doc = "< ADC group injected rank 1 data register,       Address offset: 0x80"]
    pub JDR1: u32,
    #[doc = "< ADC group injected rank 2 data register,       Address offset: 0x84"]
    pub JDR2: u32,
    #[doc = "< ADC group injected rank 3 data register,       Address offset: 0x88"]
    pub JDR3: u32,
    #[doc = "< ADC group injected rank 4 data register,       Address offset: 0x8C"]
    pub JDR4: u32,
    #[doc = "< Reserved,                                             0x090 - 0x09C"]
    pub RESERVED7: [u32; 4usize],
    #[doc = "< ADC analog watchdog 1 configuration register,  Address offset: 0xA0"]
    pub AWD2CR: u32,
    #[doc = "< ADC analog watchdog 3 Configuration Register,  Address offset: 0xA4"]
    pub AWD3CR: u32,
    #[doc = "< Reserved,                                                     0x0A8"]
    pub RESERVED8: u32,
    #[doc = "< Reserved,                                                     0x0AC"]
    pub RESERVED9: u32,
    #[doc = "< ADC differential mode selection register,      Address offset: 0xB0"]
    pub DIFSEL: u32,
    #[doc = "< ADC calibration factors,                       Address offset: 0xB4"]
    pub CALFACT: u32,
}
#[test]
fn bindgen_test_layout_ADC_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<ADC_TypeDef>(),
        184usize,
        concat!("Size of: ", stringify!(ADC_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).ISR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).IER as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(IER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).CR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).CFGR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(CFGR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).CFGR2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(CFGR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).SMPR1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(SMPR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).SMPR2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(SMPR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).RESERVED1 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).TR1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(TR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).TR2 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(TR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).TR3 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(TR3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).RESERVED2 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).SQR1 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(SQR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).SQR2 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(SQR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).SQR3 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(SQR3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).SQR4 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(SQR4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).DR as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(DR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).RESERVED3 as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).RESERVED4 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).JSQR as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(JSQR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).RESERVED5 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(RESERVED5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).OFR1 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(OFR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).OFR2 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(OFR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).OFR3 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(OFR3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).OFR4 as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(OFR4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).RESERVED6 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(RESERVED6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).JDR1 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(JDR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).JDR2 as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(JDR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).JDR3 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(JDR3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).JDR4 as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(JDR4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).RESERVED7 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(RESERVED7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).AWD2CR as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(AWD2CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).AWD3CR as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(AWD3CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).RESERVED8 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(RESERVED8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).RESERVED9 as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(RESERVED9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).DIFSEL as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(DIFSEL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_TypeDef>())).CALFACT as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(CALFACT)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ADC_Common_TypeDef {
    #[doc = "< ADC common status register,                    Address offset: ADC1 base address + 0x300"]
    pub CSR: u32,
    #[doc = "< Reserved,                                      Address offset: ADC1 base address + 0x304"]
    pub RESERVED: u32,
    #[doc = "< ADC common configuration register,             Address offset: ADC1 base address + 0x308"]
    pub CCR: u32,
    #[doc = "< ADC common group regular data register         Address offset: ADC1 base address + 0x30C"]
    pub CDR: u32,
}
#[test]
fn bindgen_test_layout_ADC_Common_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<ADC_Common_TypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(ADC_Common_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_Common_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_Common_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_Common_TypeDef>())).CSR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_Common_TypeDef),
            "::",
            stringify!(CSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_Common_TypeDef>())).RESERVED as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_Common_TypeDef),
            "::",
            stringify!(RESERVED)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_Common_TypeDef>())).CCR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_Common_TypeDef),
            "::",
            stringify!(CCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_Common_TypeDef>())).CDR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_Common_TypeDef),
            "::",
            stringify!(CDR)
        )
    );
}
#[doc = " @brief Controller Area Network TxMailBox"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAN_TxMailBox_TypeDef {
    #[doc = "< CAN TX mailbox identifier register"]
    pub TIR: u32,
    #[doc = "< CAN mailbox data length control and time stamp register"]
    pub TDTR: u32,
    #[doc = "< CAN mailbox data low register"]
    pub TDLR: u32,
    #[doc = "< CAN mailbox data high register"]
    pub TDHR: u32,
}
#[test]
fn bindgen_test_layout_CAN_TxMailBox_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<CAN_TxMailBox_TypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(CAN_TxMailBox_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<CAN_TxMailBox_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(CAN_TxMailBox_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TxMailBox_TypeDef>())).TIR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TxMailBox_TypeDef),
            "::",
            stringify!(TIR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TxMailBox_TypeDef>())).TDTR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TxMailBox_TypeDef),
            "::",
            stringify!(TDTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TxMailBox_TypeDef>())).TDLR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TxMailBox_TypeDef),
            "::",
            stringify!(TDLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TxMailBox_TypeDef>())).TDHR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TxMailBox_TypeDef),
            "::",
            stringify!(TDHR)
        )
    );
}
#[doc = " @brief Controller Area Network FIFOMailBox"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAN_FIFOMailBox_TypeDef {
    #[doc = "< CAN receive FIFO mailbox identifier register"]
    pub RIR: u32,
    #[doc = "< CAN receive FIFO mailbox data length control and time stamp register"]
    pub RDTR: u32,
    #[doc = "< CAN receive FIFO mailbox data low register"]
    pub RDLR: u32,
    #[doc = "< CAN receive FIFO mailbox data high register"]
    pub RDHR: u32,
}
#[test]
fn bindgen_test_layout_CAN_FIFOMailBox_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<CAN_FIFOMailBox_TypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(CAN_FIFOMailBox_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<CAN_FIFOMailBox_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(CAN_FIFOMailBox_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_FIFOMailBox_TypeDef>())).RIR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FIFOMailBox_TypeDef),
            "::",
            stringify!(RIR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_FIFOMailBox_TypeDef>())).RDTR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FIFOMailBox_TypeDef),
            "::",
            stringify!(RDTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_FIFOMailBox_TypeDef>())).RDLR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FIFOMailBox_TypeDef),
            "::",
            stringify!(RDLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_FIFOMailBox_TypeDef>())).RDHR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FIFOMailBox_TypeDef),
            "::",
            stringify!(RDHR)
        )
    );
}
#[doc = " @brief Controller Area Network FilterRegister"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAN_FilterRegister_TypeDef {
    #[doc = "< CAN Filter bank register 1"]
    pub FR1: u32,
    #[doc = "< CAN Filter bank register 1"]
    pub FR2: u32,
}
#[test]
fn bindgen_test_layout_CAN_FilterRegister_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<CAN_FilterRegister_TypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(CAN_FilterRegister_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<CAN_FilterRegister_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(CAN_FilterRegister_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_FilterRegister_TypeDef>())).FR1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FilterRegister_TypeDef),
            "::",
            stringify!(FR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_FilterRegister_TypeDef>())).FR2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FilterRegister_TypeDef),
            "::",
            stringify!(FR2)
        )
    );
}
#[doc = " @brief Controller Area Network"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAN_TypeDef {
    #[doc = "< CAN master control register,         Address offset: 0x00"]
    pub MCR: u32,
    #[doc = "< CAN master status register,          Address offset: 0x04"]
    pub MSR: u32,
    #[doc = "< CAN transmit status register,        Address offset: 0x08"]
    pub TSR: u32,
    #[doc = "< CAN receive FIFO 0 register,         Address offset: 0x0C"]
    pub RF0R: u32,
    #[doc = "< CAN receive FIFO 1 register,         Address offset: 0x10"]
    pub RF1R: u32,
    #[doc = "< CAN interrupt enable register,       Address offset: 0x14"]
    pub IER: u32,
    #[doc = "< CAN error status register,           Address offset: 0x18"]
    pub ESR: u32,
    #[doc = "< CAN bit timing register,             Address offset: 0x1C"]
    pub BTR: u32,
    #[doc = "< Reserved, 0x020 - 0x17F"]
    pub RESERVED0: [u32; 88usize],
    #[doc = "< CAN Tx MailBox,                      Address offset: 0x180 - 0x1AC"]
    pub sTxMailBox: [CAN_TxMailBox_TypeDef; 3usize],
    #[doc = "< CAN FIFO MailBox,                    Address offset: 0x1B0 - 0x1CC"]
    pub sFIFOMailBox: [CAN_FIFOMailBox_TypeDef; 2usize],
    #[doc = "< Reserved, 0x1D0 - 0x1FF"]
    pub RESERVED1: [u32; 12usize],
    #[doc = "< CAN filter master register,          Address offset: 0x200"]
    pub FMR: u32,
    #[doc = "< CAN filter mode register,            Address offset: 0x204"]
    pub FM1R: u32,
    #[doc = "< Reserved, 0x208"]
    pub RESERVED2: u32,
    #[doc = "< CAN filter scale register,           Address offset: 0x20C"]
    pub FS1R: u32,
    #[doc = "< Reserved, 0x210"]
    pub RESERVED3: u32,
    #[doc = "< CAN filter FIFO assignment register, Address offset: 0x214"]
    pub FFA1R: u32,
    #[doc = "< Reserved, 0x218"]
    pub RESERVED4: u32,
    #[doc = "< CAN filter activation register,      Address offset: 0x21C"]
    pub FA1R: u32,
    #[doc = "< Reserved, 0x220-0x23F"]
    pub RESERVED5: [u32; 8usize],
    #[doc = "< CAN Filter Register,                 Address offset: 0x240-0x31C"]
    pub sFilterRegister: [CAN_FilterRegister_TypeDef; 28usize],
}
#[test]
fn bindgen_test_layout_CAN_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<CAN_TypeDef>(),
        800usize,
        concat!("Size of: ", stringify!(CAN_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<CAN_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(CAN_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).MCR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(MCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).MSR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(MSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).TSR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(TSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).RF0R as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(RF0R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).RF1R as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(RF1R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).IER as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(IER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).ESR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(ESR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).BTR as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(BTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).RESERVED0 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).sTxMailBox as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(sTxMailBox)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).sFIFOMailBox as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(sFIFOMailBox)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).RESERVED1 as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).FMR as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(FMR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).FM1R as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(FM1R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).RESERVED2 as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).FS1R as *const _ as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(FS1R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).RESERVED3 as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).FFA1R as *const _ as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(FFA1R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).RESERVED4 as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).FA1R as *const _ as usize },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(FA1R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).RESERVED5 as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(RESERVED5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TypeDef>())).sFilterRegister as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TypeDef),
            "::",
            stringify!(sFilterRegister)
        )
    );
}
impl Default for CAN_TypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Comparator"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct COMP_TypeDef {
    #[doc = "< COMP control and status register, Address offset: 0x00"]
    pub CSR: u32,
}
#[test]
fn bindgen_test_layout_COMP_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<COMP_TypeDef>(),
        4usize,
        concat!("Size of: ", stringify!(COMP_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<COMP_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(COMP_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMP_TypeDef>())).CSR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_TypeDef),
            "::",
            stringify!(CSR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct COMP_Common_TypeDef {
    #[doc = "< COMP control and status register, used for bits common to several COMP instances, Address offset: 0x00"]
    pub CSR: u32,
}
#[test]
fn bindgen_test_layout_COMP_Common_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<COMP_Common_TypeDef>(),
        4usize,
        concat!("Size of: ", stringify!(COMP_Common_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<COMP_Common_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(COMP_Common_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMP_Common_TypeDef>())).CSR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_Common_TypeDef),
            "::",
            stringify!(CSR)
        )
    );
}
#[doc = " @brief CRC calculation unit"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CRC_TypeDef {
    #[doc = "< CRC Data register,                           Address offset: 0x00"]
    pub DR: u32,
    #[doc = "< CRC Independent data register,               Address offset: 0x04"]
    pub IDR: u8,
    #[doc = "< Reserved,                                                    0x05"]
    pub RESERVED0: u8,
    #[doc = "< Reserved,                                                    0x06"]
    pub RESERVED1: u16,
    #[doc = "< CRC Control register,                        Address offset: 0x08"]
    pub CR: u32,
    #[doc = "< Reserved,                                                    0x0C"]
    pub RESERVED2: u32,
    #[doc = "< Initial CRC value register,                  Address offset: 0x10"]
    pub INIT: u32,
    #[doc = "< CRC polynomial register,                     Address offset: 0x14"]
    pub POL: u32,
}
#[test]
fn bindgen_test_layout_CRC_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<CRC_TypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(CRC_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<CRC_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(CRC_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRC_TypeDef>())).DR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_TypeDef),
            "::",
            stringify!(DR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRC_TypeDef>())).IDR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_TypeDef),
            "::",
            stringify!(IDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRC_TypeDef>())).RESERVED0 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_TypeDef),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRC_TypeDef>())).RESERVED1 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRC_TypeDef>())).CR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRC_TypeDef>())).RESERVED2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_TypeDef),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRC_TypeDef>())).INIT as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_TypeDef),
            "::",
            stringify!(INIT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRC_TypeDef>())).POL as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_TypeDef),
            "::",
            stringify!(POL)
        )
    );
}
#[doc = " @brief Digital to Analog Converter"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DAC_TypeDef {
    #[doc = "< DAC control register,                                    Address offset: 0x00"]
    pub CR: u32,
    #[doc = "< DAC software trigger register,                           Address offset: 0x04"]
    pub SWTRIGR: u32,
    #[doc = "< DAC channel1 12-bit right-aligned data holding register, Address offset: 0x08"]
    pub DHR12R1: u32,
    #[doc = "< DAC channel1 12-bit left aligned data holding register,  Address offset: 0x0C"]
    pub DHR12L1: u32,
    #[doc = "< DAC channel1 8-bit right aligned data holding register,  Address offset: 0x10"]
    pub DHR8R1: u32,
    #[doc = "< DAC channel2 12-bit right aligned data holding register, Address offset: 0x14"]
    pub DHR12R2: u32,
    #[doc = "< DAC channel2 12-bit left aligned data holding register,  Address offset: 0x18"]
    pub DHR12L2: u32,
    #[doc = "< DAC channel2 8-bit right-aligned data holding register,  Address offset: 0x1C"]
    pub DHR8R2: u32,
    #[doc = "< Dual DAC 12-bit right-aligned data holding register,     Address offset: 0x20"]
    pub DHR12RD: u32,
    #[doc = "< DUAL DAC 12-bit left aligned data holding register,      Address offset: 0x24"]
    pub DHR12LD: u32,
    #[doc = "< DUAL DAC 8-bit right aligned data holding register,      Address offset: 0x28"]
    pub DHR8RD: u32,
    #[doc = "< DAC channel1 data output register,                       Address offset: 0x2C"]
    pub DOR1: u32,
    #[doc = "< DAC channel2 data output register,                       Address offset: 0x30"]
    pub DOR2: u32,
    #[doc = "< DAC status register,                                     Address offset: 0x34"]
    pub SR: u32,
    #[doc = "< DAC calibration control register,                        Address offset: 0x38"]
    pub CCR: u32,
    #[doc = "< DAC mode control register,                               Address offset: 0x3C"]
    pub MCR: u32,
    #[doc = "< DAC Sample and Hold sample time register 1,              Address offset: 0x40"]
    pub SHSR1: u32,
    #[doc = "< DAC Sample and Hold sample time register 2,              Address offset: 0x44"]
    pub SHSR2: u32,
    #[doc = "< DAC Sample and Hold hold time register,                  Address offset: 0x48"]
    pub SHHR: u32,
    #[doc = "< DAC Sample and Hold refresh time register,               Address offset: 0x4C"]
    pub SHRR: u32,
}
#[test]
fn bindgen_test_layout_DAC_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DAC_TypeDef>(),
        80usize,
        concat!("Size of: ", stringify!(DAC_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DAC_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).CR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).SWTRIGR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(SWTRIGR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).DHR12R1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(DHR12R1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).DHR12L1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(DHR12L1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).DHR8R1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(DHR8R1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).DHR12R2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(DHR12R2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).DHR12L2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(DHR12L2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).DHR8R2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(DHR8R2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).DHR12RD as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(DHR12RD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).DHR12LD as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(DHR12LD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).DHR8RD as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(DHR8RD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).DOR1 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(DOR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).DOR2 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(DOR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).SR as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).CCR as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(CCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).MCR as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(MCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).SHSR1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(SHSR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).SHSR2 as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(SHSR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).SHHR as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(SHHR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_TypeDef>())).SHRR as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_TypeDef),
            "::",
            stringify!(SHRR)
        )
    );
}
#[doc = " @brief DFSDM module registers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DFSDM_Filter_TypeDef {
    #[doc = "< DFSDM control register1,                          Address offset: 0x100"]
    pub FLTCR1: u32,
    #[doc = "< DFSDM control register2,                          Address offset: 0x104"]
    pub FLTCR2: u32,
    #[doc = "< DFSDM interrupt and status register,              Address offset: 0x108"]
    pub FLTISR: u32,
    #[doc = "< DFSDM interrupt flag clear register,              Address offset: 0x10C"]
    pub FLTICR: u32,
    #[doc = "< DFSDM injected channel group selection register,  Address offset: 0x110"]
    pub FLTJCHGR: u32,
    #[doc = "< DFSDM filter control register,                    Address offset: 0x114"]
    pub FLTFCR: u32,
    #[doc = "< DFSDM data register for injected group,           Address offset: 0x118"]
    pub FLTJDATAR: u32,
    #[doc = "< DFSDM data register for regular group,            Address offset: 0x11C"]
    pub FLTRDATAR: u32,
    #[doc = "< DFSDM analog watchdog high threshold register,    Address offset: 0x120"]
    pub FLTAWHTR: u32,
    #[doc = "< DFSDM analog watchdog low threshold register,     Address offset: 0x124"]
    pub FLTAWLTR: u32,
    #[doc = "< DFSDM analog watchdog status register             Address offset: 0x128"]
    pub FLTAWSR: u32,
    #[doc = "< DFSDM analog watchdog clear flag register         Address offset: 0x12C"]
    pub FLTAWCFR: u32,
    #[doc = "< DFSDM extreme detector maximum register,          Address offset: 0x130"]
    pub FLTEXMAX: u32,
    #[doc = "< DFSDM extreme detector minimum register           Address offset: 0x134"]
    pub FLTEXMIN: u32,
    #[doc = "< DFSDM conversion timer,                           Address offset: 0x138"]
    pub FLTCNVTIMR: u32,
}
#[test]
fn bindgen_test_layout_DFSDM_Filter_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DFSDM_Filter_TypeDef>(),
        60usize,
        concat!("Size of: ", stringify!(DFSDM_Filter_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DFSDM_Filter_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DFSDM_Filter_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Filter_TypeDef>())).FLTCR1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_TypeDef),
            "::",
            stringify!(FLTCR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Filter_TypeDef>())).FLTCR2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_TypeDef),
            "::",
            stringify!(FLTCR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Filter_TypeDef>())).FLTISR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_TypeDef),
            "::",
            stringify!(FLTISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Filter_TypeDef>())).FLTICR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_TypeDef),
            "::",
            stringify!(FLTICR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Filter_TypeDef>())).FLTJCHGR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_TypeDef),
            "::",
            stringify!(FLTJCHGR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Filter_TypeDef>())).FLTFCR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_TypeDef),
            "::",
            stringify!(FLTFCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Filter_TypeDef>())).FLTJDATAR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_TypeDef),
            "::",
            stringify!(FLTJDATAR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Filter_TypeDef>())).FLTRDATAR as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_TypeDef),
            "::",
            stringify!(FLTRDATAR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Filter_TypeDef>())).FLTAWHTR as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_TypeDef),
            "::",
            stringify!(FLTAWHTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Filter_TypeDef>())).FLTAWLTR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_TypeDef),
            "::",
            stringify!(FLTAWLTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Filter_TypeDef>())).FLTAWSR as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_TypeDef),
            "::",
            stringify!(FLTAWSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Filter_TypeDef>())).FLTAWCFR as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_TypeDef),
            "::",
            stringify!(FLTAWCFR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Filter_TypeDef>())).FLTEXMAX as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_TypeDef),
            "::",
            stringify!(FLTEXMAX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Filter_TypeDef>())).FLTEXMIN as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_TypeDef),
            "::",
            stringify!(FLTEXMIN)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_TypeDef>())).FLTCNVTIMR as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_TypeDef),
            "::",
            stringify!(FLTCNVTIMR)
        )
    );
}
#[doc = " @brief DFSDM channel configuration registers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DFSDM_Channel_TypeDef {
    #[doc = "< DFSDM channel configuration register1,            Address offset: 0x00"]
    pub CHCFGR1: u32,
    #[doc = "< DFSDM channel configuration register2,            Address offset: 0x04"]
    pub CHCFGR2: u32,
    #[doc = "< DFSDM channel analog watchdog and"]
    #[doc = "short circuit detector register,                  Address offset: 0x08"]
    pub CHAWSCDR: u32,
    #[doc = "< DFSDM channel watchdog filter data register,      Address offset: 0x0C"]
    pub CHWDATAR: u32,
    #[doc = "< DFSDM channel data input register,                Address offset: 0x10"]
    pub CHDATINR: u32,
}
#[test]
fn bindgen_test_layout_DFSDM_Channel_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DFSDM_Channel_TypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(DFSDM_Channel_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DFSDM_Channel_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DFSDM_Channel_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Channel_TypeDef>())).CHCFGR1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_TypeDef),
            "::",
            stringify!(CHCFGR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Channel_TypeDef>())).CHCFGR2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_TypeDef),
            "::",
            stringify!(CHCFGR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Channel_TypeDef>())).CHAWSCDR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_TypeDef),
            "::",
            stringify!(CHAWSCDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Channel_TypeDef>())).CHWDATAR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_TypeDef),
            "::",
            stringify!(CHWDATAR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Channel_TypeDef>())).CHDATINR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_TypeDef),
            "::",
            stringify!(CHDATINR)
        )
    );
}
#[doc = " @brief Debug MCU"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DBGMCU_TypeDef {
    #[doc = "< MCU device ID code,                 Address offset: 0x00"]
    pub IDCODE: u32,
    #[doc = "< Debug MCU configuration register,   Address offset: 0x04"]
    pub CR: u32,
    #[doc = "< Debug MCU APB1 freeze register 1,   Address offset: 0x08"]
    pub APB1FZR1: u32,
    #[doc = "< Debug MCU APB1 freeze register 2,   Address offset: 0x0C"]
    pub APB1FZR2: u32,
    #[doc = "< Debug MCU APB2 freeze register,     Address offset: 0x10"]
    pub APB2FZ: u32,
}
#[test]
fn bindgen_test_layout_DBGMCU_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DBGMCU_TypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(DBGMCU_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DBGMCU_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DBGMCU_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DBGMCU_TypeDef>())).IDCODE as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DBGMCU_TypeDef),
            "::",
            stringify!(IDCODE)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DBGMCU_TypeDef>())).CR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DBGMCU_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DBGMCU_TypeDef>())).APB1FZR1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DBGMCU_TypeDef),
            "::",
            stringify!(APB1FZR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DBGMCU_TypeDef>())).APB1FZR2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DBGMCU_TypeDef),
            "::",
            stringify!(APB1FZR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DBGMCU_TypeDef>())).APB2FZ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DBGMCU_TypeDef),
            "::",
            stringify!(APB2FZ)
        )
    );
}
#[doc = " @brief DMA Controller"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DMA_Channel_TypeDef {
    #[doc = "< DMA channel x configuration register"]
    pub CCR: u32,
    #[doc = "< DMA channel x number of data register"]
    pub CNDTR: u32,
    #[doc = "< DMA channel x peripheral address register"]
    pub CPAR: u32,
    #[doc = "< DMA channel x memory address register"]
    pub CMAR: u32,
}
#[test]
fn bindgen_test_layout_DMA_Channel_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DMA_Channel_TypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(DMA_Channel_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DMA_Channel_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DMA_Channel_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMA_Channel_TypeDef>())).CCR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_Channel_TypeDef),
            "::",
            stringify!(CCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMA_Channel_TypeDef>())).CNDTR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_Channel_TypeDef),
            "::",
            stringify!(CNDTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMA_Channel_TypeDef>())).CPAR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_Channel_TypeDef),
            "::",
            stringify!(CPAR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMA_Channel_TypeDef>())).CMAR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_Channel_TypeDef),
            "::",
            stringify!(CMAR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DMA_TypeDef {
    #[doc = "< DMA interrupt status register,                 Address offset: 0x00"]
    pub ISR: u32,
    #[doc = "< DMA interrupt flag clear register,             Address offset: 0x04"]
    pub IFCR: u32,
}
#[test]
fn bindgen_test_layout_DMA_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DMA_TypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(DMA_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DMA_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DMA_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMA_TypeDef>())).ISR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMA_TypeDef>())).IFCR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_TypeDef),
            "::",
            stringify!(IFCR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DMA_Request_TypeDef {
    #[doc = "< DMA channel selection register"]
    pub CSELR: u32,
}
#[test]
fn bindgen_test_layout_DMA_Request_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DMA_Request_TypeDef>(),
        4usize,
        concat!("Size of: ", stringify!(DMA_Request_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DMA_Request_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DMA_Request_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMA_Request_TypeDef>())).CSELR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_Request_TypeDef),
            "::",
            stringify!(CSELR)
        )
    );
}
#[doc = " @brief External Interrupt/Event Controller"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct EXTI_TypeDef {
    #[doc = "< EXTI Interrupt mask register 1,             Address offset: 0x00"]
    pub IMR1: u32,
    #[doc = "< EXTI Event mask register 1,                 Address offset: 0x04"]
    pub EMR1: u32,
    #[doc = "< EXTI Rising trigger selection register 1,   Address offset: 0x08"]
    pub RTSR1: u32,
    #[doc = "< EXTI Falling trigger selection register 1,  Address offset: 0x0C"]
    pub FTSR1: u32,
    #[doc = "< EXTI Software interrupt event register 1,   Address offset: 0x10"]
    pub SWIER1: u32,
    #[doc = "< EXTI Pending register 1,                    Address offset: 0x14"]
    pub PR1: u32,
    #[doc = "< Reserved, 0x18"]
    pub RESERVED1: u32,
    #[doc = "< Reserved, 0x1C"]
    pub RESERVED2: u32,
    #[doc = "< EXTI Interrupt mask register 2,             Address offset: 0x20"]
    pub IMR2: u32,
    #[doc = "< EXTI Event mask register 2,                 Address offset: 0x24"]
    pub EMR2: u32,
    #[doc = "< EXTI Rising trigger selection register 2,   Address offset: 0x28"]
    pub RTSR2: u32,
    #[doc = "< EXTI Falling trigger selection register 2,  Address offset: 0x2C"]
    pub FTSR2: u32,
    #[doc = "< EXTI Software interrupt event register 2,   Address offset: 0x30"]
    pub SWIER2: u32,
    #[doc = "< EXTI Pending register 2,                    Address offset: 0x34"]
    pub PR2: u32,
}
#[test]
fn bindgen_test_layout_EXTI_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<EXTI_TypeDef>(),
        56usize,
        concat!("Size of: ", stringify!(EXTI_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<EXTI_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(EXTI_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_TypeDef>())).IMR1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(IMR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_TypeDef>())).EMR1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(EMR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_TypeDef>())).RTSR1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(RTSR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_TypeDef>())).FTSR1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(FTSR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_TypeDef>())).SWIER1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(SWIER1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_TypeDef>())).PR1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(PR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_TypeDef>())).RESERVED1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_TypeDef>())).RESERVED2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_TypeDef>())).IMR2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(IMR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_TypeDef>())).EMR2 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(EMR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_TypeDef>())).RTSR2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(RTSR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_TypeDef>())).FTSR2 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(FTSR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_TypeDef>())).SWIER2 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(SWIER2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_TypeDef>())).PR2 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(PR2)
        )
    );
}
#[doc = " @brief Firewall"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FIREWALL_TypeDef {
    #[doc = "< Code Segment Start Address register,              Address offset: 0x00"]
    pub CSSA: u32,
    #[doc = "< Code Segment Length register,                      Address offset: 0x04"]
    pub CSL: u32,
    #[doc = "< NON volatile data Segment Start Address register,  Address offset: 0x08"]
    pub NVDSSA: u32,
    #[doc = "< NON volatile data Segment Length register,         Address offset: 0x0C"]
    pub NVDSL: u32,
    #[doc = "< Volatile data Segment Start Address register,      Address offset: 0x10"]
    pub VDSSA: u32,
    #[doc = "< Volatile data Segment Length register,             Address offset: 0x14"]
    pub VDSL: u32,
    #[doc = "< Reserved1,                                         Address offset: 0x18"]
    pub RESERVED1: u32,
    #[doc = "< Reserved2,                                         Address offset: 0x1C"]
    pub RESERVED2: u32,
    #[doc = "< Configuration  register,                           Address offset: 0x20"]
    pub CR: u32,
}
#[test]
fn bindgen_test_layout_FIREWALL_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<FIREWALL_TypeDef>(),
        36usize,
        concat!("Size of: ", stringify!(FIREWALL_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FIREWALL_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FIREWALL_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FIREWALL_TypeDef>())).CSSA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_TypeDef),
            "::",
            stringify!(CSSA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FIREWALL_TypeDef>())).CSL as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_TypeDef),
            "::",
            stringify!(CSL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FIREWALL_TypeDef>())).NVDSSA as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_TypeDef),
            "::",
            stringify!(NVDSSA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FIREWALL_TypeDef>())).NVDSL as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_TypeDef),
            "::",
            stringify!(NVDSL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FIREWALL_TypeDef>())).VDSSA as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_TypeDef),
            "::",
            stringify!(VDSSA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FIREWALL_TypeDef>())).VDSL as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_TypeDef),
            "::",
            stringify!(VDSL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FIREWALL_TypeDef>())).RESERVED1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FIREWALL_TypeDef>())).RESERVED2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_TypeDef),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FIREWALL_TypeDef>())).CR as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_TypeDef),
            "::",
            stringify!(CR)
        )
    );
}
#[doc = " @brief FLASH Registers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FLASH_TypeDef {
    #[doc = "< FLASH access control register,            Address offset: 0x00"]
    pub ACR: u32,
    #[doc = "< FLASH power down key register,            Address offset: 0x04"]
    pub PDKEYR: u32,
    #[doc = "< FLASH key register,                       Address offset: 0x08"]
    pub KEYR: u32,
    #[doc = "< FLASH option key register,                Address offset: 0x0C"]
    pub OPTKEYR: u32,
    #[doc = "< FLASH status register,                    Address offset: 0x10"]
    pub SR: u32,
    #[doc = "< FLASH control register,                   Address offset: 0x14"]
    pub CR: u32,
    #[doc = "< FLASH ECC register,                       Address offset: 0x18"]
    pub ECCR: u32,
    #[doc = "< Reserved1,                                Address offset: 0x1C"]
    pub RESERVED1: u32,
    #[doc = "< FLASH option register,                    Address offset: 0x20"]
    pub OPTR: u32,
    #[doc = "< FLASH bank1 PCROP start address register, Address offset: 0x24"]
    pub PCROP1SR: u32,
    #[doc = "< FLASH bank1 PCROP end address register,   Address offset: 0x28"]
    pub PCROP1ER: u32,
    #[doc = "< FLASH bank1 WRP area A address register,  Address offset: 0x2C"]
    pub WRP1AR: u32,
    #[doc = "< FLASH bank1 WRP area B address register,  Address offset: 0x30"]
    pub WRP1BR: u32,
    #[doc = "< Reserved2,                           Address offset: 0x34-0x40"]
    pub RESERVED2: [u32; 4usize],
    #[doc = "< FLASH bank2 PCROP start address register, Address offset: 0x44"]
    pub PCROP2SR: u32,
    #[doc = "< FLASH bank2 PCROP end address register,   Address offset: 0x48"]
    pub PCROP2ER: u32,
    #[doc = "< FLASH bank2 WRP area A address register,  Address offset: 0x4C"]
    pub WRP2AR: u32,
    #[doc = "< FLASH bank2 WRP area B address register,  Address offset: 0x50"]
    pub WRP2BR: u32,
}
#[test]
fn bindgen_test_layout_FLASH_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<FLASH_TypeDef>(),
        84usize,
        concat!("Size of: ", stringify!(FLASH_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FLASH_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FLASH_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).ACR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(ACR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).PDKEYR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(PDKEYR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).KEYR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(KEYR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).OPTKEYR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(OPTKEYR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).SR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).CR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).ECCR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(ECCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).RESERVED1 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).OPTR as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(OPTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).PCROP1SR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(PCROP1SR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).PCROP1ER as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(PCROP1ER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).WRP1AR as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(WRP1AR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).WRP1BR as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(WRP1BR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).RESERVED2 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).PCROP2SR as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(PCROP2SR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).PCROP2ER as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(PCROP2ER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).WRP2AR as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(WRP2AR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_TypeDef>())).WRP2BR as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(WRP2BR)
        )
    );
}
#[doc = " @brief Flexible Memory Controller"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FMC_Bank1_TypeDef {
    #[doc = "< NOR/PSRAM chip-select control register(BCR) and chip-select timing register(BTR), Address offset: 0x00-1C"]
    pub BTCR: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_FMC_Bank1_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<FMC_Bank1_TypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(FMC_Bank1_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FMC_Bank1_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FMC_Bank1_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FMC_Bank1_TypeDef>())).BTCR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_Bank1_TypeDef),
            "::",
            stringify!(BTCR)
        )
    );
}
#[doc = " @brief Flexible Memory Controller Bank1E"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FMC_Bank1E_TypeDef {
    #[doc = "< NOR/PSRAM write timing registers, Address offset: 0x104-0x11C"]
    pub BWTR: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_FMC_Bank1E_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<FMC_Bank1E_TypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(FMC_Bank1E_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FMC_Bank1E_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FMC_Bank1E_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FMC_Bank1E_TypeDef>())).BWTR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_Bank1E_TypeDef),
            "::",
            stringify!(BWTR)
        )
    );
}
#[doc = " @brief Flexible Memory Controller Bank3"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FMC_Bank3_TypeDef {
    #[doc = "< NAND Flash control register,                       Address offset: 0x80"]
    pub PCR: u32,
    #[doc = "< NAND Flash FIFO status and interrupt register,     Address offset: 0x84"]
    pub SR: u32,
    #[doc = "< NAND Flash Common memory space timing register,    Address offset: 0x88"]
    pub PMEM: u32,
    #[doc = "< NAND Flash Attribute memory space timing register, Address offset: 0x8C"]
    pub PATT: u32,
    #[doc = "< Reserved, 0x90"]
    pub RESERVED0: u32,
    #[doc = "< NAND Flash ECC result registers,                   Address offset: 0x94"]
    pub ECCR: u32,
}
#[test]
fn bindgen_test_layout_FMC_Bank3_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<FMC_Bank3_TypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(FMC_Bank3_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FMC_Bank3_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FMC_Bank3_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FMC_Bank3_TypeDef>())).PCR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_Bank3_TypeDef),
            "::",
            stringify!(PCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FMC_Bank3_TypeDef>())).SR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_Bank3_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FMC_Bank3_TypeDef>())).PMEM as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_Bank3_TypeDef),
            "::",
            stringify!(PMEM)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FMC_Bank3_TypeDef>())).PATT as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_Bank3_TypeDef),
            "::",
            stringify!(PATT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FMC_Bank3_TypeDef>())).RESERVED0 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_Bank3_TypeDef),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FMC_Bank3_TypeDef>())).ECCR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_Bank3_TypeDef),
            "::",
            stringify!(ECCR)
        )
    );
}
#[doc = " @brief General Purpose I/O"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GPIO_TypeDef {
    #[doc = "< GPIO port mode register,               Address offset: 0x00"]
    pub MODER: u32,
    #[doc = "< GPIO port output type register,        Address offset: 0x04"]
    pub OTYPER: u32,
    #[doc = "< GPIO port output speed register,       Address offset: 0x08"]
    pub OSPEEDR: u32,
    #[doc = "< GPIO port pull-up/pull-down register,  Address offset: 0x0C"]
    pub PUPDR: u32,
    #[doc = "< GPIO port input data register,         Address offset: 0x10"]
    pub IDR: u32,
    #[doc = "< GPIO port output data register,        Address offset: 0x14"]
    pub ODR: u32,
    #[doc = "< GPIO port bit set/reset  register,     Address offset: 0x18"]
    pub BSRR: u32,
    #[doc = "< GPIO port configuration lock register, Address offset: 0x1C"]
    pub LCKR: u32,
    #[doc = "< GPIO alternate function registers,     Address offset: 0x20-0x24"]
    pub AFR: [u32; 2usize],
    #[doc = "< GPIO Bit Reset register,               Address offset: 0x28"]
    pub BRR: u32,
    #[doc = "< GPIO analog switch control register,   Address offset: 0x2C"]
    pub ASCR: u32,
}
#[test]
fn bindgen_test_layout_GPIO_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<GPIO_TypeDef>(),
        48usize,
        concat!("Size of: ", stringify!(GPIO_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<GPIO_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(GPIO_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_TypeDef>())).MODER as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(MODER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_TypeDef>())).OTYPER as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(OTYPER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_TypeDef>())).OSPEEDR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(OSPEEDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_TypeDef>())).PUPDR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(PUPDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_TypeDef>())).IDR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(IDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_TypeDef>())).ODR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(ODR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_TypeDef>())).BSRR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(BSRR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_TypeDef>())).LCKR as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(LCKR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_TypeDef>())).AFR as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(AFR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_TypeDef>())).BRR as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(BRR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_TypeDef>())).ASCR as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(ASCR)
        )
    );
}
#[doc = " @brief Inter-integrated Circuit Interface"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct I2C_TypeDef {
    #[doc = "< I2C Control register 1,            Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< I2C Control register 2,            Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< I2C Own address 1 register,        Address offset: 0x08"]
    pub OAR1: u32,
    #[doc = "< I2C Own address 2 register,        Address offset: 0x0C"]
    pub OAR2: u32,
    #[doc = "< I2C Timing register,               Address offset: 0x10"]
    pub TIMINGR: u32,
    #[doc = "< I2C Timeout register,              Address offset: 0x14"]
    pub TIMEOUTR: u32,
    #[doc = "< I2C Interrupt and status register, Address offset: 0x18"]
    pub ISR: u32,
    #[doc = "< I2C Interrupt clear register,      Address offset: 0x1C"]
    pub ICR: u32,
    #[doc = "< I2C PEC register,                  Address offset: 0x20"]
    pub PECR: u32,
    #[doc = "< I2C Receive data register,         Address offset: 0x24"]
    pub RXDR: u32,
    #[doc = "< I2C Transmit data register,        Address offset: 0x28"]
    pub TXDR: u32,
}
#[test]
fn bindgen_test_layout_I2C_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<I2C_TypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(I2C_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<I2C_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(I2C_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_TypeDef>())).CR1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_TypeDef>())).CR2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_TypeDef>())).OAR1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(OAR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_TypeDef>())).OAR2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(OAR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_TypeDef>())).TIMINGR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(TIMINGR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_TypeDef>())).TIMEOUTR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(TIMEOUTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_TypeDef>())).ISR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_TypeDef>())).ICR as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_TypeDef>())).PECR as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(PECR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_TypeDef>())).RXDR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(RXDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_TypeDef>())).TXDR as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(TXDR)
        )
    );
}
#[doc = " @brief Independent WATCHDOG"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IWDG_TypeDef {
    #[doc = "< IWDG Key register,       Address offset: 0x00"]
    pub KR: u32,
    #[doc = "< IWDG Prescaler register, Address offset: 0x04"]
    pub PR: u32,
    #[doc = "< IWDG Reload register,    Address offset: 0x08"]
    pub RLR: u32,
    #[doc = "< IWDG Status register,    Address offset: 0x0C"]
    pub SR: u32,
    #[doc = "< IWDG Window register,    Address offset: 0x10"]
    pub WINR: u32,
}
#[test]
fn bindgen_test_layout_IWDG_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<IWDG_TypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(IWDG_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<IWDG_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(IWDG_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IWDG_TypeDef>())).KR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_TypeDef),
            "::",
            stringify!(KR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IWDG_TypeDef>())).PR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_TypeDef),
            "::",
            stringify!(PR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IWDG_TypeDef>())).RLR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_TypeDef),
            "::",
            stringify!(RLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IWDG_TypeDef>())).SR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IWDG_TypeDef>())).WINR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_TypeDef),
            "::",
            stringify!(WINR)
        )
    );
}
#[doc = " @brief LPTIMER"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LPTIM_TypeDef {
    #[doc = "< LPTIM Interrupt and Status register,                Address offset: 0x00"]
    pub ISR: u32,
    #[doc = "< LPTIM Interrupt Clear register,                     Address offset: 0x04"]
    pub ICR: u32,
    #[doc = "< LPTIM Interrupt Enable register,                    Address offset: 0x08"]
    pub IER: u32,
    #[doc = "< LPTIM Configuration register,                       Address offset: 0x0C"]
    pub CFGR: u32,
    #[doc = "< LPTIM Control register,                             Address offset: 0x10"]
    pub CR: u32,
    #[doc = "< LPTIM Compare register,                             Address offset: 0x14"]
    pub CMP: u32,
    #[doc = "< LPTIM Autoreload register,                          Address offset: 0x18"]
    pub ARR: u32,
    #[doc = "< LPTIM Counter register,                             Address offset: 0x1C"]
    pub CNT: u32,
    #[doc = "< LPTIM Option register,                              Address offset: 0x20"]
    pub OR: u32,
}
#[test]
fn bindgen_test_layout_LPTIM_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<LPTIM_TypeDef>(),
        36usize,
        concat!("Size of: ", stringify!(LPTIM_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LPTIM_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LPTIM_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_TypeDef>())).ISR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_TypeDef>())).ICR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_TypeDef>())).IER as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(IER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_TypeDef>())).CFGR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CFGR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_TypeDef>())).CR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_TypeDef>())).CMP as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CMP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_TypeDef>())).ARR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(ARR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_TypeDef>())).CNT as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_TypeDef>())).OR as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(OR)
        )
    );
}
#[doc = " @brief Operational Amplifier (OPAMP)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OPAMP_TypeDef {
    #[doc = "< OPAMP control/status register,                     Address offset: 0x00"]
    pub CSR: u32,
    #[doc = "< OPAMP offset trimming register for normal mode,    Address offset: 0x04"]
    pub OTR: u32,
    #[doc = "< OPAMP offset trimming register for low power mode, Address offset: 0x08"]
    pub LPOTR: u32,
}
#[test]
fn bindgen_test_layout_OPAMP_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<OPAMP_TypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(OPAMP_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<OPAMP_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(OPAMP_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OPAMP_TypeDef>())).CSR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_TypeDef),
            "::",
            stringify!(CSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OPAMP_TypeDef>())).OTR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_TypeDef),
            "::",
            stringify!(OTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OPAMP_TypeDef>())).LPOTR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_TypeDef),
            "::",
            stringify!(LPOTR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OPAMP_Common_TypeDef {
    #[doc = "< OPAMP control/status register, used for bits common to several OPAMP instances, Address offset: 0x00"]
    pub CSR: u32,
}
#[test]
fn bindgen_test_layout_OPAMP_Common_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<OPAMP_Common_TypeDef>(),
        4usize,
        concat!("Size of: ", stringify!(OPAMP_Common_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<OPAMP_Common_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(OPAMP_Common_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OPAMP_Common_TypeDef>())).CSR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_Common_TypeDef),
            "::",
            stringify!(CSR)
        )
    );
}
#[doc = " @brief Power Control"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PWR_TypeDef {
    #[doc = "< PWR power control register 1,        Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< PWR power control register 2,        Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< PWR power control register 3,        Address offset: 0x08"]
    pub CR3: u32,
    #[doc = "< PWR power control register 4,        Address offset: 0x0C"]
    pub CR4: u32,
    #[doc = "< PWR power status register 1,         Address offset: 0x10"]
    pub SR1: u32,
    #[doc = "< PWR power status register 2,         Address offset: 0x14"]
    pub SR2: u32,
    #[doc = "< PWR power status reset register,     Address offset: 0x18"]
    pub SCR: u32,
    #[doc = "< Reserved,                            Address offset: 0x1C"]
    pub RESERVED: u32,
    #[doc = "< Pull_up control register of portA,   Address offset: 0x20"]
    pub PUCRA: u32,
    #[doc = "< Pull_Down control register of portA, Address offset: 0x24"]
    pub PDCRA: u32,
    #[doc = "< Pull_up control register of portB,   Address offset: 0x28"]
    pub PUCRB: u32,
    #[doc = "< Pull_Down control register of portB, Address offset: 0x2C"]
    pub PDCRB: u32,
    #[doc = "< Pull_up control register of portC,   Address offset: 0x30"]
    pub PUCRC: u32,
    #[doc = "< Pull_Down control register of portC, Address offset: 0x34"]
    pub PDCRC: u32,
    #[doc = "< Pull_up control register of portD,   Address offset: 0x38"]
    pub PUCRD: u32,
    #[doc = "< Pull_Down control register of portD, Address offset: 0x3C"]
    pub PDCRD: u32,
    #[doc = "< Pull_up control register of portE,   Address offset: 0x40"]
    pub PUCRE: u32,
    #[doc = "< Pull_Down control register of portE, Address offset: 0x44"]
    pub PDCRE: u32,
    #[doc = "< Pull_up control register of portF,   Address offset: 0x48"]
    pub PUCRF: u32,
    #[doc = "< Pull_Down control register of portF, Address offset: 0x4C"]
    pub PDCRF: u32,
    #[doc = "< Pull_up control register of portG,   Address offset: 0x50"]
    pub PUCRG: u32,
    #[doc = "< Pull_Down control register of portG, Address offset: 0x54"]
    pub PDCRG: u32,
    #[doc = "< Pull_up control register of portH,   Address offset: 0x58"]
    pub PUCRH: u32,
    #[doc = "< Pull_Down control register of portH, Address offset: 0x5C"]
    pub PDCRH: u32,
}
#[test]
fn bindgen_test_layout_PWR_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<PWR_TypeDef>(),
        96usize,
        concat!("Size of: ", stringify!(PWR_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<PWR_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(PWR_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).CR1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).CR2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).CR3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(CR3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).CR4 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(CR4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).SR1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(SR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).SR2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(SR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).SCR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(SCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).RESERVED as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(RESERVED)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PUCRA as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PUCRA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PDCRA as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PDCRA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PUCRB as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PUCRB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PDCRB as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PDCRB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PUCRC as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PUCRC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PDCRC as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PDCRC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PUCRD as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PUCRD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PDCRD as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PDCRD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PUCRE as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PUCRE)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PDCRE as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PDCRE)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PUCRF as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PUCRF)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PDCRF as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PDCRF)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PUCRG as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PUCRG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PDCRG as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PDCRG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PUCRH as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PUCRH)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_TypeDef>())).PDCRH as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(PDCRH)
        )
    );
}
#[doc = " @brief QUAD Serial Peripheral Interface"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QUADSPI_TypeDef {
    #[doc = "< QUADSPI Control register,                           Address offset: 0x00"]
    pub CR: u32,
    #[doc = "< QUADSPI Device Configuration register,              Address offset: 0x04"]
    pub DCR: u32,
    #[doc = "< QUADSPI Status register,                            Address offset: 0x08"]
    pub SR: u32,
    #[doc = "< QUADSPI Flag Clear register,                        Address offset: 0x0C"]
    pub FCR: u32,
    #[doc = "< QUADSPI Data Length register,                       Address offset: 0x10"]
    pub DLR: u32,
    #[doc = "< QUADSPI Communication Configuration register,       Address offset: 0x14"]
    pub CCR: u32,
    #[doc = "< QUADSPI Address register,                           Address offset: 0x18"]
    pub AR: u32,
    #[doc = "< QUADSPI Alternate Bytes register,                   Address offset: 0x1C"]
    pub ABR: u32,
    #[doc = "< QUADSPI Data register,                              Address offset: 0x20"]
    pub DR: u32,
    #[doc = "< QUADSPI Polling Status Mask register,               Address offset: 0x24"]
    pub PSMKR: u32,
    #[doc = "< QUADSPI Polling Status Match register,              Address offset: 0x28"]
    pub PSMAR: u32,
    #[doc = "< QUADSPI Polling Interval register,                  Address offset: 0x2C"]
    pub PIR: u32,
    #[doc = "< QUADSPI Low Power Timeout register,                 Address offset: 0x30"]
    pub LPTR: u32,
}
#[test]
fn bindgen_test_layout_QUADSPI_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<QUADSPI_TypeDef>(),
        52usize,
        concat!("Size of: ", stringify!(QUADSPI_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<QUADSPI_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(QUADSPI_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QUADSPI_TypeDef>())).CR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QUADSPI_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QUADSPI_TypeDef>())).DCR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(QUADSPI_TypeDef),
            "::",
            stringify!(DCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QUADSPI_TypeDef>())).SR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QUADSPI_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QUADSPI_TypeDef>())).FCR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(QUADSPI_TypeDef),
            "::",
            stringify!(FCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QUADSPI_TypeDef>())).DLR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(QUADSPI_TypeDef),
            "::",
            stringify!(DLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QUADSPI_TypeDef>())).CCR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(QUADSPI_TypeDef),
            "::",
            stringify!(CCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QUADSPI_TypeDef>())).AR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(QUADSPI_TypeDef),
            "::",
            stringify!(AR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QUADSPI_TypeDef>())).ABR as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(QUADSPI_TypeDef),
            "::",
            stringify!(ABR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QUADSPI_TypeDef>())).DR as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(QUADSPI_TypeDef),
            "::",
            stringify!(DR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QUADSPI_TypeDef>())).PSMKR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(QUADSPI_TypeDef),
            "::",
            stringify!(PSMKR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QUADSPI_TypeDef>())).PSMAR as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(QUADSPI_TypeDef),
            "::",
            stringify!(PSMAR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QUADSPI_TypeDef>())).PIR as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(QUADSPI_TypeDef),
            "::",
            stringify!(PIR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QUADSPI_TypeDef>())).LPTR as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(QUADSPI_TypeDef),
            "::",
            stringify!(LPTR)
        )
    );
}
#[doc = " @brief Reset and Clock Control"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RCC_TypeDef {
    #[doc = "< RCC clock control register,                                              Address offset: 0x00"]
    pub CR: u32,
    #[doc = "< RCC internal clock sources calibration register,                         Address offset: 0x04"]
    pub ICSCR: u32,
    #[doc = "< RCC clock configuration register,                                        Address offset: 0x08"]
    pub CFGR: u32,
    #[doc = "< RCC system PLL configuration register,                                   Address offset: 0x0C"]
    pub PLLCFGR: u32,
    #[doc = "< RCC PLL SAI1 configuration register,                                     Address offset: 0x10"]
    pub PLLSAI1CFGR: u32,
    #[doc = "< RCC PLL SAI2 configuration register,                                     Address offset: 0x14"]
    pub PLLSAI2CFGR: u32,
    #[doc = "< RCC clock interrupt enable register,                                     Address offset: 0x18"]
    pub CIER: u32,
    #[doc = "< RCC clock interrupt flag register,                                       Address offset: 0x1C"]
    pub CIFR: u32,
    #[doc = "< RCC clock interrupt clear register,                                      Address offset: 0x20"]
    pub CICR: u32,
    #[doc = "< Reserved,                                                                Address offset: 0x24"]
    pub RESERVED0: u32,
    #[doc = "< RCC AHB1 peripheral reset register,                                      Address offset: 0x28"]
    pub AHB1RSTR: u32,
    #[doc = "< RCC AHB2 peripheral reset register,                                      Address offset: 0x2C"]
    pub AHB2RSTR: u32,
    #[doc = "< RCC AHB3 peripheral reset register,                                      Address offset: 0x30"]
    pub AHB3RSTR: u32,
    #[doc = "< Reserved,                                                                Address offset: 0x34"]
    pub RESERVED1: u32,
    #[doc = "< RCC APB1 peripheral reset register 1,                                    Address offset: 0x38"]
    pub APB1RSTR1: u32,
    #[doc = "< RCC APB1 peripheral reset register 2,                                    Address offset: 0x3C"]
    pub APB1RSTR2: u32,
    #[doc = "< RCC APB2 peripheral reset register,                                      Address offset: 0x40"]
    pub APB2RSTR: u32,
    #[doc = "< Reserved,                                                                Address offset: 0x44"]
    pub RESERVED2: u32,
    #[doc = "< RCC AHB1 peripheral clocks enable register,                              Address offset: 0x48"]
    pub AHB1ENR: u32,
    #[doc = "< RCC AHB2 peripheral clocks enable register,                              Address offset: 0x4C"]
    pub AHB2ENR: u32,
    #[doc = "< RCC AHB3 peripheral clocks enable register,                              Address offset: 0x50"]
    pub AHB3ENR: u32,
    #[doc = "< Reserved,                                                                Address offset: 0x54"]
    pub RESERVED3: u32,
    #[doc = "< RCC APB1 peripheral clocks enable register 1,                            Address offset: 0x58"]
    pub APB1ENR1: u32,
    #[doc = "< RCC APB1 peripheral clocks enable register 2,                            Address offset: 0x5C"]
    pub APB1ENR2: u32,
    #[doc = "< RCC APB2 peripheral clocks enable register,                              Address offset: 0x60"]
    pub APB2ENR: u32,
    #[doc = "< Reserved,                                                                Address offset: 0x64"]
    pub RESERVED4: u32,
    #[doc = "< RCC AHB1 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x68"]
    pub AHB1SMENR: u32,
    #[doc = "< RCC AHB2 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x6C"]
    pub AHB2SMENR: u32,
    #[doc = "< RCC AHB3 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x70"]
    pub AHB3SMENR: u32,
    #[doc = "< Reserved,                                                                Address offset: 0x74"]
    pub RESERVED5: u32,
    #[doc = "< RCC APB1 peripheral clocks enable in sleep mode and stop modes register 1, Address offset: 0x78"]
    pub APB1SMENR1: u32,
    #[doc = "< RCC APB1 peripheral clocks enable in sleep mode and stop modes register 2, Address offset: 0x7C"]
    pub APB1SMENR2: u32,
    #[doc = "< RCC APB2 peripheral clocks enable in sleep mode and stop modes register, Address offset: 0x80"]
    pub APB2SMENR: u32,
    #[doc = "< Reserved,                                                                Address offset: 0x84"]
    pub RESERVED6: u32,
    #[doc = "< RCC peripherals independent clock configuration register,                Address offset: 0x88"]
    pub CCIPR: u32,
    #[doc = "< Reserved,                                                                Address offset: 0x8C"]
    pub RESERVED7: u32,
    #[doc = "< RCC backup domain control register,                                      Address offset: 0x90"]
    pub BDCR: u32,
    #[doc = "< RCC clock control & status register,                                     Address offset: 0x94"]
    pub CSR: u32,
}
#[test]
fn bindgen_test_layout_RCC_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RCC_TypeDef>(),
        152usize,
        concat!("Size of: ", stringify!(RCC_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RCC_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RCC_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).CR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).ICSCR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(ICSCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).CFGR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(CFGR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).PLLCFGR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(PLLCFGR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).PLLSAI1CFGR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(PLLSAI1CFGR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).PLLSAI2CFGR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(PLLSAI2CFGR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).CIER as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(CIER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).CIFR as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(CIFR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).CICR as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(CICR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).RESERVED0 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).AHB1RSTR as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(AHB1RSTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).AHB2RSTR as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(AHB2RSTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).AHB3RSTR as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(AHB3RSTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).RESERVED1 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).APB1RSTR1 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(APB1RSTR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).APB1RSTR2 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(APB1RSTR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).APB2RSTR as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(APB2RSTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).RESERVED2 as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).AHB1ENR as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(AHB1ENR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).AHB2ENR as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(AHB2ENR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).AHB3ENR as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(AHB3ENR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).RESERVED3 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).APB1ENR1 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(APB1ENR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).APB1ENR2 as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(APB1ENR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).APB2ENR as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(APB2ENR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).RESERVED4 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).AHB1SMENR as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(AHB1SMENR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).AHB2SMENR as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(AHB2SMENR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).AHB3SMENR as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(AHB3SMENR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).RESERVED5 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(RESERVED5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).APB1SMENR1 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(APB1SMENR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).APB1SMENR2 as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(APB1SMENR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).APB2SMENR as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(APB2SMENR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).RESERVED6 as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(RESERVED6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).CCIPR as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(CCIPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).RESERVED7 as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(RESERVED7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).BDCR as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(BDCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_TypeDef>())).CSR as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(CSR)
        )
    );
}
#[doc = " @brief Real-Time Clock"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTC_TypeDef {
    #[doc = "< RTC time register,                                         Address offset: 0x00"]
    pub TR: u32,
    #[doc = "< RTC date register,                                         Address offset: 0x04"]
    pub DR: u32,
    #[doc = "< RTC control register,                                      Address offset: 0x08"]
    pub CR: u32,
    #[doc = "< RTC initialization and status register,                    Address offset: 0x0C"]
    pub ISR: u32,
    #[doc = "< RTC prescaler register,                                    Address offset: 0x10"]
    pub PRER: u32,
    #[doc = "< RTC wakeup timer register,                                 Address offset: 0x14"]
    pub WUTR: u32,
    #[doc = "< Reserved"]
    pub reserved: u32,
    #[doc = "< RTC alarm A register,                                      Address offset: 0x1C"]
    pub ALRMAR: u32,
    #[doc = "< RTC alarm B register,                                      Address offset: 0x20"]
    pub ALRMBR: u32,
    #[doc = "< RTC write protection register,                             Address offset: 0x24"]
    pub WPR: u32,
    #[doc = "< RTC sub second register,                                   Address offset: 0x28"]
    pub SSR: u32,
    #[doc = "< RTC shift control register,                                Address offset: 0x2C"]
    pub SHIFTR: u32,
    #[doc = "< RTC time stamp time register,                              Address offset: 0x30"]
    pub TSTR: u32,
    #[doc = "< RTC time stamp date register,                              Address offset: 0x34"]
    pub TSDR: u32,
    #[doc = "< RTC time-stamp sub second register,                        Address offset: 0x38"]
    pub TSSSR: u32,
    #[doc = "< RTC calibration register,                                  Address offset: 0x3C"]
    pub CALR: u32,
    #[doc = "< RTC tamper configuration register,                         Address offset: 0x40"]
    pub TAMPCR: u32,
    #[doc = "< RTC alarm A sub second register,                           Address offset: 0x44"]
    pub ALRMASSR: u32,
    #[doc = "< RTC alarm B sub second register,                           Address offset: 0x48"]
    pub ALRMBSSR: u32,
    #[doc = "< RTC option register,                                       Address offset: 0x4C"]
    pub OR: u32,
    #[doc = "< RTC backup register 0,                                     Address offset: 0x50"]
    pub BKP0R: u32,
    #[doc = "< RTC backup register 1,                                     Address offset: 0x54"]
    pub BKP1R: u32,
    #[doc = "< RTC backup register 2,                                     Address offset: 0x58"]
    pub BKP2R: u32,
    #[doc = "< RTC backup register 3,                                     Address offset: 0x5C"]
    pub BKP3R: u32,
    #[doc = "< RTC backup register 4,                                     Address offset: 0x60"]
    pub BKP4R: u32,
    #[doc = "< RTC backup register 5,                                     Address offset: 0x64"]
    pub BKP5R: u32,
    #[doc = "< RTC backup register 6,                                     Address offset: 0x68"]
    pub BKP6R: u32,
    #[doc = "< RTC backup register 7,                                     Address offset: 0x6C"]
    pub BKP7R: u32,
    #[doc = "< RTC backup register 8,                                     Address offset: 0x70"]
    pub BKP8R: u32,
    #[doc = "< RTC backup register 9,                                     Address offset: 0x74"]
    pub BKP9R: u32,
    #[doc = "< RTC backup register 10,                                    Address offset: 0x78"]
    pub BKP10R: u32,
    #[doc = "< RTC backup register 11,                                    Address offset: 0x7C"]
    pub BKP11R: u32,
    #[doc = "< RTC backup register 12,                                    Address offset: 0x80"]
    pub BKP12R: u32,
    #[doc = "< RTC backup register 13,                                    Address offset: 0x84"]
    pub BKP13R: u32,
    #[doc = "< RTC backup register 14,                                    Address offset: 0x88"]
    pub BKP14R: u32,
    #[doc = "< RTC backup register 15,                                    Address offset: 0x8C"]
    pub BKP15R: u32,
    #[doc = "< RTC backup register 16,                                    Address offset: 0x90"]
    pub BKP16R: u32,
    #[doc = "< RTC backup register 17,                                    Address offset: 0x94"]
    pub BKP17R: u32,
    #[doc = "< RTC backup register 18,                                    Address offset: 0x98"]
    pub BKP18R: u32,
    #[doc = "< RTC backup register 19,                                    Address offset: 0x9C"]
    pub BKP19R: u32,
    #[doc = "< RTC backup register 20,                                    Address offset: 0xA0"]
    pub BKP20R: u32,
    #[doc = "< RTC backup register 21,                                    Address offset: 0xA4"]
    pub BKP21R: u32,
    #[doc = "< RTC backup register 22,                                    Address offset: 0xA8"]
    pub BKP22R: u32,
    #[doc = "< RTC backup register 23,                                    Address offset: 0xAC"]
    pub BKP23R: u32,
    #[doc = "< RTC backup register 24,                                    Address offset: 0xB0"]
    pub BKP24R: u32,
    #[doc = "< RTC backup register 25,                                    Address offset: 0xB4"]
    pub BKP25R: u32,
    #[doc = "< RTC backup register 26,                                    Address offset: 0xB8"]
    pub BKP26R: u32,
    #[doc = "< RTC backup register 27,                                    Address offset: 0xBC"]
    pub BKP27R: u32,
    #[doc = "< RTC backup register 28,                                    Address offset: 0xC0"]
    pub BKP28R: u32,
    #[doc = "< RTC backup register 29,                                    Address offset: 0xC4"]
    pub BKP29R: u32,
    #[doc = "< RTC backup register 30,                                    Address offset: 0xC8"]
    pub BKP30R: u32,
    #[doc = "< RTC backup register 31,                                    Address offset: 0xCC"]
    pub BKP31R: u32,
}
#[test]
fn bindgen_test_layout_RTC_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RTC_TypeDef>(),
        208usize,
        concat!("Size of: ", stringify!(RTC_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).TR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).DR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(DR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).CR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).ISR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).PRER as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(PRER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).WUTR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(WUTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).reserved as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).ALRMAR as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMAR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).ALRMBR as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMBR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).WPR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(WPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).SSR as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(SSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).SHIFTR as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(SHIFTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).TSTR as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TSTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).TSDR as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TSDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).TSSSR as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TSSSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).CALR as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(CALR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).TAMPCR as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TAMPCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).ALRMASSR as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMASSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).ALRMBSSR as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMBSSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).OR as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(OR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP0R as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP0R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP1R as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP1R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP2R as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP2R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP3R as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP3R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP4R as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP4R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP5R as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP5R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP6R as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP6R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP7R as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP7R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP8R as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP8R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP9R as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP9R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP10R as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP10R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP11R as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP11R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP12R as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP12R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP13R as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP13R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP14R as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP14R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP15R as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP15R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP16R as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP16R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP17R as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP17R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP18R as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP18R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP19R as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP19R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP20R as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP20R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP21R as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP21R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP22R as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP22R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP23R as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP23R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP24R as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP24R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP25R as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP25R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP26R as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP26R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP27R as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP27R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP28R as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP28R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP29R as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP29R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP30R as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP30R)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TypeDef>())).BKP31R as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP31R)
        )
    );
}
#[doc = " @brief Serial Audio Interface"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SAI_TypeDef {
    #[doc = "< SAI global configuration register,        Address offset: 0x00"]
    pub GCR: u32,
}
#[test]
fn bindgen_test_layout_SAI_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SAI_TypeDef>(),
        4usize,
        concat!("Size of: ", stringify!(SAI_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SAI_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SAI_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_TypeDef>())).GCR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_TypeDef),
            "::",
            stringify!(GCR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SAI_Block_TypeDef {
    #[doc = "< SAI block x configuration register 1,     Address offset: 0x04"]
    pub CR1: u32,
    #[doc = "< SAI block x configuration register 2,     Address offset: 0x08"]
    pub CR2: u32,
    #[doc = "< SAI block x frame configuration register, Address offset: 0x0C"]
    pub FRCR: u32,
    #[doc = "< SAI block x slot register,                Address offset: 0x10"]
    pub SLOTR: u32,
    #[doc = "< SAI block x interrupt mask register,      Address offset: 0x14"]
    pub IMR: u32,
    #[doc = "< SAI block x status register,              Address offset: 0x18"]
    pub SR: u32,
    #[doc = "< SAI block x clear flag register,          Address offset: 0x1C"]
    pub CLRFR: u32,
    #[doc = "< SAI block x data register,                Address offset: 0x20"]
    pub DR: u32,
}
#[test]
fn bindgen_test_layout_SAI_Block_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SAI_Block_TypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(SAI_Block_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SAI_Block_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SAI_Block_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_Block_TypeDef>())).CR1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_Block_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_Block_TypeDef>())).CR2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_Block_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_Block_TypeDef>())).FRCR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_Block_TypeDef),
            "::",
            stringify!(FRCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_Block_TypeDef>())).SLOTR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_Block_TypeDef),
            "::",
            stringify!(SLOTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_Block_TypeDef>())).IMR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_Block_TypeDef),
            "::",
            stringify!(IMR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_Block_TypeDef>())).SR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_Block_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_Block_TypeDef>())).CLRFR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_Block_TypeDef),
            "::",
            stringify!(CLRFR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_Block_TypeDef>())).DR as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_Block_TypeDef),
            "::",
            stringify!(DR)
        )
    );
}
#[doc = " @brief Secure digital input/output Interface"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDMMC_TypeDef {
    #[doc = "< SDMMC power control register,    Address offset: 0x00"]
    pub POWER: u32,
    #[doc = "< SDMMC clock control register,    Address offset: 0x04"]
    pub CLKCR: u32,
    #[doc = "< SDMMC argument register,         Address offset: 0x08"]
    pub ARG: u32,
    #[doc = "< SDMMC command register,          Address offset: 0x0C"]
    pub CMD: u32,
    #[doc = "< SDMMC command response register, Address offset: 0x10"]
    pub RESPCMD: u32,
    #[doc = "< SDMMC response 1 register,       Address offset: 0x14"]
    pub RESP1: u32,
    #[doc = "< SDMMC response 2 register,       Address offset: 0x18"]
    pub RESP2: u32,
    #[doc = "< SDMMC response 3 register,       Address offset: 0x1C"]
    pub RESP3: u32,
    #[doc = "< SDMMC response 4 register,       Address offset: 0x20"]
    pub RESP4: u32,
    #[doc = "< SDMMC data timer register,       Address offset: 0x24"]
    pub DTIMER: u32,
    #[doc = "< SDMMC data length register,      Address offset: 0x28"]
    pub DLEN: u32,
    #[doc = "< SDMMC data control register,     Address offset: 0x2C"]
    pub DCTRL: u32,
    #[doc = "< SDMMC data counter register,     Address offset: 0x30"]
    pub DCOUNT: u32,
    #[doc = "< SDMMC status register,           Address offset: 0x34"]
    pub STA: u32,
    #[doc = "< SDMMC interrupt clear register,  Address offset: 0x38"]
    pub ICR: u32,
    #[doc = "< SDMMC mask register,             Address offset: 0x3C"]
    pub MASK: u32,
    #[doc = "< Reserved, 0x40-0x44"]
    pub RESERVED0: [u32; 2usize],
    #[doc = "< SDMMC FIFO counter register,     Address offset: 0x48"]
    pub FIFOCNT: u32,
    #[doc = "< Reserved, 0x4C-0x7C"]
    pub RESERVED1: [u32; 13usize],
    #[doc = "< SDMMC data FIFO register,        Address offset: 0x80"]
    pub FIFO: u32,
}
#[test]
fn bindgen_test_layout_SDMMC_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SDMMC_TypeDef>(),
        132usize,
        concat!("Size of: ", stringify!(SDMMC_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SDMMC_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SDMMC_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).POWER as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(POWER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).CLKCR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(CLKCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).ARG as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(ARG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).CMD as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(CMD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).RESPCMD as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(RESPCMD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).RESP1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(RESP1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).RESP2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(RESP2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).RESP3 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(RESP3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).RESP4 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(RESP4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).DTIMER as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(DTIMER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).DLEN as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(DLEN)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).DCTRL as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(DCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).DCOUNT as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(DCOUNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).STA as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(STA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).ICR as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).MASK as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(MASK)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).RESERVED0 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).FIFOCNT as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(FIFOCNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).RESERVED1 as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_TypeDef>())).FIFO as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_TypeDef),
            "::",
            stringify!(FIFO)
        )
    );
}
#[doc = " @brief Serial Peripheral Interface"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SPI_TypeDef {
    #[doc = "< SPI Control register 1,                              Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< SPI Control register 2,                              Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< SPI Status register,                                 Address offset: 0x08"]
    pub SR: u32,
    #[doc = "< SPI data register,                                   Address offset: 0x0C"]
    pub DR: u32,
    #[doc = "< SPI CRC polynomial register,                         Address offset: 0x10"]
    pub CRCPR: u32,
    #[doc = "< SPI Rx CRC register,                                 Address offset: 0x14"]
    pub RXCRCR: u32,
    #[doc = "< SPI Tx CRC register,                                 Address offset: 0x18"]
    pub TXCRCR: u32,
}
#[test]
fn bindgen_test_layout_SPI_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SPI_TypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(SPI_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SPI_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SPI_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_TypeDef>())).CR1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_TypeDef>())).CR2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_TypeDef>())).SR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_TypeDef>())).DR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(DR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_TypeDef>())).CRCPR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(CRCPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_TypeDef>())).RXCRCR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(RXCRCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_TypeDef>())).TXCRCR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(TXCRCR)
        )
    );
}
#[doc = " @brief Single Wire Protocol Master Interface SPWMI"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SWPMI_TypeDef {
    #[doc = "< SWPMI Configuration/Control register,     Address offset: 0x00"]
    pub CR: u32,
    #[doc = "< SWPMI bitrate register,                   Address offset: 0x04"]
    pub BRR: u32,
    #[doc = "< Reserved, 0x08"]
    pub RESERVED1: u32,
    #[doc = "< SWPMI Interrupt and Status register,      Address offset: 0x0C"]
    pub ISR: u32,
    #[doc = "< SWPMI Interrupt Flag Clear register,      Address offset: 0x10"]
    pub ICR: u32,
    #[doc = "< SWPMI Interrupt Enable register,          Address offset: 0x14"]
    pub IER: u32,
    #[doc = "< SWPMI Receive Frame Length register,      Address offset: 0x18"]
    pub RFL: u32,
    #[doc = "< SWPMI Transmit data register,             Address offset: 0x1C"]
    pub TDR: u32,
    #[doc = "< SWPMI Receive data register,              Address offset: 0x20"]
    pub RDR: u32,
    #[doc = "< SWPMI Option register,                    Address offset: 0x24"]
    pub OR: u32,
}
#[test]
fn bindgen_test_layout_SWPMI_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SWPMI_TypeDef>(),
        40usize,
        concat!("Size of: ", stringify!(SWPMI_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SWPMI_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SWPMI_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_TypeDef>())).CR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_TypeDef>())).BRR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_TypeDef),
            "::",
            stringify!(BRR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_TypeDef>())).RESERVED1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_TypeDef>())).ISR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_TypeDef>())).ICR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_TypeDef>())).IER as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_TypeDef),
            "::",
            stringify!(IER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_TypeDef>())).RFL as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_TypeDef),
            "::",
            stringify!(RFL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_TypeDef>())).TDR as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_TypeDef),
            "::",
            stringify!(TDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_TypeDef>())).RDR as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_TypeDef),
            "::",
            stringify!(RDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_TypeDef>())).OR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_TypeDef),
            "::",
            stringify!(OR)
        )
    );
}
#[doc = " @brief System configuration controller"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SYSCFG_TypeDef {
    #[doc = "< SYSCFG memory remap register,                      Address offset: 0x00"]
    pub MEMRMP: u32,
    #[doc = "< SYSCFG configuration register 1,                   Address offset: 0x04"]
    pub CFGR1: u32,
    #[doc = "< SYSCFG external interrupt configuration registers, Address offset: 0x08-0x14"]
    pub EXTICR: [u32; 4usize],
    #[doc = "< SYSCFG SRAM2 control and status register,          Address offset: 0x18"]
    pub SCSR: u32,
    #[doc = "< SYSCFG configuration register 2,                   Address offset: 0x1C"]
    pub CFGR2: u32,
    #[doc = "< SYSCFG SRAM2 write protection register,            Address offset: 0x20"]
    pub SWPR: u32,
    #[doc = "< SYSCFG SRAM2 key register,                         Address offset: 0x24"]
    pub SKR: u32,
}
#[test]
fn bindgen_test_layout_SYSCFG_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SYSCFG_TypeDef>(),
        40usize,
        concat!("Size of: ", stringify!(SYSCFG_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCFG_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSCFG_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCFG_TypeDef>())).MEMRMP as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCFG_TypeDef),
            "::",
            stringify!(MEMRMP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCFG_TypeDef>())).CFGR1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCFG_TypeDef),
            "::",
            stringify!(CFGR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCFG_TypeDef>())).EXTICR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCFG_TypeDef),
            "::",
            stringify!(EXTICR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCFG_TypeDef>())).SCSR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCFG_TypeDef),
            "::",
            stringify!(SCSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCFG_TypeDef>())).CFGR2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCFG_TypeDef),
            "::",
            stringify!(CFGR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCFG_TypeDef>())).SWPR as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCFG_TypeDef),
            "::",
            stringify!(SWPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCFG_TypeDef>())).SKR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCFG_TypeDef),
            "::",
            stringify!(SKR)
        )
    );
}
#[doc = " @brief TIM"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TIM_TypeDef {
    #[doc = "< TIM control register 1,                   Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< TIM control register 2,                   Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< TIM slave mode control register,          Address offset: 0x08"]
    pub SMCR: u32,
    #[doc = "< TIM DMA/interrupt enable register,        Address offset: 0x0C"]
    pub DIER: u32,
    #[doc = "< TIM status register,                      Address offset: 0x10"]
    pub SR: u32,
    #[doc = "< TIM event generation register,            Address offset: 0x14"]
    pub EGR: u32,
    #[doc = "< TIM capture/compare mode register 1,      Address offset: 0x18"]
    pub CCMR1: u32,
    #[doc = "< TIM capture/compare mode register 2,      Address offset: 0x1C"]
    pub CCMR2: u32,
    #[doc = "< TIM capture/compare enable register,      Address offset: 0x20"]
    pub CCER: u32,
    #[doc = "< TIM counter register,                     Address offset: 0x24"]
    pub CNT: u32,
    #[doc = "< TIM prescaler,                            Address offset: 0x28"]
    pub PSC: u32,
    #[doc = "< TIM auto-reload register,                 Address offset: 0x2C"]
    pub ARR: u32,
    #[doc = "< TIM repetition counter register,          Address offset: 0x30"]
    pub RCR: u32,
    #[doc = "< TIM capture/compare register 1,           Address offset: 0x34"]
    pub CCR1: u32,
    #[doc = "< TIM capture/compare register 2,           Address offset: 0x38"]
    pub CCR2: u32,
    #[doc = "< TIM capture/compare register 3,           Address offset: 0x3C"]
    pub CCR3: u32,
    #[doc = "< TIM capture/compare register 4,           Address offset: 0x40"]
    pub CCR4: u32,
    #[doc = "< TIM break and dead-time register,         Address offset: 0x44"]
    pub BDTR: u32,
    #[doc = "< TIM DMA control register,                 Address offset: 0x48"]
    pub DCR: u32,
    #[doc = "< TIM DMA address for full transfer,        Address offset: 0x4C"]
    pub DMAR: u32,
    #[doc = "< TIM option register 1,                    Address offset: 0x50"]
    pub OR1: u32,
    #[doc = "< TIM capture/compare mode register 3,      Address offset: 0x54"]
    pub CCMR3: u32,
    #[doc = "< TIM capture/compare register5,            Address offset: 0x58"]
    pub CCR5: u32,
    #[doc = "< TIM capture/compare register6,            Address offset: 0x5C"]
    pub CCR6: u32,
    #[doc = "< TIM option register 2,                    Address offset: 0x60"]
    pub OR2: u32,
    #[doc = "< TIM option register 3,                    Address offset: 0x64"]
    pub OR3: u32,
}
#[test]
fn bindgen_test_layout_TIM_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TIM_TypeDef>(),
        104usize,
        concat!("Size of: ", stringify!(TIM_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).CR1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).CR2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).SMCR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(SMCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).DIER as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(DIER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).SR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).EGR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(EGR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).CCMR1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCMR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).CCMR2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCMR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).CCER as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).CNT as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).PSC as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(PSC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).ARR as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(ARR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).RCR as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(RCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).CCR1 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).CCR2 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).CCR3 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).CCR4 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).BDTR as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(BDTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).DCR as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(DCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).DMAR as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(DMAR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).OR1 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(OR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).CCMR3 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCMR3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).CCR5 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).CCR6 as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).OR2 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(OR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_TypeDef>())).OR3 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(OR3)
        )
    );
}
#[doc = " @brief Touch Sensing Controller (TSC)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TSC_TypeDef {
    #[doc = "< TSC control register,                                     Address offset: 0x00"]
    pub CR: u32,
    #[doc = "< TSC interrupt enable register,                            Address offset: 0x04"]
    pub IER: u32,
    #[doc = "< TSC interrupt clear register,                             Address offset: 0x08"]
    pub ICR: u32,
    #[doc = "< TSC interrupt status register,                            Address offset: 0x0C"]
    pub ISR: u32,
    #[doc = "< TSC I/O hysteresis control register,                      Address offset: 0x10"]
    pub IOHCR: u32,
    #[doc = "< Reserved,                                                 Address offset: 0x14"]
    pub RESERVED1: u32,
    #[doc = "< TSC I/O analog switch control register,                   Address offset: 0x18"]
    pub IOASCR: u32,
    #[doc = "< Reserved,                                                 Address offset: 0x1C"]
    pub RESERVED2: u32,
    #[doc = "< TSC I/O sampling control register,                        Address offset: 0x20"]
    pub IOSCR: u32,
    #[doc = "< Reserved,                                                 Address offset: 0x24"]
    pub RESERVED3: u32,
    #[doc = "< TSC I/O channel control register,                         Address offset: 0x28"]
    pub IOCCR: u32,
    #[doc = "< Reserved,                                                 Address offset: 0x2C"]
    pub RESERVED4: u32,
    #[doc = "< TSC I/O group control status register,                    Address offset: 0x30"]
    pub IOGCSR: u32,
    #[doc = "< TSC I/O group x counter register,                         Address offset: 0x34-50"]
    pub IOGXCR: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_TSC_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TSC_TypeDef>(),
        84usize,
        concat!("Size of: ", stringify!(TSC_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TSC_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TSC_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_TypeDef>())).CR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_TypeDef>())).IER as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_TypeDef),
            "::",
            stringify!(IER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_TypeDef>())).ICR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_TypeDef>())).ISR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_TypeDef>())).IOHCR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_TypeDef),
            "::",
            stringify!(IOHCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_TypeDef>())).RESERVED1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_TypeDef>())).IOASCR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_TypeDef),
            "::",
            stringify!(IOASCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_TypeDef>())).RESERVED2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_TypeDef),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_TypeDef>())).IOSCR as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_TypeDef),
            "::",
            stringify!(IOSCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_TypeDef>())).RESERVED3 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_TypeDef),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_TypeDef>())).IOCCR as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_TypeDef),
            "::",
            stringify!(IOCCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_TypeDef>())).RESERVED4 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_TypeDef),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_TypeDef>())).IOGCSR as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_TypeDef),
            "::",
            stringify!(IOGCSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_TypeDef>())).IOGXCR as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_TypeDef),
            "::",
            stringify!(IOGXCR)
        )
    );
}
#[doc = " @brief Universal Synchronous Asynchronous Receiver Transmitter"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USART_TypeDef {
    #[doc = "< USART Control register 1,                 Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< USART Control register 2,                 Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< USART Control register 3,                 Address offset: 0x08"]
    pub CR3: u32,
    #[doc = "< USART Baud rate register,                 Address offset: 0x0C"]
    pub BRR: u32,
    #[doc = "< USART Guard time and prescaler register,  Address offset: 0x10"]
    pub GTPR: u16,
    #[doc = "< Reserved, 0x12"]
    pub RESERVED2: u16,
    #[doc = "< USART Receiver Time Out register,         Address offset: 0x14"]
    pub RTOR: u32,
    #[doc = "< USART Request register,                   Address offset: 0x18"]
    pub RQR: u16,
    #[doc = "< Reserved, 0x1A"]
    pub RESERVED3: u16,
    #[doc = "< USART Interrupt and status register,      Address offset: 0x1C"]
    pub ISR: u32,
    #[doc = "< USART Interrupt flag Clear register,      Address offset: 0x20"]
    pub ICR: u32,
    #[doc = "< USART Receive Data register,              Address offset: 0x24"]
    pub RDR: u16,
    #[doc = "< Reserved, 0x26"]
    pub RESERVED4: u16,
    #[doc = "< USART Transmit Data register,             Address offset: 0x28"]
    pub TDR: u16,
    #[doc = "< Reserved, 0x2A"]
    pub RESERVED5: u16,
}
#[test]
fn bindgen_test_layout_USART_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<USART_TypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(USART_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USART_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USART_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_TypeDef>())).CR1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_TypeDef>())).CR2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_TypeDef>())).CR3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(CR3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_TypeDef>())).BRR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(BRR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_TypeDef>())).GTPR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(GTPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_TypeDef>())).RESERVED2 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_TypeDef>())).RTOR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RTOR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_TypeDef>())).RQR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RQR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_TypeDef>())).RESERVED3 as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_TypeDef>())).ISR as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_TypeDef>())).ICR as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_TypeDef>())).RDR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_TypeDef>())).RESERVED4 as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_TypeDef>())).TDR as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(TDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_TypeDef>())).RESERVED5 as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RESERVED5)
        )
    );
}
#[doc = " @brief VREFBUF"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VREFBUF_TypeDef {
    #[doc = "< VREFBUF control and status register,         Address offset: 0x00"]
    pub CSR: u32,
    #[doc = "< VREFBUF calibration and control register,    Address offset: 0x04"]
    pub CCR: u32,
}
#[test]
fn bindgen_test_layout_VREFBUF_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<VREFBUF_TypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(VREFBUF_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<VREFBUF_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(VREFBUF_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VREFBUF_TypeDef>())).CSR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VREFBUF_TypeDef),
            "::",
            stringify!(CSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VREFBUF_TypeDef>())).CCR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VREFBUF_TypeDef),
            "::",
            stringify!(CCR)
        )
    );
}
#[doc = " @brief Window WATCHDOG"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WWDG_TypeDef {
    #[doc = "< WWDG Control register,       Address offset: 0x00"]
    pub CR: u32,
    #[doc = "< WWDG Configuration register, Address offset: 0x04"]
    pub CFR: u32,
    #[doc = "< WWDG Status register,        Address offset: 0x08"]
    pub SR: u32,
}
#[test]
fn bindgen_test_layout_WWDG_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<WWDG_TypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(WWDG_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<WWDG_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(WWDG_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WWDG_TypeDef>())).CR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WWDG_TypeDef>())).CFR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_TypeDef),
            "::",
            stringify!(CFR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WWDG_TypeDef>())).SR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_TypeDef),
            "::",
            stringify!(SR)
        )
    );
}
#[doc = " @brief RNG"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RNG_TypeDef {
    #[doc = "< RNG control register, Address offset: 0x00"]
    pub CR: u32,
    #[doc = "< RNG status register,  Address offset: 0x04"]
    pub SR: u32,
    #[doc = "< RNG data register,    Address offset: 0x08"]
    pub DR: u32,
}
#[test]
fn bindgen_test_layout_RNG_TypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RNG_TypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(RNG_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RNG_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RNG_TypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RNG_TypeDef>())).CR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RNG_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RNG_TypeDef>())).SR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RNG_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RNG_TypeDef>())).DR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RNG_TypeDef),
            "::",
            stringify!(DR)
        )
    );
}
#[doc = " @brief USB_OTG_Core_register"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USB_OTG_GlobalTypeDef {
    #[doc = "<  USB_OTG Control and Status Register          000h"]
    pub GOTGCTL: u32,
    #[doc = "<  USB_OTG Interrupt Register                   004h"]
    pub GOTGINT: u32,
    #[doc = "<  Core AHB Configuration Register              008h"]
    pub GAHBCFG: u32,
    #[doc = "<  Core USB Configuration Register              00Ch"]
    pub GUSBCFG: u32,
    #[doc = "<  Core Reset Register                          010h"]
    pub GRSTCTL: u32,
    #[doc = "<  Core Interrupt Register                      014h"]
    pub GINTSTS: u32,
    #[doc = "<  Core Interrupt Mask Register                 018h"]
    pub GINTMSK: u32,
    #[doc = "<  Receive Sts Q Read Register                  01Ch"]
    pub GRXSTSR: u32,
    #[doc = "<  Receive Sts Q Read & POP Register            020h"]
    pub GRXSTSP: u32,
    #[doc = "<  Receive FIFO Size Register                   024h"]
    pub GRXFSIZ: u32,
    #[doc = "<  EP0 / Non Periodic Tx FIFO Size Register     028h"]
    pub DIEPTXF0_HNPTXFSIZ: u32,
    #[doc = "<  Non Periodic Tx FIFO/Queue Sts reg           02Ch"]
    pub HNPTXSTS: u32,
    #[doc = "<  Reserved                                     030h"]
    pub Reserved30: [u32; 2usize],
    #[doc = "<  General Purpose IO Register                  038h"]
    pub GCCFG: u32,
    #[doc = "<  User ID Register                             03Ch"]
    pub CID: u32,
    #[doc = "<  USB_OTG core ID                              040h"]
    pub GSNPSID: u32,
    #[doc = "<  User HW config1                              044h"]
    pub GHWCFG1: u32,
    #[doc = "<  User HW config2                              048h"]
    pub GHWCFG2: u32,
    #[doc = "<  User HW config3                              04Ch"]
    pub GHWCFG3: u32,
    #[doc = "<  Reserved                                     050h"]
    pub Reserved6: u32,
    #[doc = "<  LPM Register                                 054h"]
    pub GLPMCFG: u32,
    #[doc = "<  Power Down Register                          058h"]
    pub GPWRDN: u32,
    #[doc = "<  DFIFO Software Config Register               05Ch"]
    pub GDFIFOCFG: u32,
    #[doc = "<  ADP Timer, Control and Status Register       060h"]
    pub GADPCTL: u32,
    #[doc = "<  Reserved                                064h-0FFh"]
    pub Reserved43: [u32; 39usize],
    #[doc = "<  Host Periodic Tx FIFO Size Reg               100h"]
    pub HPTXFSIZ: u32,
    #[doc = "<  dev Periodic Transmit FIFO"]
    pub DIEPTXF: [u32; 15usize],
}
#[test]
fn bindgen_test_layout_USB_OTG_GlobalTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<USB_OTG_GlobalTypeDef>(),
        320usize,
        concat!("Size of: ", stringify!(USB_OTG_GlobalTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_OTG_GlobalTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_OTG_GlobalTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GOTGCTL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GOTGCTL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GOTGINT as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GOTGINT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GAHBCFG as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GAHBCFG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GUSBCFG as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GUSBCFG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GRSTCTL as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GRSTCTL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GINTSTS as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GINTSTS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GINTMSK as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GINTMSK)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GRXSTSR as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GRXSTSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GRXSTSP as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GRXSTSP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GRXFSIZ as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GRXFSIZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).DIEPTXF0_HNPTXFSIZ as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(DIEPTXF0_HNPTXFSIZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).HNPTXSTS as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(HNPTXSTS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).Reserved30 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(Reserved30)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GCCFG as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GCCFG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).CID as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(CID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GSNPSID as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GSNPSID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GHWCFG1 as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GHWCFG1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GHWCFG2 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GHWCFG2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GHWCFG3 as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GHWCFG3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).Reserved6 as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GLPMCFG as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GLPMCFG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GPWRDN as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GPWRDN)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GDFIFOCFG as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GDFIFOCFG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).GADPCTL as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(GADPCTL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).Reserved43 as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(Reserved43)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).HPTXFSIZ as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(HPTXFSIZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_GlobalTypeDef>())).DIEPTXF as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_GlobalTypeDef),
            "::",
            stringify!(DIEPTXF)
        )
    );
}
impl Default for USB_OTG_GlobalTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief USB_OTG_device_Registers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USB_OTG_DeviceTypeDef {
    pub DCFG: u32,
    pub DCTL: u32,
    pub DSTS: u32,
    pub Reserved0C: u32,
    pub DIEPMSK: u32,
    pub DOEPMSK: u32,
    pub DAINT: u32,
    pub DAINTMSK: u32,
    pub Reserved20: u32,
    pub Reserved24: u32,
    pub DVBUSDIS: u32,
    pub DVBUSPULSE: u32,
    pub DTHRCTL: u32,
    pub DIEPEMPMSK: u32,
    pub DEACHINT: u32,
    pub DEACHMSK: u32,
    pub Reserved40: u32,
    pub DINEP1MSK: u32,
    pub Reserved44: [u32; 15usize],
    pub DOUTEP1MSK: u32,
}
#[test]
fn bindgen_test_layout_USB_OTG_DeviceTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<USB_OTG_DeviceTypeDef>(),
        136usize,
        concat!("Size of: ", stringify!(USB_OTG_DeviceTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_OTG_DeviceTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_OTG_DeviceTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).DCFG as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(DCFG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).DCTL as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(DCTL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).DSTS as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(DSTS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).Reserved0C as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(Reserved0C)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).DIEPMSK as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(DIEPMSK)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).DOEPMSK as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(DOEPMSK)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).DAINT as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(DAINT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).DAINTMSK as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(DAINTMSK)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).Reserved20 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(Reserved20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).Reserved24 as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(Reserved24)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).DVBUSDIS as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(DVBUSDIS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).DVBUSPULSE as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(DVBUSPULSE)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).DTHRCTL as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(DTHRCTL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).DIEPEMPMSK as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(DIEPEMPMSK)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).DEACHINT as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(DEACHINT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).DEACHMSK as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(DEACHMSK)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).Reserved40 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(Reserved40)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).DINEP1MSK as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(DINEP1MSK)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).Reserved44 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(Reserved44)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_DeviceTypeDef>())).DOUTEP1MSK as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_DeviceTypeDef),
            "::",
            stringify!(DOUTEP1MSK)
        )
    );
}
#[doc = " @brief USB_OTG_IN_Endpoint-Specific_Register"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USB_OTG_INEndpointTypeDef {
    pub DIEPCTL: u32,
    pub Reserved04: u32,
    pub DIEPINT: u32,
    pub Reserved0C: u32,
    pub DIEPTSIZ: u32,
    pub DIEPDMA: u32,
    pub DTXFSTS: u32,
    pub Reserved18: u32,
}
#[test]
fn bindgen_test_layout_USB_OTG_INEndpointTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<USB_OTG_INEndpointTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(USB_OTG_INEndpointTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_OTG_INEndpointTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_OTG_INEndpointTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_INEndpointTypeDef>())).DIEPCTL as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_INEndpointTypeDef),
            "::",
            stringify!(DIEPCTL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_INEndpointTypeDef>())).Reserved04 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_INEndpointTypeDef),
            "::",
            stringify!(Reserved04)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_INEndpointTypeDef>())).DIEPINT as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_INEndpointTypeDef),
            "::",
            stringify!(DIEPINT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_INEndpointTypeDef>())).Reserved0C as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_INEndpointTypeDef),
            "::",
            stringify!(Reserved0C)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_INEndpointTypeDef>())).DIEPTSIZ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_INEndpointTypeDef),
            "::",
            stringify!(DIEPTSIZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_INEndpointTypeDef>())).DIEPDMA as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_INEndpointTypeDef),
            "::",
            stringify!(DIEPDMA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_INEndpointTypeDef>())).DTXFSTS as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_INEndpointTypeDef),
            "::",
            stringify!(DTXFSTS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_INEndpointTypeDef>())).Reserved18 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_INEndpointTypeDef),
            "::",
            stringify!(Reserved18)
        )
    );
}
#[doc = " @brief USB_OTG_OUT_Endpoint-Specific_Registers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USB_OTG_OUTEndpointTypeDef {
    pub DOEPCTL: u32,
    pub Reserved04: u32,
    pub DOEPINT: u32,
    pub Reserved0C: u32,
    pub DOEPTSIZ: u32,
    pub DOEPDMA: u32,
    pub Reserved18: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_USB_OTG_OUTEndpointTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<USB_OTG_OUTEndpointTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(USB_OTG_OUTEndpointTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_OTG_OUTEndpointTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_OTG_OUTEndpointTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_OUTEndpointTypeDef>())).DOEPCTL as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_OUTEndpointTypeDef),
            "::",
            stringify!(DOEPCTL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_OUTEndpointTypeDef>())).Reserved04 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_OUTEndpointTypeDef),
            "::",
            stringify!(Reserved04)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_OUTEndpointTypeDef>())).DOEPINT as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_OUTEndpointTypeDef),
            "::",
            stringify!(DOEPINT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_OUTEndpointTypeDef>())).Reserved0C as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_OUTEndpointTypeDef),
            "::",
            stringify!(Reserved0C)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_OUTEndpointTypeDef>())).DOEPTSIZ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_OUTEndpointTypeDef),
            "::",
            stringify!(DOEPTSIZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_OUTEndpointTypeDef>())).DOEPDMA as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_OUTEndpointTypeDef),
            "::",
            stringify!(DOEPDMA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_OUTEndpointTypeDef>())).Reserved18 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_OUTEndpointTypeDef),
            "::",
            stringify!(Reserved18)
        )
    );
}
#[doc = " @brief USB_OTG_Host_Mode_Register_Structures"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USB_OTG_HostTypeDef {
    pub HCFG: u32,
    pub HFIR: u32,
    pub HFNUM: u32,
    pub Reserved40C: u32,
    pub HPTXSTS: u32,
    pub HAINT: u32,
    pub HAINTMSK: u32,
}
#[test]
fn bindgen_test_layout_USB_OTG_HostTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<USB_OTG_HostTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(USB_OTG_HostTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_OTG_HostTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_OTG_HostTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HostTypeDef>())).HCFG as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HostTypeDef),
            "::",
            stringify!(HCFG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HostTypeDef>())).HFIR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HostTypeDef),
            "::",
            stringify!(HFIR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HostTypeDef>())).HFNUM as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HostTypeDef),
            "::",
            stringify!(HFNUM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_HostTypeDef>())).Reserved40C as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HostTypeDef),
            "::",
            stringify!(Reserved40C)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HostTypeDef>())).HPTXSTS as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HostTypeDef),
            "::",
            stringify!(HPTXSTS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HostTypeDef>())).HAINT as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HostTypeDef),
            "::",
            stringify!(HAINT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HostTypeDef>())).HAINTMSK as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HostTypeDef),
            "::",
            stringify!(HAINTMSK)
        )
    );
}
#[doc = " @brief USB_OTG_Host_Channel_Specific_Registers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USB_OTG_HostChannelTypeDef {
    pub HCCHAR: u32,
    pub HCSPLT: u32,
    pub HCINT: u32,
    pub HCINTMSK: u32,
    pub HCTSIZ: u32,
    pub HCDMA: u32,
    pub Reserved: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_USB_OTG_HostChannelTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<USB_OTG_HostChannelTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(USB_OTG_HostChannelTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_OTG_HostChannelTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_OTG_HostChannelTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_HostChannelTypeDef>())).HCCHAR as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HostChannelTypeDef),
            "::",
            stringify!(HCCHAR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_HostChannelTypeDef>())).HCSPLT as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HostChannelTypeDef),
            "::",
            stringify!(HCSPLT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_HostChannelTypeDef>())).HCINT as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HostChannelTypeDef),
            "::",
            stringify!(HCINT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_HostChannelTypeDef>())).HCINTMSK as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HostChannelTypeDef),
            "::",
            stringify!(HCINTMSK)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_HostChannelTypeDef>())).HCTSIZ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HostChannelTypeDef),
            "::",
            stringify!(HCTSIZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_HostChannelTypeDef>())).HCDMA as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HostChannelTypeDef),
            "::",
            stringify!(HCDMA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_HostChannelTypeDef>())).Reserved as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HostChannelTypeDef),
            "::",
            stringify!(Reserved)
        )
    );
}
pub const FlagStatus_RESET: FlagStatus = 0;
pub const FlagStatus_SET: FlagStatus = 1;
#[doc = " @addtogroup Exported_types"]
#[doc = " @{"]
pub type FlagStatus = libc::c_uint;
#[doc = " @addtogroup Exported_types"]
#[doc = " @{"]
pub use self::FlagStatus as ITStatus;
pub const FunctionalState_DISABLE: FunctionalState = 0;
pub const FunctionalState_ENABLE: FunctionalState = 1;
pub type FunctionalState = libc::c_uint;
pub const ErrorStatus_SUCCESS: ErrorStatus = 0;
pub const ErrorStatus_ERROR: ErrorStatus = 1;
pub type ErrorStatus = libc::c_uint;
pub type size_t = libc::c_uint;
pub type wchar_t = libc::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: libc::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub const HAL_StatusTypeDef_HAL_OK: HAL_StatusTypeDef = 0;
pub const HAL_StatusTypeDef_HAL_ERROR: HAL_StatusTypeDef = 1;
pub const HAL_StatusTypeDef_HAL_BUSY: HAL_StatusTypeDef = 2;
pub const HAL_StatusTypeDef_HAL_TIMEOUT: HAL_StatusTypeDef = 3;
#[doc = " @brief  HAL Status structures definition"]
pub type HAL_StatusTypeDef = libc::c_uint;
pub const HAL_LockTypeDef_HAL_UNLOCKED: HAL_LockTypeDef = 0;
pub const HAL_LockTypeDef_HAL_LOCKED: HAL_LockTypeDef = 1;
#[doc = " @brief  HAL Lock structures definition"]
pub type HAL_LockTypeDef = libc::c_uint;
#[doc = " @brief  RCC PLL configuration structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RCC_PLLInitTypeDef {
    #[doc = "< The new state of the PLL."]
    #[doc = "This parameter can be a value of @ref RCC_PLL_Config"]
    pub PLLState: u32,
    #[doc = "< RCC_PLLSource: PLL entry clock source."]
    #[doc = "This parameter must be a value of @ref RCC_PLL_Clock_Source"]
    pub PLLSource: u32,
    #[doc = "< PLLM: Division factor for PLL VCO input clock."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 16 on STM32L4Rx/STM32L4Sx devices."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 8 on the other devices"]
    pub PLLM: u32,
    #[doc = "< PLLN: Multiplication factor for PLL VCO output clock."]
    #[doc = "This parameter must be a number between Min_Data = 8 and Max_Data = 86"]
    pub PLLN: u32,
    #[doc = "< PLLP: Division factor for SAI clock."]
    #[doc = "This parameter must be a value of @ref RCC_PLLP_Clock_Divider"]
    pub PLLP: u32,
    #[doc = "< PLLQ: Division factor for SDMMC1, RNG and USB clocks."]
    #[doc = "This parameter must be a value of @ref RCC_PLLQ_Clock_Divider"]
    pub PLLQ: u32,
    #[doc = "< PLLR: Division for the main system clock."]
    #[doc = "User have to set the PLLR parameter correctly to not exceed max frequency 120MHZ"]
    #[doc = "on STM32L4Rx/STM32L4Sx devices else 80MHz on the other devices."]
    #[doc = "This parameter must be a value of @ref RCC_PLLR_Clock_Divider"]
    pub PLLR: u32,
}
#[test]
fn bindgen_test_layout_RCC_PLLInitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RCC_PLLInitTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(RCC_PLLInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RCC_PLLInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RCC_PLLInitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_PLLInitTypeDef>())).PLLState as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLInitTypeDef),
            "::",
            stringify!(PLLState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_PLLInitTypeDef>())).PLLSource as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLInitTypeDef),
            "::",
            stringify!(PLLSource)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_PLLInitTypeDef>())).PLLM as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLInitTypeDef),
            "::",
            stringify!(PLLM)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_PLLInitTypeDef>())).PLLN as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLInitTypeDef),
            "::",
            stringify!(PLLN)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_PLLInitTypeDef>())).PLLP as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLInitTypeDef),
            "::",
            stringify!(PLLP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_PLLInitTypeDef>())).PLLQ as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLInitTypeDef),
            "::",
            stringify!(PLLQ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_PLLInitTypeDef>())).PLLR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLInitTypeDef),
            "::",
            stringify!(PLLR)
        )
    );
}
#[doc = " @brief  RCC Internal/External Oscillator (HSE, HSI, MSI, LSE and LSI) configuration structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RCC_OscInitTypeDef {
    #[doc = "< The oscillators to be configured."]
    #[doc = "This parameter can be a value of @ref RCC_Oscillator_Type"]
    pub OscillatorType: u32,
    #[doc = "< The new state of the HSE."]
    #[doc = "This parameter can be a value of @ref RCC_HSE_Config"]
    pub HSEState: u32,
    #[doc = "< The new state of the LSE."]
    #[doc = "This parameter can be a value of @ref RCC_LSE_Config"]
    pub LSEState: u32,
    #[doc = "< The new state of the HSI."]
    #[doc = "This parameter can be a value of @ref RCC_HSI_Config"]
    pub HSIState: u32,
    #[doc = "< The calibration trimming value (default is RCC_HSICALIBRATION_DEFAULT)."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 31 on"]
    #[doc = "STM32L43x/STM32L44x/STM32L47x/STM32L48x devices."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 127 on"]
    #[doc = "the other devices"]
    pub HSICalibrationValue: u32,
    #[doc = "< The new state of the LSI."]
    #[doc = "This parameter can be a value of @ref RCC_LSI_Config"]
    pub LSIState: u32,
    #[doc = "< The new state of the MSI."]
    #[doc = "This parameter can be a value of @ref RCC_MSI_Config"]
    pub MSIState: u32,
    #[doc = "< The calibration trimming value (default is RCC_MSICALIBRATION_DEFAULT)."]
    #[doc = "This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF"]
    pub MSICalibrationValue: u32,
    #[doc = "< The MSI frequency range."]
    #[doc = "This parameter can be a value of @ref RCC_MSI_Clock_Range"]
    pub MSIClockRange: u32,
    #[doc = "< The new state of the HSI48 (only applicable to STM32L43x/STM32L44x/STM32L49x/STM32L4Ax devices)."]
    #[doc = "This parameter can be a value of @ref RCC_HSI48_Config"]
    pub HSI48State: u32,
    #[doc = "< Main PLL structure parameters"]
    pub PLL: RCC_PLLInitTypeDef,
}
#[test]
fn bindgen_test_layout_RCC_OscInitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RCC_OscInitTypeDef>(),
        68usize,
        concat!("Size of: ", stringify!(RCC_OscInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RCC_OscInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RCC_OscInitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_OscInitTypeDef>())).OscillatorType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(OscillatorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_OscInitTypeDef>())).HSEState as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(HSEState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_OscInitTypeDef>())).LSEState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(LSEState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_OscInitTypeDef>())).HSIState as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(HSIState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_OscInitTypeDef>())).HSICalibrationValue as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(HSICalibrationValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_OscInitTypeDef>())).LSIState as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(LSIState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_OscInitTypeDef>())).MSIState as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(MSIState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_OscInitTypeDef>())).MSICalibrationValue as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(MSICalibrationValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_OscInitTypeDef>())).MSIClockRange as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(MSIClockRange)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_OscInitTypeDef>())).HSI48State as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(HSI48State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_OscInitTypeDef>())).PLL as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(PLL)
        )
    );
}
#[doc = " @brief  RCC System, AHB and APB busses clock configuration structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RCC_ClkInitTypeDef {
    #[doc = "< The clock to be configured."]
    #[doc = "This parameter can be a value of @ref RCC_System_Clock_Type"]
    pub ClockType: u32,
    #[doc = "< The clock source used as system clock (SYSCLK)."]
    #[doc = "This parameter can be a value of @ref RCC_System_Clock_Source"]
    pub SYSCLKSource: u32,
    #[doc = "< The AHB clock (HCLK) divider. This clock is derived from the system clock (SYSCLK)."]
    #[doc = "This parameter can be a value of @ref RCC_AHB_Clock_Source"]
    pub AHBCLKDivider: u32,
    #[doc = "< The APB1 clock (PCLK1) divider. This clock is derived from the AHB clock (HCLK)."]
    #[doc = "This parameter can be a value of @ref RCC_APB1_APB2_Clock_Source"]
    pub APB1CLKDivider: u32,
    #[doc = "< The APB2 clock (PCLK2) divider. This clock is derived from the AHB clock (HCLK)."]
    #[doc = "This parameter can be a value of @ref RCC_APB1_APB2_Clock_Source"]
    pub APB2CLKDivider: u32,
}
#[test]
fn bindgen_test_layout_RCC_ClkInitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RCC_ClkInitTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(RCC_ClkInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RCC_ClkInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RCC_ClkInitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RCC_ClkInitTypeDef>())).ClockType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_ClkInitTypeDef),
            "::",
            stringify!(ClockType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_ClkInitTypeDef>())).SYSCLKSource as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_ClkInitTypeDef),
            "::",
            stringify!(SYSCLKSource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_ClkInitTypeDef>())).AHBCLKDivider as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_ClkInitTypeDef),
            "::",
            stringify!(AHBCLKDivider)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_ClkInitTypeDef>())).APB1CLKDivider as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_ClkInitTypeDef),
            "::",
            stringify!(APB1CLKDivider)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_ClkInitTypeDef>())).APB2CLKDivider as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_ClkInitTypeDef),
            "::",
            stringify!(APB2CLKDivider)
        )
    );
}
#[doc = " @brief  PLLSAI1 Clock structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RCC_PLLSAI1InitTypeDef {
    #[doc = "< PLLSAI1Source: PLLSAI1 entry clock source."]
    #[doc = "This parameter must be a value of @ref RCC_PLL_Clock_Source"]
    pub PLLSAI1Source: u32,
    #[doc = "< PLLSAI1M: specifies the division factor for PLLSAI1 input clock."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 8"]
    pub PLLSAI1M: u32,
    #[doc = "< PLLSAI1N: specifies the multiplication factor for PLLSAI1 VCO output clock."]
    #[doc = "This parameter must be a number between 8 and 86 or 127 depending on devices."]
    pub PLLSAI1N: u32,
    #[doc = "< PLLSAI1P: specifies the division factor for SAI clock."]
    #[doc = "This parameter must be a value of @ref RCC_PLLP_Clock_Divider"]
    pub PLLSAI1P: u32,
    #[doc = "< PLLSAI1Q: specifies the division factor for USB/RNG/SDMMC1 clock."]
    #[doc = "This parameter must be a value of @ref RCC_PLLQ_Clock_Divider"]
    pub PLLSAI1Q: u32,
    #[doc = "< PLLSAI1R: specifies the division factor for ADC clock."]
    #[doc = "This parameter must be a value of @ref RCC_PLLR_Clock_Divider"]
    pub PLLSAI1R: u32,
    #[doc = "< PLLSAIClockOut: specifies PLLSAI1 output clock to be enabled."]
    #[doc = "This parameter must be a value of @ref RCC_PLLSAI1_Clock_Output"]
    pub PLLSAI1ClockOut: u32,
}
#[test]
fn bindgen_test_layout_RCC_PLLSAI1InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RCC_PLLSAI1InitTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(RCC_PLLSAI1InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RCC_PLLSAI1InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RCC_PLLSAI1InitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PLLSAI1InitTypeDef>())).PLLSAI1Source as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLSAI1InitTypeDef),
            "::",
            stringify!(PLLSAI1Source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PLLSAI1InitTypeDef>())).PLLSAI1M as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLSAI1InitTypeDef),
            "::",
            stringify!(PLLSAI1M)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PLLSAI1InitTypeDef>())).PLLSAI1N as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLSAI1InitTypeDef),
            "::",
            stringify!(PLLSAI1N)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PLLSAI1InitTypeDef>())).PLLSAI1P as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLSAI1InitTypeDef),
            "::",
            stringify!(PLLSAI1P)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PLLSAI1InitTypeDef>())).PLLSAI1Q as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLSAI1InitTypeDef),
            "::",
            stringify!(PLLSAI1Q)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PLLSAI1InitTypeDef>())).PLLSAI1R as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLSAI1InitTypeDef),
            "::",
            stringify!(PLLSAI1R)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PLLSAI1InitTypeDef>())).PLLSAI1ClockOut as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLSAI1InitTypeDef),
            "::",
            stringify!(PLLSAI1ClockOut)
        )
    );
}
#[doc = " @brief  PLLSAI2 Clock structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RCC_PLLSAI2InitTypeDef {
    #[doc = "< PLLSAI2Source: PLLSAI2 entry clock source."]
    #[doc = "This parameter must be a value of @ref RCC_PLL_Clock_Source"]
    pub PLLSAI2Source: u32,
    #[doc = "< PLLSAI2M: specifies the division factor for PLLSAI2 input clock."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 8"]
    pub PLLSAI2M: u32,
    #[doc = "< PLLSAI2N: specifies the multiplication factor for PLLSAI2 VCO output clock."]
    #[doc = "This parameter must be a number between 8 and 86 or 127 depending on devices."]
    pub PLLSAI2N: u32,
    #[doc = "< PLLSAI2P: specifies the division factor for SAI clock."]
    #[doc = "This parameter must be a value of @ref RCC_PLLP_Clock_Divider"]
    pub PLLSAI2P: u32,
    #[doc = "< PLLSAI2R: specifies the division factor for ADC clock."]
    #[doc = "This parameter must be a value of @ref RCC_PLLR_Clock_Divider"]
    pub PLLSAI2R: u32,
    #[doc = "< PLLSAIClockOut: specifies PLLSAI2 output clock to be enabled."]
    #[doc = "This parameter must be a value of @ref RCC_PLLSAI2_Clock_Output"]
    pub PLLSAI2ClockOut: u32,
}
#[test]
fn bindgen_test_layout_RCC_PLLSAI2InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RCC_PLLSAI2InitTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(RCC_PLLSAI2InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RCC_PLLSAI2InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RCC_PLLSAI2InitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PLLSAI2InitTypeDef>())).PLLSAI2Source as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLSAI2InitTypeDef),
            "::",
            stringify!(PLLSAI2Source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PLLSAI2InitTypeDef>())).PLLSAI2M as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLSAI2InitTypeDef),
            "::",
            stringify!(PLLSAI2M)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PLLSAI2InitTypeDef>())).PLLSAI2N as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLSAI2InitTypeDef),
            "::",
            stringify!(PLLSAI2N)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PLLSAI2InitTypeDef>())).PLLSAI2P as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLSAI2InitTypeDef),
            "::",
            stringify!(PLLSAI2P)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PLLSAI2InitTypeDef>())).PLLSAI2R as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLSAI2InitTypeDef),
            "::",
            stringify!(PLLSAI2R)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PLLSAI2InitTypeDef>())).PLLSAI2ClockOut as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLSAI2InitTypeDef),
            "::",
            stringify!(PLLSAI2ClockOut)
        )
    );
}
#[doc = " @brief  RCC extended clocks structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RCC_PeriphCLKInitTypeDef {
    #[doc = "< The Extended Clock to be configured."]
    #[doc = "This parameter can be a value of @ref RCCEx_Periph_Clock_Selection"]
    pub PeriphClockSelection: u32,
    #[doc = "< PLLSAI1 structure parameters."]
    #[doc = "This parameter will be used only when PLLSAI1 is selected as Clock Source for SAI1, USB/RNG/SDMMC1 or ADC"]
    pub PLLSAI1: RCC_PLLSAI1InitTypeDef,
    #[doc = "< PLLSAI2 structure parameters."]
    #[doc = "This parameter will be used only when PLLSAI2 is selected as Clock Source for SAI2 or ADC"]
    pub PLLSAI2: RCC_PLLSAI2InitTypeDef,
    #[doc = "< Specifies USART1 clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_USART1_Clock_Source"]
    pub Usart1ClockSelection: u32,
    #[doc = "< Specifies USART2 clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_USART2_Clock_Source"]
    pub Usart2ClockSelection: u32,
    #[doc = "< Specifies USART3 clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_USART3_Clock_Source"]
    pub Usart3ClockSelection: u32,
    #[doc = "< Specifies UART4 clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_UART4_Clock_Source"]
    pub Uart4ClockSelection: u32,
    #[doc = "< Specifies UART5 clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_UART5_Clock_Source"]
    pub Uart5ClockSelection: u32,
    #[doc = "< Specifies LPUART1 clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_LPUART1_Clock_Source"]
    pub Lpuart1ClockSelection: u32,
    #[doc = "< Specifies I2C1 clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_I2C1_Clock_Source"]
    pub I2c1ClockSelection: u32,
    #[doc = "< Specifies I2C2 clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_I2C2_Clock_Source"]
    pub I2c2ClockSelection: u32,
    #[doc = "< Specifies I2C3 clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_I2C3_Clock_Source"]
    pub I2c3ClockSelection: u32,
    #[doc = "< Specifies LPTIM1 clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_LPTIM1_Clock_Source"]
    pub Lptim1ClockSelection: u32,
    #[doc = "< Specifies LPTIM2 clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_LPTIM2_Clock_Source"]
    pub Lptim2ClockSelection: u32,
    #[doc = "< Specifies SAI1 clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_SAI1_Clock_Source"]
    pub Sai1ClockSelection: u32,
    #[doc = "< Specifies SAI2 clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_SAI2_Clock_Source"]
    pub Sai2ClockSelection: u32,
    #[doc = "< Specifies USB clock source (warning: same source for SDMMC1 and RNG)."]
    #[doc = "This parameter can be a value of @ref RCCEx_USB_Clock_Source"]
    pub UsbClockSelection: u32,
    #[doc = "< Specifies SDMMC1 clock source (warning: same source for USB and RNG)."]
    #[doc = "This parameter can be a value of @ref RCCEx_SDMMC1_Clock_Source"]
    pub Sdmmc1ClockSelection: u32,
    #[doc = "< Specifies RNG clock source (warning: same source for USB and SDMMC1)."]
    #[doc = "This parameter can be a value of @ref RCCEx_RNG_Clock_Source"]
    pub RngClockSelection: u32,
    #[doc = "< Specifies ADC interface clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_ADC_Clock_Source"]
    pub AdcClockSelection: u32,
    #[doc = "< Specifies SWPMI1 clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_SWPMI1_Clock_Source"]
    pub Swpmi1ClockSelection: u32,
    #[doc = "< Specifies DFSDM1 clock source."]
    #[doc = "This parameter can be a value of @ref RCCEx_DFSDM1_Clock_Source"]
    pub Dfsdm1ClockSelection: u32,
    #[doc = "< Specifies RTC clock source."]
    #[doc = "This parameter can be a value of @ref RCC_RTC_Clock_Source"]
    pub RTCClockSelection: u32,
}
#[test]
fn bindgen_test_layout_RCC_PeriphCLKInitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RCC_PeriphCLKInitTypeDef>(),
        136usize,
        concat!("Size of: ", stringify!(RCC_PeriphCLKInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RCC_PeriphCLKInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RCC_PeriphCLKInitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).PeriphClockSelection as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(PeriphClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).PLLSAI1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(PLLSAI1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).PLLSAI2 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(PLLSAI2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).Usart1ClockSelection as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(Usart1ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).Usart2ClockSelection as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(Usart2ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).Usart3ClockSelection as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(Usart3ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).Uart4ClockSelection as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(Uart4ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).Uart5ClockSelection as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(Uart5ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).Lpuart1ClockSelection as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(Lpuart1ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).I2c1ClockSelection as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(I2c1ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).I2c2ClockSelection as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(I2c2ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).I2c3ClockSelection as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(I2c3ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).Lptim1ClockSelection as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(Lptim1ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).Lptim2ClockSelection as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(Lptim2ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).Sai1ClockSelection as *const _
                as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(Sai1ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).Sai2ClockSelection as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(Sai2ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).UsbClockSelection as *const _
                as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(UsbClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).Sdmmc1ClockSelection as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(Sdmmc1ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).RngClockSelection as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(RngClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).AdcClockSelection as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(AdcClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).Swpmi1ClockSelection as *const _
                as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(Swpmi1ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).Dfsdm1ClockSelection as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(Dfsdm1ClockSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RCC_PeriphCLKInitTypeDef>())).RTCClockSelection as *const _
                as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(RTCClockSelection)
        )
    );
}
extern "C" {
    #[doc = " @addtogroup RCCEx_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_RCCEx_PeriphCLKConfig(
        PeriphClkInit: *mut RCC_PeriphCLKInitTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RCCEx_GetPeriphCLKConfig(PeriphClkInit: *mut RCC_PeriphCLKInitTypeDef);
}
extern "C" {
    pub fn HAL_RCCEx_GetPeriphCLKFreq(PeriphClk: u32) -> u32;
}
extern "C" {
    pub fn HAL_RCCEx_EnablePLLSAI1(PLLSAI1Init: *mut RCC_PLLSAI1InitTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RCCEx_DisablePLLSAI1() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RCCEx_EnablePLLSAI2(PLLSAI2Init: *mut RCC_PLLSAI2InitTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RCCEx_DisablePLLSAI2() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RCCEx_WakeUpStopCLKConfig(WakeUpClk: u32);
}
extern "C" {
    pub fn HAL_RCCEx_StandbyMSIRangeConfig(MSIRange: u32);
}
extern "C" {
    pub fn HAL_RCCEx_EnableLSECSS();
}
extern "C" {
    pub fn HAL_RCCEx_DisableLSECSS();
}
extern "C" {
    pub fn HAL_RCCEx_EnableLSECSS_IT();
}
extern "C" {
    pub fn HAL_RCCEx_LSECSS_IRQHandler();
}
extern "C" {
    pub fn HAL_RCCEx_LSECSS_Callback();
}
extern "C" {
    pub fn HAL_RCCEx_EnableLSCO(LSCOSource: u32);
}
extern "C" {
    pub fn HAL_RCCEx_DisableLSCO();
}
extern "C" {
    pub fn HAL_RCCEx_EnableMSIPLLMode();
}
extern "C" {
    pub fn HAL_RCCEx_DisableMSIPLLMode();
}
extern "C" {
    #[doc = " @addtogroup RCC_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_RCC_DeInit() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RCC_OscConfig(RCC_OscInitStruct: *mut RCC_OscInitTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RCC_ClockConfig(
        RCC_ClkInitStruct: *mut RCC_ClkInitTypeDef,
        FLatency: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup RCC_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_RCC_MCOConfig(RCC_MCOx: u32, RCC_MCOSource: u32, RCC_MCODiv: u32);
}
extern "C" {
    pub fn HAL_RCC_EnableCSS();
}
extern "C" {
    pub fn HAL_RCC_GetSysClockFreq() -> u32;
}
extern "C" {
    pub fn HAL_RCC_GetHCLKFreq() -> u32;
}
extern "C" {
    pub fn HAL_RCC_GetPCLK1Freq() -> u32;
}
extern "C" {
    pub fn HAL_RCC_GetPCLK2Freq() -> u32;
}
extern "C" {
    pub fn HAL_RCC_GetOscConfig(RCC_OscInitStruct: *mut RCC_OscInitTypeDef);
}
extern "C" {
    pub fn HAL_RCC_GetClockConfig(RCC_ClkInitStruct: *mut RCC_ClkInitTypeDef, pFLatency: *mut u32);
}
extern "C" {
    pub fn HAL_RCC_NMI_IRQHandler();
}
extern "C" {
    pub fn HAL_RCC_CSSCallback();
}
#[doc = " @defgroup GPIO_Exported_Types GPIO Exported Types"]
#[doc = " @{"]
#[doc = " @brief   GPIO Init structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GPIO_InitTypeDef {
    #[doc = "< Specifies the GPIO pins to be configured."]
    #[doc = "This parameter can be any value of @ref GPIO_pins"]
    pub Pin: u32,
    #[doc = "< Specifies the operating mode for the selected pins."]
    #[doc = "This parameter can be a value of @ref GPIO_mode"]
    pub Mode: u32,
    #[doc = "< Specifies the Pull-up or Pull-Down activation for the selected pins."]
    #[doc = "This parameter can be a value of @ref GPIO_pull"]
    pub Pull: u32,
    #[doc = "< Specifies the speed for the selected pins."]
    #[doc = "This parameter can be a value of @ref GPIO_speed"]
    pub Speed: u32,
    #[doc = "< Peripheral to be connected to the selected pins"]
    #[doc = "This parameter can be a value of @ref GPIOEx_Alternate_function_selection"]
    pub Alternate: u32,
}
#[test]
fn bindgen_test_layout_GPIO_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<GPIO_InitTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(GPIO_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<GPIO_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(GPIO_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_InitTypeDef>())).Pin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_InitTypeDef),
            "::",
            stringify!(Pin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_InitTypeDef>())).Mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_InitTypeDef>())).Pull as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_InitTypeDef),
            "::",
            stringify!(Pull)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_InitTypeDef>())).Speed as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_InitTypeDef),
            "::",
            stringify!(Speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GPIO_InitTypeDef>())).Alternate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_InitTypeDef),
            "::",
            stringify!(Alternate)
        )
    );
}
pub const GPIO_PinState_GPIO_PIN_RESET: GPIO_PinState = 0;
pub const GPIO_PinState_GPIO_PIN_SET: GPIO_PinState = 1;
#[doc = " @brief  GPIO Bit SET and Bit RESET enumeration"]
pub type GPIO_PinState = libc::c_uint;
extern "C" {
    #[doc = " @addtogroup GPIO_Exported_Functions_Group1 Initialization/de-initialization functions"]
    #[doc = "  @brief    Initialization and Configuration functions"]
    #[doc = " @{"]
    pub fn HAL_GPIO_Init(GPIOx: *mut GPIO_TypeDef, GPIO_Init: *mut GPIO_InitTypeDef);
}
extern "C" {
    pub fn HAL_GPIO_DeInit(GPIOx: *mut GPIO_TypeDef, GPIO_Pin: u32);
}
extern "C" {
    #[doc = " @addtogroup GPIO_Exported_Functions_Group2 IO operation functions"]
    #[doc = " @{"]
    pub fn HAL_GPIO_ReadPin(GPIOx: *mut GPIO_TypeDef, GPIO_Pin: u16) -> GPIO_PinState;
}
extern "C" {
    pub fn HAL_GPIO_WritePin(GPIOx: *mut GPIO_TypeDef, GPIO_Pin: u16, PinState: GPIO_PinState);
}
extern "C" {
    pub fn HAL_GPIO_TogglePin(GPIOx: *mut GPIO_TypeDef, GPIO_Pin: u16);
}
extern "C" {
    pub fn HAL_GPIO_LockPin(GPIOx: *mut GPIO_TypeDef, GPIO_Pin: u16) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_GPIO_EXTI_IRQHandler(GPIO_Pin: u16);
}
extern "C" {
    pub fn HAL_GPIO_EXTI_Callback(GPIO_Pin: u16);
}
#[doc = " @brief  DMA Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DMA_InitTypeDef {
    #[doc = "< Specifies the request selected for the specified channel."]
    #[doc = "This parameter can be a value of @ref DMA_request"]
    pub Request: u32,
    #[doc = "< Specifies if the data will be transferred from memory to peripheral,"]
    #[doc = "from memory to memory or from peripheral to memory."]
    #[doc = "This parameter can be a value of @ref DMA_Data_transfer_direction"]
    pub Direction: u32,
    #[doc = "< Specifies whether the Peripheral address register should be incremented or not."]
    #[doc = "This parameter can be a value of @ref DMA_Peripheral_incremented_mode"]
    pub PeriphInc: u32,
    #[doc = "< Specifies whether the memory address register should be incremented or not."]
    #[doc = "This parameter can be a value of @ref DMA_Memory_incremented_mode"]
    pub MemInc: u32,
    #[doc = "< Specifies the Peripheral data width."]
    #[doc = "This parameter can be a value of @ref DMA_Peripheral_data_size"]
    pub PeriphDataAlignment: u32,
    #[doc = "< Specifies the Memory data width."]
    #[doc = "This parameter can be a value of @ref DMA_Memory_data_size"]
    pub MemDataAlignment: u32,
    #[doc = "< Specifies the operation mode of the DMAy Channelx."]
    #[doc = "This parameter can be a value of @ref DMA_mode"]
    #[doc = "@note The circular buffer mode cannot be used if the memory-to-memory"]
    #[doc = "data transfer is configured on the selected Channel"]
    pub Mode: u32,
    #[doc = "< Specifies the software priority for the DMAy Channelx."]
    #[doc = "This parameter can be a value of @ref DMA_Priority_level"]
    pub Priority: u32,
}
#[test]
fn bindgen_test_layout_DMA_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DMA_InitTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(DMA_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DMA_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DMA_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMA_InitTypeDef>())).Request as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_InitTypeDef),
            "::",
            stringify!(Request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMA_InitTypeDef>())).Direction as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_InitTypeDef),
            "::",
            stringify!(Direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMA_InitTypeDef>())).PeriphInc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_InitTypeDef),
            "::",
            stringify!(PeriphInc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMA_InitTypeDef>())).MemInc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_InitTypeDef),
            "::",
            stringify!(MemInc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DMA_InitTypeDef>())).PeriphDataAlignment as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_InitTypeDef),
            "::",
            stringify!(PeriphDataAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DMA_InitTypeDef>())).MemDataAlignment as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_InitTypeDef),
            "::",
            stringify!(MemDataAlignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMA_InitTypeDef>())).Mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMA_InitTypeDef>())).Priority as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_InitTypeDef),
            "::",
            stringify!(Priority)
        )
    );
}
#[doc = "< DMA not yet initialized or disabled"]
pub const HAL_DMA_StateTypeDef_HAL_DMA_STATE_RESET: HAL_DMA_StateTypeDef = 0;
#[doc = "< DMA initialized and ready for use"]
pub const HAL_DMA_StateTypeDef_HAL_DMA_STATE_READY: HAL_DMA_StateTypeDef = 1;
#[doc = "< DMA process is ongoing"]
pub const HAL_DMA_StateTypeDef_HAL_DMA_STATE_BUSY: HAL_DMA_StateTypeDef = 2;
#[doc = "< DMA timeout state"]
pub const HAL_DMA_StateTypeDef_HAL_DMA_STATE_TIMEOUT: HAL_DMA_StateTypeDef = 3;
#[doc = " @brief  HAL DMA State structures definition"]
pub type HAL_DMA_StateTypeDef = libc::c_uint;
#[doc = "< Full transfer"]
pub const HAL_DMA_LevelCompleteTypeDef_HAL_DMA_FULL_TRANSFER: HAL_DMA_LevelCompleteTypeDef = 0;
#[doc = "< Half Transfer"]
pub const HAL_DMA_LevelCompleteTypeDef_HAL_DMA_HALF_TRANSFER: HAL_DMA_LevelCompleteTypeDef = 1;
#[doc = " @brief  HAL DMA Error Code structure definition"]
pub type HAL_DMA_LevelCompleteTypeDef = libc::c_uint;
#[doc = "< Full transfer"]
pub const HAL_DMA_CallbackIDTypeDef_HAL_DMA_XFER_CPLT_CB_ID: HAL_DMA_CallbackIDTypeDef = 0;
#[doc = "< Half transfer"]
pub const HAL_DMA_CallbackIDTypeDef_HAL_DMA_XFER_HALFCPLT_CB_ID: HAL_DMA_CallbackIDTypeDef = 1;
#[doc = "< Error"]
pub const HAL_DMA_CallbackIDTypeDef_HAL_DMA_XFER_ERROR_CB_ID: HAL_DMA_CallbackIDTypeDef = 2;
#[doc = "< Abort"]
pub const HAL_DMA_CallbackIDTypeDef_HAL_DMA_XFER_ABORT_CB_ID: HAL_DMA_CallbackIDTypeDef = 3;
#[doc = "< All"]
pub const HAL_DMA_CallbackIDTypeDef_HAL_DMA_XFER_ALL_CB_ID: HAL_DMA_CallbackIDTypeDef = 4;
#[doc = " @brief  HAL DMA Callback ID structure definition"]
pub type HAL_DMA_CallbackIDTypeDef = libc::c_uint;
#[doc = " @brief  DMA handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __DMA_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut DMA_Channel_TypeDef,
    #[doc = "< DMA communication parameters"]
    pub Init: DMA_InitTypeDef,
    #[doc = "< DMA locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< DMA transfer state"]
    pub State: HAL_DMA_StateTypeDef,
    #[doc = "< Parent object state"]
    pub Parent: *mut libc::c_void,
    #[doc = "< DMA transfer complete callback"]
    pub XferCpltCallback:
        ::core::option::Option<unsafe extern "C" fn(hdma: *mut __DMA_HandleTypeDef)>,
    #[doc = "< DMA Half transfer complete callback"]
    pub XferHalfCpltCallback:
        ::core::option::Option<unsafe extern "C" fn(hdma: *mut __DMA_HandleTypeDef)>,
    #[doc = "< DMA transfer error callback"]
    pub XferErrorCallback:
        ::core::option::Option<unsafe extern "C" fn(hdma: *mut __DMA_HandleTypeDef)>,
    #[doc = "< DMA transfer abort callback"]
    pub XferAbortCallback:
        ::core::option::Option<unsafe extern "C" fn(hdma: *mut __DMA_HandleTypeDef)>,
    #[doc = "< DMA Error code"]
    pub ErrorCode: u32,
    #[doc = "< DMA Channel Base Address"]
    pub DmaBaseAddress: *mut DMA_TypeDef,
    #[doc = "< DMA Channel Index"]
    pub ChannelIndex: u32,
}
#[test]
fn bindgen_test_layout___DMA_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<__DMA_HandleTypeDef>(),
        76usize,
        concat!("Size of: ", stringify!(__DMA_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<__DMA_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(__DMA_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DMA_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DMA_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DMA_HandleTypeDef>())).Lock as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DMA_HandleTypeDef>())).State as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DMA_HandleTypeDef>())).Parent as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(Parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__DMA_HandleTypeDef>())).XferCpltCallback as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(XferCpltCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__DMA_HandleTypeDef>())).XferHalfCpltCallback as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(XferHalfCpltCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__DMA_HandleTypeDef>())).XferErrorCallback as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(XferErrorCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__DMA_HandleTypeDef>())).XferAbortCallback as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(XferAbortCallback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DMA_HandleTypeDef>())).ErrorCode as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__DMA_HandleTypeDef>())).DmaBaseAddress as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(DmaBaseAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__DMA_HandleTypeDef>())).ChannelIndex as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(ChannelIndex)
        )
    );
}
impl Default for __DMA_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  DMA handle Structure definition"]
pub type DMA_HandleTypeDef = __DMA_HandleTypeDef;
extern "C" {
    #[doc = " @addtogroup DMA_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_DMA_Init(hdma: *mut DMA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DMA_DeInit(hdma: *mut DMA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup DMA_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_DMA_Start(
        hdma: *mut DMA_HandleTypeDef,
        SrcAddress: u32,
        DstAddress: u32,
        DataLength: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DMA_Start_IT(
        hdma: *mut DMA_HandleTypeDef,
        SrcAddress: u32,
        DstAddress: u32,
        DataLength: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DMA_Abort(hdma: *mut DMA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DMA_Abort_IT(hdma: *mut DMA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DMA_PollForTransfer(
        hdma: *mut DMA_HandleTypeDef,
        CompleteLevel: HAL_DMA_LevelCompleteTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DMA_IRQHandler(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DMA_RegisterCallback(
        hdma: *mut DMA_HandleTypeDef,
        CallbackID: HAL_DMA_CallbackIDTypeDef,
        pCallback: ::core::option::Option<unsafe extern "C" fn(_hdma: *mut DMA_HandleTypeDef)>,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DMA_UnRegisterCallback(
        hdma: *mut DMA_HandleTypeDef,
        CallbackID: HAL_DMA_CallbackIDTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup DMA_Exported_Functions_Group3"]
    #[doc = " @{"]
    pub fn HAL_DMA_GetState(hdma: *mut DMA_HandleTypeDef) -> HAL_DMA_StateTypeDef;
}
extern "C" {
    pub fn HAL_DMA_GetError(hdma: *mut DMA_HandleTypeDef) -> u32;
}
#[doc = "< DFSDM channel not initialized"]
pub const HAL_DFSDM_Channel_StateTypeDef_HAL_DFSDM_CHANNEL_STATE_RESET:
    HAL_DFSDM_Channel_StateTypeDef = 0;
#[doc = "< DFSDM channel initialized and ready for use"]
pub const HAL_DFSDM_Channel_StateTypeDef_HAL_DFSDM_CHANNEL_STATE_READY:
    HAL_DFSDM_Channel_StateTypeDef = 1;
#[doc = "< DFSDM channel state error"]
pub const HAL_DFSDM_Channel_StateTypeDef_HAL_DFSDM_CHANNEL_STATE_ERROR:
    HAL_DFSDM_Channel_StateTypeDef = 255;
#[doc = " @brief  HAL DFSDM Channel states definition"]
pub type HAL_DFSDM_Channel_StateTypeDef = libc::c_uint;
#[doc = " @brief  DFSDM channel output clock structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFSDM_Channel_OutputClockTypeDef {
    #[doc = "< Output clock enable/disable"]
    pub Activation: FunctionalState,
    #[doc = "< Output clock is system clock or audio clock."]
    #[doc = "This parameter can be a value of @ref DFSDM_Channel_OuputClock"]
    pub Selection: u32,
    #[doc = "< Output clock divider."]
    #[doc = "This parameter must be a number between Min_Data = 2 and Max_Data = 256"]
    pub Divider: u32,
}
#[test]
fn bindgen_test_layout_DFSDM_Channel_OutputClockTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DFSDM_Channel_OutputClockTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(DFSDM_Channel_OutputClockTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DFSDM_Channel_OutputClockTypeDef>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DFSDM_Channel_OutputClockTypeDef)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_OutputClockTypeDef>())).Activation as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_OutputClockTypeDef),
            "::",
            stringify!(Activation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_OutputClockTypeDef>())).Selection as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_OutputClockTypeDef),
            "::",
            stringify!(Selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_OutputClockTypeDef>())).Divider as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_OutputClockTypeDef),
            "::",
            stringify!(Divider)
        )
    );
}
impl Default for DFSDM_Channel_OutputClockTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  DFSDM channel input structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DFSDM_Channel_InputTypeDef {
    #[doc = "< Input is external serial inputs, internal register or ADC output."]
    #[doc = "ADC output is available only on STM32L451xx, STM32L452xx, STM32L462xx,"]
    #[doc = "STM32L496xx, STM32L4A6xx, STM32L4R5xx, STM32L4R7xx, STM32L4R9xx,"]
    #[doc = "STM32L4S5xx, STM32L4S7xx, STM32L4S9xx, STM32L4P5xx and STM32L4Q5xx products."]
    #[doc = "This parameter can be a value of @ref DFSDM_Channel_InputMultiplexer"]
    pub Multiplexer: u32,
    #[doc = "< Standard, interleaved or dual mode for internal register."]
    #[doc = "This parameter can be a value of @ref DFSDM_Channel_DataPacking"]
    pub DataPacking: u32,
    #[doc = "< Input pins are taken from same or following channel."]
    #[doc = "This parameter can be a value of @ref DFSDM_Channel_InputPins"]
    pub Pins: u32,
}
#[test]
fn bindgen_test_layout_DFSDM_Channel_InputTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DFSDM_Channel_InputTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(DFSDM_Channel_InputTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DFSDM_Channel_InputTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DFSDM_Channel_InputTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_InputTypeDef>())).Multiplexer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_InputTypeDef),
            "::",
            stringify!(Multiplexer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_InputTypeDef>())).DataPacking as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_InputTypeDef),
            "::",
            stringify!(DataPacking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_InputTypeDef>())).Pins as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_InputTypeDef),
            "::",
            stringify!(Pins)
        )
    );
}
#[doc = " @brief  DFSDM channel serial interface structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DFSDM_Channel_SerialInterfaceTypeDef {
    #[doc = "< SPI or Manchester modes."]
    #[doc = "This parameter can be a value of @ref DFSDM_Channel_SerialInterfaceType"]
    pub Type: u32,
    #[doc = "< SPI clock select (external or internal with different sampling point)."]
    #[doc = "This parameter can be a value of @ref DFSDM_Channel_SpiClock"]
    pub SpiClock: u32,
}
#[test]
fn bindgen_test_layout_DFSDM_Channel_SerialInterfaceTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DFSDM_Channel_SerialInterfaceTypeDef>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(DFSDM_Channel_SerialInterfaceTypeDef)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<DFSDM_Channel_SerialInterfaceTypeDef>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DFSDM_Channel_SerialInterfaceTypeDef)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_SerialInterfaceTypeDef>())).Type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_SerialInterfaceTypeDef),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_SerialInterfaceTypeDef>())).SpiClock as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_SerialInterfaceTypeDef),
            "::",
            stringify!(SpiClock)
        )
    );
}
#[doc = " @brief  DFSDM channel analog watchdog structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DFSDM_Channel_AwdTypeDef {
    #[doc = "< Analog watchdog Sinc filter order."]
    #[doc = "This parameter can be a value of @ref DFSDM_Channel_AwdFilterOrder"]
    pub FilterOrder: u32,
    #[doc = "< Analog watchdog filter oversampling ratio."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 32"]
    pub Oversampling: u32,
}
#[test]
fn bindgen_test_layout_DFSDM_Channel_AwdTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DFSDM_Channel_AwdTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(DFSDM_Channel_AwdTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DFSDM_Channel_AwdTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DFSDM_Channel_AwdTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_AwdTypeDef>())).FilterOrder as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_AwdTypeDef),
            "::",
            stringify!(FilterOrder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_AwdTypeDef>())).Oversampling as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_AwdTypeDef),
            "::",
            stringify!(Oversampling)
        )
    );
}
#[doc = " @brief  DFSDM channel init structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFSDM_Channel_InitTypeDef {
    #[doc = "< DFSDM channel output clock parameters"]
    pub OutputClock: DFSDM_Channel_OutputClockTypeDef,
    #[doc = "< DFSDM channel input parameters"]
    pub Input: DFSDM_Channel_InputTypeDef,
    #[doc = "< DFSDM channel serial interface parameters"]
    pub SerialInterface: DFSDM_Channel_SerialInterfaceTypeDef,
    #[doc = "< DFSDM channel analog watchdog parameters"]
    pub Awd: DFSDM_Channel_AwdTypeDef,
    #[doc = "< DFSDM channel offset."]
    #[doc = "This parameter must be a number between Min_Data = -8388608 and Max_Data = 8388607"]
    pub Offset: i32,
    #[doc = "< DFSDM channel right bit shift."]
    #[doc = "This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x1F"]
    pub RightBitShift: u32,
}
#[test]
fn bindgen_test_layout_DFSDM_Channel_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DFSDM_Channel_InitTypeDef>(),
        48usize,
        concat!("Size of: ", stringify!(DFSDM_Channel_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DFSDM_Channel_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DFSDM_Channel_InitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_InitTypeDef>())).OutputClock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_InitTypeDef),
            "::",
            stringify!(OutputClock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_InitTypeDef>())).Input as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_InitTypeDef),
            "::",
            stringify!(Input)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_InitTypeDef>())).SerialInterface as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_InitTypeDef),
            "::",
            stringify!(SerialInterface)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DFSDM_Channel_InitTypeDef>())).Awd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_InitTypeDef),
            "::",
            stringify!(Awd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_InitTypeDef>())).Offset as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_InitTypeDef),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_InitTypeDef>())).RightBitShift as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_InitTypeDef),
            "::",
            stringify!(RightBitShift)
        )
    );
}
impl Default for DFSDM_Channel_InitTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFSDM_Channel_HandleTypeDef {
    #[doc = "< DFSDM channel instance"]
    pub Instance: *mut DFSDM_Channel_TypeDef,
    #[doc = "< DFSDM channel init parameters"]
    pub Init: DFSDM_Channel_InitTypeDef,
    #[doc = "< DFSDM channel state"]
    pub State: HAL_DFSDM_Channel_StateTypeDef,
}
#[test]
fn bindgen_test_layout_DFSDM_Channel_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DFSDM_Channel_HandleTypeDef>(),
        56usize,
        concat!("Size of: ", stringify!(DFSDM_Channel_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DFSDM_Channel_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DFSDM_Channel_HandleTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_HandleTypeDef>())).Instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_HandleTypeDef>())).Init as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Channel_HandleTypeDef>())).State as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Channel_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
}
impl Default for DFSDM_Channel_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< DFSDM filter not initialized"]
pub const HAL_DFSDM_Filter_StateTypeDef_HAL_DFSDM_FILTER_STATE_RESET:
    HAL_DFSDM_Filter_StateTypeDef = 0;
#[doc = "< DFSDM filter initialized and ready for use"]
pub const HAL_DFSDM_Filter_StateTypeDef_HAL_DFSDM_FILTER_STATE_READY:
    HAL_DFSDM_Filter_StateTypeDef = 1;
#[doc = "< DFSDM filter regular conversion in progress"]
pub const HAL_DFSDM_Filter_StateTypeDef_HAL_DFSDM_FILTER_STATE_REG: HAL_DFSDM_Filter_StateTypeDef =
    2;
#[doc = "< DFSDM filter injected conversion in progress"]
pub const HAL_DFSDM_Filter_StateTypeDef_HAL_DFSDM_FILTER_STATE_INJ: HAL_DFSDM_Filter_StateTypeDef =
    3;
#[doc = "< DFSDM filter regular and injected conversions in progress"]
pub const HAL_DFSDM_Filter_StateTypeDef_HAL_DFSDM_FILTER_STATE_REG_INJ:
    HAL_DFSDM_Filter_StateTypeDef = 4;
#[doc = "< DFSDM filter state error"]
pub const HAL_DFSDM_Filter_StateTypeDef_HAL_DFSDM_FILTER_STATE_ERROR:
    HAL_DFSDM_Filter_StateTypeDef = 255;
#[doc = " @brief  HAL DFSDM Filter states definition"]
pub type HAL_DFSDM_Filter_StateTypeDef = libc::c_uint;
#[doc = " @brief  DFSDM filter regular conversion parameters structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFSDM_Filter_RegularParamTypeDef {
    #[doc = "< Trigger used to start regular conversion: software or synchronous."]
    #[doc = "This parameter can be a value of @ref DFSDM_Filter_Trigger"]
    pub Trigger: u32,
    #[doc = "< Enable/disable fast mode for regular conversion"]
    pub FastMode: FunctionalState,
    #[doc = "< Enable/disable DMA for regular conversion"]
    pub DmaMode: FunctionalState,
}
#[test]
fn bindgen_test_layout_DFSDM_Filter_RegularParamTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DFSDM_Filter_RegularParamTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(DFSDM_Filter_RegularParamTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DFSDM_Filter_RegularParamTypeDef>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DFSDM_Filter_RegularParamTypeDef)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_RegularParamTypeDef>())).Trigger as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_RegularParamTypeDef),
            "::",
            stringify!(Trigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_RegularParamTypeDef>())).FastMode as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_RegularParamTypeDef),
            "::",
            stringify!(FastMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_RegularParamTypeDef>())).DmaMode as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_RegularParamTypeDef),
            "::",
            stringify!(DmaMode)
        )
    );
}
impl Default for DFSDM_Filter_RegularParamTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  DFSDM filter injected conversion parameters structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFSDM_Filter_InjectedParamTypeDef {
    #[doc = "< Trigger used to start injected conversion: software, external or synchronous."]
    #[doc = "This parameter can be a value of @ref DFSDM_Filter_Trigger"]
    pub Trigger: u32,
    #[doc = "< Enable/disable scanning mode for injected conversion"]
    pub ScanMode: FunctionalState,
    #[doc = "< Enable/disable DMA for injected conversion"]
    pub DmaMode: FunctionalState,
    #[doc = "< External trigger."]
    #[doc = "This parameter can be a value of @ref DFSDM_Filter_ExtTrigger"]
    pub ExtTrigger: u32,
    #[doc = "< External trigger edge: rising, falling or both."]
    #[doc = "This parameter can be a value of @ref DFSDM_Filter_ExtTriggerEdge"]
    pub ExtTriggerEdge: u32,
}
#[test]
fn bindgen_test_layout_DFSDM_Filter_InjectedParamTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DFSDM_Filter_InjectedParamTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(DFSDM_Filter_InjectedParamTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DFSDM_Filter_InjectedParamTypeDef>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DFSDM_Filter_InjectedParamTypeDef)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_InjectedParamTypeDef>())).Trigger as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_InjectedParamTypeDef),
            "::",
            stringify!(Trigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_InjectedParamTypeDef>())).ScanMode as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_InjectedParamTypeDef),
            "::",
            stringify!(ScanMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_InjectedParamTypeDef>())).DmaMode as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_InjectedParamTypeDef),
            "::",
            stringify!(DmaMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_InjectedParamTypeDef>())).ExtTrigger as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_InjectedParamTypeDef),
            "::",
            stringify!(ExtTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_InjectedParamTypeDef>())).ExtTriggerEdge
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_InjectedParamTypeDef),
            "::",
            stringify!(ExtTriggerEdge)
        )
    );
}
impl Default for DFSDM_Filter_InjectedParamTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  DFSDM filter parameters structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DFSDM_Filter_FilterParamTypeDef {
    #[doc = "< Sinc filter order."]
    #[doc = "This parameter can be a value of @ref DFSDM_Filter_SincOrder"]
    pub SincOrder: u32,
    #[doc = "< Filter oversampling ratio."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 1024"]
    pub Oversampling: u32,
    #[doc = "< Integrator oversampling ratio."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 256"]
    pub IntOversampling: u32,
}
#[test]
fn bindgen_test_layout_DFSDM_Filter_FilterParamTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DFSDM_Filter_FilterParamTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(DFSDM_Filter_FilterParamTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DFSDM_Filter_FilterParamTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DFSDM_Filter_FilterParamTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_FilterParamTypeDef>())).SincOrder as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_FilterParamTypeDef),
            "::",
            stringify!(SincOrder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_FilterParamTypeDef>())).Oversampling as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_FilterParamTypeDef),
            "::",
            stringify!(Oversampling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_FilterParamTypeDef>())).IntOversampling as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_FilterParamTypeDef),
            "::",
            stringify!(IntOversampling)
        )
    );
}
#[doc = " @brief  DFSDM filter init structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFSDM_Filter_InitTypeDef {
    #[doc = "< DFSDM regular conversion parameters"]
    pub RegularParam: DFSDM_Filter_RegularParamTypeDef,
    #[doc = "< DFSDM injected conversion parameters"]
    pub InjectedParam: DFSDM_Filter_InjectedParamTypeDef,
    #[doc = "< DFSDM filter parameters"]
    pub FilterParam: DFSDM_Filter_FilterParamTypeDef,
}
#[test]
fn bindgen_test_layout_DFSDM_Filter_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DFSDM_Filter_InitTypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(DFSDM_Filter_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DFSDM_Filter_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DFSDM_Filter_InitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_InitTypeDef>())).RegularParam as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_InitTypeDef),
            "::",
            stringify!(RegularParam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_InitTypeDef>())).InjectedParam as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_InitTypeDef),
            "::",
            stringify!(InjectedParam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_InitTypeDef>())).FilterParam as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_InitTypeDef),
            "::",
            stringify!(FilterParam)
        )
    );
}
impl Default for DFSDM_Filter_InitTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFSDM_Filter_HandleTypeDef {
    #[doc = "< DFSDM filter instance"]
    pub Instance: *mut DFSDM_Filter_TypeDef,
    #[doc = "< DFSDM filter init parameters"]
    pub Init: DFSDM_Filter_InitTypeDef,
    #[doc = "< Pointer on DMA handler for regular conversions"]
    pub hdmaReg: *mut DMA_HandleTypeDef,
    #[doc = "< Pointer on DMA handler for injected conversions"]
    pub hdmaInj: *mut DMA_HandleTypeDef,
    #[doc = "< Regular conversion continuous mode"]
    pub RegularContMode: u32,
    #[doc = "< Trigger used for regular conversion"]
    pub RegularTrigger: u32,
    #[doc = "< Trigger used for injected conversion"]
    pub InjectedTrigger: u32,
    #[doc = "< Rising, falling or both edges selected"]
    pub ExtTriggerEdge: u32,
    #[doc = "< Injected scanning mode"]
    pub InjectedScanMode: FunctionalState,
    #[doc = "< Number of channels in injected sequence"]
    pub InjectedChannelsNbr: u32,
    #[doc = "< Injected conversions remaining"]
    pub InjConvRemaining: u32,
    #[doc = "< DFSDM filter state"]
    pub State: HAL_DFSDM_Filter_StateTypeDef,
    #[doc = "< DFSDM filter error code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout_DFSDM_Filter_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DFSDM_Filter_HandleTypeDef>(),
        92usize,
        concat!("Size of: ", stringify!(DFSDM_Filter_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DFSDM_Filter_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DFSDM_Filter_HandleTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_HandleTypeDef>())).Instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_HandleTypeDef>())).Init as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_HandleTypeDef>())).hdmaReg as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_HandleTypeDef),
            "::",
            stringify!(hdmaReg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_HandleTypeDef>())).hdmaInj as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_HandleTypeDef),
            "::",
            stringify!(hdmaInj)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_HandleTypeDef>())).RegularContMode as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_HandleTypeDef),
            "::",
            stringify!(RegularContMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_HandleTypeDef>())).RegularTrigger as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_HandleTypeDef),
            "::",
            stringify!(RegularTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_HandleTypeDef>())).InjectedTrigger as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_HandleTypeDef),
            "::",
            stringify!(InjectedTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_HandleTypeDef>())).ExtTriggerEdge as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_HandleTypeDef),
            "::",
            stringify!(ExtTriggerEdge)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_HandleTypeDef>())).InjectedScanMode as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_HandleTypeDef),
            "::",
            stringify!(InjectedScanMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_HandleTypeDef>())).InjectedChannelsNbr as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_HandleTypeDef),
            "::",
            stringify!(InjectedChannelsNbr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_HandleTypeDef>())).InjConvRemaining as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_HandleTypeDef),
            "::",
            stringify!(InjConvRemaining)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_HandleTypeDef>())).State as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_HandleTypeDef>())).ErrorCode as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl Default for DFSDM_Filter_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  DFSDM filter analog watchdog parameters structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DFSDM_Filter_AwdParamTypeDef {
    #[doc = "< Values from digital filter or from channel watchdog filter."]
    #[doc = "This parameter can be a value of @ref DFSDM_Filter_AwdDataSource"]
    pub DataSource: u32,
    #[doc = "< Analog watchdog channel selection."]
    #[doc = "This parameter can be a values combination of @ref DFSDM_Channel_Selection"]
    pub Channel: u32,
    #[doc = "< High threshold for the analog watchdog."]
    #[doc = "This parameter must be a number between Min_Data = -8388608 and Max_Data = 8388607"]
    pub HighThreshold: i32,
    #[doc = "< Low threshold for the analog watchdog."]
    #[doc = "This parameter must be a number between Min_Data = -8388608 and Max_Data = 8388607"]
    pub LowThreshold: i32,
    #[doc = "< Break signal assigned to analog watchdog high threshold event."]
    #[doc = "This parameter can be a values combination of @ref DFSDM_BreakSignals"]
    pub HighBreakSignal: u32,
    #[doc = "< Break signal assigned to analog watchdog low threshold event."]
    #[doc = "This parameter can be a values combination of @ref DFSDM_BreakSignals"]
    pub LowBreakSignal: u32,
}
#[test]
fn bindgen_test_layout_DFSDM_Filter_AwdParamTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DFSDM_Filter_AwdParamTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(DFSDM_Filter_AwdParamTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DFSDM_Filter_AwdParamTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DFSDM_Filter_AwdParamTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_AwdParamTypeDef>())).DataSource as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_AwdParamTypeDef),
            "::",
            stringify!(DataSource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_AwdParamTypeDef>())).Channel as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_AwdParamTypeDef),
            "::",
            stringify!(Channel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_AwdParamTypeDef>())).HighThreshold as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_AwdParamTypeDef),
            "::",
            stringify!(HighThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_AwdParamTypeDef>())).LowThreshold as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_AwdParamTypeDef),
            "::",
            stringify!(LowThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_AwdParamTypeDef>())).HighBreakSignal as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_AwdParamTypeDef),
            "::",
            stringify!(HighBreakSignal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DFSDM_Filter_AwdParamTypeDef>())).LowBreakSignal as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DFSDM_Filter_AwdParamTypeDef),
            "::",
            stringify!(LowBreakSignal)
        )
    );
}
extern "C" {
    #[doc = " @addtogroup DFSDM_Exported_Functions_Group1_Channel Channel initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_DFSDM_ChannelInit(
        hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_ChannelDeInit(
        hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_ChannelMspInit(hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DFSDM_ChannelMspDeInit(hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup DFSDM_Exported_Functions_Group2_Channel Channel operation functions"]
    #[doc = " @{"]
    pub fn HAL_DFSDM_ChannelCkabStart(
        hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_ChannelCkabStart_IT(
        hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_ChannelCkabStop(
        hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_ChannelCkabStop_IT(
        hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_ChannelScdStart(
        hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef,
        Threshold: u32,
        BreakSignal: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_ChannelScdStart_IT(
        hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef,
        Threshold: u32,
        BreakSignal: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_ChannelScdStop(
        hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_ChannelScdStop_IT(
        hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_ChannelGetAwdValue(hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef) -> i16;
}
extern "C" {
    pub fn HAL_DFSDM_ChannelModifyOffset(
        hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef,
        Offset: i32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_ChannelPollForCkab(
        hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_ChannelPollForScd(
        hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_ChannelCkabCallback(hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DFSDM_ChannelScdCallback(hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef);
}
extern "C" {
    #[doc = " @defgroup DFSDM_Exported_Functions_Group3_Channel Channel state function"]
    #[doc = " @{"]
    pub fn HAL_DFSDM_ChannelGetState(
        hdfsdm_channel: *mut DFSDM_Channel_HandleTypeDef,
    ) -> HAL_DFSDM_Channel_StateTypeDef;
}
extern "C" {
    #[doc = " @addtogroup DFSDM_Exported_Functions_Group1_Filter Filter initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_DFSDM_FilterInit(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterDeInit(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterMspInit(hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DFSDM_FilterMspDeInit(hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup DFSDM_Exported_Functions_Group2_Filter Filter control functions"]
    #[doc = " @{"]
    pub fn HAL_DFSDM_FilterConfigRegChannel(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
        Channel: u32,
        ContinuousMode: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterConfigInjChannel(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup DFSDM_Exported_Functions_Group3_Filter Filter operation functions"]
    #[doc = " @{"]
    pub fn HAL_DFSDM_FilterRegularStart(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterRegularStart_IT(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterRegularStart_DMA(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
        pData: *mut i32,
        Length: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterRegularMsbStart_DMA(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
        pData: *mut i16,
        Length: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterRegularStop(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterRegularStop_IT(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterRegularStop_DMA(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterInjectedStart(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterInjectedStart_IT(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterInjectedStart_DMA(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
        pData: *mut i32,
        Length: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterInjectedMsbStart_DMA(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
        pData: *mut i16,
        Length: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterInjectedStop(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterInjectedStop_IT(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterInjectedStop_DMA(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterAwdStart_IT(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
        awdParam: *mut DFSDM_Filter_AwdParamTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterAwdStop_IT(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterExdStart(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterExdStop(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterGetRegularValue(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
        Channel: *mut u32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_DFSDM_FilterGetInjectedValue(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
        Channel: *mut u32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_DFSDM_FilterGetExdMaxValue(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
        Channel: *mut u32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_DFSDM_FilterGetExdMinValue(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
        Channel: *mut u32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_DFSDM_FilterGetConvTimeValue(hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_DFSDM_IRQHandler(hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DFSDM_FilterPollForRegConversion(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterPollForInjConversion(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterRegConvCpltCallback(hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DFSDM_FilterRegConvHalfCpltCallback(hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DFSDM_FilterInjConvCpltCallback(hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DFSDM_FilterInjConvHalfCpltCallback(hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DFSDM_FilterAwdCallback(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
        Channel: u32,
        Threshold: u32,
    );
}
extern "C" {
    pub fn HAL_DFSDM_FilterErrorCallback(hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef);
}
extern "C" {
    #[doc = " @defgroup DFSDM_Exported_Functions_Group4_Filter Filter state functions"]
    #[doc = " @{"]
    pub fn HAL_DFSDM_FilterGetState(
        hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef,
    ) -> HAL_DFSDM_Filter_StateTypeDef;
}
extern "C" {
    pub fn HAL_DFSDM_FilterGetError(hdfsdm_filter: *mut DFSDM_Filter_HandleTypeDef) -> u32;
}
#[doc = " @defgroup CORTEX_MPU_Region_Initialization_Structure_definition MPU Region Initialization Structure Definition"]
#[doc = " @brief  MPU Region initialization structure"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MPU_Region_InitTypeDef {
    #[doc = "< Specifies the status of the region."]
    #[doc = "This parameter can be a value of @ref CORTEX_MPU_Region_Enable"]
    pub Enable: u8,
    #[doc = "< Specifies the number of the region to protect."]
    #[doc = "This parameter can be a value of @ref CORTEX_MPU_Region_Number"]
    pub Number: u8,
    #[doc = "< Specifies the base address of the region to protect."]
    pub BaseAddress: u32,
    #[doc = "< Specifies the size of the region to protect."]
    #[doc = "This parameter can be a value of @ref CORTEX_MPU_Region_Size"]
    pub Size: u8,
    #[doc = "< Specifies the number of the subregion protection to disable."]
    #[doc = "This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF"]
    pub SubRegionDisable: u8,
    #[doc = "< Specifies the TEX field level."]
    #[doc = "This parameter can be a value of @ref CORTEX_MPU_TEX_Levels"]
    pub TypeExtField: u8,
    #[doc = "< Specifies the region access permission type."]
    #[doc = "This parameter can be a value of @ref CORTEX_MPU_Region_Permission_Attributes"]
    pub AccessPermission: u8,
    #[doc = "< Specifies the instruction access status."]
    #[doc = "This parameter can be a value of @ref CORTEX_MPU_Instruction_Access"]
    pub DisableExec: u8,
    #[doc = "< Specifies the shareability status of the protected region."]
    #[doc = "This parameter can be a value of @ref CORTEX_MPU_Access_Shareable"]
    pub IsShareable: u8,
    #[doc = "< Specifies the cacheable status of the region protected."]
    #[doc = "This parameter can be a value of @ref CORTEX_MPU_Access_Cacheable"]
    pub IsCacheable: u8,
    #[doc = "< Specifies the bufferable status of the protected region."]
    #[doc = "This parameter can be a value of @ref CORTEX_MPU_Access_Bufferable"]
    pub IsBufferable: u8,
}
#[test]
fn bindgen_test_layout_MPU_Region_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<MPU_Region_InitTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(MPU_Region_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<MPU_Region_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(MPU_Region_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPU_Region_InitTypeDef>())).Enable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Region_InitTypeDef),
            "::",
            stringify!(Enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPU_Region_InitTypeDef>())).Number as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Region_InitTypeDef),
            "::",
            stringify!(Number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MPU_Region_InitTypeDef>())).BaseAddress as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Region_InitTypeDef),
            "::",
            stringify!(BaseAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPU_Region_InitTypeDef>())).Size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Region_InitTypeDef),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MPU_Region_InitTypeDef>())).SubRegionDisable as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Region_InitTypeDef),
            "::",
            stringify!(SubRegionDisable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MPU_Region_InitTypeDef>())).TypeExtField as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Region_InitTypeDef),
            "::",
            stringify!(TypeExtField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MPU_Region_InitTypeDef>())).AccessPermission as *const _
                as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Region_InitTypeDef),
            "::",
            stringify!(AccessPermission)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MPU_Region_InitTypeDef>())).DisableExec as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Region_InitTypeDef),
            "::",
            stringify!(DisableExec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MPU_Region_InitTypeDef>())).IsShareable as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Region_InitTypeDef),
            "::",
            stringify!(IsShareable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MPU_Region_InitTypeDef>())).IsCacheable as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Region_InitTypeDef),
            "::",
            stringify!(IsCacheable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MPU_Region_InitTypeDef>())).IsBufferable as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Region_InitTypeDef),
            "::",
            stringify!(IsBufferable)
        )
    );
}
extern "C" {
    #[doc = " @defgroup CORTEX_Exported_Functions_Group1 Initialization and Configuration functions"]
    #[doc = " @brief    Initialization and Configuration functions"]
    #[doc = " @{"]
    pub fn HAL_NVIC_SetPriorityGrouping(PriorityGroup: u32);
}
extern "C" {
    pub fn HAL_NVIC_SetPriority(IRQn: IRQn_Type, PreemptPriority: u32, SubPriority: u32);
}
extern "C" {
    pub fn HAL_NVIC_EnableIRQ(IRQn: IRQn_Type);
}
extern "C" {
    pub fn HAL_NVIC_DisableIRQ(IRQn: IRQn_Type);
}
extern "C" {
    pub fn HAL_NVIC_SystemReset();
}
extern "C" {
    pub fn HAL_SYSTICK_Config(TicksNumb: u32) -> u32;
}
extern "C" {
    #[doc = " @defgroup CORTEX_Exported_Functions_Group2 Peripheral Control functions"]
    #[doc = " @brief   Cortex control functions"]
    #[doc = " @{"]
    pub fn HAL_NVIC_GetPriorityGrouping() -> u32;
}
extern "C" {
    pub fn HAL_NVIC_GetPriority(
        IRQn: IRQn_Type,
        PriorityGroup: u32,
        pPreemptPriority: *mut u32,
        pSubPriority: *mut u32,
    );
}
extern "C" {
    pub fn HAL_NVIC_GetPendingIRQ(IRQn: IRQn_Type) -> u32;
}
extern "C" {
    pub fn HAL_NVIC_SetPendingIRQ(IRQn: IRQn_Type);
}
extern "C" {
    pub fn HAL_NVIC_ClearPendingIRQ(IRQn: IRQn_Type);
}
extern "C" {
    pub fn HAL_NVIC_GetActive(IRQn: IRQn_Type) -> u32;
}
extern "C" {
    pub fn HAL_SYSTICK_CLKSourceConfig(CLKSource: u32);
}
extern "C" {
    pub fn HAL_SYSTICK_IRQHandler();
}
extern "C" {
    pub fn HAL_SYSTICK_Callback();
}
extern "C" {
    pub fn HAL_MPU_Enable(MPU_Control: u32);
}
extern "C" {
    pub fn HAL_MPU_Disable();
}
extern "C" {
    pub fn HAL_MPU_ConfigRegion(MPU_Init: *mut MPU_Region_InitTypeDef);
}
#[doc = " @brief  ADC group regular oversampling structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ADC_OversamplingTypeDef {
    #[doc = "< Configures the oversampling ratio."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_OVS_RATIO"]
    pub Ratio: u32,
    #[doc = "< Configures the division coefficient for the Oversampler."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_OVS_SHIFT"]
    pub RightBitShift: u32,
    #[doc = "< Selects the regular triggered oversampling mode."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_OVS_DISCONT_MODE"]
    pub TriggeredMode: u32,
    #[doc = "< Selects the regular oversampling mode."]
    #[doc = "The oversampling is either temporary stopped or reset upon an injected"]
    #[doc = "sequence interruption."]
    #[doc = "If oversampling is enabled on both regular and injected groups, this parameter"]
    #[doc = "is discarded and forced to setting \"ADC_REGOVERSAMPLING_RESUMED_MODE\""]
    #[doc = "(the oversampling buffer is zeroed during injection sequence)."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_OVS_SCOPE_REG"]
    pub OversamplingStopReset: u32,
}
#[test]
fn bindgen_test_layout_ADC_OversamplingTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<ADC_OversamplingTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(ADC_OversamplingTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_OversamplingTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_OversamplingTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_OversamplingTypeDef>())).Ratio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_OversamplingTypeDef),
            "::",
            stringify!(Ratio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_OversamplingTypeDef>())).RightBitShift as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_OversamplingTypeDef),
            "::",
            stringify!(RightBitShift)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_OversamplingTypeDef>())).TriggeredMode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_OversamplingTypeDef),
            "::",
            stringify!(TriggeredMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_OversamplingTypeDef>())).OversamplingStopReset as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_OversamplingTypeDef),
            "::",
            stringify!(OversamplingStopReset)
        )
    );
}
#[doc = " @brief  Structure definition of ADC instance and ADC group regular."]
#[doc = " @note   Parameters of this structure are shared within 2 scopes:"]
#[doc = "          - Scope entire ADC (affects ADC groups regular and injected): ClockPrescaler, Resolution, DataAlign,"]
#[doc = "            ScanConvMode, EOCSelection, LowPowerAutoWait."]
#[doc = "          - Scope ADC group regular: ContinuousConvMode, NbrOfConversion, DiscontinuousConvMode, NbrOfDiscConversion,"]
#[doc = "            ExternalTrigConv, ExternalTrigConvEdge, DMAContinuousRequests, Overrun, OversamplingMode, Oversampling."]
#[doc = " @note   The setting of these parameters by function HAL_ADC_Init() is conditioned to ADC state."]
#[doc = "         ADC state can be either:"]
#[doc = "          - For all parameters: ADC disabled"]
#[doc = "          - For all parameters except 'LowPowerAutoWait', 'DMAContinuousRequests' and 'Oversampling': ADC enabled without conversion on going on group regular."]
#[doc = "          - For parameters 'LowPowerAutoWait' and 'DMAContinuousRequests': ADC enabled without conversion on going on groups regular and injected."]
#[doc = "         If ADC is not in the appropriate state to modify some parameters, these parameters setting is bypassed"]
#[doc = "         without error reporting (as it can be the expected behavior in case of intended action to update another parameter"]
#[doc = "         (which fulfills the ADC state condition) on the fly)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_InitTypeDef {
    #[doc = "< Select ADC clock source (synchronous clock derived from APB clock or asynchronous clock derived from system clock or PLL (Refer to reference manual for list of clocks available)) and clock prescaler."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_COMMON_CLOCK_SOURCE."]
    #[doc = "Note: The ADC clock configuration is common to all ADC instances."]
    #[doc = "Note: In case of usage of channels on injected group, ADC frequency should be lower than AHB clock frequency /4 for resolution 12 or 10 bits,"]
    #[doc = "AHB clock frequency /3 for resolution 8 bits, AHB clock frequency /2 for resolution 6 bits."]
    #[doc = "Note: In case of synchronous clock mode based on HCLK/1, the configuration must be enabled only"]
    #[doc = "if the system clock has a 50% duty clock cycle (APB prescaler configured inside RCC"]
    #[doc = "must be bypassed and PCLK clock must have 50% duty cycle). Refer to reference manual for details."]
    #[doc = "Note: In case of usage of asynchronous clock, the selected clock must be preliminarily enabled at RCC top level."]
    #[doc = "Note: This parameter can be modified only if all ADC instances are disabled."]
    pub ClockPrescaler: u32,
    #[doc = "< Configure the ADC resolution."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_RESOLUTION"]
    pub Resolution: u32,
    #[doc = "< Specify ADC data alignment in conversion data register (right or left)."]
    #[doc = "Refer to reference manual for alignments formats versus resolutions."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_DATA_ALIGN"]
    pub DataAlign: u32,
    #[doc = "< Configure the sequencer of ADC groups regular and injected."]
    #[doc = "This parameter can be associated to parameter 'DiscontinuousConvMode' to have main sequence subdivided in successive parts."]
    #[doc = "If disabled: Conversion is performed in single mode (one channel converted, the one defined in rank 1)."]
    #[doc = "Parameters 'NbrOfConversion' and 'InjectedNbrOfConversion' are discarded (equivalent to set to 1)."]
    #[doc = "If enabled:  Conversions are performed in sequence mode (multiple ranks defined by 'NbrOfConversion' or 'InjectedNbrOfConversion' and rank of each channel in sequencer)."]
    #[doc = "Scan direction is upward: from rank 1 to rank 'n'."]
    #[doc = "This parameter can be a value of @ref ADC_Scan_mode"]
    pub ScanConvMode: u32,
    #[doc = "< Specify which EOC (End Of Conversion) flag is used for conversion by polling and interruption: end of unitary conversion or end of sequence conversions."]
    #[doc = "This parameter can be a value of @ref ADC_EOCSelection."]
    pub EOCSelection: u32,
    #[doc = "< Select the dynamic low power Auto Delay: new conversion start only when the previous"]
    #[doc = "conversion (for ADC group regular) or previous sequence (for ADC group injected) has been retrieved by user software,"]
    #[doc = "using function HAL_ADC_GetValue() or HAL_ADCEx_InjectedGetValue()."]
    #[doc = "This feature automatically adapts the frequency of ADC conversions triggers to the speed of the system that reads the data. Moreover, this avoids risk of overrun"]
    #[doc = "for low frequency applications."]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    #[doc = "Note: It is not recommended to use with interruption or DMA (HAL_ADC_Start_IT(), HAL_ADC_Start_DMA()) since these modes have to clear immediately the EOC flag (by CPU to free the IRQ pending event or by DMA)."]
    #[doc = "Auto wait will work but fort a very short time, discarding its intended benefit (except specific case of high load of CPU or DMA transfers which can justify usage of auto wait)."]
    #[doc = "Do use with polling: 1. Start conversion with HAL_ADC_Start(), 2. Later on, when ADC conversion data is needed:"]
    #[doc = "use HAL_ADC_PollForConversion() to ensure that conversion is completed and HAL_ADC_GetValue() to retrieve conversion result and trig another conversion start."]
    #[doc = "(in case of usage of ADC group injected, use the equivalent functions HAL_ADCExInjected_Start(), HAL_ADCEx_InjectedGetValue(), ...)."]
    pub LowPowerAutoWait: FunctionalState,
    #[doc = "< Specify whether the conversion is performed in single mode (one conversion) or continuous mode for ADC group regular,"]
    #[doc = "after the first ADC conversion start trigger occurred (software start or external trigger)."]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    pub ContinuousConvMode: FunctionalState,
    #[doc = "< Specify the number of ranks that will be converted within the regular group sequencer."]
    #[doc = "To use the regular group sequencer and convert several ranks, parameter 'ScanConvMode' must be enabled."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 16."]
    #[doc = "Note: This parameter must be modified when no conversion is on going on regular group (ADC disabled, or ADC enabled without"]
    #[doc = "continuous mode or external trigger that could launch a conversion)."]
    pub NbrOfConversion: u32,
    #[doc = "< Specify whether the conversions sequence of ADC group regular is performed in Complete-sequence/Discontinuous-sequence"]
    #[doc = "(main sequence subdivided in successive parts)."]
    #[doc = "Discontinuous mode is used only if sequencer is enabled (parameter 'ScanConvMode'). If sequencer is disabled, this parameter is discarded."]
    #[doc = "Discontinuous mode can be enabled only if continuous mode is disabled. If continuous mode is enabled, this parameter setting is discarded."]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    pub DiscontinuousConvMode: FunctionalState,
    #[doc = "< Specifies the number of discontinuous conversions in which the main sequence of ADC group regular (parameter NbrOfConversion) will be subdivided."]
    #[doc = "If parameter 'DiscontinuousConvMode' is disabled, this parameter is discarded."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 8."]
    pub NbrOfDiscConversion: u32,
    #[doc = "< Select the external event source used to trigger ADC group regular conversion start."]
    #[doc = "If set to ADC_SOFTWARE_START, external triggers are disabled and software trigger is used instead."]
    #[doc = "This parameter can be a value of @ref ADC_regular_external_trigger_source."]
    #[doc = "Caution: external trigger source is common to all ADC instances."]
    pub ExternalTrigConv: u32,
    #[doc = "< Select the external event edge used to trigger ADC group regular conversion start."]
    #[doc = "If trigger source is set to ADC_SOFTWARE_START, this parameter is discarded."]
    #[doc = "This parameter can be a value of @ref ADC_regular_external_trigger_edge"]
    pub ExternalTrigConvEdge: u32,
    #[doc = "< Specify whether the DMA requests are performed in one shot mode (DMA transfer stops when number of conversions is reached)"]
    #[doc = "or in continuous mode (DMA transfer unlimited, whatever number of conversions)."]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    #[doc = "Note: In continuous mode, DMA must be configured in circular mode. Otherwise an overrun will be triggered when DMA buffer maximum pointer is reached."]
    pub DMAContinuousRequests: FunctionalState,
    #[doc = "< Select the behavior in case of overrun: data overwritten or preserved (default)."]
    #[doc = "This parameter applies to ADC group regular only."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_REG_OVR_DATA_BEHAVIOR."]
    #[doc = "Note: In case of overrun set to data preserved and usage with programming model with interruption (HAL_Start_IT()): ADC IRQ handler has to clear"]
    #[doc = "end of conversion flags, this induces the release of the preserved data. If needed, this data can be saved in function"]
    #[doc = "HAL_ADC_ConvCpltCallback(), placed in user program code (called before end of conversion flags clear)."]
    #[doc = "Note: Error reporting with respect to the conversion mode:"]
    #[doc = "- Usage with ADC conversion by polling for event or interruption: Error is reported only if overrun is set to data preserved. If overrun is set to data"]
    #[doc = "overwritten, user can willingly not read all the converted data, this is not considered as an erroneous case."]
    #[doc = "- Usage with ADC conversion by DMA: Error is reported whatever overrun setting (DMA is expected to process all data from data register)."]
    pub Overrun: u32,
    #[doc = "< Specify whether the oversampling feature is enabled or disabled."]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    #[doc = "Note: This parameter can be modified only if there is no conversion is ongoing on ADC groups regular and injected"]
    pub OversamplingMode: FunctionalState,
    #[doc = "< Specify the Oversampling parameters."]
    #[doc = "Caution: this setting overwrites the previous oversampling configuration if oversampling is already enabled."]
    pub Oversampling: ADC_OversamplingTypeDef,
}
#[test]
fn bindgen_test_layout_ADC_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<ADC_InitTypeDef>(),
        76usize,
        concat!("Size of: ", stringify!(ADC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_InitTypeDef>())).ClockPrescaler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(ClockPrescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_InitTypeDef>())).Resolution as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(Resolution)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_InitTypeDef>())).DataAlign as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(DataAlign)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_InitTypeDef>())).ScanConvMode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(ScanConvMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_InitTypeDef>())).EOCSelection as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(EOCSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InitTypeDef>())).LowPowerAutoWait as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(LowPowerAutoWait)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InitTypeDef>())).ContinuousConvMode as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(ContinuousConvMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InitTypeDef>())).NbrOfConversion as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(NbrOfConversion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InitTypeDef>())).DiscontinuousConvMode as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(DiscontinuousConvMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InitTypeDef>())).NbrOfDiscConversion as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(NbrOfDiscConversion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InitTypeDef>())).ExternalTrigConv as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(ExternalTrigConv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InitTypeDef>())).ExternalTrigConvEdge as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(ExternalTrigConvEdge)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InitTypeDef>())).DMAContinuousRequests as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(DMAContinuousRequests)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_InitTypeDef>())).Overrun as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(Overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InitTypeDef>())).OversamplingMode as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(OversamplingMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_InitTypeDef>())).Oversampling as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(Oversampling)
        )
    );
}
impl Default for ADC_InitTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  Structure definition of ADC channel for regular group"]
#[doc = " @note   The setting of these parameters by function HAL_ADC_ConfigChannel() is conditioned to ADC state."]
#[doc = "         ADC state can be either:"]
#[doc = "          - For all parameters: ADC disabled (this is the only possible ADC state to modify parameter 'SingleDiff')"]
#[doc = "          - For all except parameters 'SamplingTime', 'Offset', 'OffsetNumber': ADC enabled without conversion on going on regular group."]
#[doc = "          - For parameters 'SamplingTime', 'Offset', 'OffsetNumber': ADC enabled without conversion on going on regular and injected groups."]
#[doc = "         If ADC is not in the appropriate state to modify some parameters, these parameters setting is bypassed"]
#[doc = "         without error reporting (as it can be the expected behavior in case of intended action to update another parameter (which fulfills the ADC state condition)"]
#[doc = "         on the fly)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ADC_ChannelConfTypeDef {
    #[doc = "< Specify the channel to configure into ADC regular group."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_CHANNEL"]
    #[doc = "Note: Depending on devices and ADC instances, some channels may not be available on device package pins. Refer to device datasheet for channels availability."]
    pub Channel: u32,
    #[doc = "< Specify the rank in the regular group sequencer."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_REG_SEQ_RANKS"]
    #[doc = "Note: to disable a channel or change order of conversion sequencer, rank containing a previous channel setting can be overwritten by"]
    #[doc = "the new channel setting (or parameter number of conversions adjusted)"]
    pub Rank: u32,
    #[doc = "< Sampling time value to be set for the selected channel."]
    #[doc = "Unit: ADC clock cycles"]
    #[doc = "Conversion time is the addition of sampling time and processing time"]
    #[doc = "(12.5 ADC clock cycles at ADC resolution 12 bits, 10.5 cycles at 10 bits, 8.5 cycles at 8 bits, 6.5 cycles at 6 bits)."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_CHANNEL_SAMPLINGTIME"]
    #[doc = "Caution: This parameter applies to a channel that can be used into regular and/or injected group."]
    #[doc = "It overwrites the last setting."]
    #[doc = "Note: In case of usage of internal measurement channels (VrefInt/Vbat/TempSensor),"]
    #[doc = "sampling time constraints must be respected (sampling time can be adjusted in function of ADC clock frequency and sampling time setting)"]
    #[doc = "Refer to device datasheet for timings values."]
    pub SamplingTime: u32,
    #[doc = "< Select single-ended or differential input."]
    #[doc = "In differential mode: Differential measurement is carried out between the selected channel 'i' (positive input) and channel 'i+1' (negative input)."]
    #[doc = "Only channel 'i' has to be configured, channel 'i+1' is configured automatically."]
    #[doc = "This parameter must be a value of @ref ADC_HAL_EC_CHANNEL_SINGLE_DIFF_ENDING"]
    #[doc = "Caution: This parameter applies to a channel that can be used in a regular and/or injected group."]
    #[doc = "It overwrites the last setting."]
    #[doc = "Note: Refer to Reference Manual to ensure the selected channel is available in differential mode."]
    #[doc = "Note: When configuring a channel 'i' in differential mode, the channel 'i+1' is not usable separately."]
    #[doc = "Note: This parameter must be modified when ADC is disabled (before ADC start conversion or after ADC stop conversion)."]
    #[doc = "If ADC is enabled, this parameter setting is bypassed without error reporting (as it can be the expected behavior in case"]
    #[doc = "of another parameter update on the fly)"]
    pub SingleDiff: u32,
    #[doc = "< Select the offset number"]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_OFFSET_NB"]
    #[doc = "Caution: Only one offset is allowed per channel. This parameter overwrites the last setting."]
    pub OffsetNumber: u32,
    #[doc = "< Define the offset to be subtracted from the raw converted data."]
    #[doc = "Offset value must be a positive number."]
    #[doc = "Depending of ADC resolution selected (12, 10, 8 or 6 bits), this parameter must be a number between Min_Data = 0x000 and Max_Data = 0xFFF,"]
    #[doc = "0x3FF, 0xFF or 0x3F respectively."]
    #[doc = "Note: This parameter must be modified when no conversion is on going on both regular and injected groups (ADC disabled, or ADC enabled"]
    #[doc = "without continuous mode or external trigger that could launch a conversion)."]
    pub Offset: u32,
}
#[test]
fn bindgen_test_layout_ADC_ChannelConfTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<ADC_ChannelConfTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(ADC_ChannelConfTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_ChannelConfTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_ChannelConfTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_ChannelConfTypeDef>())).Channel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_ChannelConfTypeDef),
            "::",
            stringify!(Channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_ChannelConfTypeDef>())).Rank as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_ChannelConfTypeDef),
            "::",
            stringify!(Rank)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_ChannelConfTypeDef>())).SamplingTime as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_ChannelConfTypeDef),
            "::",
            stringify!(SamplingTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_ChannelConfTypeDef>())).SingleDiff as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_ChannelConfTypeDef),
            "::",
            stringify!(SingleDiff)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_ChannelConfTypeDef>())).OffsetNumber as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_ChannelConfTypeDef),
            "::",
            stringify!(OffsetNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_ChannelConfTypeDef>())).Offset as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_ChannelConfTypeDef),
            "::",
            stringify!(Offset)
        )
    );
}
#[doc = " @brief  Structure definition of ADC analog watchdog"]
#[doc = " @note   The setting of these parameters by function HAL_ADC_AnalogWDGConfig() is conditioned to ADC state."]
#[doc = "         ADC state can be either:"]
#[doc = "          - For all parameters: ADC disabled or ADC enabled without conversion on going on ADC groups regular and injected."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_AnalogWDGConfTypeDef {
    #[doc = "< Select which ADC analog watchdog is monitoring the selected channel."]
    #[doc = "For Analog Watchdog 1: Only 1 channel can be monitored (or overall group of channels by setting parameter 'WatchdogMode')"]
    #[doc = "For Analog Watchdog 2 and 3: Several channels can be monitored (by successive calls of 'HAL_ADC_AnalogWDGConfig()' for each channel)"]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_AWD_NUMBER."]
    pub WatchdogNumber: u32,
    #[doc = "< Configure the ADC analog watchdog mode: single/all/none channels."]
    #[doc = "For Analog Watchdog 1: Configure the ADC analog watchdog mode: single channel or all channels, ADC groups regular and-or injected."]
    #[doc = "For Analog Watchdog 2 and 3: Several channels can be monitored by applying successively the AWD init structure. Channels on ADC group regular and injected are not differentiated: Set value 'ADC_ANALOGWATCHDOG_SINGLE_xxx' to monitor 1 channel, value 'ADC_ANALOGWATCHDOG_ALL_xxx' to monitor all channels, 'ADC_ANALOGWATCHDOG_NONE' to monitor no channel."]
    #[doc = "This parameter can be a value of @ref ADC_analog_watchdog_mode."]
    pub WatchdogMode: u32,
    #[doc = "< Select which ADC channel to monitor by analog watchdog."]
    #[doc = "For Analog Watchdog 1: this parameter has an effect only if parameter 'WatchdogMode' is configured on single channel (only 1 channel can be monitored)."]
    #[doc = "For Analog Watchdog 2 and 3: Several channels can be monitored. To use this feature, call successively the function HAL_ADC_AnalogWDGConfig() for each channel to be added (or removed with value 'ADC_ANALOGWATCHDOG_NONE')."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_CHANNEL."]
    pub Channel: u32,
    #[doc = "< Specify whether the analog watchdog is configured in interrupt or polling mode."]
    #[doc = "This parameter can be set to ENABLE or DISABLE"]
    pub ITMode: FunctionalState,
    #[doc = "< Configure the ADC analog watchdog High threshold value."]
    #[doc = "Depending of ADC resolution selected (12, 10, 8 or 6 bits), this parameter must be a number"]
    #[doc = "between Min_Data = 0x000 and Max_Data = 0xFFF, 0x3FF, 0xFF or 0x3F respectively."]
    #[doc = "Note: Analog watchdog 2 and 3 are limited to a resolution of 8 bits: if ADC resolution is 12 bits"]
    #[doc = "the 4 LSB are ignored, if ADC resolution is 10 bits the 2 LSB are ignored."]
    #[doc = "Note: If ADC oversampling is enabled, ADC analog watchdog thresholds are"]
    #[doc = "impacted: the comparison of analog watchdog thresholds is done on"]
    #[doc = "oversampling final computation (after ratio and shift application):"]
    #[doc = "ADC data register bitfield [15:4] (12 most significant bits)."]
    pub HighThreshold: u32,
    #[doc = "< Configures the ADC analog watchdog Low threshold value."]
    #[doc = "Depending of ADC resolution selected (12, 10, 8 or 6 bits), this parameter must be a number"]
    #[doc = "between Min_Data = 0x000 and Max_Data = 0xFFF, 0x3FF, 0xFF or 0x3F respectively."]
    #[doc = "Note: Analog watchdog 2 and 3 are limited to a resolution of 8 bits: if ADC resolution is 12 bits"]
    #[doc = "the 4 LSB are ignored, if ADC resolution is 10 bits the 2 LSB are ignored."]
    #[doc = "Note: If ADC oversampling is enabled, ADC analog watchdog thresholds are"]
    #[doc = "impacted: the comparison of analog watchdog thresholds is done on"]
    #[doc = "oversampling final computation (after ratio and shift application):"]
    #[doc = "ADC data register bitfield [15:4] (12 most significant bits)."]
    pub LowThreshold: u32,
}
#[test]
fn bindgen_test_layout_ADC_AnalogWDGConfTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<ADC_AnalogWDGConfTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(ADC_AnalogWDGConfTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_AnalogWDGConfTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_AnalogWDGConfTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_AnalogWDGConfTypeDef>())).WatchdogNumber as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_AnalogWDGConfTypeDef),
            "::",
            stringify!(WatchdogNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_AnalogWDGConfTypeDef>())).WatchdogMode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_AnalogWDGConfTypeDef),
            "::",
            stringify!(WatchdogMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_AnalogWDGConfTypeDef>())).Channel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_AnalogWDGConfTypeDef),
            "::",
            stringify!(Channel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_AnalogWDGConfTypeDef>())).ITMode as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_AnalogWDGConfTypeDef),
            "::",
            stringify!(ITMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_AnalogWDGConfTypeDef>())).HighThreshold as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_AnalogWDGConfTypeDef),
            "::",
            stringify!(HighThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_AnalogWDGConfTypeDef>())).LowThreshold as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_AnalogWDGConfTypeDef),
            "::",
            stringify!(LowThreshold)
        )
    );
}
impl Default for ADC_AnalogWDGConfTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  ADC group injected contexts queue configuration"]
#[doc = " @note   Structure intended to be used only through structure \"ADC_HandleTypeDef\""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ADC_InjectionConfigTypeDef {
    #[doc = "< Injected channel configuration context: build-up over each"]
    #[doc = "HAL_ADCEx_InjectedConfigChannel() call to finally initialize"]
    #[doc = "JSQR register at HAL_ADCEx_InjectedConfigChannel() last call"]
    pub ContextQueue: u32,
    #[doc = "< Number of channels in the injected sequence"]
    pub ChannelCount: u32,
}
#[test]
fn bindgen_test_layout_ADC_InjectionConfigTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<ADC_InjectionConfigTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(ADC_InjectionConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_InjectionConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_InjectionConfigTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfigTypeDef>())).ContextQueue as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfigTypeDef),
            "::",
            stringify!(ContextQueue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfigTypeDef>())).ChannelCount as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfigTypeDef),
            "::",
            stringify!(ChannelCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut ADC_TypeDef,
    #[doc = "< ADC initialization parameters and regular conversions setting"]
    pub Init: ADC_InitTypeDef,
    #[doc = "< Pointer DMA Handler"]
    pub DMA_Handle: *mut DMA_HandleTypeDef,
    #[doc = "< ADC locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< ADC communication state (bitmap of ADC states)"]
    pub State: u32,
    #[doc = "< ADC Error code"]
    pub ErrorCode: u32,
    #[doc = "< ADC injected channel configuration build-up structure"]
    pub InjectionConfig: ADC_InjectionConfigTypeDef,
}
#[test]
fn bindgen_test_layout_ADC_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<ADC_HandleTypeDef>(),
        104usize,
        concat!("Size of: ", stringify!(ADC_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_HandleTypeDef>())).DMA_Handle as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_HandleTypeDef),
            "::",
            stringify!(DMA_Handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_HandleTypeDef>())).Lock as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_HandleTypeDef>())).State as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_HandleTypeDef>())).ErrorCode as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_HandleTypeDef>())).InjectionConfig as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_HandleTypeDef),
            "::",
            stringify!(InjectionConfig)
        )
    );
}
impl Default for ADC_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  ADC Injected Conversion Oversampling structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ADC_InjOversamplingTypeDef {
    #[doc = "< Configures the oversampling ratio."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_OVS_RATIO"]
    pub Ratio: u32,
    #[doc = "< Configures the division coefficient for the Oversampler."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_OVS_SHIFT"]
    pub RightBitShift: u32,
}
#[test]
fn bindgen_test_layout_ADC_InjOversamplingTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<ADC_InjOversamplingTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(ADC_InjOversamplingTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_InjOversamplingTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_InjOversamplingTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjOversamplingTypeDef>())).Ratio as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjOversamplingTypeDef),
            "::",
            stringify!(Ratio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjOversamplingTypeDef>())).RightBitShift as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjOversamplingTypeDef),
            "::",
            stringify!(RightBitShift)
        )
    );
}
#[doc = " @brief  Structure definition of ADC group injected and ADC channel affected to ADC group injected"]
#[doc = " @note   Parameters of this structure are shared within 2 scopes:"]
#[doc = "          - Scope channel: InjectedChannel, InjectedRank, InjectedSamplingTime , InjectedSingleDiff, InjectedOffsetNumber, InjectedOffset"]
#[doc = "          - Scope ADC group injected (affects all channels of injected group): InjectedNbrOfConversion, InjectedDiscontinuousConvMode,"]
#[doc = "            AutoInjectedConv, QueueInjectedContext, ExternalTrigInjecConv, ExternalTrigInjecConvEdge, InjecOversamplingMode, InjecOversampling."]
#[doc = " @note   The setting of these parameters by function HAL_ADCEx_InjectedConfigChannel() is conditioned to ADC state."]
#[doc = "         ADC state can be either:"]
#[doc = "          - For all parameters: ADC disabled (this is the only possible ADC state to modify parameter 'InjectedSingleDiff')"]
#[doc = "          - For parameters 'InjectedDiscontinuousConvMode', 'QueueInjectedContext', 'InjecOversampling': ADC enabled without conversion on going on injected group."]
#[doc = "          - For parameters 'InjectedSamplingTime', 'InjectedOffset', 'InjectedOffsetNumber', 'AutoInjectedConv': ADC enabled without conversion on going on regular and injected groups."]
#[doc = "          - For parameters 'InjectedChannel', 'InjectedRank', 'InjectedNbrOfConversion', 'ExternalTrigInjecConv', 'ExternalTrigInjecConvEdge': ADC enabled and while conversion on going"]
#[doc = "            on ADC groups regular and injected."]
#[doc = "         If ADC is not in the appropriate state to modify some parameters, these parameters setting is bypassed"]
#[doc = "         without error reporting (as it can be the expected behavior in case of intended action to update another parameter (which fulfills the ADC state condition) on the fly)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_InjectionConfTypeDef {
    #[doc = "< Specifies the channel to configure into ADC group injected."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_CHANNEL"]
    #[doc = "Note: Depending on devices and ADC instances, some channels may not be available on device package pins. Refer to device datasheet for channels availability."]
    pub InjectedChannel: u32,
    #[doc = "< Specifies the rank in the ADC group injected sequencer."]
    #[doc = "This parameter must be a value of @ref ADC_INJ_SEQ_RANKS."]
    #[doc = "Note: to disable a channel or change order of conversion sequencer, rank containing a previous channel setting can be overwritten by"]
    #[doc = "the new channel setting (or parameter number of conversions adjusted)"]
    pub InjectedRank: u32,
    #[doc = "< Sampling time value to be set for the selected channel."]
    #[doc = "Unit: ADC clock cycles."]
    #[doc = "Conversion time is the addition of sampling time and processing time"]
    #[doc = "(12.5 ADC clock cycles at ADC resolution 12 bits, 10.5 cycles at 10 bits, 8.5 cycles at 8 bits, 6.5 cycles at 6 bits)."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_CHANNEL_SAMPLINGTIME."]
    #[doc = "Caution: This parameter applies to a channel that can be used in a regular and/or injected group."]
    #[doc = "It overwrites the last setting."]
    #[doc = "Note: In case of usage of internal measurement channels (VrefInt/Vbat/TempSensor),"]
    #[doc = "sampling time constraints must be respected (sampling time can be adjusted in function of ADC clock frequency and sampling time setting)"]
    #[doc = "Refer to device datasheet for timings values."]
    pub InjectedSamplingTime: u32,
    #[doc = "< Selection of single-ended or differential input."]
    #[doc = "In differential mode: Differential measurement is between the selected channel 'i' (positive input) and channel 'i+1' (negative input)."]
    #[doc = "Only channel 'i' has to be configured, channel 'i+1' is configured automatically."]
    #[doc = "This parameter must be a value of @ref ADC_HAL_EC_CHANNEL_SINGLE_DIFF_ENDING."]
    #[doc = "Caution: This parameter applies to a channel that can be used in a regular and/or injected group."]
    #[doc = "It overwrites the last setting."]
    #[doc = "Note: Refer to Reference Manual to ensure the selected channel is available in differential mode."]
    #[doc = "Note: When configuring a channel 'i' in differential mode, the channel 'i+1' is not usable separately."]
    #[doc = "Note: This parameter must be modified when ADC is disabled (before ADC start conversion or after ADC stop conversion)."]
    #[doc = "If ADC is enabled, this parameter setting is bypassed without error reporting (as it can be the expected behavior in case"]
    #[doc = "of another parameter update on the fly)"]
    pub InjectedSingleDiff: u32,
    #[doc = "< Selects the offset number."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_OFFSET_NB."]
    #[doc = "Caution: Only one offset is allowed per channel. This parameter overwrites the last setting."]
    pub InjectedOffsetNumber: u32,
    #[doc = "< Defines the offset to be subtracted from the raw converted data."]
    #[doc = "Offset value must be a positive number."]
    #[doc = "Depending of ADC resolution selected (12, 10, 8 or 6 bits), this parameter must be a number"]
    #[doc = "between Min_Data = 0x000 and Max_Data = 0xFFF,  0x3FF, 0xFF or 0x3F respectively."]
    #[doc = "Note: This parameter must be modified when no conversion is on going on both regular and injected groups (ADC disabled, or ADC enabled"]
    #[doc = "without continuous mode or external trigger that could launch a conversion)."]
    pub InjectedOffset: u32,
    #[doc = "< Specifies the number of ranks that will be converted within the ADC group injected sequencer."]
    #[doc = "To use the injected group sequencer and convert several ranks, parameter 'ScanConvMode' must be enabled."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 4."]
    #[doc = "Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to"]
    #[doc = "configure a channel on injected group can impact the configuration of other channels previously set."]
    pub InjectedNbrOfConversion: u32,
    #[doc = "< Specifies whether the conversions sequence of ADC group injected is performed in Complete-sequence/Discontinuous-sequence"]
    #[doc = "(main sequence subdivided in successive parts)."]
    #[doc = "Discontinuous mode is used only if sequencer is enabled (parameter 'ScanConvMode'). If sequencer is disabled, this parameter is discarded."]
    #[doc = "Discontinuous mode can be enabled only if continuous mode is disabled."]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    #[doc = "Note: This parameter must be modified when ADC is disabled (before ADC start conversion or after ADC stop conversion)."]
    #[doc = "Note: For injected group, discontinuous mode converts the sequence channel by channel (discontinuous length fixed to 1 rank)."]
    #[doc = "Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to"]
    #[doc = "configure a channel on injected group can impact the configuration of other channels previously set."]
    pub InjectedDiscontinuousConvMode: FunctionalState,
    #[doc = "< Enables or disables the selected ADC group injected automatic conversion after regular one"]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    #[doc = "Note: To use Automatic injected conversion, discontinuous mode must be disabled ('DiscontinuousConvMode' and 'InjectedDiscontinuousConvMode' set to DISABLE)"]
    #[doc = "Note: To use Automatic injected conversion, injected group external triggers must be disabled ('ExternalTrigInjecConv' set to ADC_INJECTED_SOFTWARE_START)"]
    #[doc = "Note: In case of DMA used with regular group: if DMA configured in normal mode (single shot) JAUTO will be stopped upon DMA transfer complete."]
    #[doc = "To maintain JAUTO always enabled, DMA must be configured in circular mode."]
    #[doc = "Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to"]
    #[doc = "configure a channel on injected group can impact the configuration of other channels previously set."]
    pub AutoInjectedConv: FunctionalState,
    #[doc = "< Specifies whether the context queue feature is enabled."]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    #[doc = "If context queue is enabled, injected sequencer&channels configurations are queued on up to 2 contexts. If a"]
    #[doc = "new injected context is set when queue is full, error is triggered by interruption and through function"]
    #[doc = "'HAL_ADCEx_InjectedQueueOverflowCallback'."]
    #[doc = "Caution: This feature request that the sequence is fully configured before injected conversion start."]
    #[doc = "Therefore, configure channels with as many calls to HAL_ADCEx_InjectedConfigChannel() as the 'InjectedNbrOfConversion' parameter."]
    #[doc = "Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to"]
    #[doc = "configure a channel on injected group can impact the configuration of other channels previously set."]
    #[doc = "Note: This parameter must be modified when ADC is disabled (before ADC start conversion or after ADC stop conversion)."]
    pub QueueInjectedContext: FunctionalState,
    #[doc = "< Selects the external event used to trigger the conversion start of injected group."]
    #[doc = "If set to ADC_INJECTED_SOFTWARE_START, external triggers are disabled and software trigger is used instead."]
    #[doc = "This parameter can be a value of @ref ADC_injected_external_trigger_source."]
    #[doc = "Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to"]
    #[doc = "configure a channel on injected group can impact the configuration of other channels previously set."]
    pub ExternalTrigInjecConv: u32,
    #[doc = "< Selects the external trigger edge of injected group."]
    #[doc = "This parameter can be a value of @ref ADC_injected_external_trigger_edge."]
    #[doc = "If trigger source is set to ADC_INJECTED_SOFTWARE_START, this parameter is discarded."]
    #[doc = "Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to"]
    #[doc = "configure a channel on injected group can impact the configuration of other channels previously set."]
    pub ExternalTrigInjecConvEdge: u32,
    #[doc = "< Specifies whether the oversampling feature is enabled or disabled."]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    #[doc = "Note: This parameter can be modified only if there is no conversion is ongoing (both ADSTART and JADSTART cleared)."]
    pub InjecOversamplingMode: FunctionalState,
    #[doc = "< Specifies the Oversampling parameters."]
    #[doc = "Caution: this setting overwrites the previous oversampling configuration if oversampling already enabled."]
    #[doc = "Note: This parameter can be modified only if there is no conversion is ongoing (both ADSTART and JADSTART cleared)."]
    pub InjecOversampling: ADC_InjOversamplingTypeDef,
}
#[test]
fn bindgen_test_layout_ADC_InjectionConfTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<ADC_InjectionConfTypeDef>(),
        60usize,
        concat!("Size of: ", stringify!(ADC_InjectionConfTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_InjectionConfTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_InjectionConfTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfTypeDef>())).InjectedChannel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfTypeDef),
            "::",
            stringify!(InjectedChannel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfTypeDef>())).InjectedRank as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfTypeDef),
            "::",
            stringify!(InjectedRank)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfTypeDef>())).InjectedSamplingTime as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfTypeDef),
            "::",
            stringify!(InjectedSamplingTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfTypeDef>())).InjectedSingleDiff as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfTypeDef),
            "::",
            stringify!(InjectedSingleDiff)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfTypeDef>())).InjectedOffsetNumber as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfTypeDef),
            "::",
            stringify!(InjectedOffsetNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfTypeDef>())).InjectedOffset as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfTypeDef),
            "::",
            stringify!(InjectedOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfTypeDef>())).InjectedNbrOfConversion
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfTypeDef),
            "::",
            stringify!(InjectedNbrOfConversion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfTypeDef>())).InjectedDiscontinuousConvMode
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfTypeDef),
            "::",
            stringify!(InjectedDiscontinuousConvMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfTypeDef>())).AutoInjectedConv as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfTypeDef),
            "::",
            stringify!(AutoInjectedConv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfTypeDef>())).QueueInjectedContext as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfTypeDef),
            "::",
            stringify!(QueueInjectedContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfTypeDef>())).ExternalTrigInjecConv as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfTypeDef),
            "::",
            stringify!(ExternalTrigInjecConv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfTypeDef>())).ExternalTrigInjecConvEdge
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfTypeDef),
            "::",
            stringify!(ExternalTrigInjecConvEdge)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfTypeDef>())).InjecOversamplingMode as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfTypeDef),
            "::",
            stringify!(InjecOversamplingMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_InjectionConfTypeDef>())).InjecOversampling as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InjectionConfTypeDef),
            "::",
            stringify!(InjecOversampling)
        )
    );
}
impl Default for ADC_InjectionConfTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  Structure definition of ADC multimode"]
#[doc = " @note   The setting of these parameters by function HAL_ADCEx_MultiModeConfigChannel() is conditioned by ADCs state (both Master and Slave ADCs)."]
#[doc = "         Both Master and Slave ADCs must be disabled."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ADC_MultiModeTypeDef {
    #[doc = "< Configures the ADC to operate in independent or multimode."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_MULTI_MODE."]
    pub Mode: u32,
    #[doc = "< Configures the DMA mode for multimode ADC:"]
    #[doc = "selection whether 2 DMA channels (each ADC uses its own DMA channel) or 1 DMA channel (one DMA channel for both ADC, DMA of ADC master)"]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_MULTI_DMA_TRANSFER_RESOLUTION."]
    pub DMAAccessMode: u32,
    #[doc = "< Configures the Delay between 2 sampling phases."]
    #[doc = "This parameter can be a value of @ref ADC_HAL_EC_MULTI_TWOSMP_DELAY."]
    #[doc = "Delay range depends on selected resolution:"]
    #[doc = "from 1 to 12 clock cycles for 12 bits, from 1 to 10 clock cycles for 10 bits,"]
    #[doc = "from 1 to 8 clock cycles for 8 bits, from 1 to 6 clock cycles for 6 bits."]
    pub TwoSamplingDelay: u32,
}
#[test]
fn bindgen_test_layout_ADC_MultiModeTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<ADC_MultiModeTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(ADC_MultiModeTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_MultiModeTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_MultiModeTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_MultiModeTypeDef>())).Mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_MultiModeTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_MultiModeTypeDef>())).DMAAccessMode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_MultiModeTypeDef),
            "::",
            stringify!(DMAAccessMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ADC_MultiModeTypeDef>())).TwoSamplingDelay as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_MultiModeTypeDef),
            "::",
            stringify!(TwoSamplingDelay)
        )
    );
}
extern "C" {
    #[doc = " @addtogroup ADCEx_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_ADCEx_Calibration_Start(
        hadc: *mut ADC_HandleTypeDef,
        SingleDiff: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_Calibration_GetValue(hadc: *mut ADC_HandleTypeDef, SingleDiff: u32) -> u32;
}
extern "C" {
    pub fn HAL_ADCEx_Calibration_SetValue(
        hadc: *mut ADC_HandleTypeDef,
        SingleDiff: u32,
        CalibrationFactor: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_InjectedStart(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_InjectedStop(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_InjectedPollForConversion(
        hadc: *mut ADC_HandleTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_InjectedStart_IT(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_InjectedStop_IT(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_MultiModeStart_DMA(
        hadc: *mut ADC_HandleTypeDef,
        pData: *mut u32,
        Length: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_MultiModeStop_DMA(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_MultiModeGetValue(hadc: *mut ADC_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_ADCEx_InjectedGetValue(hadc: *mut ADC_HandleTypeDef, InjectedRank: u32) -> u32;
}
extern "C" {
    pub fn HAL_ADCEx_InjectedConvCpltCallback(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADCEx_InjectedQueueOverflowCallback(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADCEx_LevelOutOfWindow2Callback(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADCEx_LevelOutOfWindow3Callback(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADCEx_EndOfSamplingCallback(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADCEx_RegularStop(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_RegularStop_IT(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_RegularStop_DMA(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_RegularMultiModeStop_DMA(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup ADCEx_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_ADCEx_InjectedConfigChannel(
        hadc: *mut ADC_HandleTypeDef,
        sConfigInjected: *mut ADC_InjectionConfTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_MultiModeConfigChannel(
        hadc: *mut ADC_HandleTypeDef,
        multimode: *mut ADC_MultiModeTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_EnableInjectedQueue(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_DisableInjectedQueue(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_DisableVoltageRegulator(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADCEx_EnterADCDeepPowerDownMode(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup ADC_Exported_Functions_Group1"]
    #[doc = " @brief    Initialization and Configuration functions"]
    #[doc = " @{"]
    pub fn HAL_ADC_Init(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_DeInit(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_MspInit(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADC_MspDeInit(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup ADC_Exported_Functions_Group2"]
    #[doc = " @brief    IO operation functions"]
    #[doc = " @{"]
    pub fn HAL_ADC_Start(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_Stop(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_PollForConversion(
        hadc: *mut ADC_HandleTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_PollForEvent(
        hadc: *mut ADC_HandleTypeDef,
        EventType: u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_Start_IT(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_Stop_IT(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_Start_DMA(
        hadc: *mut ADC_HandleTypeDef,
        pData: *mut u32,
        Length: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_Stop_DMA(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_GetValue(hadc: *mut ADC_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_ADC_IRQHandler(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADC_ConvCpltCallback(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADC_ConvHalfCpltCallback(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADC_LevelOutOfWindowCallback(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADC_ErrorCallback(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup ADC_Exported_Functions_Group3 Peripheral Control functions"]
    #[doc = "  @brief    Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_ADC_ConfigChannel(
        hadc: *mut ADC_HandleTypeDef,
        sConfig: *mut ADC_ChannelConfTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_AnalogWDGConfig(
        hadc: *mut ADC_HandleTypeDef,
        AnalogWDGConfig: *mut ADC_AnalogWDGConfTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup ADC_Exported_Functions_Group4"]
    #[doc = " @{"]
    pub fn HAL_ADC_GetState(hadc: *mut ADC_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_ADC_GetError(hadc: *mut ADC_HandleTypeDef) -> u32;
}
extern "C" {
    #[doc = " @addtogroup ADC_Private_Functions ADC Private Functions"]
    #[doc = " @{"]
    pub fn ADC_ConversionStop(
        hadc: *mut ADC_HandleTypeDef,
        ConversionGroup: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn ADC_Enable(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn ADC_Disable(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn ADC_DMAConvCplt(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn ADC_DMAHalfConvCplt(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn ADC_DMAError(hdma: *mut DMA_HandleTypeDef);
}
#[doc = "< CAN not yet initialized or disabled"]
pub const HAL_CAN_StateTypeDef_HAL_CAN_STATE_RESET: HAL_CAN_StateTypeDef = 0;
#[doc = "< CAN initialized and ready for use"]
pub const HAL_CAN_StateTypeDef_HAL_CAN_STATE_READY: HAL_CAN_StateTypeDef = 1;
#[doc = "< CAN receive process is ongoing"]
pub const HAL_CAN_StateTypeDef_HAL_CAN_STATE_LISTENING: HAL_CAN_StateTypeDef = 2;
#[doc = "< CAN sleep request is pending"]
pub const HAL_CAN_StateTypeDef_HAL_CAN_STATE_SLEEP_PENDING: HAL_CAN_StateTypeDef = 3;
#[doc = "< CAN sleep mode is active"]
pub const HAL_CAN_StateTypeDef_HAL_CAN_STATE_SLEEP_ACTIVE: HAL_CAN_StateTypeDef = 4;
#[doc = "< CAN error state"]
pub const HAL_CAN_StateTypeDef_HAL_CAN_STATE_ERROR: HAL_CAN_StateTypeDef = 5;
#[doc = " @defgroup CAN_Exported_Types CAN Exported Types"]
#[doc = " @{"]
#[doc = " @brief  HAL State structures definition"]
pub type HAL_CAN_StateTypeDef = libc::c_uint;
#[doc = " @brief  CAN init structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAN_InitTypeDef {
    #[doc = "< Specifies the length of a time quantum."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 1024."]
    pub Prescaler: u32,
    #[doc = "< Specifies the CAN operating mode."]
    #[doc = "This parameter can be a value of @ref CAN_operating_mode"]
    pub Mode: u32,
    #[doc = "< Specifies the maximum number of time quanta the CAN hardware"]
    #[doc = "is allowed to lengthen or shorten a bit to perform resynchronization."]
    #[doc = "This parameter can be a value of @ref CAN_synchronisation_jump_width"]
    pub SyncJumpWidth: u32,
    #[doc = "< Specifies the number of time quanta in Bit Segment 1."]
    #[doc = "This parameter can be a value of @ref CAN_time_quantum_in_bit_segment_1"]
    pub TimeSeg1: u32,
    #[doc = "< Specifies the number of time quanta in Bit Segment 2."]
    #[doc = "This parameter can be a value of @ref CAN_time_quantum_in_bit_segment_2"]
    pub TimeSeg2: u32,
    #[doc = "< Enable or disable the time triggered communication mode."]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    pub TimeTriggeredMode: FunctionalState,
    #[doc = "< Enable or disable the automatic bus-off management."]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    pub AutoBusOff: FunctionalState,
    #[doc = "< Enable or disable the automatic wake-up mode."]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    pub AutoWakeUp: FunctionalState,
    #[doc = "< Enable or disable the non-automatic retransmission mode."]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    pub AutoRetransmission: FunctionalState,
    #[doc = "< Enable or disable the Receive FIFO Locked mode."]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    pub ReceiveFifoLocked: FunctionalState,
    #[doc = "< Enable or disable the transmit FIFO priority."]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    pub TransmitFifoPriority: FunctionalState,
}
#[test]
fn bindgen_test_layout_CAN_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<CAN_InitTypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(CAN_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<CAN_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(CAN_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_InitTypeDef>())).Prescaler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_InitTypeDef>())).Mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_InitTypeDef>())).SyncJumpWidth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_InitTypeDef),
            "::",
            stringify!(SyncJumpWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_InitTypeDef>())).TimeSeg1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_InitTypeDef),
            "::",
            stringify!(TimeSeg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_InitTypeDef>())).TimeSeg2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_InitTypeDef),
            "::",
            stringify!(TimeSeg2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CAN_InitTypeDef>())).TimeTriggeredMode as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_InitTypeDef),
            "::",
            stringify!(TimeTriggeredMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_InitTypeDef>())).AutoBusOff as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_InitTypeDef),
            "::",
            stringify!(AutoBusOff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_InitTypeDef>())).AutoWakeUp as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_InitTypeDef),
            "::",
            stringify!(AutoWakeUp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CAN_InitTypeDef>())).AutoRetransmission as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_InitTypeDef),
            "::",
            stringify!(AutoRetransmission)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CAN_InitTypeDef>())).ReceiveFifoLocked as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_InitTypeDef),
            "::",
            stringify!(ReceiveFifoLocked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CAN_InitTypeDef>())).TransmitFifoPriority as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_InitTypeDef),
            "::",
            stringify!(TransmitFifoPriority)
        )
    );
}
impl Default for CAN_InitTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  CAN filter configuration structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAN_FilterTypeDef {
    #[doc = "< Specifies the filter identification number (MSBs for a 32-bit"]
    #[doc = "configuration, first one for a 16-bit configuration)."]
    #[doc = "This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF."]
    pub FilterIdHigh: u32,
    #[doc = "< Specifies the filter identification number (LSBs for a 32-bit"]
    #[doc = "configuration, second one for a 16-bit configuration)."]
    #[doc = "This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF."]
    pub FilterIdLow: u32,
    #[doc = "< Specifies the filter mask number or identification number,"]
    #[doc = "according to the mode (MSBs for a 32-bit configuration,"]
    #[doc = "first one for a 16-bit configuration)."]
    #[doc = "This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF."]
    pub FilterMaskIdHigh: u32,
    #[doc = "< Specifies the filter mask number or identification number,"]
    #[doc = "according to the mode (LSBs for a 32-bit configuration,"]
    #[doc = "second one for a 16-bit configuration)."]
    #[doc = "This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF."]
    pub FilterMaskIdLow: u32,
    #[doc = "< Specifies the FIFO (0 or 1U) which will be assigned to the filter."]
    #[doc = "This parameter can be a value of @ref CAN_filter_FIFO"]
    pub FilterFIFOAssignment: u32,
    #[doc = "< Specifies the filter bank which will be initialized."]
    #[doc = "For single CAN instance(14 dedicated filter banks),"]
    #[doc = "this parameter must be a number between Min_Data = 0 and Max_Data = 13."]
    #[doc = "For dual CAN instances(28 filter banks shared),"]
    #[doc = "this parameter must be a number between Min_Data = 0 and Max_Data = 27."]
    pub FilterBank: u32,
    #[doc = "< Specifies the filter mode to be initialized."]
    #[doc = "This parameter can be a value of @ref CAN_filter_mode"]
    pub FilterMode: u32,
    #[doc = "< Specifies the filter scale."]
    #[doc = "This parameter can be a value of @ref CAN_filter_scale"]
    pub FilterScale: u32,
    #[doc = "< Enable or disable the filter."]
    #[doc = "This parameter can be a value of @ref CAN_filter_activation"]
    pub FilterActivation: u32,
    #[doc = "< Select the start filter bank for the slave CAN instance."]
    #[doc = "For single CAN instances, this parameter is meaningless."]
    #[doc = "For dual CAN instances, all filter banks with lower index are assigned to master"]
    #[doc = "CAN instance, whereas all filter banks with greater index are assigned to slave"]
    #[doc = "CAN instance."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 27."]
    pub SlaveStartFilterBank: u32,
}
#[test]
fn bindgen_test_layout_CAN_FilterTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<CAN_FilterTypeDef>(),
        40usize,
        concat!("Size of: ", stringify!(CAN_FilterTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<CAN_FilterTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(CAN_FilterTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_FilterTypeDef>())).FilterIdHigh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FilterTypeDef),
            "::",
            stringify!(FilterIdHigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_FilterTypeDef>())).FilterIdLow as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FilterTypeDef),
            "::",
            stringify!(FilterIdLow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CAN_FilterTypeDef>())).FilterMaskIdHigh as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FilterTypeDef),
            "::",
            stringify!(FilterMaskIdHigh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CAN_FilterTypeDef>())).FilterMaskIdLow as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FilterTypeDef),
            "::",
            stringify!(FilterMaskIdLow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CAN_FilterTypeDef>())).FilterFIFOAssignment as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FilterTypeDef),
            "::",
            stringify!(FilterFIFOAssignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_FilterTypeDef>())).FilterBank as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FilterTypeDef),
            "::",
            stringify!(FilterBank)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_FilterTypeDef>())).FilterMode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FilterTypeDef),
            "::",
            stringify!(FilterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_FilterTypeDef>())).FilterScale as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FilterTypeDef),
            "::",
            stringify!(FilterScale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CAN_FilterTypeDef>())).FilterActivation as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FilterTypeDef),
            "::",
            stringify!(FilterActivation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CAN_FilterTypeDef>())).SlaveStartFilterBank as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_FilterTypeDef),
            "::",
            stringify!(SlaveStartFilterBank)
        )
    );
}
#[doc = " @brief  CAN Tx message header structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAN_TxHeaderTypeDef {
    #[doc = "< Specifies the standard identifier."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 0x7FF."]
    pub StdId: u32,
    #[doc = "< Specifies the extended identifier."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 0x1FFFFFFF."]
    pub ExtId: u32,
    #[doc = "< Specifies the type of identifier for the message that will be transmitted."]
    #[doc = "This parameter can be a value of @ref CAN_identifier_type"]
    pub IDE: u32,
    #[doc = "< Specifies the type of frame for the message that will be transmitted."]
    #[doc = "This parameter can be a value of @ref CAN_remote_transmission_request"]
    pub RTR: u32,
    #[doc = "< Specifies the length of the frame that will be transmitted."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 8."]
    pub DLC: u32,
    #[doc = "< Specifies whether the timestamp counter value captured on start"]
    #[doc = "of frame transmission, is sent in DATA6 and DATA7 replacing pData[6] and pData[7]."]
    #[doc = "@note: Time Triggered Communication Mode must be enabled."]
    #[doc = "@note: DLC must be programmed as 8 bytes, in order these 2 bytes are sent."]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    pub TransmitGlobalTime: FunctionalState,
}
#[test]
fn bindgen_test_layout_CAN_TxHeaderTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<CAN_TxHeaderTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(CAN_TxHeaderTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<CAN_TxHeaderTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(CAN_TxHeaderTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TxHeaderTypeDef>())).StdId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TxHeaderTypeDef),
            "::",
            stringify!(StdId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TxHeaderTypeDef>())).ExtId as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TxHeaderTypeDef),
            "::",
            stringify!(ExtId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TxHeaderTypeDef>())).IDE as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TxHeaderTypeDef),
            "::",
            stringify!(IDE)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TxHeaderTypeDef>())).RTR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TxHeaderTypeDef),
            "::",
            stringify!(RTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_TxHeaderTypeDef>())).DLC as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TxHeaderTypeDef),
            "::",
            stringify!(DLC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CAN_TxHeaderTypeDef>())).TransmitGlobalTime as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_TxHeaderTypeDef),
            "::",
            stringify!(TransmitGlobalTime)
        )
    );
}
impl Default for CAN_TxHeaderTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  CAN Rx message header structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAN_RxHeaderTypeDef {
    #[doc = "< Specifies the standard identifier."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 0x7FF."]
    pub StdId: u32,
    #[doc = "< Specifies the extended identifier."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 0x1FFFFFFF."]
    pub ExtId: u32,
    #[doc = "< Specifies the type of identifier for the message that will be transmitted."]
    #[doc = "This parameter can be a value of @ref CAN_identifier_type"]
    pub IDE: u32,
    #[doc = "< Specifies the type of frame for the message that will be transmitted."]
    #[doc = "This parameter can be a value of @ref CAN_remote_transmission_request"]
    pub RTR: u32,
    #[doc = "< Specifies the length of the frame that will be transmitted."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 8."]
    pub DLC: u32,
    #[doc = "< Specifies the timestamp counter value captured on start of frame reception."]
    #[doc = "@note: Time Triggered Communication Mode must be enabled."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 0xFFFF."]
    pub Timestamp: u32,
    #[doc = "< Specifies the index of matching acceptance filter element."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 0xFF."]
    pub FilterMatchIndex: u32,
}
#[test]
fn bindgen_test_layout_CAN_RxHeaderTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<CAN_RxHeaderTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(CAN_RxHeaderTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<CAN_RxHeaderTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(CAN_RxHeaderTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_RxHeaderTypeDef>())).StdId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_RxHeaderTypeDef),
            "::",
            stringify!(StdId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_RxHeaderTypeDef>())).ExtId as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_RxHeaderTypeDef),
            "::",
            stringify!(ExtId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_RxHeaderTypeDef>())).IDE as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_RxHeaderTypeDef),
            "::",
            stringify!(IDE)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_RxHeaderTypeDef>())).RTR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_RxHeaderTypeDef),
            "::",
            stringify!(RTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_RxHeaderTypeDef>())).DLC as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_RxHeaderTypeDef),
            "::",
            stringify!(DLC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CAN_RxHeaderTypeDef>())).Timestamp as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_RxHeaderTypeDef),
            "::",
            stringify!(Timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CAN_RxHeaderTypeDef>())).FilterMatchIndex as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CAN_RxHeaderTypeDef),
            "::",
            stringify!(FilterMatchIndex)
        )
    );
}
#[doc = " @brief  CAN handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CAN_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut CAN_TypeDef,
    #[doc = "< CAN required parameters"]
    pub Init: CAN_InitTypeDef,
    #[doc = "< CAN communication state"]
    pub State: HAL_CAN_StateTypeDef,
    #[doc = "< CAN Error code."]
    #[doc = "This parameter can be a value of @ref CAN_Error_Code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout___CAN_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<__CAN_HandleTypeDef>(),
        56usize,
        concat!("Size of: ", stringify!(__CAN_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<__CAN_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(__CAN_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__CAN_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CAN_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__CAN_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__CAN_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__CAN_HandleTypeDef>())).State as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__CAN_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__CAN_HandleTypeDef>())).ErrorCode as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__CAN_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl Default for __CAN_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  CAN handle Structure definition"]
pub type CAN_HandleTypeDef = __CAN_HandleTypeDef;
extern "C" {
    #[doc = " @addtogroup CAN_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = "  @brief    Initialization and Configuration functions"]
    #[doc = " @{"]
    pub fn HAL_CAN_Init(hcan: *mut CAN_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CAN_DeInit(hcan: *mut CAN_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CAN_MspInit(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    pub fn HAL_CAN_MspDeInit(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup CAN_Exported_Functions_Group2 Configuration functions"]
    #[doc = "  @brief    Configuration functions"]
    #[doc = " @{"]
    pub fn HAL_CAN_ConfigFilter(
        hcan: *mut CAN_HandleTypeDef,
        sFilterConfig: *mut CAN_FilterTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup CAN_Exported_Functions_Group3 Control functions"]
    #[doc = "  @brief    Control functions"]
    #[doc = " @{"]
    pub fn HAL_CAN_Start(hcan: *mut CAN_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CAN_Stop(hcan: *mut CAN_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CAN_RequestSleep(hcan: *mut CAN_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CAN_WakeUp(hcan: *mut CAN_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CAN_IsSleepActive(hcan: *mut CAN_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_CAN_AddTxMessage(
        hcan: *mut CAN_HandleTypeDef,
        pHeader: *mut CAN_TxHeaderTypeDef,
        aData: *mut u8,
        pTxMailbox: *mut u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CAN_AbortTxRequest(
        hcan: *mut CAN_HandleTypeDef,
        TxMailboxes: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CAN_GetTxMailboxesFreeLevel(hcan: *mut CAN_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_CAN_IsTxMessagePending(hcan: *mut CAN_HandleTypeDef, TxMailboxes: u32) -> u32;
}
extern "C" {
    pub fn HAL_CAN_GetTxTimestamp(hcan: *mut CAN_HandleTypeDef, TxMailbox: u32) -> u32;
}
extern "C" {
    pub fn HAL_CAN_GetRxMessage(
        hcan: *mut CAN_HandleTypeDef,
        RxFifo: u32,
        pHeader: *mut CAN_RxHeaderTypeDef,
        aData: *mut u8,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CAN_GetRxFifoFillLevel(hcan: *mut CAN_HandleTypeDef, RxFifo: u32) -> u32;
}
extern "C" {
    #[doc = " @addtogroup CAN_Exported_Functions_Group4 Interrupts management"]
    #[doc = "  @brief    Interrupts management"]
    #[doc = " @{"]
    pub fn HAL_CAN_ActivateNotification(
        hcan: *mut CAN_HandleTypeDef,
        ActiveITs: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CAN_DeactivateNotification(
        hcan: *mut CAN_HandleTypeDef,
        InactiveITs: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CAN_IRQHandler(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup CAN_Exported_Functions_Group5 Callback functions"]
    #[doc = "  @brief    Callback functions"]
    #[doc = " @{"]
    pub fn HAL_CAN_TxMailbox0CompleteCallback(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    pub fn HAL_CAN_TxMailbox1CompleteCallback(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    pub fn HAL_CAN_TxMailbox2CompleteCallback(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    pub fn HAL_CAN_TxMailbox0AbortCallback(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    pub fn HAL_CAN_TxMailbox1AbortCallback(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    pub fn HAL_CAN_TxMailbox2AbortCallback(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    pub fn HAL_CAN_RxFifo0MsgPendingCallback(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    pub fn HAL_CAN_RxFifo0FullCallback(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    pub fn HAL_CAN_RxFifo1MsgPendingCallback(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    pub fn HAL_CAN_RxFifo1FullCallback(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    pub fn HAL_CAN_SleepCallback(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    pub fn HAL_CAN_WakeUpFromRxMsgCallback(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    pub fn HAL_CAN_ErrorCallback(hcan: *mut CAN_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup CAN_Exported_Functions_Group6 Peripheral State and Error functions"]
    #[doc = "  @brief   CAN Peripheral State functions"]
    #[doc = " @{"]
    pub fn HAL_CAN_GetState(hcan: *mut CAN_HandleTypeDef) -> HAL_CAN_StateTypeDef;
}
extern "C" {
    pub fn HAL_CAN_GetError(hcan: *mut CAN_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_CAN_ResetError(hcan: *mut CAN_HandleTypeDef) -> HAL_StatusTypeDef;
}
#[doc = " @brief  COMP Init structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct COMP_InitTypeDef {
    #[doc = "< Set window mode of a pair of comparators instances"]
    #[doc = "(2 consecutive instances odd and even COMP<x> and COMP<x+1>)."]
    #[doc = "Note: HAL COMP driver allows to set window mode from any COMP instance of the pair of COMP instances composing window mode."]
    #[doc = "This parameter can be a value of @ref COMP_WindowMode"]
    pub WindowMode: u32,
    #[doc = "< Set comparator operating mode to adjust power and speed."]
    #[doc = "Note: For the characteristics of comparator power modes"]
    #[doc = "(propagation delay and power consumption), refer to device datasheet."]
    #[doc = "This parameter can be a value of @ref COMP_PowerMode"]
    pub Mode: u32,
    #[doc = "< Set comparator input plus (non-inverting input)."]
    #[doc = "This parameter can be a value of @ref COMP_InputPlus"]
    pub NonInvertingInput: u32,
    #[doc = "< Set comparator input minus (inverting input)."]
    #[doc = "This parameter can be a value of @ref COMP_InputMinus"]
    pub InvertingInput: u32,
    #[doc = "< Set comparator hysteresis mode of the input minus."]
    #[doc = "This parameter can be a value of @ref COMP_Hysteresis"]
    pub Hysteresis: u32,
    #[doc = "< Set comparator output polarity."]
    #[doc = "This parameter can be a value of @ref COMP_OutputPolarity"]
    pub OutputPol: u32,
    #[doc = "< Set comparator blanking source."]
    #[doc = "This parameter can be a value of @ref COMP_BlankingSrce"]
    pub BlankingSrce: u32,
    #[doc = "< Set the comparator output triggering External Interrupt Line (EXTI)."]
    #[doc = "This parameter can be a value of @ref COMP_EXTI_TriggerMode"]
    pub TriggerMode: u32,
}
#[test]
fn bindgen_test_layout_COMP_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<COMP_InitTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(COMP_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<COMP_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(COMP_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMP_InitTypeDef>())).WindowMode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_InitTypeDef),
            "::",
            stringify!(WindowMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMP_InitTypeDef>())).Mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<COMP_InitTypeDef>())).NonInvertingInput as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_InitTypeDef),
            "::",
            stringify!(NonInvertingInput)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<COMP_InitTypeDef>())).InvertingInput as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_InitTypeDef),
            "::",
            stringify!(InvertingInput)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMP_InitTypeDef>())).Hysteresis as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_InitTypeDef),
            "::",
            stringify!(Hysteresis)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMP_InitTypeDef>())).OutputPol as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_InitTypeDef),
            "::",
            stringify!(OutputPol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMP_InitTypeDef>())).BlankingSrce as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_InitTypeDef),
            "::",
            stringify!(BlankingSrce)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMP_InitTypeDef>())).TriggerMode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_InitTypeDef),
            "::",
            stringify!(TriggerMode)
        )
    );
}
#[doc = "< COMP not yet initialized"]
pub const HAL_COMP_StateTypeDef_HAL_COMP_STATE_RESET: HAL_COMP_StateTypeDef = 0;
#[doc = "< COMP not yet initialized and configuration is locked"]
pub const HAL_COMP_StateTypeDef_HAL_COMP_STATE_RESET_LOCKED: HAL_COMP_StateTypeDef = 16;
#[doc = "< COMP initialized and ready for use"]
pub const HAL_COMP_StateTypeDef_HAL_COMP_STATE_READY: HAL_COMP_StateTypeDef = 1;
#[doc = "< COMP initialized but configuration is locked"]
pub const HAL_COMP_StateTypeDef_HAL_COMP_STATE_READY_LOCKED: HAL_COMP_StateTypeDef = 17;
#[doc = "< COMP is running"]
pub const HAL_COMP_StateTypeDef_HAL_COMP_STATE_BUSY: HAL_COMP_StateTypeDef = 2;
#[doc = "< COMP is running and configuration is locked"]
pub const HAL_COMP_StateTypeDef_HAL_COMP_STATE_BUSY_LOCKED: HAL_COMP_StateTypeDef = 18;
pub type HAL_COMP_StateTypeDef = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct COMP_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut COMP_TypeDef,
    #[doc = "< COMP required parameters"]
    pub Init: COMP_InitTypeDef,
    #[doc = "< Locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< COMP communication state"]
    pub State: HAL_COMP_StateTypeDef,
    #[doc = "< COMP error code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout_COMP_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<COMP_HandleTypeDef>(),
        48usize,
        concat!("Size of: ", stringify!(COMP_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<COMP_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(COMP_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMP_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMP_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMP_HandleTypeDef>())).Lock as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMP_HandleTypeDef>())).State as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<COMP_HandleTypeDef>())).ErrorCode as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl Default for COMP_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @addtogroup COMP_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_COMP_Init(hcomp: *mut COMP_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_COMP_DeInit(hcomp: *mut COMP_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_COMP_MspInit(hcomp: *mut COMP_HandleTypeDef);
}
extern "C" {
    pub fn HAL_COMP_MspDeInit(hcomp: *mut COMP_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup COMP_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_COMP_Start(hcomp: *mut COMP_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_COMP_Stop(hcomp: *mut COMP_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_COMP_IRQHandler(hcomp: *mut COMP_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup COMP_Exported_Functions_Group3"]
    #[doc = " @{"]
    pub fn HAL_COMP_Lock(hcomp: *mut COMP_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_COMP_GetOutputLevel(hcomp: *mut COMP_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_COMP_TriggerCallback(hcomp: *mut COMP_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup COMP_Exported_Functions_Group4"]
    #[doc = " @{"]
    pub fn HAL_COMP_GetState(hcomp: *mut COMP_HandleTypeDef) -> HAL_COMP_StateTypeDef;
}
extern "C" {
    pub fn HAL_COMP_GetError(hcomp: *mut COMP_HandleTypeDef) -> u32;
}
#[doc = "< CRC not yet initialized or disabled"]
pub const HAL_CRC_StateTypeDef_HAL_CRC_STATE_RESET: HAL_CRC_StateTypeDef = 0;
#[doc = "< CRC initialized and ready for use"]
pub const HAL_CRC_StateTypeDef_HAL_CRC_STATE_READY: HAL_CRC_StateTypeDef = 1;
#[doc = "< CRC internal process is ongoing"]
pub const HAL_CRC_StateTypeDef_HAL_CRC_STATE_BUSY: HAL_CRC_StateTypeDef = 2;
#[doc = "< CRC timeout state"]
pub const HAL_CRC_StateTypeDef_HAL_CRC_STATE_TIMEOUT: HAL_CRC_StateTypeDef = 3;
#[doc = "< CRC error state"]
pub const HAL_CRC_StateTypeDef_HAL_CRC_STATE_ERROR: HAL_CRC_StateTypeDef = 4;
#[doc = " @brief  CRC HAL State Structure definition"]
pub type HAL_CRC_StateTypeDef = libc::c_uint;
#[doc = " @brief CRC Init Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CRC_InitTypeDef {
    #[doc = "< This parameter is a value of @ref CRC_Default_Polynomial and indicates if default polynomial is used."]
    #[doc = "If set to DEFAULT_POLYNOMIAL_ENABLE, resort to default"]
    #[doc = "X^32 + X^26 + X^23 + X^22 + X^16 + X^12 + X^11 + X^10 +X^8 + X^7 + X^5 + X^4 + X^2+ X +1."]
    #[doc = "In that case, there is no need to set GeneratingPolynomial field."]
    #[doc = "If otherwise set to DEFAULT_POLYNOMIAL_DISABLE, GeneratingPolynomial and CRCLength fields must be set."]
    pub DefaultPolynomialUse: u8,
    #[doc = "< This parameter is a value of @ref CRC_Default_InitValue_Use and indicates if default init value is used."]
    #[doc = "If set to DEFAULT_INIT_VALUE_ENABLE, resort to default"]
    #[doc = "0xFFFFFFFF value. In that case, there is no need to set InitValue field."]
    #[doc = "If otherwise set to DEFAULT_INIT_VALUE_DISABLE,  InitValue field must be set."]
    pub DefaultInitValueUse: u8,
    #[doc = "< Set CRC generating polynomial as a 7, 8, 16 or 32-bit long value for a polynomial degree"]
    #[doc = "respectively equal to 7, 8, 16 or 32. This field is written in normal representation,"]
    #[doc = "e.g., for a polynomial of degree 7, X^7 + X^6 + X^5 + X^2 + 1 is written 0x65."]
    #[doc = "No need to specify it if DefaultPolynomialUse is set to DEFAULT_POLYNOMIAL_ENABLE."]
    pub GeneratingPolynomial: u32,
    #[doc = "< This parameter is a value of @ref CRC_Polynomial_Sizes and indicates CRC length."]
    #[doc = "Value can be either one of"]
    #[doc = "@arg @ref CRC_POLYLENGTH_32B                  (32-bit CRC),"]
    #[doc = "@arg @ref CRC_POLYLENGTH_16B                  (16-bit CRC),"]
    #[doc = "@arg @ref CRC_POLYLENGTH_8B                   (8-bit CRC),"]
    #[doc = "@arg @ref CRC_POLYLENGTH_7B                   (7-bit CRC)."]
    pub CRCLength: u32,
    #[doc = "< Init value to initiate CRC computation. No need to specify it if DefaultInitValueUse"]
    #[doc = "is set to DEFAULT_INIT_VALUE_ENABLE."]
    pub InitValue: u32,
    #[doc = "< This parameter is a value of @ref CRCEx_Input_Data_Inversion and specifies input data inversion mode."]
    #[doc = "Can be either one of the following values"]
    #[doc = "@arg @ref CRC_INPUTDATA_INVERSION_NONE       no input data inversion"]
    #[doc = "@arg @ref CRC_INPUTDATA_INVERSION_BYTE       byte-wise inversion, 0x1A2B3C4D becomes 0x58D43CB2"]
    #[doc = "@arg @ref CRC_INPUTDATA_INVERSION_HALFWORD   halfword-wise inversion, 0x1A2B3C4D becomes 0xD458B23C"]
    #[doc = "@arg @ref CRC_INPUTDATA_INVERSION_WORD       word-wise inversion, 0x1A2B3C4D becomes 0xB23CD458"]
    pub InputDataInversionMode: u32,
    #[doc = "< This parameter is a value of @ref CRCEx_Output_Data_Inversion and specifies output data (i.e. CRC) inversion mode."]
    #[doc = "Can be either"]
    #[doc = "@arg @ref CRC_OUTPUTDATA_INVERSION_DISABLE   no CRC inversion,"]
    #[doc = "@arg @ref CRC_OUTPUTDATA_INVERSION_ENABLE    CRC 0x11223344 is converted into 0x22CC4488"]
    pub OutputDataInversionMode: u32,
}
#[test]
fn bindgen_test_layout_CRC_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<CRC_InitTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(CRC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<CRC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(CRC_InitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRC_InitTypeDef>())).DefaultPolynomialUse as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_InitTypeDef),
            "::",
            stringify!(DefaultPolynomialUse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRC_InitTypeDef>())).DefaultInitValueUse as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_InitTypeDef),
            "::",
            stringify!(DefaultInitValueUse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRC_InitTypeDef>())).GeneratingPolynomial as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_InitTypeDef),
            "::",
            stringify!(GeneratingPolynomial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRC_InitTypeDef>())).CRCLength as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_InitTypeDef),
            "::",
            stringify!(CRCLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRC_InitTypeDef>())).InitValue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_InitTypeDef),
            "::",
            stringify!(InitValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRC_InitTypeDef>())).InputDataInversionMode as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_InitTypeDef),
            "::",
            stringify!(InputDataInversionMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRC_InitTypeDef>())).OutputDataInversionMode as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_InitTypeDef),
            "::",
            stringify!(OutputDataInversionMode)
        )
    );
}
#[doc = " @brief  CRC Handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CRC_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut CRC_TypeDef,
    #[doc = "< CRC configuration parameters"]
    pub Init: CRC_InitTypeDef,
    #[doc = "< CRC Locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< CRC communication state"]
    pub State: HAL_CRC_StateTypeDef,
    #[doc = "< This parameter is a value of @ref CRC_Input_Buffer_Format and specifies input data format."]
    #[doc = "Can be either"]
    #[doc = "@arg @ref CRC_INPUTDATA_FORMAT_BYTES       input data is a stream of bytes (8-bit data)"]
    #[doc = "@arg @ref CRC_INPUTDATA_FORMAT_HALFWORDS   input data is a stream of half-words (16-bit data)"]
    #[doc = "@arg @ref CRC_INPUTDATA_FORMAT_WORDS       input data is a stream of words (32-bit data)"]
    #[doc = ""]
    #[doc = "Note that constant CRC_INPUT_FORMAT_UNDEFINED is defined but an initialization error"]
    #[doc = "must occur if InputBufferFormat is not one of the three values listed above"]
    pub InputDataFormat: u32,
}
#[test]
fn bindgen_test_layout_CRC_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<CRC_HandleTypeDef>(),
        40usize,
        concat!("Size of: ", stringify!(CRC_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<CRC_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(CRC_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRC_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRC_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRC_HandleTypeDef>())).Lock as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRC_HandleTypeDef>())).State as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRC_HandleTypeDef>())).InputDataFormat as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_HandleTypeDef),
            "::",
            stringify!(InputDataFormat)
        )
    );
}
impl Default for CRC_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @addtogroup CRCEx_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_CRCEx_Polynomial_Set(
        hcrc: *mut CRC_HandleTypeDef,
        Pol: u32,
        PolyLength: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CRCEx_Input_Data_Reverse(
        hcrc: *mut CRC_HandleTypeDef,
        InputReverseMode: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CRCEx_Output_Data_Reverse(
        hcrc: *mut CRC_HandleTypeDef,
        OutputReverseMode: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup CRC_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_CRC_Init(hcrc: *mut CRC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CRC_DeInit(hcrc: *mut CRC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CRC_MspInit(hcrc: *mut CRC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_CRC_MspDeInit(hcrc: *mut CRC_HandleTypeDef);
}
extern "C" {
    #[doc = " @defgroup CRC_Exported_Functions_Group2 Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_CRC_Accumulate(
        hcrc: *mut CRC_HandleTypeDef,
        pBuffer: *mut u32,
        BufferLength: u32,
    ) -> u32;
}
extern "C" {
    pub fn HAL_CRC_Calculate(
        hcrc: *mut CRC_HandleTypeDef,
        pBuffer: *mut u32,
        BufferLength: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " @defgroup CRC_Exported_Functions_Group3 Peripheral State functions"]
    #[doc = " @{"]
    pub fn HAL_CRC_GetState(hcrc: *mut CRC_HandleTypeDef) -> HAL_CRC_StateTypeDef;
}
#[doc = "< DAC not yet initialized or disabled"]
pub const HAL_DAC_StateTypeDef_HAL_DAC_STATE_RESET: HAL_DAC_StateTypeDef = 0;
#[doc = "< DAC initialized and ready for use"]
pub const HAL_DAC_StateTypeDef_HAL_DAC_STATE_READY: HAL_DAC_StateTypeDef = 1;
#[doc = "< DAC internal processing is ongoing"]
pub const HAL_DAC_StateTypeDef_HAL_DAC_STATE_BUSY: HAL_DAC_StateTypeDef = 2;
#[doc = "< DAC timeout state"]
pub const HAL_DAC_StateTypeDef_HAL_DAC_STATE_TIMEOUT: HAL_DAC_StateTypeDef = 3;
#[doc = "< DAC error state"]
pub const HAL_DAC_StateTypeDef_HAL_DAC_STATE_ERROR: HAL_DAC_StateTypeDef = 4;
#[doc = " @brief  HAL State structures definition"]
pub type HAL_DAC_StateTypeDef = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DAC_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut DAC_TypeDef,
    #[doc = "< DAC communication state"]
    pub State: HAL_DAC_StateTypeDef,
    #[doc = "< DAC locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< Pointer DMA handler for channel 1"]
    pub DMA_Handle1: *mut DMA_HandleTypeDef,
    #[doc = "< Pointer DMA handler for channel 2"]
    pub DMA_Handle2: *mut DMA_HandleTypeDef,
    #[doc = "< DAC Error code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout_DAC_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DAC_HandleTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(DAC_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DAC_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_HandleTypeDef>())).State as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_HandleTypeDef>())).Lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_HandleTypeDef>())).DMA_Handle1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_HandleTypeDef),
            "::",
            stringify!(DMA_Handle1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_HandleTypeDef>())).DMA_Handle2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_HandleTypeDef),
            "::",
            stringify!(DMA_Handle2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_HandleTypeDef>())).ErrorCode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl Default for DAC_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   DAC Configuration sample and hold Channel structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DAC_SampleAndHoldConfTypeDef {
    #[doc = "< Specifies the Sample time for the selected channel."]
    #[doc = "This parameter applies when DAC_SampleAndHold is DAC_SAMPLEANDHOLD_ENABLE."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 1023"]
    pub DAC_SampleTime: u32,
    #[doc = "< Specifies the hold time for the selected channel"]
    #[doc = "This parameter applies when DAC_SampleAndHold is DAC_SAMPLEANDHOLD_ENABLE."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 1023"]
    pub DAC_HoldTime: u32,
    #[doc = "< Specifies the refresh time for the selected channel"]
    #[doc = "This parameter applies when DAC_SampleAndHold is DAC_SAMPLEANDHOLD_ENABLE."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 255"]
    pub DAC_RefreshTime: u32,
}
#[test]
fn bindgen_test_layout_DAC_SampleAndHoldConfTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DAC_SampleAndHoldConfTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(DAC_SampleAndHoldConfTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_SampleAndHoldConfTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DAC_SampleAndHoldConfTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DAC_SampleAndHoldConfTypeDef>())).DAC_SampleTime as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_SampleAndHoldConfTypeDef),
            "::",
            stringify!(DAC_SampleTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DAC_SampleAndHoldConfTypeDef>())).DAC_HoldTime as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_SampleAndHoldConfTypeDef),
            "::",
            stringify!(DAC_HoldTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DAC_SampleAndHoldConfTypeDef>())).DAC_RefreshTime as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_SampleAndHoldConfTypeDef),
            "::",
            stringify!(DAC_RefreshTime)
        )
    );
}
#[doc = " @brief   DAC Configuration regular Channel structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DAC_ChannelConfTypeDef {
    #[doc = "< Specifies whether the DAC mode."]
    #[doc = "This parameter can be a value of @ref DAC_SampleAndHold"]
    pub DAC_SampleAndHold: u32,
    #[doc = "< Specifies the external trigger for the selected DAC channel."]
    #[doc = "This parameter can be a value of @ref DAC_trigger_selection"]
    pub DAC_Trigger: u32,
    #[doc = "< Specifies whether the DAC channel output buffer is enabled or disabled."]
    #[doc = "This parameter can be a value of @ref DAC_output_buffer"]
    pub DAC_OutputBuffer: u32,
    #[doc = "< Specifies whether the DAC output is connected or not to on chip peripheral ."]
    #[doc = "This parameter can be a value of @ref DAC_ConnectOnChipPeripheral"]
    pub DAC_ConnectOnChipPeripheral: u32,
    #[doc = "< Specifies the trimming mode"]
    #[doc = "This parameter must be a value of @ref DAC_UserTrimming"]
    #[doc = "DAC_UserTrimming is either factory or user trimming"]
    pub DAC_UserTrimming: u32,
    #[doc = "< Specifies the offset trimming value"]
    #[doc = "i.e. when DAC_SampleAndHold is DAC_TRIMMING_USER."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 31"]
    pub DAC_TrimmingValue: u32,
    #[doc = "< Sample and Hold settings"]
    pub DAC_SampleAndHoldConfig: DAC_SampleAndHoldConfTypeDef,
}
#[test]
fn bindgen_test_layout_DAC_ChannelConfTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<DAC_ChannelConfTypeDef>(),
        36usize,
        concat!("Size of: ", stringify!(DAC_ChannelConfTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_ChannelConfTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DAC_ChannelConfTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DAC_ChannelConfTypeDef>())).DAC_SampleAndHold as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_ChannelConfTypeDef),
            "::",
            stringify!(DAC_SampleAndHold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DAC_ChannelConfTypeDef>())).DAC_Trigger as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_ChannelConfTypeDef),
            "::",
            stringify!(DAC_Trigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DAC_ChannelConfTypeDef>())).DAC_OutputBuffer as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_ChannelConfTypeDef),
            "::",
            stringify!(DAC_OutputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DAC_ChannelConfTypeDef>())).DAC_ConnectOnChipPeripheral
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_ChannelConfTypeDef),
            "::",
            stringify!(DAC_ConnectOnChipPeripheral)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DAC_ChannelConfTypeDef>())).DAC_UserTrimming as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_ChannelConfTypeDef),
            "::",
            stringify!(DAC_UserTrimming)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DAC_ChannelConfTypeDef>())).DAC_TrimmingValue as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_ChannelConfTypeDef),
            "::",
            stringify!(DAC_TrimmingValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DAC_ChannelConfTypeDef>())).DAC_SampleAndHoldConfig as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_ChannelConfTypeDef),
            "::",
            stringify!(DAC_SampleAndHoldConfig)
        )
    );
}
extern "C" {
    #[doc = " @addtogroup DACEx_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_DACEx_TriangleWaveGenerate(
        hdac: *mut DAC_HandleTypeDef,
        Channel: u32,
        Amplitude: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DACEx_NoiseWaveGenerate(
        hdac: *mut DAC_HandleTypeDef,
        Channel: u32,
        Amplitude: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DACEx_DualSetValue(
        hdac: *mut DAC_HandleTypeDef,
        Alignment: u32,
        Data1: u32,
        Data2: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DACEx_DualGetValue(hdac: *mut DAC_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_DACEx_ConvCpltCallbackCh2(hdac: *mut DAC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DACEx_ConvHalfCpltCallbackCh2(hdac: *mut DAC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DACEx_ErrorCallbackCh2(hdac: *mut DAC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DACEx_DMAUnderrunCallbackCh2(hdac: *mut DAC_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup DACEx_Exported_Functions_Group3"]
    #[doc = " @{"]
    pub fn HAL_DACEx_SelfCalibrate(
        hdac: *mut DAC_HandleTypeDef,
        sConfig: *mut DAC_ChannelConfTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DACEx_SetUserTrimming(
        hdac: *mut DAC_HandleTypeDef,
        sConfig: *mut DAC_ChannelConfTypeDef,
        Channel: u32,
        NewTrimmingValue: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DACEx_GetTrimOffset(hdac: *mut DAC_HandleTypeDef, Channel: u32) -> u32;
}
extern "C" {
    #[doc = " @addtogroup DACEx_Private_Functions"]
    #[doc = " @{"]
    pub fn DAC_DMAConvCpltCh2(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn DAC_DMAErrorCh2(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn DAC_DMAHalfConvCpltCh2(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup DAC_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_DAC_Init(hdac: *mut DAC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DAC_DeInit(hdac: *mut DAC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DAC_MspInit(hdac: *mut DAC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DAC_MspDeInit(hdac: *mut DAC_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup DAC_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_DAC_Start(hdac: *mut DAC_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DAC_Stop(hdac: *mut DAC_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DAC_Start_DMA(
        hdac: *mut DAC_HandleTypeDef,
        Channel: u32,
        pData: *mut u32,
        Length: u32,
        Alignment: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DAC_Stop_DMA(hdac: *mut DAC_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DAC_IRQHandler(hdac: *mut DAC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DAC_SetValue(
        hdac: *mut DAC_HandleTypeDef,
        Channel: u32,
        Alignment: u32,
        Data: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DAC_ConvCpltCallbackCh1(hdac: *mut DAC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DAC_ConvHalfCpltCallbackCh1(hdac: *mut DAC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DAC_ErrorCallbackCh1(hdac: *mut DAC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DAC_DMAUnderrunCallbackCh1(hdac: *mut DAC_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup DAC_Exported_Functions_Group3"]
    #[doc = " @{"]
    pub fn HAL_DAC_GetValue(hdac: *mut DAC_HandleTypeDef, Channel: u32) -> u32;
}
extern "C" {
    pub fn HAL_DAC_ConfigChannel(
        hdac: *mut DAC_HandleTypeDef,
        sConfig: *mut DAC_ChannelConfTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup DAC_Exported_Functions_Group4"]
    #[doc = " @{"]
    pub fn HAL_DAC_GetState(hdac: *mut DAC_HandleTypeDef) -> HAL_DAC_StateTypeDef;
}
extern "C" {
    pub fn HAL_DAC_GetError(hdac: *mut DAC_HandleTypeDef) -> u32;
}
extern "C" {
    #[doc = " @defgroup DAC_Private_Functions DAC Private Functions"]
    #[doc = " @{"]
    pub fn DAC_DMAConvCpltCh1(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn DAC_DMAErrorCh1(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn DAC_DMAHalfConvCpltCh1(hdma: *mut DMA_HandleTypeDef);
}
pub const EXTI_CallbackIDTypeDef_HAL_EXTI_COMMON_CB_ID: EXTI_CallbackIDTypeDef = 0;
pub const EXTI_CallbackIDTypeDef_HAL_EXTI_RISING_CB_ID: EXTI_CallbackIDTypeDef = 1;
pub const EXTI_CallbackIDTypeDef_HAL_EXTI_FALLING_CB_ID: EXTI_CallbackIDTypeDef = 2;
#[doc = " @defgroup EXTI_Exported_Types EXTI Exported Types"]
#[doc = " @{"]
pub type EXTI_CallbackIDTypeDef = libc::c_uint;
#[doc = " @brief  EXTI Handle structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct EXTI_HandleTypeDef {
    #[doc = "<  Exti line number"]
    pub Line: u32,
    #[doc = "<  Exti pending callback"]
    pub PendingCallback: ::core::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_EXTI_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<EXTI_HandleTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(EXTI_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<EXTI_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(EXTI_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_HandleTypeDef>())).Line as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_HandleTypeDef),
            "::",
            stringify!(Line)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<EXTI_HandleTypeDef>())).PendingCallback as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_HandleTypeDef),
            "::",
            stringify!(PendingCallback)
        )
    );
}
#[doc = " @brief  EXTI Configuration structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct EXTI_ConfigTypeDef {
    #[doc = "< The Exti line to be configured. This parameter"]
    #[doc = "can be a value of @ref EXTI_Line"]
    pub Line: u32,
    #[doc = "< The Exit Mode to be configured for a core."]
    #[doc = "This parameter can be a combination of @ref EXTI_Mode"]
    pub Mode: u32,
    #[doc = "< The Exti Trigger to be configured. This parameter"]
    #[doc = "can be a value of @ref EXTI_Trigger"]
    pub Trigger: u32,
    #[doc = "< The Exti GPIO multiplexer selection to be configured."]
    #[doc = "This parameter is only possible for line 0 to 15. It"]
    #[doc = "can be a value of @ref EXTI_GPIOSel"]
    pub GPIOSel: u32,
}
#[test]
fn bindgen_test_layout_EXTI_ConfigTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<EXTI_ConfigTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(EXTI_ConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<EXTI_ConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(EXTI_ConfigTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_ConfigTypeDef>())).Line as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_ConfigTypeDef),
            "::",
            stringify!(Line)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_ConfigTypeDef>())).Mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_ConfigTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_ConfigTypeDef>())).Trigger as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_ConfigTypeDef),
            "::",
            stringify!(Trigger)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EXTI_ConfigTypeDef>())).GPIOSel as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_ConfigTypeDef),
            "::",
            stringify!(GPIOSel)
        )
    );
}
extern "C" {
    #[doc = " @defgroup EXTI_Exported_Functions_Group1 Configuration functions"]
    #[doc = " @brief    Configuration functions"]
    #[doc = " @{"]
    pub fn HAL_EXTI_SetConfigLine(
        hexti: *mut EXTI_HandleTypeDef,
        pExtiConfig: *mut EXTI_ConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_EXTI_GetConfigLine(
        hexti: *mut EXTI_HandleTypeDef,
        pExtiConfig: *mut EXTI_ConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_EXTI_ClearConfigLine(hexti: *mut EXTI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_EXTI_RegisterCallback(
        hexti: *mut EXTI_HandleTypeDef,
        CallbackID: EXTI_CallbackIDTypeDef,
        pPendingCbfn: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_EXTI_GetHandle(hexti: *mut EXTI_HandleTypeDef, ExtiLine: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup EXTI_Exported_Functions_Group2 IO operation functions"]
    #[doc = " @brief    IO operation functions"]
    #[doc = " @{"]
    pub fn HAL_EXTI_IRQHandler(hexti: *mut EXTI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_EXTI_GetPending(hexti: *mut EXTI_HandleTypeDef, Edge: u32) -> u32;
}
extern "C" {
    pub fn HAL_EXTI_ClearPending(hexti: *mut EXTI_HandleTypeDef, Edge: u32);
}
extern "C" {
    pub fn HAL_EXTI_GenerateSWI(hexti: *mut EXTI_HandleTypeDef);
}
#[doc = " @brief FIREWALL Initialization Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FIREWALL_InitTypeDef {
    #[doc = "< Protected code segment start address. This value is 24-bit long, the 8 LSB bits are"]
    #[doc = "reserved and forced to 0 in order to allow a 256-byte granularity."]
    pub CodeSegmentStartAddress: u32,
    #[doc = "< Protected code segment length in bytes. This value is 22-bit long, the 8 LSB bits are"]
    #[doc = "reserved and forced to 0 for the length to be a multiple of 256 bytes."]
    pub CodeSegmentLength: u32,
    #[doc = "< Protected non-volatile data segment start address. This value is 24-bit long, the 8 LSB"]
    #[doc = "bits are reserved and forced to 0 in order to allow a 256-byte granularity."]
    pub NonVDataSegmentStartAddress: u32,
    #[doc = "< Protected non-volatile data segment length in bytes. This value is 22-bit long, the 8 LSB"]
    #[doc = "bits are reserved and forced to 0 for the length to be a multiple of 256 bytes."]
    pub NonVDataSegmentLength: u32,
    #[doc = "< Protected volatile data segment start address. This value is 17-bit long, the 6 LSB bits"]
    #[doc = "are reserved and forced to 0 in order to allow a 64-byte granularity."]
    pub VDataSegmentStartAddress: u32,
    #[doc = "< Protected volatile data segment length in bytes. This value is 17-bit long, the 6 LSB"]
    #[doc = "bits are reserved and forced to 0 for the length to be a multiple of 64 bytes."]
    pub VDataSegmentLength: u32,
    #[doc = "< Set VDE bit specifying whether or not the volatile data segment can be executed."]
    #[doc = "When VDS = 1 (set by parameter VolatileDataShared), VDE bit has no meaning."]
    #[doc = "This parameter can be a value of @ref FIREWALL_VolatileData_Executable"]
    pub VolatileDataExecution: u32,
    #[doc = "< Set VDS bit in specifying whether or not the volatile data segment can be shared with a"]
    #[doc = "non-protected application code."]
    #[doc = "This parameter can be a value of @ref FIREWALL_VolatileData_Shared"]
    pub VolatileDataShared: u32,
}
#[test]
fn bindgen_test_layout_FIREWALL_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<FIREWALL_InitTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(FIREWALL_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FIREWALL_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FIREWALL_InitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FIREWALL_InitTypeDef>())).CodeSegmentStartAddress as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_InitTypeDef),
            "::",
            stringify!(CodeSegmentStartAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FIREWALL_InitTypeDef>())).CodeSegmentLength as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_InitTypeDef),
            "::",
            stringify!(CodeSegmentLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FIREWALL_InitTypeDef>())).NonVDataSegmentStartAddress
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_InitTypeDef),
            "::",
            stringify!(NonVDataSegmentStartAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FIREWALL_InitTypeDef>())).NonVDataSegmentLength as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_InitTypeDef),
            "::",
            stringify!(NonVDataSegmentLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FIREWALL_InitTypeDef>())).VDataSegmentStartAddress as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_InitTypeDef),
            "::",
            stringify!(VDataSegmentStartAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FIREWALL_InitTypeDef>())).VDataSegmentLength as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_InitTypeDef),
            "::",
            stringify!(VDataSegmentLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FIREWALL_InitTypeDef>())).VolatileDataExecution as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_InitTypeDef),
            "::",
            stringify!(VolatileDataExecution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FIREWALL_InitTypeDef>())).VolatileDataShared as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FIREWALL_InitTypeDef),
            "::",
            stringify!(VolatileDataShared)
        )
    );
}
extern "C" {
    #[doc = " @addtogroup FIREWALL_Exported_Functions_Group1 Initialization Functions"]
    #[doc = " @brief    Initialization and Configuration Functions"]
    #[doc = " @{"]
    pub fn HAL_FIREWALL_Config(fw_init: *mut FIREWALL_InitTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FIREWALL_GetConfig(fw_config: *mut FIREWALL_InitTypeDef);
}
extern "C" {
    pub fn HAL_FIREWALL_EnableFirewall();
}
extern "C" {
    pub fn HAL_FIREWALL_EnablePreArmFlag();
}
extern "C" {
    pub fn HAL_FIREWALL_DisablePreArmFlag();
}
#[doc = " @brief  FLASH Erase structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FLASH_EraseInitTypeDef {
    #[doc = "< Mass erase or page erase."]
    #[doc = "This parameter can be a value of @ref FLASH_Type_Erase"]
    pub TypeErase: u32,
    #[doc = "< Select bank to erase."]
    #[doc = "This parameter must be a value of @ref FLASH_Banks"]
    #[doc = "(FLASH_BANK_BOTH should be used only for mass erase)"]
    pub Banks: u32,
    #[doc = "< Initial Flash page to erase when page erase is disabled"]
    #[doc = "This parameter must be a value between 0 and (max number of pages in the bank - 1)"]
    #[doc = "(eg : 255 for 1MB dual bank)"]
    pub Page: u32,
    #[doc = "< Number of pages to be erased."]
    #[doc = "This parameter must be a value between 1 and (max number of pages in the bank - value of initial page)"]
    pub NbPages: u32,
}
#[test]
fn bindgen_test_layout_FLASH_EraseInitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<FLASH_EraseInitTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(FLASH_EraseInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FLASH_EraseInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FLASH_EraseInitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FLASH_EraseInitTypeDef>())).TypeErase as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_EraseInitTypeDef),
            "::",
            stringify!(TypeErase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_EraseInitTypeDef>())).Banks as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_EraseInitTypeDef),
            "::",
            stringify!(Banks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_EraseInitTypeDef>())).Page as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_EraseInitTypeDef),
            "::",
            stringify!(Page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_EraseInitTypeDef>())).NbPages as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_EraseInitTypeDef),
            "::",
            stringify!(NbPages)
        )
    );
}
#[doc = " @brief  FLASH Option Bytes Program structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FLASH_OBProgramInitTypeDef {
    #[doc = "< Option byte to be configured."]
    #[doc = "This parameter can be a combination of the values of @ref FLASH_OB_Type"]
    pub OptionType: u32,
    #[doc = "< Write protection area to be programmed (used for OPTIONBYTE_WRP)."]
    #[doc = "Only one WRP area could be programmed at the same time."]
    #[doc = "This parameter can be value of @ref FLASH_OB_WRP_Area"]
    pub WRPArea: u32,
    #[doc = "< Write protection start offset (used for OPTIONBYTE_WRP)."]
    #[doc = "This parameter must be a value between 0 and (max number of pages in the bank - 1)"]
    #[doc = "(eg : 25 for 1MB dual bank)"]
    pub WRPStartOffset: u32,
    #[doc = "< Write protection end offset (used for OPTIONBYTE_WRP)."]
    #[doc = "This parameter must be a value between WRPStartOffset and (max number of pages in the bank - 1)"]
    pub WRPEndOffset: u32,
    #[doc = "< Set the read protection level.. (used for OPTIONBYTE_RDP)."]
    #[doc = "This parameter can be a value of @ref FLASH_OB_Read_Protection"]
    pub RDPLevel: u32,
    #[doc = "< User option byte(s) to be configured (used for OPTIONBYTE_USER)."]
    #[doc = "This parameter can be a combination of @ref FLASH_OB_USER_Type"]
    pub USERType: u32,
    #[doc = "< Value of the user option byte (used for OPTIONBYTE_USER)."]
    #[doc = "This parameter can be a combination of @ref FLASH_OB_USER_BOR_LEVEL,"]
    #[doc = "@ref FLASH_OB_USER_nRST_STOP, @ref FLASH_OB_USER_nRST_STANDBY,"]
    #[doc = "@ref FLASH_OB_USER_nRST_SHUTDOWN, @ref FLASH_OB_USER_IWDG_SW,"]
    #[doc = "@ref FLASH_OB_USER_IWDG_STOP, @ref FLASH_OB_USER_IWDG_STANDBY,"]
    #[doc = "@ref FLASH_OB_USER_WWDG_SW, @ref FLASH_OB_USER_BFB2,"]
    #[doc = "@ref FLASH_OB_USER_DUALBANK, @ref FLASH_OB_USER_nBOOT1,"]
    #[doc = "@ref FLASH_OB_USER_SRAM2_PE and @ref FLASH_OB_USER_SRAM2_RST"]
    pub USERConfig: u32,
    #[doc = "< Configuration of the PCROP (used for OPTIONBYTE_PCROP)."]
    #[doc = "This parameter must be a combination of @ref FLASH_Banks (except FLASH_BANK_BOTH)"]
    #[doc = "and @ref FLASH_OB_PCROP_RDP"]
    pub PCROPConfig: u32,
    #[doc = "< PCROP Start address (used for OPTIONBYTE_PCROP)."]
    #[doc = "This parameter must be a value between begin and end of bank"]
    #[doc = "=> Be careful of the bank swapping for the address"]
    pub PCROPStartAddr: u32,
    #[doc = "< PCROP End address (used for OPTIONBYTE_PCROP)."]
    #[doc = "This parameter must be a value between PCROP Start address and end of bank"]
    pub PCROPEndAddr: u32,
}
#[test]
fn bindgen_test_layout_FLASH_OBProgramInitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<FLASH_OBProgramInitTypeDef>(),
        40usize,
        concat!("Size of: ", stringify!(FLASH_OBProgramInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FLASH_OBProgramInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FLASH_OBProgramInitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FLASH_OBProgramInitTypeDef>())).OptionType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(OptionType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FLASH_OBProgramInitTypeDef>())).WRPArea as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(WRPArea)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FLASH_OBProgramInitTypeDef>())).WRPStartOffset as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(WRPStartOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FLASH_OBProgramInitTypeDef>())).WRPEndOffset as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(WRPEndOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FLASH_OBProgramInitTypeDef>())).RDPLevel as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(RDPLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FLASH_OBProgramInitTypeDef>())).USERType as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(USERType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FLASH_OBProgramInitTypeDef>())).USERConfig as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(USERConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FLASH_OBProgramInitTypeDef>())).PCROPConfig as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(PCROPConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FLASH_OBProgramInitTypeDef>())).PCROPStartAddr as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(PCROPStartAddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FLASH_OBProgramInitTypeDef>())).PCROPEndAddr as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(PCROPEndAddr)
        )
    );
}
pub const FLASH_ProcedureTypeDef_FLASH_PROC_NONE: FLASH_ProcedureTypeDef = 0;
pub const FLASH_ProcedureTypeDef_FLASH_PROC_PAGE_ERASE: FLASH_ProcedureTypeDef = 1;
pub const FLASH_ProcedureTypeDef_FLASH_PROC_MASS_ERASE: FLASH_ProcedureTypeDef = 2;
pub const FLASH_ProcedureTypeDef_FLASH_PROC_PROGRAM: FLASH_ProcedureTypeDef = 3;
pub const FLASH_ProcedureTypeDef_FLASH_PROC_PROGRAM_LAST: FLASH_ProcedureTypeDef = 4;
#[doc = " @brief  FLASH Procedure structure definition"]
pub type FLASH_ProcedureTypeDef = libc::c_uint;
pub const FLASH_CacheTypeDef_FLASH_CACHE_DISABLED: FLASH_CacheTypeDef = 0;
pub const FLASH_CacheTypeDef_FLASH_CACHE_ICACHE_ENABLED: FLASH_CacheTypeDef = 1;
pub const FLASH_CacheTypeDef_FLASH_CACHE_DCACHE_ENABLED: FLASH_CacheTypeDef = 2;
pub const FLASH_CacheTypeDef_FLASH_CACHE_ICACHE_DCACHE_ENABLED: FLASH_CacheTypeDef = 3;
#[doc = " @brief  FLASH Cache structure definition"]
pub type FLASH_CacheTypeDef = libc::c_uint;
#[doc = " @brief  FLASH handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLASH_ProcessTypeDef {
    pub Lock: HAL_LockTypeDef,
    pub ErrorCode: u32,
    pub ProcedureOnGoing: FLASH_ProcedureTypeDef,
    pub Address: u32,
    pub Bank: u32,
    pub Page: u32,
    pub NbPagesToErase: u32,
    pub CacheToReactivate: FLASH_CacheTypeDef,
}
#[test]
fn bindgen_test_layout_FLASH_ProcessTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<FLASH_ProcessTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(FLASH_ProcessTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FLASH_ProcessTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FLASH_ProcessTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_ProcessTypeDef>())).Lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_ProcessTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_ProcessTypeDef>())).ErrorCode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_ProcessTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FLASH_ProcessTypeDef>())).ProcedureOnGoing as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_ProcessTypeDef),
            "::",
            stringify!(ProcedureOnGoing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_ProcessTypeDef>())).Address as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_ProcessTypeDef),
            "::",
            stringify!(Address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_ProcessTypeDef>())).Bank as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_ProcessTypeDef),
            "::",
            stringify!(Bank)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLASH_ProcessTypeDef>())).Page as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_ProcessTypeDef),
            "::",
            stringify!(Page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FLASH_ProcessTypeDef>())).NbPagesToErase as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_ProcessTypeDef),
            "::",
            stringify!(NbPagesToErase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FLASH_ProcessTypeDef>())).CacheToReactivate as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_ProcessTypeDef),
            "::",
            stringify!(CacheToReactivate)
        )
    );
}
impl Default for FLASH_ProcessTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @addtogroup FLASHEx_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_FLASHEx_Erase(
        pEraseInit: *mut FLASH_EraseInitTypeDef,
        PageError: *mut u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASHEx_Erase_IT(pEraseInit: *mut FLASH_EraseInitTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASHEx_OBProgram(pOBInit: *mut FLASH_OBProgramInitTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASHEx_OBGetConfig(pOBInit: *mut FLASH_OBProgramInitTypeDef);
}
extern "C" {
    #[doc = " @addtogroup FLASHEx_Private_Functions FLASHEx Private Functions"]
    #[doc = " @{"]
    pub fn FLASH_PageErase(Page: u32, Banks: u32);
}
extern "C" {
    pub fn FLASH_FlushCaches();
}
extern "C" {
    #[doc = " @addtogroup FLASH_RAMFUNC_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_FLASHEx_EnableRunPowerDown() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASHEx_DisableRunPowerDown() -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup FLASH_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_FLASH_Program(TypeProgram: u32, Address: u32, Data: u64) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_Program_IT(TypeProgram: u32, Address: u32, Data: u64) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_IRQHandler();
}
extern "C" {
    pub fn HAL_FLASH_EndOfOperationCallback(ReturnValue: u32);
}
extern "C" {
    pub fn HAL_FLASH_OperationErrorCallback(ReturnValue: u32);
}
extern "C" {
    #[doc = " @addtogroup FLASH_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_FLASH_Unlock() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_Lock() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_OB_Unlock() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_OB_Lock() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_OB_Launch() -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup FLASH_Exported_Functions_Group3"]
    #[doc = " @{"]
    pub fn HAL_FLASH_GetError() -> u32;
}
extern "C" {
    #[doc = " @addtogroup FLASH_Private_Variables FLASH Private Variables"]
    #[doc = " @{"]
    pub static mut pFlash: FLASH_ProcessTypeDef;
}
extern "C" {
    #[doc = " @addtogroup FLASH_Private_Functions FLASH Private Functions"]
    #[doc = " @{"]
    pub fn FLASH_WaitForLastOperation(Timeout: u32) -> HAL_StatusTypeDef;
}
pub const USB_ModeTypeDef_USB_DEVICE_MODE: USB_ModeTypeDef = 0;
pub const USB_ModeTypeDef_USB_HOST_MODE: USB_ModeTypeDef = 1;
pub const USB_ModeTypeDef_USB_DRD_MODE: USB_ModeTypeDef = 2;
pub type USB_ModeTypeDef = libc::c_uint;
pub const USB_OTG_URBStateTypeDef_URB_IDLE: USB_OTG_URBStateTypeDef = 0;
pub const USB_OTG_URBStateTypeDef_URB_DONE: USB_OTG_URBStateTypeDef = 1;
pub const USB_OTG_URBStateTypeDef_URB_NOTREADY: USB_OTG_URBStateTypeDef = 2;
pub const USB_OTG_URBStateTypeDef_URB_NYET: USB_OTG_URBStateTypeDef = 3;
pub const USB_OTG_URBStateTypeDef_URB_ERROR: USB_OTG_URBStateTypeDef = 4;
pub const USB_OTG_URBStateTypeDef_URB_STALL: USB_OTG_URBStateTypeDef = 5;
#[doc = " @brief  URB States definition"]
pub type USB_OTG_URBStateTypeDef = libc::c_uint;
pub const USB_OTG_HCStateTypeDef_HC_IDLE: USB_OTG_HCStateTypeDef = 0;
pub const USB_OTG_HCStateTypeDef_HC_XFRC: USB_OTG_HCStateTypeDef = 1;
pub const USB_OTG_HCStateTypeDef_HC_HALTED: USB_OTG_HCStateTypeDef = 2;
pub const USB_OTG_HCStateTypeDef_HC_NAK: USB_OTG_HCStateTypeDef = 3;
pub const USB_OTG_HCStateTypeDef_HC_NYET: USB_OTG_HCStateTypeDef = 4;
pub const USB_OTG_HCStateTypeDef_HC_STALL: USB_OTG_HCStateTypeDef = 5;
pub const USB_OTG_HCStateTypeDef_HC_XACTERR: USB_OTG_HCStateTypeDef = 6;
pub const USB_OTG_HCStateTypeDef_HC_BBLERR: USB_OTG_HCStateTypeDef = 7;
pub const USB_OTG_HCStateTypeDef_HC_DATATGLERR: USB_OTG_HCStateTypeDef = 8;
#[doc = " @brief  Host channel States  definition"]
pub type USB_OTG_HCStateTypeDef = libc::c_uint;
#[doc = " @brief  USB Instance Initialization Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USB_OTG_CfgTypeDef {
    #[doc = "< Device Endpoints number."]
    #[doc = "This parameter depends on the used USB core."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 15"]
    pub dev_endpoints: u32,
    #[doc = "< Host Channels number."]
    #[doc = "This parameter Depends on the used USB core."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 15"]
    pub Host_channels: u32,
    #[doc = "< USB Core speed."]
    #[doc = "This parameter can be any value of @ref USB_Core_Speed"]
    pub speed: u32,
    #[doc = "< Enable or disable of the USB embedded DMA used only for OTG HS."]
    pub dma_enable: u32,
    #[doc = "< Set the Endpoint 0 Max Packet size."]
    pub ep0_mps: u32,
    #[doc = "< Select the used PHY interface."]
    #[doc = "This parameter can be any value of @ref USB_Core_PHY"]
    pub phy_itface: u32,
    #[doc = "< Enable or disable the output of the SOF signal."]
    pub Sof_enable: u32,
    #[doc = "< Enable or disable the low power mode."]
    pub low_power_enable: u32,
    #[doc = "< Enable or disable Link Power Management."]
    pub lpm_enable: u32,
    #[doc = "< Enable or disable Battery charging."]
    pub battery_charging_enable: u32,
    #[doc = "< Enable or disable the VBUS Sensing feature."]
    pub vbus_sensing_enable: u32,
    #[doc = "< Enable or disable the use of the dedicated EP1 interrupt."]
    pub use_dedicated_ep1: u32,
    #[doc = "< Enable or disable the use of the external VBUS."]
    pub use_external_vbus: u32,
}
#[test]
fn bindgen_test_layout_USB_OTG_CfgTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<USB_OTG_CfgTypeDef>(),
        52usize,
        concat!("Size of: ", stringify!(USB_OTG_CfgTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_OTG_CfgTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_OTG_CfgTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_CfgTypeDef>())).dev_endpoints as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_CfgTypeDef),
            "::",
            stringify!(dev_endpoints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_CfgTypeDef>())).Host_channels as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_CfgTypeDef),
            "::",
            stringify!(Host_channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_CfgTypeDef>())).speed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_CfgTypeDef),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_CfgTypeDef>())).dma_enable as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_CfgTypeDef),
            "::",
            stringify!(dma_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_CfgTypeDef>())).ep0_mps as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_CfgTypeDef),
            "::",
            stringify!(ep0_mps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_CfgTypeDef>())).phy_itface as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_CfgTypeDef),
            "::",
            stringify!(phy_itface)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_CfgTypeDef>())).Sof_enable as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_CfgTypeDef),
            "::",
            stringify!(Sof_enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_CfgTypeDef>())).low_power_enable as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_CfgTypeDef),
            "::",
            stringify!(low_power_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_CfgTypeDef>())).lpm_enable as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_CfgTypeDef),
            "::",
            stringify!(lpm_enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_CfgTypeDef>())).battery_charging_enable as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_CfgTypeDef),
            "::",
            stringify!(battery_charging_enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_CfgTypeDef>())).vbus_sensing_enable as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_CfgTypeDef),
            "::",
            stringify!(vbus_sensing_enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_CfgTypeDef>())).use_dedicated_ep1 as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_CfgTypeDef),
            "::",
            stringify!(use_dedicated_ep1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_CfgTypeDef>())).use_external_vbus as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_CfgTypeDef),
            "::",
            stringify!(use_external_vbus)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USB_OTG_EPTypeDef {
    #[doc = "< Endpoint number"]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 15"]
    pub num: u8,
    #[doc = "< Endpoint direction"]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 1"]
    pub is_in: u8,
    #[doc = "< Endpoint stall condition"]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 1"]
    pub is_stall: u8,
    #[doc = "< Endpoint type"]
    #[doc = "This parameter can be any value of @ref USB_EP_Type_"]
    pub type_: u8,
    #[doc = "< Initial data PID"]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 1"]
    pub data_pid_start: u8,
    #[doc = "< IFrame parity"]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 1"]
    pub even_odd_frame: u8,
    #[doc = "< Transmission FIFO number"]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 15"]
    pub tx_fifo_num: u16,
    #[doc = "< Endpoint Max packet size"]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 64KB"]
    pub maxpacket: u32,
    #[doc = "< Pointer to transfer buffer"]
    pub xfer_buff: *mut u8,
    #[doc = "< 32 bits aligned transfer buffer address"]
    pub dma_addr: u32,
    #[doc = "< Current transfer length"]
    pub xfer_len: u32,
    #[doc = "< Partial transfer length in case of multi packet transfer"]
    pub xfer_count: u32,
}
#[test]
fn bindgen_test_layout_USB_OTG_EPTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<USB_OTG_EPTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(USB_OTG_EPTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_OTG_EPTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_OTG_EPTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_EPTypeDef>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_EPTypeDef),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_EPTypeDef>())).is_in as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_EPTypeDef),
            "::",
            stringify!(is_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_EPTypeDef>())).is_stall as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_EPTypeDef),
            "::",
            stringify!(is_stall)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_EPTypeDef>())).type_ as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_EPTypeDef),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_EPTypeDef>())).data_pid_start as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_EPTypeDef),
            "::",
            stringify!(data_pid_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_OTG_EPTypeDef>())).even_odd_frame as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_EPTypeDef),
            "::",
            stringify!(even_odd_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_EPTypeDef>())).tx_fifo_num as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_EPTypeDef),
            "::",
            stringify!(tx_fifo_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_EPTypeDef>())).maxpacket as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_EPTypeDef),
            "::",
            stringify!(maxpacket)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_EPTypeDef>())).xfer_buff as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_EPTypeDef),
            "::",
            stringify!(xfer_buff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_EPTypeDef>())).dma_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_EPTypeDef),
            "::",
            stringify!(dma_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_EPTypeDef>())).xfer_len as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_EPTypeDef),
            "::",
            stringify!(xfer_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_EPTypeDef>())).xfer_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_EPTypeDef),
            "::",
            stringify!(xfer_count)
        )
    );
}
impl Default for USB_OTG_EPTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USB_OTG_HCTypeDef {
    #[doc = "< USB device address."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 255"]
    pub dev_addr: u8,
    #[doc = "< Host channel number."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 15"]
    pub ch_num: u8,
    #[doc = "< Endpoint number."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 15"]
    pub ep_num: u8,
    #[doc = "< Endpoint direction"]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 1"]
    pub ep_is_in: u8,
    #[doc = "< USB Host speed."]
    #[doc = "This parameter can be any value of @ref USB_Core_Speed_"]
    pub speed: u8,
    #[doc = "< Enable or disable the use of the PING protocol for HS mode."]
    pub do_ping: u8,
    #[doc = "< Execute the PING protocol for HS mode."]
    pub process_ping: u8,
    #[doc = "< Endpoint Type."]
    #[doc = "This parameter can be any value of @ref USB_EP_Type_"]
    pub ep_type: u8,
    #[doc = "< Endpoint Max packet size."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 64KB"]
    pub max_packet: u16,
    #[doc = "< Initial data PID."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 1"]
    pub data_pid: u8,
    #[doc = "< Pointer to transfer buffer."]
    pub xfer_buff: *mut u8,
    #[doc = "< OTG Channel transfer size."]
    pub XferSize: u32,
    #[doc = "< Current transfer length."]
    pub xfer_len: u32,
    #[doc = "< Partial transfer length in case of multi packet transfer."]
    pub xfer_count: u32,
    #[doc = "< IN transfer current toggle flag."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 1"]
    pub toggle_in: u8,
    #[doc = "< OUT transfer current toggle flag"]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 1"]
    pub toggle_out: u8,
    #[doc = "< 32 bits aligned transfer buffer address."]
    pub dma_addr: u32,
    #[doc = "< Host channel error count."]
    pub ErrCnt: u32,
    #[doc = "< URB state."]
    #[doc = "This parameter can be any value of @ref USB_OTG_URBStateTypeDef"]
    pub urb_state: USB_OTG_URBStateTypeDef,
    #[doc = "< Host Channel state."]
    #[doc = "This parameter can be any value of @ref USB_OTG_HCStateTypeDef"]
    pub state: USB_OTG_HCStateTypeDef,
}
#[test]
fn bindgen_test_layout_USB_OTG_HCTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<USB_OTG_HCTypeDef>(),
        48usize,
        concat!("Size of: ", stringify!(USB_OTG_HCTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_OTG_HCTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_OTG_HCTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).dev_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(dev_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).ch_num as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(ch_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).ep_num as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(ep_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).ep_is_in as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(ep_is_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).speed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).do_ping as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(do_ping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).process_ping as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(process_ping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).ep_type as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(ep_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).max_packet as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(max_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).data_pid as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(data_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).xfer_buff as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(xfer_buff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).XferSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(XferSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).xfer_len as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(xfer_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).xfer_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(xfer_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).toggle_in as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(toggle_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).toggle_out as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(toggle_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).dma_addr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(dma_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).ErrCnt as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(ErrCnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).urb_state as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(urb_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_OTG_HCTypeDef>())).state as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_OTG_HCTypeDef),
            "::",
            stringify!(state)
        )
    );
}
impl Default for USB_OTG_HCTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn USB_CoreInit(
        USBx: *mut USB_OTG_GlobalTypeDef,
        cfg: USB_OTG_CfgTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_DevInit(
        USBx: *mut USB_OTG_GlobalTypeDef,
        cfg: USB_OTG_CfgTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_EnableGlobalInt(USBx: *mut USB_OTG_GlobalTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_DisableGlobalInt(USBx: *mut USB_OTG_GlobalTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_SetTurnaroundTime(
        USBx: *mut USB_OTG_GlobalTypeDef,
        hclk: u32,
        speed: u8,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_SetCurrentMode(
        USBx: *mut USB_OTG_GlobalTypeDef,
        mode: USB_ModeTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_SetDevSpeed(USBx: *mut USB_OTG_GlobalTypeDef, speed: u8) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_FlushRxFifo(USBx: *mut USB_OTG_GlobalTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_FlushTxFifo(USBx: *mut USB_OTG_GlobalTypeDef, num: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_ActivateEndpoint(
        USBx: *mut USB_OTG_GlobalTypeDef,
        ep: *mut USB_OTG_EPTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_DeactivateEndpoint(
        USBx: *mut USB_OTG_GlobalTypeDef,
        ep: *mut USB_OTG_EPTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_ActivateDedicatedEndpoint(
        USBx: *mut USB_OTG_GlobalTypeDef,
        ep: *mut USB_OTG_EPTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_DeactivateDedicatedEndpoint(
        USBx: *mut USB_OTG_GlobalTypeDef,
        ep: *mut USB_OTG_EPTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_EPStartXfer(
        USBx: *mut USB_OTG_GlobalTypeDef,
        ep: *mut USB_OTG_EPTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_EP0StartXfer(
        USBx: *mut USB_OTG_GlobalTypeDef,
        ep: *mut USB_OTG_EPTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_WritePacket(
        USBx: *mut USB_OTG_GlobalTypeDef,
        src: *mut u8,
        ch_ep_num: u8,
        len: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_ReadPacket(
        USBx: *mut USB_OTG_GlobalTypeDef,
        dest: *mut u8,
        len: u16,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn USB_EPSetStall(
        USBx: *mut USB_OTG_GlobalTypeDef,
        ep: *mut USB_OTG_EPTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_EPClearStall(
        USBx: *mut USB_OTG_GlobalTypeDef,
        ep: *mut USB_OTG_EPTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_SetDevAddress(USBx: *mut USB_OTG_GlobalTypeDef, address: u8) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_DevConnect(USBx: *mut USB_OTG_GlobalTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_DevDisconnect(USBx: *mut USB_OTG_GlobalTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_StopDevice(USBx: *mut USB_OTG_GlobalTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_ActivateSetup(USBx: *mut USB_OTG_GlobalTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_EP0_OutStart(USBx: *mut USB_OTG_GlobalTypeDef, psetup: *mut u8)
        -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_GetDevSpeed(USBx: *mut USB_OTG_GlobalTypeDef) -> u8;
}
extern "C" {
    pub fn USB_GetMode(USBx: *mut USB_OTG_GlobalTypeDef) -> u32;
}
extern "C" {
    pub fn USB_ReadInterrupts(USBx: *mut USB_OTG_GlobalTypeDef) -> u32;
}
extern "C" {
    pub fn USB_ReadDevAllOutEpInterrupt(USBx: *mut USB_OTG_GlobalTypeDef) -> u32;
}
extern "C" {
    pub fn USB_ReadDevOutEPInterrupt(USBx: *mut USB_OTG_GlobalTypeDef, epnum: u8) -> u32;
}
extern "C" {
    pub fn USB_ReadDevAllInEpInterrupt(USBx: *mut USB_OTG_GlobalTypeDef) -> u32;
}
extern "C" {
    pub fn USB_ReadDevInEPInterrupt(USBx: *mut USB_OTG_GlobalTypeDef, epnum: u8) -> u32;
}
extern "C" {
    pub fn USB_ClearInterrupts(USBx: *mut USB_OTG_GlobalTypeDef, interrupt: u32);
}
extern "C" {
    pub fn USB_HostInit(
        USBx: *mut USB_OTG_GlobalTypeDef,
        cfg: USB_OTG_CfgTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_InitFSLSPClkSel(USBx: *mut USB_OTG_GlobalTypeDef, freq: u8) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_ResetPort(USBx: *mut USB_OTG_GlobalTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_DriveVbus(USBx: *mut USB_OTG_GlobalTypeDef, state: u8) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_GetHostSpeed(USBx: *mut USB_OTG_GlobalTypeDef) -> u32;
}
extern "C" {
    pub fn USB_GetCurrentFrame(USBx: *mut USB_OTG_GlobalTypeDef) -> u32;
}
extern "C" {
    pub fn USB_HC_Init(
        USBx: *mut USB_OTG_GlobalTypeDef,
        ch_num: u8,
        epnum: u8,
        dev_address: u8,
        speed: u8,
        ep_type: u8,
        mps: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_HC_StartXfer(
        USBx: *mut USB_OTG_GlobalTypeDef,
        hc: *mut USB_OTG_HCTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_HC_ReadInterrupt(USBx: *mut USB_OTG_GlobalTypeDef) -> u32;
}
extern "C" {
    pub fn USB_HC_Halt(USBx: *mut USB_OTG_GlobalTypeDef, hc_num: u8) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_DoPing(USBx: *mut USB_OTG_GlobalTypeDef, ch_num: u8) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_StopHost(USBx: *mut USB_OTG_GlobalTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_ActivateRemoteWakeup(USBx: *mut USB_OTG_GlobalTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn USB_DeActivateRemoteWakeup(USBx: *mut USB_OTG_GlobalTypeDef) -> HAL_StatusTypeDef;
}
pub const HCD_StateTypeDef_HAL_HCD_STATE_RESET: HCD_StateTypeDef = 0;
pub const HCD_StateTypeDef_HAL_HCD_STATE_READY: HCD_StateTypeDef = 1;
pub const HCD_StateTypeDef_HAL_HCD_STATE_ERROR: HCD_StateTypeDef = 2;
pub const HCD_StateTypeDef_HAL_HCD_STATE_BUSY: HCD_StateTypeDef = 3;
pub const HCD_StateTypeDef_HAL_HCD_STATE_TIMEOUT: HCD_StateTypeDef = 4;
#[doc = " @defgroup HCD_Exported_Types_Group1 HCD State Structure definition"]
#[doc = " @{"]
pub type HCD_StateTypeDef = libc::c_uint;
pub type HCD_TypeDef = USB_OTG_GlobalTypeDef;
pub type HCD_InitTypeDef = USB_OTG_CfgTypeDef;
pub type HCD_HCTypeDef = USB_OTG_HCTypeDef;
pub use self::USB_OTG_HCStateTypeDef as HCD_HCStateTypeDef;
pub use self::USB_OTG_URBStateTypeDef as HCD_URBStateTypeDef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HCD_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut HCD_TypeDef,
    #[doc = "< HCD required parameters"]
    pub Init: HCD_InitTypeDef,
    #[doc = "< Host channels parameters"]
    pub hc: [HCD_HCTypeDef; 16usize],
    #[doc = "< HCD peripheral status"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< HCD communication state"]
    pub State: HCD_StateTypeDef,
    #[doc = "< HCD Error code"]
    pub ErrorCode: u32,
    #[doc = "< Pointer Stack Handler"]
    pub pData: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_HCD_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<HCD_HandleTypeDef>(),
        840usize,
        concat!("Size of: ", stringify!(HCD_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<HCD_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(HCD_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HCD_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HCD_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HCD_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HCD_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HCD_HandleTypeDef>())).hc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HCD_HandleTypeDef),
            "::",
            stringify!(hc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HCD_HandleTypeDef>())).Lock as *const _ as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(HCD_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HCD_HandleTypeDef>())).State as *const _ as usize },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(HCD_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HCD_HandleTypeDef>())).ErrorCode as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(HCD_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HCD_HandleTypeDef>())).pData as *const _ as usize },
        836usize,
        concat!(
            "Offset of field: ",
            stringify!(HCD_HandleTypeDef),
            "::",
            stringify!(pData)
        )
    );
}
impl Default for HCD_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @defgroup HCD_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_HCD_Init(hhcd: *mut HCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_HCD_DeInit(hhcd: *mut HCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_HCD_HC_Init(
        hhcd: *mut HCD_HandleTypeDef,
        ch_num: u8,
        epnum: u8,
        dev_address: u8,
        speed: u8,
        ep_type: u8,
        mps: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_HCD_HC_Halt(hhcd: *mut HCD_HandleTypeDef, ch_num: u8) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_HCD_MspInit(hhcd: *mut HCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_HCD_MspDeInit(hhcd: *mut HCD_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup HCD_Exported_Functions_Group2 Input and Output operation functions"]
    #[doc = " @{"]
    pub fn HAL_HCD_HC_SubmitRequest(
        hhcd: *mut HCD_HandleTypeDef,
        ch_num: u8,
        direction: u8,
        ep_type: u8,
        token: u8,
        pbuff: *mut u8,
        length: u16,
        do_ping: u8,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_HCD_IRQHandler(hhcd: *mut HCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_HCD_SOF_Callback(hhcd: *mut HCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_HCD_Connect_Callback(hhcd: *mut HCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_HCD_Disconnect_Callback(hhcd: *mut HCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_HCD_PortEnabled_Callback(hhcd: *mut HCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_HCD_PortDisabled_Callback(hhcd: *mut HCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_HCD_HC_NotifyURBChange_Callback(
        hhcd: *mut HCD_HandleTypeDef,
        chnum: u8,
        urb_state: HCD_URBStateTypeDef,
    );
}
extern "C" {
    #[doc = " @addtogroup HCD_Exported_Functions_Group3 Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_HCD_ResetPort(hhcd: *mut HCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_HCD_Start(hhcd: *mut HCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_HCD_Stop(hhcd: *mut HCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup HCD_Exported_Functions_Group4 Peripheral State functions"]
    #[doc = " @{"]
    pub fn HAL_HCD_GetState(hhcd: *mut HCD_HandleTypeDef) -> HCD_StateTypeDef;
}
extern "C" {
    pub fn HAL_HCD_HC_GetURBState(hhcd: *mut HCD_HandleTypeDef, chnum: u8) -> HCD_URBStateTypeDef;
}
extern "C" {
    pub fn HAL_HCD_HC_GetState(hhcd: *mut HCD_HandleTypeDef, chnum: u8) -> HCD_HCStateTypeDef;
}
extern "C" {
    pub fn HAL_HCD_HC_GetXferCount(hhcd: *mut HCD_HandleTypeDef, chnum: u8) -> u32;
}
extern "C" {
    pub fn HAL_HCD_GetCurrentFrame(hhcd: *mut HCD_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_HCD_GetCurrentSpeed(hhcd: *mut HCD_HandleTypeDef) -> u32;
}
#[doc = " @defgroup I2C_Configuration_Structure_definition I2C Configuration Structure definition"]
#[doc = " @brief  I2C Configuration Structure definition"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct I2C_InitTypeDef {
    #[doc = "< Specifies the I2C_TIMINGR_register value."]
    #[doc = "This parameter calculated by referring to I2C initialization"]
    #[doc = "section in Reference manual"]
    pub Timing: u32,
    #[doc = "< Specifies the first device own address."]
    #[doc = "This parameter can be a 7-bit or 10-bit address."]
    pub OwnAddress1: u32,
    #[doc = "< Specifies if 7-bit or 10-bit addressing mode is selected."]
    #[doc = "This parameter can be a value of @ref I2C_ADDRESSING_MODE"]
    pub AddressingMode: u32,
    #[doc = "< Specifies if dual addressing mode is selected."]
    #[doc = "This parameter can be a value of @ref I2C_DUAL_ADDRESSING_MODE"]
    pub DualAddressMode: u32,
    #[doc = "< Specifies the second device own address if dual addressing mode is selected"]
    #[doc = "This parameter can be a 7-bit address."]
    pub OwnAddress2: u32,
    #[doc = "< Specifies the acknowledge mask address second device own address if dual addressing mode is selected"]
    #[doc = "This parameter can be a value of @ref I2C_OWN_ADDRESS2_MASKS"]
    pub OwnAddress2Masks: u32,
    #[doc = "< Specifies if general call mode is selected."]
    #[doc = "This parameter can be a value of @ref I2C_GENERAL_CALL_ADDRESSING_MODE"]
    pub GeneralCallMode: u32,
    #[doc = "< Specifies if nostretch mode is selected."]
    #[doc = "This parameter can be a value of @ref I2C_NOSTRETCH_MODE"]
    pub NoStretchMode: u32,
}
#[test]
fn bindgen_test_layout_I2C_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<I2C_InitTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(I2C_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<I2C_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(I2C_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_InitTypeDef>())).Timing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_InitTypeDef),
            "::",
            stringify!(Timing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_InitTypeDef>())).OwnAddress1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_InitTypeDef),
            "::",
            stringify!(OwnAddress1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_InitTypeDef>())).AddressingMode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_InitTypeDef),
            "::",
            stringify!(AddressingMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<I2C_InitTypeDef>())).DualAddressMode as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_InitTypeDef),
            "::",
            stringify!(DualAddressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_InitTypeDef>())).OwnAddress2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_InitTypeDef),
            "::",
            stringify!(OwnAddress2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<I2C_InitTypeDef>())).OwnAddress2Masks as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_InitTypeDef),
            "::",
            stringify!(OwnAddress2Masks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<I2C_InitTypeDef>())).GeneralCallMode as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_InitTypeDef),
            "::",
            stringify!(GeneralCallMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2C_InitTypeDef>())).NoStretchMode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_InitTypeDef),
            "::",
            stringify!(NoStretchMode)
        )
    );
}
#[doc = "< Peripheral is not yet Initialized"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_RESET: HAL_I2C_StateTypeDef = 0;
#[doc = "< Peripheral Initialized and ready for use"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_READY: HAL_I2C_StateTypeDef = 32;
#[doc = "< An internal process is ongoing"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_BUSY: HAL_I2C_StateTypeDef = 36;
#[doc = "< Data Transmission process is ongoing"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_BUSY_TX: HAL_I2C_StateTypeDef = 33;
#[doc = "< Data Reception process is ongoing"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_BUSY_RX: HAL_I2C_StateTypeDef = 34;
#[doc = "< Address Listen Mode is ongoing"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_LISTEN: HAL_I2C_StateTypeDef = 40;
#[doc = "< Address Listen Mode and Data Transmission"]
#[doc = "process is ongoing"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_BUSY_TX_LISTEN: HAL_I2C_StateTypeDef = 41;
#[doc = "< Address Listen Mode and Data Reception"]
#[doc = "process is ongoing"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_BUSY_RX_LISTEN: HAL_I2C_StateTypeDef = 42;
#[doc = "< Abort user request ongoing"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_ABORT: HAL_I2C_StateTypeDef = 96;
#[doc = "< Timeout state"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_TIMEOUT: HAL_I2C_StateTypeDef = 160;
#[doc = "< Error"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_ERROR: HAL_I2C_StateTypeDef = 224;
#[doc = " @defgroup HAL_state_structure_definition HAL state structure definition"]
#[doc = " @brief  HAL State structure definition"]
#[doc = " @note  HAL I2C State value coding follow below described bitmap :\\n"]
#[doc = "          b7-b6  Error information\\n"]
#[doc = "             00 : No Error\\n"]
#[doc = "             01 : Abort (Abort user request on going)\\n"]
#[doc = "             10 : Timeout\\n"]
#[doc = "             11 : Error\\n"]
#[doc = "          b5     Peripheral initialization status\\n"]
#[doc = "             0  : Reset (peripheral not initialized)\\n"]
#[doc = "             1  : Init done (peripheral initialized and ready to use. HAL I2C Init function called)\\n"]
#[doc = "          b4     (not used)\\n"]
#[doc = "             x  : Should be set to 0\\n"]
#[doc = "          b3\\n"]
#[doc = "             0  : Ready or Busy (No Listen mode ongoing)\\n"]
#[doc = "             1  : Listen (peripheral in Address Listen Mode)\\n"]
#[doc = "          b2     Intrinsic process state\\n"]
#[doc = "             0  : Ready\\n"]
#[doc = "             1  : Busy (peripheral busy with some configuration or internal operations)\\n"]
#[doc = "          b1     Rx state\\n"]
#[doc = "             0  : Ready (no Rx operation ongoing)\\n"]
#[doc = "             1  : Busy (Rx operation ongoing)\\n"]
#[doc = "          b0     Tx state\\n"]
#[doc = "             0  : Ready (no Tx operation ongoing)\\n"]
#[doc = "             1  : Busy (Tx operation ongoing)"]
#[doc = " @{"]
pub type HAL_I2C_StateTypeDef = libc::c_uint;
#[doc = "< No I2C communication on going"]
pub const HAL_I2C_ModeTypeDef_HAL_I2C_MODE_NONE: HAL_I2C_ModeTypeDef = 0;
#[doc = "< I2C communication is in Master Mode"]
pub const HAL_I2C_ModeTypeDef_HAL_I2C_MODE_MASTER: HAL_I2C_ModeTypeDef = 16;
#[doc = "< I2C communication is in Slave Mode"]
pub const HAL_I2C_ModeTypeDef_HAL_I2C_MODE_SLAVE: HAL_I2C_ModeTypeDef = 32;
#[doc = "< I2C communication is in Memory Mode"]
pub const HAL_I2C_ModeTypeDef_HAL_I2C_MODE_MEM: HAL_I2C_ModeTypeDef = 64;
#[doc = " @defgroup HAL_mode_structure_definition HAL mode structure definition"]
#[doc = " @brief  HAL Mode structure definition"]
#[doc = " @note  HAL I2C Mode value coding follow below described bitmap :\\n"]
#[doc = "          b7     (not used)\\n"]
#[doc = "             x  : Should be set to 0\\n"]
#[doc = "          b6\\n"]
#[doc = "             0  : None\\n"]
#[doc = "             1  : Memory (HAL I2C communication is in Memory Mode)\\n"]
#[doc = "          b5\\n"]
#[doc = "             0  : None\\n"]
#[doc = "             1  : Slave (HAL I2C communication is in Slave Mode)\\n"]
#[doc = "          b4\\n"]
#[doc = "             0  : None\\n"]
#[doc = "             1  : Master (HAL I2C communication is in Master Mode)\\n"]
#[doc = "          b3-b2-b1-b0  (not used)\\n"]
#[doc = "             xxxx : Should be set to 0000"]
#[doc = " @{"]
pub type HAL_I2C_ModeTypeDef = libc::c_uint;
#[doc = " @defgroup I2C_handle_Structure_definition I2C handle Structure definition"]
#[doc = " @brief  I2C handle Structure definition"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __I2C_HandleTypeDef {
    #[doc = "< I2C registers base address"]
    pub Instance: *mut I2C_TypeDef,
    #[doc = "< I2C communication parameters"]
    pub Init: I2C_InitTypeDef,
    #[doc = "< Pointer to I2C transfer buffer"]
    pub pBuffPtr: *mut u8,
    #[doc = "< I2C transfer size"]
    pub XferSize: u16,
    #[doc = "< I2C transfer counter"]
    pub XferCount: u16,
    #[doc = "< I2C sequantial transfer options, this parameter can"]
    #[doc = "be a value of @ref I2C_XFEROPTIONS"]
    pub XferOptions: u32,
    #[doc = "< I2C communication Previous state"]
    pub PreviousState: u32,
    #[doc = "< I2C transfer IRQ handler function pointer"]
    pub XferISR: ::core::option::Option<
        unsafe extern "C" fn(
            hi2c: *mut __I2C_HandleTypeDef,
            ITFlags: u32,
            ITSources: u32,
        ) -> HAL_StatusTypeDef,
    >,
    #[doc = "< I2C Tx DMA handle parameters"]
    pub hdmatx: *mut DMA_HandleTypeDef,
    #[doc = "< I2C Rx DMA handle parameters"]
    pub hdmarx: *mut DMA_HandleTypeDef,
    #[doc = "< I2C locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< I2C communication state"]
    pub State: HAL_I2C_StateTypeDef,
    #[doc = "< I2C communication mode"]
    pub Mode: HAL_I2C_ModeTypeDef,
    #[doc = "< I2C Error code"]
    pub ErrorCode: u32,
    #[doc = "< I2C Address Event counter"]
    pub AddrEventCount: u32,
}
#[test]
fn bindgen_test_layout___I2C_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<__I2C_HandleTypeDef>(),
        84usize,
        concat!("Size of: ", stringify!(__I2C_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<__I2C_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(__I2C_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__I2C_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__I2C_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__I2C_HandleTypeDef>())).pBuffPtr as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(pBuffPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__I2C_HandleTypeDef>())).XferSize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(XferSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__I2C_HandleTypeDef>())).XferCount as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(XferCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__I2C_HandleTypeDef>())).XferOptions as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(XferOptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__I2C_HandleTypeDef>())).PreviousState as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(PreviousState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__I2C_HandleTypeDef>())).XferISR as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(XferISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__I2C_HandleTypeDef>())).hdmatx as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(hdmatx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__I2C_HandleTypeDef>())).hdmarx as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(hdmarx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__I2C_HandleTypeDef>())).Lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__I2C_HandleTypeDef>())).State as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__I2C_HandleTypeDef>())).Mode as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__I2C_HandleTypeDef>())).ErrorCode as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__I2C_HandleTypeDef>())).AddrEventCount as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(AddrEventCount)
        )
    );
}
impl Default for __I2C_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @defgroup I2C_handle_Structure_definition I2C handle Structure definition"]
#[doc = " @brief  I2C handle Structure definition"]
#[doc = " @{"]
pub type I2C_HandleTypeDef = __I2C_HandleTypeDef;
extern "C" {
    #[doc = " @addtogroup I2CEx_Exported_Functions_Group1 I2C Extended Filter Mode Functions"]
    #[doc = " @{"]
    pub fn HAL_I2CEx_ConfigAnalogFilter(
        hi2c: *mut I2C_HandleTypeDef,
        AnalogFilter: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2CEx_ConfigDigitalFilter(
        hi2c: *mut I2C_HandleTypeDef,
        DigitalFilter: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup I2CEx_Exported_Functions_Group2 I2C Extended WakeUp Mode Functions"]
    #[doc = " @{"]
    pub fn HAL_I2CEx_EnableWakeUp(hi2c: *mut I2C_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2CEx_DisableWakeUp(hi2c: *mut I2C_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup I2CEx_Exported_Functions_Group3 I2C Extended FastModePlus Functions"]
    #[doc = " @{"]
    pub fn HAL_I2CEx_EnableFastModePlus(ConfigFastModePlus: u32);
}
extern "C" {
    pub fn HAL_I2CEx_DisableFastModePlus(ConfigFastModePlus: u32);
}
extern "C" {
    #[doc = " @addtogroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_I2C_Init(hi2c: *mut I2C_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_DeInit(hi2c: *mut I2C_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_MspInit(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_MspDeInit(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    #[doc = " Blocking mode: Polling"]
    pub fn HAL_I2C_Master_Transmit(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Receive(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Transmit(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Receive(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Mem_Write(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        MemAddress: u16,
        MemAddSize: u16,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Mem_Read(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        MemAddress: u16,
        MemAddSize: u16,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_IsDeviceReady(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        Trials: u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " Non-Blocking mode: Interrupt"]
    pub fn HAL_I2C_Master_Transmit_IT(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Receive_IT(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Transmit_IT(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Receive_IT(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Mem_Write_IT(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        MemAddress: u16,
        MemAddSize: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Mem_Read_IT(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        MemAddress: u16,
        MemAddSize: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Seq_Transmit_IT(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Seq_Receive_IT(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Seq_Transmit_IT(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Seq_Receive_IT(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_EnableListen_IT(hi2c: *mut I2C_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_DisableListen_IT(hi2c: *mut I2C_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Abort_IT(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " Non-Blocking mode: DMA"]
    pub fn HAL_I2C_Master_Transmit_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Receive_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Transmit_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Receive_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Mem_Write_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        MemAddress: u16,
        MemAddSize: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Mem_Read_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        MemAddress: u16,
        MemAddSize: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Seq_Transmit_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Seq_Receive_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Seq_Transmit_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Seq_Receive_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup I2C_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks"]
    #[doc = " @{"]
    pub fn HAL_I2C_EV_IRQHandler(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_ER_IRQHandler(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_MasterTxCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_MasterRxCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_SlaveTxCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_SlaveRxCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_AddrCallback(
        hi2c: *mut I2C_HandleTypeDef,
        TransferDirection: u8,
        AddrMatchCode: u16,
    );
}
extern "C" {
    pub fn HAL_I2C_ListenCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_MemTxCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_MemRxCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_ErrorCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_AbortCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions"]
    #[doc = " @{"]
    pub fn HAL_I2C_GetState(hi2c: *mut I2C_HandleTypeDef) -> HAL_I2C_StateTypeDef;
}
extern "C" {
    pub fn HAL_I2C_GetMode(hi2c: *mut I2C_HandleTypeDef) -> HAL_I2C_ModeTypeDef;
}
extern "C" {
    pub fn HAL_I2C_GetError(hi2c: *mut I2C_HandleTypeDef) -> u32;
}
#[doc = " @brief IRDA Init Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IRDA_InitTypeDef {
    #[doc = "< This member configures the IRDA communication baud rate."]
    #[doc = "The baud rate register is computed using the following formula:"]
    #[doc = "Baud Rate Register = ((usart_ker_ckpres) / ((hirda->Init.BaudRate)))"]
    #[doc = "where usart_ker_ckpres is the IRDA input clock divided by a prescaler"]
    pub BaudRate: u32,
    #[doc = "< Specifies the number of data bits transmitted or received in a frame."]
    #[doc = "This parameter can be a value of @ref IRDAEx_Word_Length"]
    pub WordLength: u32,
    #[doc = "< Specifies the parity mode."]
    #[doc = "This parameter can be a value of @ref IRDA_Parity"]
    #[doc = "@note When parity is enabled, the computed parity is inserted"]
    #[doc = "at the MSB position of the transmitted data (9th bit when"]
    #[doc = "the word length is set to 9 data bits; 8th bit when the"]
    #[doc = "word length is set to 8 data bits)."]
    pub Parity: u32,
    #[doc = "< Specifies whether the Receive or Transmit mode is enabled or disabled."]
    #[doc = "This parameter can be a value of @ref IRDA_Transfer_Mode"]
    pub Mode: u32,
    #[doc = "< Specifies the Prescaler value for dividing the UART/USART source clock"]
    #[doc = "to achieve low-power frequency."]
    #[doc = "@note Prescaler value 0 is forbidden"]
    pub Prescaler: u8,
    #[doc = "< Specifies the IRDA power mode."]
    #[doc = "This parameter can be a value of @ref IRDA_Low_Power"]
    pub PowerMode: u16,
}
#[test]
fn bindgen_test_layout_IRDA_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<IRDA_InitTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(IRDA_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<IRDA_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(IRDA_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_InitTypeDef>())).BaudRate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_InitTypeDef),
            "::",
            stringify!(BaudRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_InitTypeDef>())).WordLength as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_InitTypeDef),
            "::",
            stringify!(WordLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_InitTypeDef>())).Parity as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_InitTypeDef),
            "::",
            stringify!(Parity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_InitTypeDef>())).Mode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_InitTypeDef>())).Prescaler as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_InitTypeDef>())).PowerMode as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_InitTypeDef),
            "::",
            stringify!(PowerMode)
        )
    );
}
#[doc = " @brief HAL IRDA State definition"]
#[doc = " @note  HAL IRDA State value is a combination of 2 different substates: gState and RxState (see @ref IRDA_State_Definition)."]
#[doc = "        - gState contains IRDA state information related to global Handle management"]
#[doc = "          and also information related to Tx operations."]
#[doc = "          gState value coding follow below described bitmap :"]
#[doc = "          b7-b6  Error information"]
#[doc = "             00 : No Error"]
#[doc = "             01 : (Not Used)"]
#[doc = "             10 : Timeout"]
#[doc = "             11 : Error"]
#[doc = "          b5     Peripheral initialization status"]
#[doc = "             0  : Reset (Peripheral not initialized)"]
#[doc = "             1  : Init done (Peripheral initialized. HAL IRDA Init function already called)"]
#[doc = "          b4-b3  (not used)"]
#[doc = "             xx : Should be set to 00"]
#[doc = "          b2     Intrinsic process state"]
#[doc = "             0  : Ready"]
#[doc = "             1  : Busy (Peripheral busy with some configuration or internal operations)"]
#[doc = "          b1     (not used)"]
#[doc = "             x  : Should be set to 0"]
#[doc = "          b0     Tx state"]
#[doc = "             0  : Ready (no Tx operation ongoing)"]
#[doc = "             1  : Busy (Tx operation ongoing)"]
#[doc = "        - RxState contains information related to Rx operations."]
#[doc = "          RxState value coding follow below described bitmap :"]
#[doc = "          b7-b6  (not used)"]
#[doc = "             xx : Should be set to 00"]
#[doc = "          b5     Peripheral initialization status"]
#[doc = "             0  : Reset (Peripheral not initialized)"]
#[doc = "             1  : Init done (Peripheral initialized)"]
#[doc = "          b4-b2  (not used)"]
#[doc = "            xxx : Should be set to 000"]
#[doc = "          b1     Rx state"]
#[doc = "             0  : Ready (no Rx operation ongoing)"]
#[doc = "             1  : Busy (Rx operation ongoing)"]
#[doc = "          b0     (not used)"]
#[doc = "             x  : Should be set to 0."]
pub type HAL_IRDA_StateTypeDef = u32;
#[doc = "< PCLK1 clock source"]
pub const IRDA_ClockSourceTypeDef_IRDA_CLOCKSOURCE_PCLK1: IRDA_ClockSourceTypeDef = 0;
#[doc = "< PCLK2 clock source"]
pub const IRDA_ClockSourceTypeDef_IRDA_CLOCKSOURCE_PCLK2: IRDA_ClockSourceTypeDef = 1;
#[doc = "< HSI clock source"]
pub const IRDA_ClockSourceTypeDef_IRDA_CLOCKSOURCE_HSI: IRDA_ClockSourceTypeDef = 2;
#[doc = "< SYSCLK clock source"]
pub const IRDA_ClockSourceTypeDef_IRDA_CLOCKSOURCE_SYSCLK: IRDA_ClockSourceTypeDef = 4;
#[doc = "< LSE clock source"]
pub const IRDA_ClockSourceTypeDef_IRDA_CLOCKSOURCE_LSE: IRDA_ClockSourceTypeDef = 16;
#[doc = "< Undefined clock source"]
pub const IRDA_ClockSourceTypeDef_IRDA_CLOCKSOURCE_UNDEFINED: IRDA_ClockSourceTypeDef = 32;
#[doc = " @brief IRDA clock sources definition"]
pub type IRDA_ClockSourceTypeDef = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRDA_HandleTypeDef {
    #[doc = "< USART registers base address"]
    pub Instance: *mut USART_TypeDef,
    #[doc = "< IRDA communication parameters"]
    pub Init: IRDA_InitTypeDef,
    #[doc = "< Pointer to IRDA Tx transfer Buffer"]
    pub pTxBuffPtr: *mut u8,
    #[doc = "< IRDA Tx Transfer size"]
    pub TxXferSize: u16,
    #[doc = "< IRDA Tx Transfer Counter"]
    pub TxXferCount: u16,
    #[doc = "< Pointer to IRDA Rx transfer Buffer"]
    pub pRxBuffPtr: *mut u8,
    #[doc = "< IRDA Rx Transfer size"]
    pub RxXferSize: u16,
    #[doc = "< IRDA Rx Transfer Counter"]
    pub RxXferCount: u16,
    #[doc = "< USART RX RDR register mask"]
    pub Mask: u16,
    #[doc = "< IRDA Tx DMA Handle parameters"]
    pub hdmatx: *mut DMA_HandleTypeDef,
    #[doc = "< IRDA Rx DMA Handle parameters"]
    pub hdmarx: *mut DMA_HandleTypeDef,
    #[doc = "< Locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< IRDA state information related to global Handle management"]
    #[doc = "and also related to Tx operations."]
    #[doc = "This parameter can be a value of @ref HAL_IRDA_StateTypeDef"]
    pub gState: HAL_IRDA_StateTypeDef,
    #[doc = "< IRDA state information related to Rx operations."]
    #[doc = "This parameter can be a value of @ref HAL_IRDA_StateTypeDef"]
    pub RxState: HAL_IRDA_StateTypeDef,
    #[doc = "< IRDA Error code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout_IRDA_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<IRDA_HandleTypeDef>(),
        68usize,
        concat!("Size of: ", stringify!(IRDA_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<IRDA_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(IRDA_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_HandleTypeDef>())).pTxBuffPtr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_HandleTypeDef),
            "::",
            stringify!(pTxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_HandleTypeDef>())).TxXferSize as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_HandleTypeDef),
            "::",
            stringify!(TxXferSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_HandleTypeDef>())).TxXferCount as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_HandleTypeDef),
            "::",
            stringify!(TxXferCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_HandleTypeDef>())).pRxBuffPtr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_HandleTypeDef),
            "::",
            stringify!(pRxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_HandleTypeDef>())).RxXferSize as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_HandleTypeDef),
            "::",
            stringify!(RxXferSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_HandleTypeDef>())).RxXferCount as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_HandleTypeDef),
            "::",
            stringify!(RxXferCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_HandleTypeDef>())).Mask as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_HandleTypeDef),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_HandleTypeDef>())).hdmatx as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_HandleTypeDef),
            "::",
            stringify!(hdmatx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_HandleTypeDef>())).hdmarx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_HandleTypeDef),
            "::",
            stringify!(hdmarx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_HandleTypeDef>())).Lock as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_HandleTypeDef>())).gState as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_HandleTypeDef),
            "::",
            stringify!(gState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_HandleTypeDef>())).RxState as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_HandleTypeDef),
            "::",
            stringify!(RxState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IRDA_HandleTypeDef>())).ErrorCode as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IRDA_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl Default for IRDA_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @addtogroup IRDA_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_IRDA_Init(hirda: *mut IRDA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_DeInit(hirda: *mut IRDA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_MspInit(hirda: *mut IRDA_HandleTypeDef);
}
extern "C" {
    pub fn HAL_IRDA_MspDeInit(hirda: *mut IRDA_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup IRDA_Exported_Functions_Group2 IO operation functions"]
    #[doc = " @{"]
    pub fn HAL_IRDA_Transmit(
        hirda: *mut IRDA_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_Receive(
        hirda: *mut IRDA_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_Transmit_IT(
        hirda: *mut IRDA_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_Receive_IT(
        hirda: *mut IRDA_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_Transmit_DMA(
        hirda: *mut IRDA_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_Receive_DMA(
        hirda: *mut IRDA_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_DMAPause(hirda: *mut IRDA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_DMAResume(hirda: *mut IRDA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_DMAStop(hirda: *mut IRDA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_Abort(hirda: *mut IRDA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_AbortTransmit(hirda: *mut IRDA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_AbortReceive(hirda: *mut IRDA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_Abort_IT(hirda: *mut IRDA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_AbortTransmit_IT(hirda: *mut IRDA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_AbortReceive_IT(hirda: *mut IRDA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_IRQHandler(hirda: *mut IRDA_HandleTypeDef);
}
extern "C" {
    pub fn HAL_IRDA_TxCpltCallback(hirda: *mut IRDA_HandleTypeDef);
}
extern "C" {
    pub fn HAL_IRDA_RxCpltCallback(hirda: *mut IRDA_HandleTypeDef);
}
extern "C" {
    pub fn HAL_IRDA_TxHalfCpltCallback(hirda: *mut IRDA_HandleTypeDef);
}
extern "C" {
    pub fn HAL_IRDA_RxHalfCpltCallback(hirda: *mut IRDA_HandleTypeDef);
}
extern "C" {
    pub fn HAL_IRDA_ErrorCallback(hirda: *mut IRDA_HandleTypeDef);
}
extern "C" {
    pub fn HAL_IRDA_AbortCpltCallback(hirda: *mut IRDA_HandleTypeDef);
}
extern "C" {
    pub fn HAL_IRDA_AbortTransmitCpltCallback(hirda: *mut IRDA_HandleTypeDef);
}
extern "C" {
    pub fn HAL_IRDA_AbortReceiveCpltCallback(hirda: *mut IRDA_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup IRDA_Exported_Functions_Group4 Peripheral State and Error functions"]
    #[doc = " @{"]
    pub fn HAL_IRDA_GetState(hirda: *mut IRDA_HandleTypeDef) -> HAL_IRDA_StateTypeDef;
}
extern "C" {
    pub fn HAL_IRDA_GetError(hirda: *mut IRDA_HandleTypeDef) -> u32;
}
#[doc = " @brief  IWDG Init structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IWDG_InitTypeDef {
    #[doc = "< Select the prescaler of the IWDG."]
    #[doc = "This parameter can be a value of @ref IWDG_Prescaler"]
    pub Prescaler: u32,
    #[doc = "< Specifies the IWDG down-counter reload value."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 0x0FFF"]
    pub Reload: u32,
    #[doc = "< Specifies the window value to be compared to the down-counter."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 0x0FFF"]
    pub Window: u32,
}
#[test]
fn bindgen_test_layout_IWDG_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<IWDG_InitTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(IWDG_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<IWDG_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(IWDG_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IWDG_InitTypeDef>())).Prescaler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IWDG_InitTypeDef>())).Reload as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_InitTypeDef),
            "::",
            stringify!(Reload)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IWDG_InitTypeDef>())).Window as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_InitTypeDef),
            "::",
            stringify!(Window)
        )
    );
}
#[doc = " @brief  IWDG Handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWDG_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut IWDG_TypeDef,
    #[doc = "< IWDG required parameters"]
    pub Init: IWDG_InitTypeDef,
}
#[test]
fn bindgen_test_layout_IWDG_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<IWDG_HandleTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(IWDG_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<IWDG_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(IWDG_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IWDG_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IWDG_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
}
impl Default for IWDG_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @defgroup IWDG_Exported_Functions_Group1 Initialization and Start functions"]
    #[doc = " @{"]
    pub fn HAL_IWDG_Init(hiwdg: *mut IWDG_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup IWDG_Exported_Functions_Group2 IO operation functions"]
    #[doc = " @{"]
    pub fn HAL_IWDG_Refresh(hiwdg: *mut IWDG_HandleTypeDef) -> HAL_StatusTypeDef;
}
#[doc = " @brief  LPTIM Clock configuration definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LPTIM_ClockConfigTypeDef {
    #[doc = "< Selects the clock source."]
    #[doc = "This parameter can be a value of @ref LPTIM_Clock_Source"]
    pub Source: u32,
    #[doc = "< Specifies the counter clock Prescaler."]
    #[doc = "This parameter can be a value of @ref LPTIM_Clock_Prescaler"]
    pub Prescaler: u32,
}
#[test]
fn bindgen_test_layout_LPTIM_ClockConfigTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<LPTIM_ClockConfigTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(LPTIM_ClockConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LPTIM_ClockConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LPTIM_ClockConfigTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LPTIM_ClockConfigTypeDef>())).Source as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_ClockConfigTypeDef),
            "::",
            stringify!(Source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LPTIM_ClockConfigTypeDef>())).Prescaler as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_ClockConfigTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
}
#[doc = " @brief  LPTIM Clock configuration definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LPTIM_ULPClockConfigTypeDef {
    #[doc = "< Selects the polarity of the active edge for the counter unit"]
    #[doc = "if the ULPTIM input is selected."]
    #[doc = "Note: This parameter is used only when Ultra low power clock source is used."]
    #[doc = "Note: If the polarity is configured on 'both edges', an auxiliary clock"]
    #[doc = "(one of the Low power oscillator) must be active."]
    #[doc = "This parameter can be a value of @ref LPTIM_Clock_Polarity"]
    pub Polarity: u32,
    #[doc = "< Selects the clock sampling time to configure the clock glitch filter."]
    #[doc = "Note: This parameter is used only when Ultra low power clock source is used."]
    #[doc = "This parameter can be a value of @ref LPTIM_Clock_Sample_Time"]
    pub SampleTime: u32,
}
#[test]
fn bindgen_test_layout_LPTIM_ULPClockConfigTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<LPTIM_ULPClockConfigTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(LPTIM_ULPClockConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LPTIM_ULPClockConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LPTIM_ULPClockConfigTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LPTIM_ULPClockConfigTypeDef>())).Polarity as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_ULPClockConfigTypeDef),
            "::",
            stringify!(Polarity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LPTIM_ULPClockConfigTypeDef>())).SampleTime as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_ULPClockConfigTypeDef),
            "::",
            stringify!(SampleTime)
        )
    );
}
#[doc = " @brief  LPTIM Trigger configuration definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LPTIM_TriggerConfigTypeDef {
    #[doc = "< Selects the Trigger source."]
    #[doc = "This parameter can be a value of @ref LPTIM_Trigger_Source"]
    pub Source: u32,
    #[doc = "< Selects the Trigger active edge."]
    #[doc = "Note: This parameter is used only when an external trigger is used."]
    #[doc = "This parameter can be a value of @ref LPTIM_External_Trigger_Polarity"]
    pub ActiveEdge: u32,
    #[doc = "< Selects the trigger sampling time to configure the clock glitch filter."]
    #[doc = "Note: This parameter is used only when an external trigger is used."]
    #[doc = "This parameter can be a value of @ref LPTIM_Trigger_Sample_Time"]
    pub SampleTime: u32,
}
#[test]
fn bindgen_test_layout_LPTIM_TriggerConfigTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<LPTIM_TriggerConfigTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(LPTIM_TriggerConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LPTIM_TriggerConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LPTIM_TriggerConfigTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LPTIM_TriggerConfigTypeDef>())).Source as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TriggerConfigTypeDef),
            "::",
            stringify!(Source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LPTIM_TriggerConfigTypeDef>())).ActiveEdge as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TriggerConfigTypeDef),
            "::",
            stringify!(ActiveEdge)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LPTIM_TriggerConfigTypeDef>())).SampleTime as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TriggerConfigTypeDef),
            "::",
            stringify!(SampleTime)
        )
    );
}
#[doc = " @brief  LPTIM Initialization Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LPTIM_InitTypeDef {
    #[doc = "< Specifies the clock parameters"]
    pub Clock: LPTIM_ClockConfigTypeDef,
    #[doc = "< Specifies the Ultra Low Power clock parameters"]
    pub UltraLowPowerClock: LPTIM_ULPClockConfigTypeDef,
    #[doc = "< Specifies the Trigger parameters"]
    pub Trigger: LPTIM_TriggerConfigTypeDef,
    #[doc = "< Specifies the Output polarity."]
    #[doc = "This parameter can be a value of @ref LPTIM_Output_Polarity"]
    pub OutputPolarity: u32,
    #[doc = "< Specifies whether the update of the autoreload and the compare"]
    #[doc = "values is done immediately or after the end of current period."]
    #[doc = "This parameter can be a value of @ref LPTIM_Updating_Mode"]
    pub UpdateMode: u32,
    #[doc = "< Specifies whether the counter is incremented each internal event"]
    #[doc = "or each external event."]
    #[doc = "This parameter can be a value of @ref LPTIM_Counter_Source"]
    pub CounterSource: u32,
    #[doc = "< Specifies source selected for input1 (GPIO or comparator output)."]
    #[doc = "This parameter can be a value of @ref LPTIM_Input1_Source"]
    pub Input1Source: u32,
    #[doc = "< Specifies source selected for input2 (GPIO or comparator output)."]
    #[doc = "Note: This parameter is used only for encoder feature so is used only"]
    #[doc = "for LPTIM1 instance."]
    #[doc = "This parameter can be a value of @ref LPTIM_Input2_Source"]
    pub Input2Source: u32,
}
#[test]
fn bindgen_test_layout_LPTIM_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<LPTIM_InitTypeDef>(),
        48usize,
        concat!("Size of: ", stringify!(LPTIM_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LPTIM_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LPTIM_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_InitTypeDef>())).Clock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_InitTypeDef),
            "::",
            stringify!(Clock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LPTIM_InitTypeDef>())).UltraLowPowerClock as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_InitTypeDef),
            "::",
            stringify!(UltraLowPowerClock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_InitTypeDef>())).Trigger as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_InitTypeDef),
            "::",
            stringify!(Trigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LPTIM_InitTypeDef>())).OutputPolarity as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_InitTypeDef),
            "::",
            stringify!(OutputPolarity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_InitTypeDef>())).UpdateMode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_InitTypeDef),
            "::",
            stringify!(UpdateMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LPTIM_InitTypeDef>())).CounterSource as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_InitTypeDef),
            "::",
            stringify!(CounterSource)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_InitTypeDef>())).Input1Source as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_InitTypeDef),
            "::",
            stringify!(Input1Source)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_InitTypeDef>())).Input2Source as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_InitTypeDef),
            "::",
            stringify!(Input2Source)
        )
    );
}
#[doc = "< Peripheral not yet initialized or disabled"]
pub const HAL_LPTIM_StateTypeDef_HAL_LPTIM_STATE_RESET: HAL_LPTIM_StateTypeDef = 0;
#[doc = "< Peripheral Initialized and ready for use"]
pub const HAL_LPTIM_StateTypeDef_HAL_LPTIM_STATE_READY: HAL_LPTIM_StateTypeDef = 1;
#[doc = "< An internal process is ongoing"]
pub const HAL_LPTIM_StateTypeDef_HAL_LPTIM_STATE_BUSY: HAL_LPTIM_StateTypeDef = 2;
#[doc = "< Timeout state"]
pub const HAL_LPTIM_StateTypeDef_HAL_LPTIM_STATE_TIMEOUT: HAL_LPTIM_StateTypeDef = 3;
#[doc = "< Internal Process is ongoing"]
pub const HAL_LPTIM_StateTypeDef_HAL_LPTIM_STATE_ERROR: HAL_LPTIM_StateTypeDef = 4;
#[doc = " @brief  HAL LPTIM State structure definition"]
pub type HAL_LPTIM_StateTypeDef = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LPTIM_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut LPTIM_TypeDef,
    #[doc = "< LPTIM required parameters"]
    pub Init: LPTIM_InitTypeDef,
    #[doc = "< LPTIM peripheral status"]
    pub Status: HAL_StatusTypeDef,
    #[doc = "< LPTIM locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< LPTIM peripheral state"]
    pub State: HAL_LPTIM_StateTypeDef,
}
#[test]
fn bindgen_test_layout_LPTIM_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<LPTIM_HandleTypeDef>(),
        64usize,
        concat!("Size of: ", stringify!(LPTIM_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LPTIM_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LPTIM_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_HandleTypeDef>())).Status as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_HandleTypeDef),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_HandleTypeDef>())).Lock as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LPTIM_HandleTypeDef>())).State as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
}
impl Default for LPTIM_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @addtogroup LPTIM_Exported_Functions_Group1"]
    #[doc = "  @brief    Initialization and Configuration functions."]
    #[doc = " @{"]
    pub fn HAL_LPTIM_Init(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_DeInit(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_MspInit(hlptim: *mut LPTIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_LPTIM_MspDeInit(hlptim: *mut LPTIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_LPTIM_PWM_Start(
        hlptim: *mut LPTIM_HandleTypeDef,
        Period: u32,
        Pulse: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_PWM_Stop(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_PWM_Start_IT(
        hlptim: *mut LPTIM_HandleTypeDef,
        Period: u32,
        Pulse: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_PWM_Stop_IT(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_OnePulse_Start(
        hlptim: *mut LPTIM_HandleTypeDef,
        Period: u32,
        Pulse: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_OnePulse_Stop(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_OnePulse_Start_IT(
        hlptim: *mut LPTIM_HandleTypeDef,
        Period: u32,
        Pulse: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_OnePulse_Stop_IT(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_SetOnce_Start(
        hlptim: *mut LPTIM_HandleTypeDef,
        Period: u32,
        Pulse: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_SetOnce_Stop(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_SetOnce_Start_IT(
        hlptim: *mut LPTIM_HandleTypeDef,
        Period: u32,
        Pulse: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_SetOnce_Stop_IT(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_Encoder_Start(
        hlptim: *mut LPTIM_HandleTypeDef,
        Period: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_Encoder_Stop(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_Encoder_Start_IT(
        hlptim: *mut LPTIM_HandleTypeDef,
        Period: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_Encoder_Stop_IT(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_TimeOut_Start(
        hlptim: *mut LPTIM_HandleTypeDef,
        Period: u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_TimeOut_Stop(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_TimeOut_Start_IT(
        hlptim: *mut LPTIM_HandleTypeDef,
        Period: u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_TimeOut_Stop_IT(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_Counter_Start(
        hlptim: *mut LPTIM_HandleTypeDef,
        Period: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_Counter_Stop(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_Counter_Start_IT(
        hlptim: *mut LPTIM_HandleTypeDef,
        Period: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_Counter_Stop_IT(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup LPTIM_Exported_Functions_Group3"]
    #[doc = "  @brief  Read operation functions."]
    #[doc = " @{"]
    pub fn HAL_LPTIM_ReadCounter(hlptim: *mut LPTIM_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_LPTIM_ReadAutoReload(hlptim: *mut LPTIM_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_LPTIM_ReadCompare(hlptim: *mut LPTIM_HandleTypeDef) -> u32;
}
extern "C" {
    #[doc = " @addtogroup LPTIM_Exported_Functions_Group4"]
    #[doc = "  @brief  LPTIM IRQ handler and callback functions."]
    #[doc = " @{"]
    pub fn HAL_LPTIM_IRQHandler(hlptim: *mut LPTIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_LPTIM_CompareMatchCallback(hlptim: *mut LPTIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_LPTIM_AutoReloadMatchCallback(hlptim: *mut LPTIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_LPTIM_TriggerCallback(hlptim: *mut LPTIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_LPTIM_CompareWriteCallback(hlptim: *mut LPTIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_LPTIM_AutoReloadWriteCallback(hlptim: *mut LPTIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_LPTIM_DirectionUpCallback(hlptim: *mut LPTIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_LPTIM_DirectionDownCallback(hlptim: *mut LPTIM_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup LPTIM_Group5"]
    #[doc = "  @brief   Peripheral State functions."]
    #[doc = " @{"]
    pub fn HAL_LPTIM_GetState(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_LPTIM_StateTypeDef;
}
extern "C" {
    #[doc = " @defgroup LPTIM_Private_Functions LPTIM Private Functions"]
    #[doc = " @{"]
    pub fn LPTIM_Disable(hlptim: *mut LPTIM_HandleTypeDef);
}
#[doc = " @brief  SDMMC Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDMMC_InitTypeDef {
    #[doc = "< Specifies the clock transition on which the bit capture is made."]
    #[doc = "This parameter can be a value of @ref SDMMC_LL_Clock_Edge"]
    pub ClockEdge: u32,
    #[doc = "< Specifies whether the SDMMC Clock divider bypass is"]
    #[doc = "enabled or disabled."]
    #[doc = "This parameter can be a value of @ref SDMMC_LL_Clock_Bypass"]
    pub ClockBypass: u32,
    #[doc = "< Specifies whether SDMMC Clock output is enabled or"]
    #[doc = "disabled when the bus is idle."]
    #[doc = "This parameter can be a value of @ref SDMMC_LL_Clock_Power_Save"]
    pub ClockPowerSave: u32,
    #[doc = "< Specifies the SDMMC bus width."]
    #[doc = "This parameter can be a value of @ref SDMMC_LL_Bus_Wide"]
    pub BusWide: u32,
    #[doc = "< Specifies whether the SDMMC hardware flow control is enabled or disabled."]
    #[doc = "This parameter can be a value of @ref SDMMC_LL_Hardware_Flow_Control"]
    pub HardwareFlowControl: u32,
    #[doc = "< Specifies the clock frequency of the SDMMC controller."]
    #[doc = "This parameter can be a value between Min_Data = 0 and Max_Data = 1023"]
    pub ClockDiv: u32,
}
#[test]
fn bindgen_test_layout_SDMMC_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SDMMC_InitTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(SDMMC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SDMMC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SDMMC_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_InitTypeDef>())).ClockEdge as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_InitTypeDef),
            "::",
            stringify!(ClockEdge)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_InitTypeDef>())).ClockBypass as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_InitTypeDef),
            "::",
            stringify!(ClockBypass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDMMC_InitTypeDef>())).ClockPowerSave as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_InitTypeDef),
            "::",
            stringify!(ClockPowerSave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_InitTypeDef>())).BusWide as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_InitTypeDef),
            "::",
            stringify!(BusWide)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDMMC_InitTypeDef>())).HardwareFlowControl as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_InitTypeDef),
            "::",
            stringify!(HardwareFlowControl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_InitTypeDef>())).ClockDiv as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_InitTypeDef),
            "::",
            stringify!(ClockDiv)
        )
    );
}
#[doc = " @brief  SDMMC Command Control structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDMMC_CmdInitTypeDef {
    #[doc = "< Specifies the SDMMC command argument which is sent"]
    #[doc = "to a card as part of a command message. If a command"]
    #[doc = "contains an argument, it must be loaded into this register"]
    #[doc = "before writing the command to the command register."]
    pub Argument: u32,
    #[doc = "< Specifies the SDMMC command index. It must be Min_Data = 0 and"]
    #[doc = "Max_Data = 64"]
    pub CmdIndex: u32,
    #[doc = "< Specifies the SDMMC response type."]
    #[doc = "This parameter can be a value of @ref SDMMC_LL_Response_Type"]
    pub Response: u32,
    #[doc = "< Specifies whether SDMMC wait for interrupt request is"]
    #[doc = "enabled or disabled."]
    #[doc = "This parameter can be a value of @ref SDMMC_LL_Wait_Interrupt_State"]
    pub WaitForInterrupt: u32,
    #[doc = "< Specifies whether SDMMC Command path state machine (CPSM)"]
    #[doc = "is enabled or disabled."]
    #[doc = "This parameter can be a value of @ref SDMMC_LL_CPSM_State"]
    pub CPSM: u32,
}
#[test]
fn bindgen_test_layout_SDMMC_CmdInitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SDMMC_CmdInitTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(SDMMC_CmdInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SDMMC_CmdInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SDMMC_CmdInitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_CmdInitTypeDef>())).Argument as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_CmdInitTypeDef),
            "::",
            stringify!(Argument)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_CmdInitTypeDef>())).CmdIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_CmdInitTypeDef),
            "::",
            stringify!(CmdIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_CmdInitTypeDef>())).Response as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_CmdInitTypeDef),
            "::",
            stringify!(Response)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDMMC_CmdInitTypeDef>())).WaitForInterrupt as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_CmdInitTypeDef),
            "::",
            stringify!(WaitForInterrupt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_CmdInitTypeDef>())).CPSM as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_CmdInitTypeDef),
            "::",
            stringify!(CPSM)
        )
    );
}
#[doc = " @brief  SDMMC Data Control structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDMMC_DataInitTypeDef {
    #[doc = "< Specifies the data timeout period in card bus clock periods."]
    pub DataTimeOut: u32,
    #[doc = "< Specifies the number of data bytes to be transferred."]
    pub DataLength: u32,
    #[doc = "< Specifies the data block size for block transfer."]
    #[doc = "This parameter can be a value of @ref SDMMC_LL_Data_Block_Size"]
    pub DataBlockSize: u32,
    #[doc = "< Specifies the data transfer direction, whether the transfer"]
    #[doc = "is a read or write."]
    #[doc = "This parameter can be a value of @ref SDMMC_LL_Transfer_Direction"]
    pub TransferDir: u32,
    #[doc = "< Specifies whether data transfer is in stream or block mode."]
    #[doc = "This parameter can be a value of @ref SDMMC_LL_Transfer_Type"]
    pub TransferMode: u32,
    #[doc = "< Specifies whether SDMMC Data path state machine (DPSM)"]
    #[doc = "is enabled or disabled."]
    #[doc = "This parameter can be a value of @ref SDMMC_LL_DPSM_State"]
    pub DPSM: u32,
}
#[test]
fn bindgen_test_layout_SDMMC_DataInitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SDMMC_DataInitTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(SDMMC_DataInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SDMMC_DataInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SDMMC_DataInitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDMMC_DataInitTypeDef>())).DataTimeOut as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_DataInitTypeDef),
            "::",
            stringify!(DataTimeOut)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDMMC_DataInitTypeDef>())).DataLength as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_DataInitTypeDef),
            "::",
            stringify!(DataLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDMMC_DataInitTypeDef>())).DataBlockSize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_DataInitTypeDef),
            "::",
            stringify!(DataBlockSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDMMC_DataInitTypeDef>())).TransferDir as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_DataInitTypeDef),
            "::",
            stringify!(TransferDir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDMMC_DataInitTypeDef>())).TransferMode as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_DataInitTypeDef),
            "::",
            stringify!(TransferMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDMMC_DataInitTypeDef>())).DPSM as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDMMC_DataInitTypeDef),
            "::",
            stringify!(DPSM)
        )
    );
}
extern "C" {
    #[doc = " @addtogroup HAL_SDMMC_LL_Group1"]
    #[doc = " @{"]
    pub fn SDMMC_Init(SDMMCx: *mut SDMMC_TypeDef, Init: SDMMC_InitTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup HAL_SDMMC_LL_Group2"]
    #[doc = " @{"]
    pub fn SDMMC_ReadFIFO(SDMMCx: *mut SDMMC_TypeDef) -> u32;
}
extern "C" {
    pub fn SDMMC_WriteFIFO(SDMMCx: *mut SDMMC_TypeDef, pWriteData: *mut u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup HAL_SDMMC_LL_Group3"]
    #[doc = " @{"]
    pub fn SDMMC_PowerState_ON(SDMMCx: *mut SDMMC_TypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn SDMMC_PowerState_OFF(SDMMCx: *mut SDMMC_TypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn SDMMC_GetPowerState(SDMMCx: *mut SDMMC_TypeDef) -> u32;
}
extern "C" {
    pub fn SDMMC_SendCommand(
        SDMMCx: *mut SDMMC_TypeDef,
        Command: *mut SDMMC_CmdInitTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn SDMMC_GetCommandResponse(SDMMCx: *mut SDMMC_TypeDef) -> u8;
}
extern "C" {
    pub fn SDMMC_GetResponse(SDMMCx: *mut SDMMC_TypeDef, Response: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_ConfigData(
        SDMMCx: *mut SDMMC_TypeDef,
        Data: *mut SDMMC_DataInitTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn SDMMC_GetDataCounter(SDMMCx: *mut SDMMC_TypeDef) -> u32;
}
extern "C" {
    pub fn SDMMC_GetFIFOCount(SDMMCx: *mut SDMMC_TypeDef) -> u32;
}
extern "C" {
    pub fn SDMMC_SetSDMMCReadWaitMode(
        SDMMCx: *mut SDMMC_TypeDef,
        SDMMC_ReadWaitMode: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn SDMMC_CmdBlockLength(SDMMCx: *mut SDMMC_TypeDef, BlockSize: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdReadSingleBlock(SDMMCx: *mut SDMMC_TypeDef, ReadAdd: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdReadMultiBlock(SDMMCx: *mut SDMMC_TypeDef, ReadAdd: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdWriteSingleBlock(SDMMCx: *mut SDMMC_TypeDef, WriteAdd: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdWriteMultiBlock(SDMMCx: *mut SDMMC_TypeDef, WriteAdd: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdEraseStartAdd(SDMMCx: *mut SDMMC_TypeDef, StartAdd: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdSDEraseStartAdd(SDMMCx: *mut SDMMC_TypeDef, StartAdd: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdEraseEndAdd(SDMMCx: *mut SDMMC_TypeDef, EndAdd: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdSDEraseEndAdd(SDMMCx: *mut SDMMC_TypeDef, EndAdd: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdErase(SDMMCx: *mut SDMMC_TypeDef, EraseType: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdStopTransfer(SDMMCx: *mut SDMMC_TypeDef) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdSelDesel(SDMMCx: *mut SDMMC_TypeDef, Addr: u64) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdGoIdleState(SDMMCx: *mut SDMMC_TypeDef) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdOperCond(SDMMCx: *mut SDMMC_TypeDef) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdAppCommand(SDMMCx: *mut SDMMC_TypeDef, Argument: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdAppOperCommand(SDMMCx: *mut SDMMC_TypeDef, Argument: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdBusWidth(SDMMCx: *mut SDMMC_TypeDef, BusWidth: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdSendSCR(SDMMCx: *mut SDMMC_TypeDef) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdSendCID(SDMMCx: *mut SDMMC_TypeDef) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdSendCSD(SDMMCx: *mut SDMMC_TypeDef, Argument: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdSetRelAdd(SDMMCx: *mut SDMMC_TypeDef, pRCA: *mut u16) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdSetRelAddMmc(SDMMCx: *mut SDMMC_TypeDef, RCA: u16) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdSendStatus(SDMMCx: *mut SDMMC_TypeDef, Argument: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdStatusRegister(SDMMCx: *mut SDMMC_TypeDef) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdOpCondition(SDMMCx: *mut SDMMC_TypeDef, Argument: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdSwitch(SDMMCx: *mut SDMMC_TypeDef, Argument: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_CmdSendEXTCSD(SDMMCx: *mut SDMMC_TypeDef, Argument: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_GetCmdResp1(SDMMCx: *mut SDMMC_TypeDef, SD_CMD: u8, Timeout: u32) -> u32;
}
extern "C" {
    pub fn SDMMC_GetCmdResp2(SDMMCx: *mut SDMMC_TypeDef) -> u32;
}
extern "C" {
    pub fn SDMMC_GetCmdResp3(SDMMCx: *mut SDMMC_TypeDef) -> u32;
}
extern "C" {
    pub fn SDMMC_GetCmdResp7(SDMMCx: *mut SDMMC_TypeDef) -> u32;
}
extern "C" {
    pub fn SDMMC_GetCmdResp6(SDMMCx: *mut SDMMC_TypeDef, SD_CMD: u8, pRCA: *mut u16) -> u32;
}
#[doc = "< MMC not yet initialized or disabled"]
pub const HAL_MMC_StateTypeDef_HAL_MMC_STATE_RESET: HAL_MMC_StateTypeDef = 0;
#[doc = "< MMC initialized and ready for use"]
pub const HAL_MMC_StateTypeDef_HAL_MMC_STATE_READY: HAL_MMC_StateTypeDef = 1;
#[doc = "< MMC Timeout state"]
pub const HAL_MMC_StateTypeDef_HAL_MMC_STATE_TIMEOUT: HAL_MMC_StateTypeDef = 2;
#[doc = "< MMC process ongoing"]
pub const HAL_MMC_StateTypeDef_HAL_MMC_STATE_BUSY: HAL_MMC_StateTypeDef = 3;
#[doc = "< MMC Programming State"]
pub const HAL_MMC_StateTypeDef_HAL_MMC_STATE_PROGRAMMING: HAL_MMC_StateTypeDef = 4;
#[doc = "< MMC Receinving State"]
pub const HAL_MMC_StateTypeDef_HAL_MMC_STATE_RECEIVING: HAL_MMC_StateTypeDef = 5;
#[doc = "< MMC Transfert State"]
pub const HAL_MMC_StateTypeDef_HAL_MMC_STATE_TRANSFER: HAL_MMC_StateTypeDef = 6;
#[doc = "< MMC is in error state"]
pub const HAL_MMC_StateTypeDef_HAL_MMC_STATE_ERROR: HAL_MMC_StateTypeDef = 15;
#[doc = " @defgroup MMC_Exported_Types_Group1 MMC State enumeration structure"]
#[doc = " @{"]
pub type HAL_MMC_StateTypeDef = libc::c_uint;
#[doc = " @defgroup MMC_Exported_Types_Group2 MMC Card State enumeration structure"]
#[doc = " @{"]
pub type HAL_MMC_CardStateTypeDef = u32;
#[doc = " @brief  MMC Card Information Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_MMC_CardInfoTypeDef {
    #[doc = "< Specifies the card Type"]
    pub CardType: u32,
    #[doc = "< Specifies the class of the card class"]
    pub Class: u32,
    #[doc = "< Specifies the Relative Card Address"]
    pub RelCardAdd: u32,
    #[doc = "< Specifies the Card Capacity in blocks"]
    pub BlockNbr: u32,
    #[doc = "< Specifies one block size in bytes"]
    pub BlockSize: u32,
    #[doc = "< Specifies the Card logical Capacity in blocks"]
    pub LogBlockNbr: u32,
    #[doc = "< Specifies logical block size in bytes"]
    pub LogBlockSize: u32,
}
#[test]
fn bindgen_test_layout_HAL_MMC_CardInfoTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<HAL_MMC_CardInfoTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(HAL_MMC_CardInfoTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<HAL_MMC_CardInfoTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_MMC_CardInfoTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardInfoTypeDef>())).CardType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardInfoTypeDef),
            "::",
            stringify!(CardType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_MMC_CardInfoTypeDef>())).Class as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardInfoTypeDef),
            "::",
            stringify!(Class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardInfoTypeDef>())).RelCardAdd as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardInfoTypeDef),
            "::",
            stringify!(RelCardAdd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardInfoTypeDef>())).BlockNbr as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardInfoTypeDef),
            "::",
            stringify!(BlockNbr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardInfoTypeDef>())).BlockSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardInfoTypeDef),
            "::",
            stringify!(BlockSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardInfoTypeDef>())).LogBlockNbr as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardInfoTypeDef),
            "::",
            stringify!(LogBlockNbr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardInfoTypeDef>())).LogBlockSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardInfoTypeDef),
            "::",
            stringify!(LogBlockSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMC_HandleTypeDef {
    #[doc = "< MMC registers base address"]
    pub Instance: *mut SDMMC_TypeDef,
    #[doc = "< MMC required parameters"]
    pub Init: SDMMC_InitTypeDef,
    #[doc = "< MMC locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< Pointer to MMC Tx transfer Buffer"]
    pub pTxBuffPtr: *mut u8,
    #[doc = "< MMC Tx Transfer size"]
    pub TxXferSize: u32,
    #[doc = "< Pointer to MMC Rx transfer Buffer"]
    pub pRxBuffPtr: *mut u8,
    #[doc = "< MMC Rx Transfer size"]
    pub RxXferSize: u32,
    #[doc = "< MMC transfer context"]
    pub Context: u32,
    #[doc = "< MMC card State"]
    pub State: HAL_MMC_StateTypeDef,
    #[doc = "< MMC Card Error codes"]
    pub ErrorCode: u32,
    #[doc = "< MMC Rx DMA handle parameters"]
    pub hdmarx: *mut DMA_HandleTypeDef,
    #[doc = "< MMC Tx DMA handle parameters"]
    pub hdmatx: *mut DMA_HandleTypeDef,
    #[doc = "< MMC Card information"]
    pub MmcCard: HAL_MMC_CardInfoTypeDef,
    #[doc = "< MMC card specific data table"]
    pub CSD: [u32; 4usize],
    #[doc = "< MMC card identification number table"]
    pub CID: [u32; 4usize],
    pub Ext_CSD: [u32; 128usize],
}
#[test]
fn bindgen_test_layout_MMC_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<MMC_HandleTypeDef>(),
        640usize,
        concat!("Size of: ", stringify!(MMC_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<MMC_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(MMC_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).Lock as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).pTxBuffPtr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(pTxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).TxXferSize as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(TxXferSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).pRxBuffPtr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(pRxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).RxXferSize as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(RxXferSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).Context as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(Context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).State as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).ErrorCode as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).hdmarx as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(hdmarx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).hdmatx as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(hdmatx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).MmcCard as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(MmcCard)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).CSD as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(CSD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).CID as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(CID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMC_HandleTypeDef>())).Ext_CSD as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(MMC_HandleTypeDef),
            "::",
            stringify!(Ext_CSD)
        )
    );
}
impl Default for MMC_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @defgroup MMC_Exported_Types_Group4 Card Specific Data: CSD Register"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_MMC_CardCSDTypeDef {
    #[doc = "< CSD structure"]
    pub CSDStruct: u8,
    #[doc = "< System specification version"]
    pub SysSpecVersion: u8,
    #[doc = "< Reserved"]
    pub Reserved1: u8,
    #[doc = "< Data read access time 1"]
    pub TAAC: u8,
    #[doc = "< Data read access time 2 in CLK cycles"]
    pub NSAC: u8,
    #[doc = "< Max. bus clock frequency"]
    pub MaxBusClkFrec: u8,
    #[doc = "< Card command classes"]
    pub CardComdClasses: u16,
    #[doc = "< Max. read data block length"]
    pub RdBlockLen: u8,
    #[doc = "< Partial blocks for read allowed"]
    pub PartBlockRead: u8,
    #[doc = "< Write block misalignment"]
    pub WrBlockMisalign: u8,
    #[doc = "< Read block misalignment"]
    pub RdBlockMisalign: u8,
    #[doc = "< DSR implemented"]
    pub DSRImpl: u8,
    #[doc = "< Reserved"]
    pub Reserved2: u8,
    #[doc = "< Device Size"]
    pub DeviceSize: u32,
    #[doc = "< Max. read current @ VDD min"]
    pub MaxRdCurrentVDDMin: u8,
    #[doc = "< Max. read current @ VDD max"]
    pub MaxRdCurrentVDDMax: u8,
    #[doc = "< Max. write current @ VDD min"]
    pub MaxWrCurrentVDDMin: u8,
    #[doc = "< Max. write current @ VDD max"]
    pub MaxWrCurrentVDDMax: u8,
    #[doc = "< Device size multiplier"]
    pub DeviceSizeMul: u8,
    #[doc = "< Erase group size"]
    pub EraseGrSize: u8,
    #[doc = "< Erase group size multiplier"]
    pub EraseGrMul: u8,
    #[doc = "< Write protect group size"]
    pub WrProtectGrSize: u8,
    #[doc = "< Write protect group enable"]
    pub WrProtectGrEnable: u8,
    #[doc = "< Manufacturer default ECC"]
    pub ManDeflECC: u8,
    #[doc = "< Write speed factor"]
    pub WrSpeedFact: u8,
    #[doc = "< Max. write data block length"]
    pub MaxWrBlockLen: u8,
    #[doc = "< Partial blocks for write allowed"]
    pub WriteBlockPaPartial: u8,
    #[doc = "< Reserved"]
    pub Reserved3: u8,
    #[doc = "< Content protection application"]
    pub ContentProtectAppli: u8,
    #[doc = "< File format group"]
    pub FileFormatGroup: u8,
    #[doc = "< Copy flag (OTP)"]
    pub CopyFlag: u8,
    #[doc = "< Permanent write protection"]
    pub PermWrProtect: u8,
    #[doc = "< Temporary write protection"]
    pub TempWrProtect: u8,
    #[doc = "< File format"]
    pub FileFormat: u8,
    #[doc = "< ECC code"]
    pub ECC: u8,
    #[doc = "< CSD CRC"]
    pub CSD_CRC: u8,
    #[doc = "< Always 1"]
    pub Reserved4: u8,
}
#[test]
fn bindgen_test_layout_HAL_MMC_CardCSDTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<HAL_MMC_CardCSDTypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(HAL_MMC_CardCSDTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<HAL_MMC_CardCSDTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_MMC_CardCSDTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).CSDStruct as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(CSDStruct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).SysSpecVersion as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(SysSpecVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).Reserved1 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).TAAC as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(TAAC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).NSAC as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(NSAC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).MaxBusClkFrec as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(MaxBusClkFrec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).CardComdClasses as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(CardComdClasses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).RdBlockLen as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(RdBlockLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).PartBlockRead as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(PartBlockRead)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).WrBlockMisalign as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(WrBlockMisalign)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).RdBlockMisalign as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(RdBlockMisalign)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).DSRImpl as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(DSRImpl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).Reserved2 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).DeviceSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(DeviceSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).MaxRdCurrentVDDMin as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(MaxRdCurrentVDDMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).MaxRdCurrentVDDMax as *const _
                as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(MaxRdCurrentVDDMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).MaxWrCurrentVDDMin as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(MaxWrCurrentVDDMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).MaxWrCurrentVDDMax as *const _
                as usize
        },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(MaxWrCurrentVDDMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).DeviceSizeMul as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(DeviceSizeMul)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).EraseGrSize as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(EraseGrSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).EraseGrMul as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(EraseGrMul)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).WrProtectGrSize as *const _ as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(WrProtectGrSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).WrProtectGrEnable as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(WrProtectGrEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).ManDeflECC as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(ManDeflECC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).WrSpeedFact as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(WrSpeedFact)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).MaxWrBlockLen as *const _ as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(MaxWrBlockLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).WriteBlockPaPartial as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(WriteBlockPaPartial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).Reserved3 as *const _ as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).ContentProtectAppli as *const _
                as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(ContentProtectAppli)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).FileFormatGroup as *const _ as usize
        },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(FileFormatGroup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).CopyFlag as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(CopyFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).PermWrProtect as *const _ as usize
        },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(PermWrProtect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).TempWrProtect as *const _ as usize
        },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(TempWrProtect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).FileFormat as *const _ as usize
        },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(FileFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).ECC as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(ECC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).CSD_CRC as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(CSD_CRC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCSDTypeDef>())).Reserved4 as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCSDTypeDef),
            "::",
            stringify!(Reserved4)
        )
    );
}
#[doc = " @defgroup MMC_Exported_Types_Group5 Card Identification Data: CID Register"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_MMC_CardCIDTypeDef {
    #[doc = "< Manufacturer ID"]
    pub ManufacturerID: u8,
    #[doc = "< OEM/Application ID"]
    pub OEM_AppliID: u16,
    #[doc = "< Product Name part1"]
    pub ProdName1: u32,
    #[doc = "< Product Name part2"]
    pub ProdName2: u8,
    #[doc = "< Product Revision"]
    pub ProdRev: u8,
    #[doc = "< Product Serial Number"]
    pub ProdSN: u32,
    #[doc = "< Reserved1"]
    pub Reserved1: u8,
    #[doc = "< Manufacturing Date"]
    pub ManufactDate: u16,
    #[doc = "< CID CRC"]
    pub CID_CRC: u8,
    #[doc = "< Always 1"]
    pub Reserved2: u8,
}
#[test]
fn bindgen_test_layout_HAL_MMC_CardCIDTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<HAL_MMC_CardCIDTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(HAL_MMC_CardCIDTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<HAL_MMC_CardCIDTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_MMC_CardCIDTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCIDTypeDef>())).ManufacturerID as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCIDTypeDef),
            "::",
            stringify!(ManufacturerID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCIDTypeDef>())).OEM_AppliID as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCIDTypeDef),
            "::",
            stringify!(OEM_AppliID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCIDTypeDef>())).ProdName1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCIDTypeDef),
            "::",
            stringify!(ProdName1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCIDTypeDef>())).ProdName2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCIDTypeDef),
            "::",
            stringify!(ProdName2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_MMC_CardCIDTypeDef>())).ProdRev as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCIDTypeDef),
            "::",
            stringify!(ProdRev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_MMC_CardCIDTypeDef>())).ProdSN as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCIDTypeDef),
            "::",
            stringify!(ProdSN)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCIDTypeDef>())).Reserved1 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCIDTypeDef),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCIDTypeDef>())).ManufactDate as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCIDTypeDef),
            "::",
            stringify!(ManufactDate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_MMC_CardCIDTypeDef>())).CID_CRC as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCIDTypeDef),
            "::",
            stringify!(CID_CRC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_MMC_CardCIDTypeDef>())).Reserved2 as *const _ as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MMC_CardCIDTypeDef),
            "::",
            stringify!(Reserved2)
        )
    );
}
extern "C" {
    #[doc = " @addtogroup MMC_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_MMC_Init(hmmc: *mut MMC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MMC_InitCard(hmmc: *mut MMC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MMC_DeInit(hmmc: *mut MMC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MMC_MspInit(hmmc: *mut MMC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_MMC_MspDeInit(hmmc: *mut MMC_HandleTypeDef);
}
extern "C" {
    #[doc = " @defgroup MMC_Exported_Functions_Group2 Input and Output operation functions"]
    #[doc = " @{"]
    pub fn HAL_MMC_ReadBlocks(
        hmmc: *mut MMC_HandleTypeDef,
        pData: *mut u8,
        BlockAdd: u32,
        NumberOfBlocks: u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MMC_WriteBlocks(
        hmmc: *mut MMC_HandleTypeDef,
        pData: *mut u8,
        BlockAdd: u32,
        NumberOfBlocks: u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MMC_Erase(
        hmmc: *mut MMC_HandleTypeDef,
        BlockStartAdd: u32,
        BlockEndAdd: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MMC_ReadBlocks_IT(
        hmmc: *mut MMC_HandleTypeDef,
        pData: *mut u8,
        BlockAdd: u32,
        NumberOfBlocks: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MMC_WriteBlocks_IT(
        hmmc: *mut MMC_HandleTypeDef,
        pData: *mut u8,
        BlockAdd: u32,
        NumberOfBlocks: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MMC_ReadBlocks_DMA(
        hmmc: *mut MMC_HandleTypeDef,
        pData: *mut u8,
        BlockAdd: u32,
        NumberOfBlocks: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MMC_WriteBlocks_DMA(
        hmmc: *mut MMC_HandleTypeDef,
        pData: *mut u8,
        BlockAdd: u32,
        NumberOfBlocks: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MMC_IRQHandler(hmmc: *mut MMC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_MMC_TxCpltCallback(hmmc: *mut MMC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_MMC_RxCpltCallback(hmmc: *mut MMC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_MMC_ErrorCallback(hmmc: *mut MMC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_MMC_AbortCallback(hmmc: *mut MMC_HandleTypeDef);
}
extern "C" {
    #[doc = " @defgroup MMC_Exported_Functions_Group3 Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_MMC_ConfigWideBusOperation(
        hmmc: *mut MMC_HandleTypeDef,
        WideMode: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup MMC_Exported_Functions_Group4 MMC card related functions"]
    #[doc = " @{"]
    pub fn HAL_MMC_GetCardState(hmmc: *mut MMC_HandleTypeDef) -> HAL_MMC_CardStateTypeDef;
}
extern "C" {
    pub fn HAL_MMC_GetCardCID(
        hmmc: *mut MMC_HandleTypeDef,
        pCID: *mut HAL_MMC_CardCIDTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MMC_GetCardCSD(
        hmmc: *mut MMC_HandleTypeDef,
        pCSD: *mut HAL_MMC_CardCSDTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MMC_GetCardInfo(
        hmmc: *mut MMC_HandleTypeDef,
        pCardInfo: *mut HAL_MMC_CardInfoTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MMC_GetCardExtCSD(
        hmmc: *mut MMC_HandleTypeDef,
        pExtCSD: *mut u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup MMC_Exported_Functions_Group5 Peripheral State and Errors functions"]
    #[doc = " @{"]
    pub fn HAL_MMC_GetState(hmmc: *mut MMC_HandleTypeDef) -> HAL_MMC_StateTypeDef;
}
extern "C" {
    pub fn HAL_MMC_GetError(hmmc: *mut MMC_HandleTypeDef) -> u32;
}
extern "C" {
    #[doc = " @defgroup MMC_Exported_Functions_Group6 Peripheral Abort management"]
    #[doc = " @{"]
    pub fn HAL_MMC_Abort(hmmc: *mut MMC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MMC_Abort_IT(hmmc: *mut MMC_HandleTypeDef) -> HAL_StatusTypeDef;
}
#[doc = " @brief  FMC NORSRAM Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FMC_NORSRAM_InitTypeDef {
    #[doc = "< Specifies the NORSRAM memory device that will be used."]
    #[doc = "This parameter can be a value of @ref FMC_NORSRAM_Bank"]
    pub NSBank: u32,
    #[doc = "< Specifies whether the address and data values are"]
    #[doc = "multiplexed on the data bus or not."]
    #[doc = "This parameter can be a value of @ref FMC_Data_Address_Bus_Multiplexing"]
    pub DataAddressMux: u32,
    #[doc = "< Specifies the type of external memory attached to"]
    #[doc = "the corresponding memory device."]
    #[doc = "This parameter can be a value of @ref FMC_Memory_Type"]
    pub MemoryType: u32,
    #[doc = "< Specifies the external memory device width."]
    #[doc = "This parameter can be a value of @ref FMC_NORSRAM_Data_Width"]
    pub MemoryDataWidth: u32,
    #[doc = "< Enables or disables the burst access mode for Flash memory,"]
    #[doc = "valid only with synchronous burst Flash memories."]
    #[doc = "This parameter can be a value of @ref FMC_Burst_Access_Mode"]
    pub BurstAccessMode: u32,
    #[doc = "< Specifies the wait signal polarity, valid only when accessing"]
    #[doc = "the Flash memory in burst mode."]
    #[doc = "This parameter can be a value of @ref FMC_Wait_Signal_Polarity"]
    pub WaitSignalPolarity: u32,
    #[doc = "< Specifies if the wait signal is asserted by the memory one"]
    #[doc = "clock cycle before the wait state or during the wait state,"]
    #[doc = "valid only when accessing memories in burst mode."]
    #[doc = "This parameter can be a value of @ref FMC_Wait_Timing"]
    pub WaitSignalActive: u32,
    #[doc = "< Enables or disables the write operation in the selected device by the FMC."]
    #[doc = "This parameter can be a value of @ref FMC_Write_Operation"]
    pub WriteOperation: u32,
    #[doc = "< Enables or disables the wait state insertion via wait"]
    #[doc = "signal, valid for Flash memory access in burst mode."]
    #[doc = "This parameter can be a value of @ref FMC_Wait_Signal"]
    pub WaitSignal: u32,
    #[doc = "< Enables or disables the extended mode."]
    #[doc = "This parameter can be a value of @ref FMC_Extended_Mode"]
    pub ExtendedMode: u32,
    #[doc = "< Enables or disables wait signal during asynchronous transfers,"]
    #[doc = "valid only with asynchronous Flash memories."]
    #[doc = "This parameter can be a value of @ref FMC_AsynchronousWait"]
    pub AsynchronousWait: u32,
    #[doc = "< Enables or disables the write burst operation."]
    #[doc = "This parameter can be a value of @ref FMC_Write_Burst"]
    pub WriteBurst: u32,
    #[doc = "< Enables or disables the FMC clock output to external memory devices."]
    #[doc = "This parameter is only enabled through the FMC_BCR1 register,"]
    #[doc = "and don't care through FMC_BCR2..4 registers."]
    #[doc = "This parameter can be a value of @ref FMC_Continous_Clock"]
    pub ContinuousClock: u32,
    #[doc = "< Enables or disables the write FIFO used by the FMC controller."]
    #[doc = "This parameter is only enabled through the FMC_BCR1 register,"]
    #[doc = "and don't care through FMC_BCR2..4 registers."]
    #[doc = "This parameter can be a value of @ref FMC_Write_FIFO"]
    pub WriteFifo: u32,
    #[doc = "< Specifies the memory page size."]
    #[doc = "This parameter can be a value of @ref FMC_Page_Size"]
    pub PageSize: u32,
    #[doc = "< Specifies the NBL setup timing clock cycle number"]
    #[doc = "This parameter can be a value of @ref FMC_Byte_Lane"]
    pub NBLSetupTime: u32,
}
#[test]
fn bindgen_test_layout_FMC_NORSRAM_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<FMC_NORSRAM_InitTypeDef>(),
        64usize,
        concat!("Size of: ", stringify!(FMC_NORSRAM_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FMC_NORSRAM_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FMC_NORSRAM_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).NSBank as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(NSBank)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).DataAddressMux as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(DataAddressMux)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).MemoryType as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(MemoryType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).MemoryDataWidth as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(MemoryDataWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).BurstAccessMode as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(BurstAccessMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).WaitSignalPolarity as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(WaitSignalPolarity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).WaitSignalActive as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(WaitSignalActive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).WriteOperation as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(WriteOperation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).WaitSignal as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(WaitSignal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).ExtendedMode as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(ExtendedMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).AsynchronousWait as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(AsynchronousWait)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).WriteBurst as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(WriteBurst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).ContinuousClock as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(ContinuousClock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).WriteFifo as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(WriteFifo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).PageSize as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(PageSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_InitTypeDef>())).NBLSetupTime as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_InitTypeDef),
            "::",
            stringify!(NBLSetupTime)
        )
    );
}
#[doc = " @brief  FMC NORSRAM Timing parameters structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FMC_NORSRAM_TimingTypeDef {
    #[doc = "< Defines the number of HCLK cycles to configure"]
    #[doc = "the duration of the address setup time."]
    #[doc = "This parameter can be a value between Min_Data = 0 and Max_Data = 15."]
    #[doc = "@note This parameter is not used with synchronous NOR Flash memories."]
    pub AddressSetupTime: u32,
    #[doc = "< Defines the number of HCLK cycles to configure"]
    #[doc = "the duration of the address hold time."]
    #[doc = "This parameter can be a value between Min_Data = 1 and Max_Data = 15."]
    #[doc = "@note This parameter is not used with synchronous NOR Flash memories."]
    pub AddressHoldTime: u32,
    #[doc = "< Defines the number of HCLK cycles to configure"]
    #[doc = "the duration of the data setup time."]
    #[doc = "This parameter can be a value between Min_Data = 1 and Max_Data = 255."]
    #[doc = "@note This parameter is used for SRAMs, ROMs and asynchronous multiplexed"]
    #[doc = "NOR Flash memories."]
    pub DataSetupTime: u32,
    #[doc = "< Defines the number of HCLK cycles to configure"]
    #[doc = "the duration of the data hold time."]
    #[doc = "This parameter can be a value between Min_Data = 0 and Max_Data = 3."]
    #[doc = "@note This parameter is used for used in asynchronous accesses."]
    pub DataHoldTime: u32,
    #[doc = "< Defines the number of HCLK cycles to configure"]
    #[doc = "the duration of the bus turnaround."]
    #[doc = "This parameter can be a value between Min_Data = 0 and Max_Data = 15."]
    #[doc = "@note This parameter is only used for multiplexed NOR Flash memories."]
    pub BusTurnAroundDuration: u32,
    #[doc = "< Defines the period of CLK clock output signal, expressed in number of"]
    #[doc = "HCLK cycles. This parameter can be a value between Min_Data = 2 and"]
    #[doc = "Max_Data = 16."]
    #[doc = "@note This parameter is not used for asynchronous NOR Flash, SRAM or ROM"]
    #[doc = "accesses."]
    pub CLKDivision: u32,
    #[doc = "< Defines the number of memory clock cycles to issue"]
    #[doc = "to the memory before getting the first data."]
    #[doc = "The parameter value depends on the memory type as shown below:"]
    #[doc = "- It must be set to 0 in case of a CRAM"]
    #[doc = "- It is don't care in asynchronous NOR, SRAM or ROM accesses"]
    #[doc = "- It may assume a value between Min_Data = 2 and Max_Data = 17"]
    #[doc = "in NOR Flash memories with synchronous burst mode enable"]
    pub DataLatency: u32,
    #[doc = "< Specifies the asynchronous access mode."]
    #[doc = "This parameter can be a value of @ref FMC_Access_Mode"]
    pub AccessMode: u32,
}
#[test]
fn bindgen_test_layout_FMC_NORSRAM_TimingTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<FMC_NORSRAM_TimingTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(FMC_NORSRAM_TimingTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FMC_NORSRAM_TimingTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FMC_NORSRAM_TimingTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_TimingTypeDef>())).AddressSetupTime as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_TimingTypeDef),
            "::",
            stringify!(AddressSetupTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_TimingTypeDef>())).AddressHoldTime as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_TimingTypeDef),
            "::",
            stringify!(AddressHoldTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_TimingTypeDef>())).DataSetupTime as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_TimingTypeDef),
            "::",
            stringify!(DataSetupTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_TimingTypeDef>())).DataHoldTime as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_TimingTypeDef),
            "::",
            stringify!(DataHoldTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_TimingTypeDef>())).BusTurnAroundDuration as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_TimingTypeDef),
            "::",
            stringify!(BusTurnAroundDuration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_TimingTypeDef>())).CLKDivision as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_TimingTypeDef),
            "::",
            stringify!(CLKDivision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_TimingTypeDef>())).DataLatency as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_TimingTypeDef),
            "::",
            stringify!(DataLatency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NORSRAM_TimingTypeDef>())).AccessMode as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NORSRAM_TimingTypeDef),
            "::",
            stringify!(AccessMode)
        )
    );
}
#[doc = " @brief  FMC NAND Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FMC_NAND_InitTypeDef {
    #[doc = "< Specifies the NAND memory device that will be used."]
    #[doc = "This parameter can be a value of @ref FMC_NAND_Bank"]
    pub NandBank: u32,
    #[doc = "< Enables or disables the Wait feature for the NAND Memory device."]
    #[doc = "This parameter can be any value of @ref FMC_Wait_feature"]
    pub Waitfeature: u32,
    #[doc = "< Specifies the external memory device width."]
    #[doc = "This parameter can be any value of @ref FMC_NAND_Data_Width"]
    pub MemoryDataWidth: u32,
    #[doc = "< Enables or disables the ECC computation."]
    #[doc = "This parameter can be any value of @ref FMC_ECC"]
    pub EccComputation: u32,
    #[doc = "< Defines the page size for the extended ECC."]
    #[doc = "This parameter can be any value of @ref FMC_ECC_Page_Size"]
    pub ECCPageSize: u32,
    #[doc = "< Defines the number of HCLK cycles to configure the"]
    #[doc = "delay between CLE low and RE low."]
    #[doc = "This parameter can be a value between Min_Data = 0 and Max_Data = 255"]
    pub TCLRSetupTime: u32,
    #[doc = "< Defines the number of HCLK cycles to configure the"]
    #[doc = "delay between ALE low and RE low."]
    #[doc = "This parameter can be a number between Min_Data = 0 and Max_Data = 255"]
    pub TARSetupTime: u32,
}
#[test]
fn bindgen_test_layout_FMC_NAND_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<FMC_NAND_InitTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(FMC_NAND_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FMC_NAND_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FMC_NAND_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FMC_NAND_InitTypeDef>())).NandBank as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NAND_InitTypeDef),
            "::",
            stringify!(NandBank)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NAND_InitTypeDef>())).Waitfeature as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NAND_InitTypeDef),
            "::",
            stringify!(Waitfeature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NAND_InitTypeDef>())).MemoryDataWidth as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NAND_InitTypeDef),
            "::",
            stringify!(MemoryDataWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NAND_InitTypeDef>())).EccComputation as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NAND_InitTypeDef),
            "::",
            stringify!(EccComputation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NAND_InitTypeDef>())).ECCPageSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NAND_InitTypeDef),
            "::",
            stringify!(ECCPageSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NAND_InitTypeDef>())).TCLRSetupTime as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NAND_InitTypeDef),
            "::",
            stringify!(TCLRSetupTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NAND_InitTypeDef>())).TARSetupTime as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NAND_InitTypeDef),
            "::",
            stringify!(TARSetupTime)
        )
    );
}
#[doc = " @brief  FMC NAND Timing parameters structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FMC_NAND_PCC_TimingTypeDef {
    #[doc = "< Defines the number of HCLK cycles to setup address before"]
    #[doc = "the command assertion for NAND-Flash read or write access"]
    #[doc = "to common/Attribute or I/O memory space (depending on"]
    #[doc = "the memory space timing to be configured)."]
    #[doc = "This parameter can be a value between Min_Data = 0 and Max_Data = 254"]
    pub SetupTime: u32,
    #[doc = "< Defines the minimum number of HCLK cycles to assert the"]
    #[doc = "command for NAND-Flash read or write access to"]
    #[doc = "common/Attribute or I/O memory space (depending on the"]
    #[doc = "memory space timing to be configured)."]
    #[doc = "This parameter can be a number between Min_Data = 0 and Max_Data = 254"]
    pub WaitSetupTime: u32,
    #[doc = "< Defines the number of HCLK clock cycles to hold address"]
    #[doc = "(and data for write access) after the command de-assertion"]
    #[doc = "for NAND-Flash read or write access to common/Attribute"]
    #[doc = "or I/O memory space (depending on the memory space timing"]
    #[doc = "to be configured)."]
    #[doc = "This parameter can be a number between Min_Data = 0 and Max_Data = 254"]
    pub HoldSetupTime: u32,
    #[doc = "< Defines the number of HCLK clock cycles during which the"]
    #[doc = "data bus is kept in HiZ after the start of a NAND-Flash"]
    #[doc = "write access to common/Attribute or I/O memory space (depending"]
    #[doc = "on the memory space timing to be configured)."]
    #[doc = "This parameter can be a number between Min_Data = 0 and Max_Data = 254"]
    pub HiZSetupTime: u32,
}
#[test]
fn bindgen_test_layout_FMC_NAND_PCC_TimingTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<FMC_NAND_PCC_TimingTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(FMC_NAND_PCC_TimingTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FMC_NAND_PCC_TimingTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FMC_NAND_PCC_TimingTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NAND_PCC_TimingTypeDef>())).SetupTime as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NAND_PCC_TimingTypeDef),
            "::",
            stringify!(SetupTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NAND_PCC_TimingTypeDef>())).WaitSetupTime as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NAND_PCC_TimingTypeDef),
            "::",
            stringify!(WaitSetupTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NAND_PCC_TimingTypeDef>())).HoldSetupTime as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NAND_PCC_TimingTypeDef),
            "::",
            stringify!(HoldSetupTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FMC_NAND_PCC_TimingTypeDef>())).HiZSetupTime as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FMC_NAND_PCC_TimingTypeDef),
            "::",
            stringify!(HiZSetupTime)
        )
    );
}
extern "C" {
    #[doc = " @defgroup FMC_LL_NORSRAM  NOR SRAM"]
    #[doc = "  @{"]
    #[doc = "  @{"]
    pub fn FMC_NORSRAM_Init(
        Device: *mut FMC_Bank1_TypeDef,
        Init: *mut FMC_NORSRAM_InitTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn FMC_NORSRAM_Timing_Init(
        Device: *mut FMC_Bank1_TypeDef,
        Timing: *mut FMC_NORSRAM_TimingTypeDef,
        Bank: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn FMC_NORSRAM_Extended_Timing_Init(
        Device: *mut FMC_Bank1E_TypeDef,
        Timing: *mut FMC_NORSRAM_TimingTypeDef,
        Bank: u32,
        ExtendedMode: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn FMC_NORSRAM_DeInit(
        Device: *mut FMC_Bank1_TypeDef,
        ExDevice: *mut FMC_Bank1E_TypeDef,
        Bank: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup FMC_LL_NORSRAM_Private_Functions_Group2 NOR SRAM Control functions"]
    #[doc = "  @{"]
    pub fn FMC_NORSRAM_WriteOperation_Enable(
        Device: *mut FMC_Bank1_TypeDef,
        Bank: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn FMC_NORSRAM_WriteOperation_Disable(
        Device: *mut FMC_Bank1_TypeDef,
        Bank: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup FMC_LL_NAND NAND"]
    #[doc = "  @{"]
    #[doc = "  @{"]
    pub fn FMC_NAND_Init(
        Device: *mut FMC_Bank3_TypeDef,
        Init: *mut FMC_NAND_InitTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn FMC_NAND_CommonSpace_Timing_Init(
        Device: *mut FMC_Bank3_TypeDef,
        Timing: *mut FMC_NAND_PCC_TimingTypeDef,
        Bank: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn FMC_NAND_AttributeSpace_Timing_Init(
        Device: *mut FMC_Bank3_TypeDef,
        Timing: *mut FMC_NAND_PCC_TimingTypeDef,
        Bank: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn FMC_NAND_DeInit(Device: *mut FMC_Bank3_TypeDef, Bank: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup FMC_LL_NAND_Private_Functions_Group2 NAND Control functions"]
    #[doc = "  @{"]
    pub fn FMC_NAND_ECC_Enable(Device: *mut FMC_Bank3_TypeDef, Bank: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn FMC_NAND_ECC_Disable(Device: *mut FMC_Bank3_TypeDef, Bank: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn FMC_NAND_GetECC(
        Device: *mut FMC_Bank3_TypeDef,
        ECCval: *mut u32,
        Bank: u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
#[doc = "< NAND not yet initialized or disabled"]
pub const HAL_NAND_StateTypeDef_HAL_NAND_STATE_RESET: HAL_NAND_StateTypeDef = 0;
#[doc = "< NAND initialized and ready for use"]
pub const HAL_NAND_StateTypeDef_HAL_NAND_STATE_READY: HAL_NAND_StateTypeDef = 1;
#[doc = "< NAND internal process is ongoing"]
pub const HAL_NAND_StateTypeDef_HAL_NAND_STATE_BUSY: HAL_NAND_StateTypeDef = 2;
#[doc = "< NAND error state"]
pub const HAL_NAND_StateTypeDef_HAL_NAND_STATE_ERROR: HAL_NAND_StateTypeDef = 3;
#[doc = " @brief  HAL NAND State structures definition"]
pub type HAL_NAND_StateTypeDef = libc::c_uint;
#[doc = " @brief  NAND Memory electronic signature Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NAND_IDTypeDef {
    pub Maker_Id: u8,
    pub Device_Id: u8,
    pub Third_Id: u8,
    pub Fourth_Id: u8,
}
#[test]
fn bindgen_test_layout_NAND_IDTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<NAND_IDTypeDef>(),
        4usize,
        concat!("Size of: ", stringify!(NAND_IDTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<NAND_IDTypeDef>(),
        1usize,
        concat!("Alignment of ", stringify!(NAND_IDTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NAND_IDTypeDef>())).Maker_Id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_IDTypeDef),
            "::",
            stringify!(Maker_Id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NAND_IDTypeDef>())).Device_Id as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_IDTypeDef),
            "::",
            stringify!(Device_Id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NAND_IDTypeDef>())).Third_Id as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_IDTypeDef),
            "::",
            stringify!(Third_Id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NAND_IDTypeDef>())).Fourth_Id as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_IDTypeDef),
            "::",
            stringify!(Fourth_Id)
        )
    );
}
#[doc = " @brief  NAND Memory address Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NAND_AddressTypeDef {
    #[doc = "< NAND memory Page address"]
    pub Page: u16,
    #[doc = "< NAND memory Zone address"]
    pub Plane: u16,
    #[doc = "< NAND memory Block address"]
    pub Block: u16,
}
#[test]
fn bindgen_test_layout_NAND_AddressTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<NAND_AddressTypeDef>(),
        6usize,
        concat!("Size of: ", stringify!(NAND_AddressTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<NAND_AddressTypeDef>(),
        2usize,
        concat!("Alignment of ", stringify!(NAND_AddressTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NAND_AddressTypeDef>())).Page as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_AddressTypeDef),
            "::",
            stringify!(Page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NAND_AddressTypeDef>())).Plane as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_AddressTypeDef),
            "::",
            stringify!(Plane)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NAND_AddressTypeDef>())).Block as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_AddressTypeDef),
            "::",
            stringify!(Block)
        )
    );
}
#[doc = " @brief  NAND Memory info Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NAND_DeviceConfigTypeDef {
    #[doc = "< NAND memory page (without spare area) size measured in bytes"]
    #[doc = "for 8 bits addressing or words for 16 bits addressing"]
    pub PageSize: u32,
    #[doc = "< NAND memory spare area size measured in bytes"]
    #[doc = "for 8 bits addressing or words for 16 bits addressing"]
    pub SpareAreaSize: u32,
    #[doc = "< NAND memory block size measured in number of pages"]
    pub BlockSize: u32,
    #[doc = "< NAND memory number of total blocks"]
    pub BlockNbr: u32,
    #[doc = "< NAND memory number of planes"]
    pub PlaneNbr: u32,
    #[doc = "< NAND memory zone size measured in number of blocks"]
    pub PlaneSize: u32,
    #[doc = "< NAND extra command needed for Page reading mode. This"]
    #[doc = "parameter is mandatory for some NAND parts after the read"]
    #[doc = "command (NAND_CMD_AREA_TRUE1) and before DATA reading sequence."]
    #[doc = "Example: Toshiba THTH58BYG3S0HBAI6."]
    #[doc = "This parameter could be ENABLE or DISABLE"]
    #[doc = "Please check the Read Mode sequnece in the NAND device datasheet"]
    pub ExtraCommandEnable: FunctionalState,
}
#[test]
fn bindgen_test_layout_NAND_DeviceConfigTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<NAND_DeviceConfigTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(NAND_DeviceConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<NAND_DeviceConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(NAND_DeviceConfigTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NAND_DeviceConfigTypeDef>())).PageSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_DeviceConfigTypeDef),
            "::",
            stringify!(PageSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NAND_DeviceConfigTypeDef>())).SpareAreaSize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_DeviceConfigTypeDef),
            "::",
            stringify!(SpareAreaSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NAND_DeviceConfigTypeDef>())).BlockSize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_DeviceConfigTypeDef),
            "::",
            stringify!(BlockSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NAND_DeviceConfigTypeDef>())).BlockNbr as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_DeviceConfigTypeDef),
            "::",
            stringify!(BlockNbr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NAND_DeviceConfigTypeDef>())).PlaneNbr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_DeviceConfigTypeDef),
            "::",
            stringify!(PlaneNbr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NAND_DeviceConfigTypeDef>())).PlaneSize as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_DeviceConfigTypeDef),
            "::",
            stringify!(PlaneSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NAND_DeviceConfigTypeDef>())).ExtraCommandEnable as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_DeviceConfigTypeDef),
            "::",
            stringify!(ExtraCommandEnable)
        )
    );
}
impl Default for NAND_DeviceConfigTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NAND_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut FMC_Bank3_TypeDef,
    #[doc = "< NAND device control configuration parameters"]
    pub Init: FMC_NAND_InitTypeDef,
    #[doc = "< NAND locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< NAND device access state"]
    pub State: HAL_NAND_StateTypeDef,
    #[doc = "< NAND phusical characteristic information structure"]
    pub Config: NAND_DeviceConfigTypeDef,
}
#[test]
fn bindgen_test_layout_NAND_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<NAND_HandleTypeDef>(),
        68usize,
        concat!("Size of: ", stringify!(NAND_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<NAND_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(NAND_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NAND_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NAND_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NAND_HandleTypeDef>())).Lock as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NAND_HandleTypeDef>())).State as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NAND_HandleTypeDef>())).Config as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NAND_HandleTypeDef),
            "::",
            stringify!(Config)
        )
    );
}
impl Default for NAND_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @addtogroup NAND_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_NAND_Init(
        hnand: *mut NAND_HandleTypeDef,
        ComSpace_Timing: *mut FMC_NAND_PCC_TimingTypeDef,
        AttSpace_Timing: *mut FMC_NAND_PCC_TimingTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_DeInit(hnand: *mut NAND_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_ConfigDevice(
        hnand: *mut NAND_HandleTypeDef,
        pDeviceConfig: *mut NAND_DeviceConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_Read_ID(
        hnand: *mut NAND_HandleTypeDef,
        pNAND_ID: *mut NAND_IDTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_MspInit(hnand: *mut NAND_HandleTypeDef);
}
extern "C" {
    pub fn HAL_NAND_MspDeInit(hnand: *mut NAND_HandleTypeDef);
}
extern "C" {
    pub fn HAL_NAND_IRQHandler(hnand: *mut NAND_HandleTypeDef);
}
extern "C" {
    pub fn HAL_NAND_ITCallback(hnand: *mut NAND_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup NAND_Exported_Functions_Group2 Input and Output functions"]
    #[doc = " @{"]
    pub fn HAL_NAND_Reset(hnand: *mut NAND_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_Read_Page_8b(
        hnand: *mut NAND_HandleTypeDef,
        pAddress: *mut NAND_AddressTypeDef,
        pBuffer: *mut u8,
        NumPageToRead: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_Write_Page_8b(
        hnand: *mut NAND_HandleTypeDef,
        pAddress: *mut NAND_AddressTypeDef,
        pBuffer: *mut u8,
        NumPageToWrite: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_Read_SpareArea_8b(
        hnand: *mut NAND_HandleTypeDef,
        pAddress: *mut NAND_AddressTypeDef,
        pBuffer: *mut u8,
        NumSpareAreaToRead: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_Write_SpareArea_8b(
        hnand: *mut NAND_HandleTypeDef,
        pAddress: *mut NAND_AddressTypeDef,
        pBuffer: *mut u8,
        NumSpareAreaTowrite: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_Read_Page_16b(
        hnand: *mut NAND_HandleTypeDef,
        pAddress: *mut NAND_AddressTypeDef,
        pBuffer: *mut u16,
        NumPageToRead: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_Write_Page_16b(
        hnand: *mut NAND_HandleTypeDef,
        pAddress: *mut NAND_AddressTypeDef,
        pBuffer: *mut u16,
        NumPageToWrite: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_Read_SpareArea_16b(
        hnand: *mut NAND_HandleTypeDef,
        pAddress: *mut NAND_AddressTypeDef,
        pBuffer: *mut u16,
        NumSpareAreaToRead: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_Write_SpareArea_16b(
        hnand: *mut NAND_HandleTypeDef,
        pAddress: *mut NAND_AddressTypeDef,
        pBuffer: *mut u16,
        NumSpareAreaTowrite: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_Erase_Block(
        hnand: *mut NAND_HandleTypeDef,
        pAddress: *mut NAND_AddressTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_Address_Inc(
        hnand: *mut NAND_HandleTypeDef,
        pAddress: *mut NAND_AddressTypeDef,
    ) -> u32;
}
extern "C" {
    #[doc = " @addtogroup NAND_Exported_Functions_Group3 Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_NAND_ECC_Enable(hnand: *mut NAND_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_ECC_Disable(hnand: *mut NAND_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NAND_GetECC(
        hnand: *mut NAND_HandleTypeDef,
        ECCval: *mut u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup NAND_Exported_Functions_Group4 Peripheral State functions"]
    #[doc = " @{"]
    pub fn HAL_NAND_GetState(hnand: *mut NAND_HandleTypeDef) -> HAL_NAND_StateTypeDef;
}
extern "C" {
    pub fn HAL_NAND_Read_Status(hnand: *mut NAND_HandleTypeDef) -> u32;
}
#[doc = "< NOR not yet initialized or disabled"]
pub const HAL_NOR_StateTypeDef_HAL_NOR_STATE_RESET: HAL_NOR_StateTypeDef = 0;
#[doc = "< NOR initialized and ready for use"]
pub const HAL_NOR_StateTypeDef_HAL_NOR_STATE_READY: HAL_NOR_StateTypeDef = 1;
#[doc = "< NOR internal processing is ongoing"]
pub const HAL_NOR_StateTypeDef_HAL_NOR_STATE_BUSY: HAL_NOR_StateTypeDef = 2;
#[doc = "< NOR error state"]
pub const HAL_NOR_StateTypeDef_HAL_NOR_STATE_ERROR: HAL_NOR_StateTypeDef = 3;
#[doc = "< NOR NORSRAM device write protected"]
pub const HAL_NOR_StateTypeDef_HAL_NOR_STATE_PROTECTED: HAL_NOR_StateTypeDef = 4;
#[doc = " @brief  HAL SRAM State structures definition"]
pub type HAL_NOR_StateTypeDef = libc::c_uint;
pub const HAL_NOR_StatusTypeDef_HAL_NOR_STATUS_SUCCESS: HAL_NOR_StatusTypeDef = 0;
pub const HAL_NOR_StatusTypeDef_HAL_NOR_STATUS_ONGOING: HAL_NOR_StatusTypeDef = 1;
pub const HAL_NOR_StatusTypeDef_HAL_NOR_STATUS_ERROR: HAL_NOR_StatusTypeDef = 2;
pub const HAL_NOR_StatusTypeDef_HAL_NOR_STATUS_TIMEOUT: HAL_NOR_StatusTypeDef = 3;
#[doc = " @brief  FMC NOR Status typedef"]
pub type HAL_NOR_StatusTypeDef = libc::c_uint;
#[doc = " @brief  FMC NOR ID typedef"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NOR_IDTypeDef {
    #[doc = "< Defines the device's manufacturer code used to identify the memory"]
    pub Manufacturer_Code: u16,
    pub Device_Code1: u16,
    pub Device_Code2: u16,
    #[doc = "< Defines the device's codes used to identify the memory."]
    #[doc = "These codes can be accessed by performing read operations with specific"]
    #[doc = "control signals and addresses set.They can also be accessed by issuing"]
    #[doc = "an Auto Select command"]
    pub Device_Code3: u16,
}
#[test]
fn bindgen_test_layout_NOR_IDTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<NOR_IDTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(NOR_IDTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<NOR_IDTypeDef>(),
        2usize,
        concat!("Alignment of ", stringify!(NOR_IDTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NOR_IDTypeDef>())).Manufacturer_Code as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NOR_IDTypeDef),
            "::",
            stringify!(Manufacturer_Code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NOR_IDTypeDef>())).Device_Code1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NOR_IDTypeDef),
            "::",
            stringify!(Device_Code1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NOR_IDTypeDef>())).Device_Code2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NOR_IDTypeDef),
            "::",
            stringify!(Device_Code2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NOR_IDTypeDef>())).Device_Code3 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(NOR_IDTypeDef),
            "::",
            stringify!(Device_Code3)
        )
    );
}
#[doc = " @brief  FMC NOR CFI typedef"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NOR_CFITypeDef {
    pub CFI_1: u16,
    pub CFI_2: u16,
    pub CFI_3: u16,
    pub CFI_4: u16,
}
#[test]
fn bindgen_test_layout_NOR_CFITypeDef() {
    assert_eq!(
        ::core::mem::size_of::<NOR_CFITypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(NOR_CFITypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<NOR_CFITypeDef>(),
        2usize,
        concat!("Alignment of ", stringify!(NOR_CFITypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NOR_CFITypeDef>())).CFI_1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NOR_CFITypeDef),
            "::",
            stringify!(CFI_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NOR_CFITypeDef>())).CFI_2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NOR_CFITypeDef),
            "::",
            stringify!(CFI_2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NOR_CFITypeDef>())).CFI_3 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NOR_CFITypeDef),
            "::",
            stringify!(CFI_3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NOR_CFITypeDef>())).CFI_4 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(NOR_CFITypeDef),
            "::",
            stringify!(CFI_4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NOR_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut FMC_Bank1_TypeDef,
    #[doc = "< Extended mode register base address"]
    pub Extended: *mut FMC_Bank1E_TypeDef,
    #[doc = "< NOR device control configuration parameters"]
    pub Init: FMC_NORSRAM_InitTypeDef,
    #[doc = "< NOR locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< NOR device access state"]
    pub State: HAL_NOR_StateTypeDef,
    #[doc = "< NOR algorithm command set and control"]
    pub CommandSet: u32,
}
#[test]
fn bindgen_test_layout_NOR_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<NOR_HandleTypeDef>(),
        84usize,
        concat!("Size of: ", stringify!(NOR_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<NOR_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(NOR_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NOR_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NOR_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NOR_HandleTypeDef>())).Extended as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NOR_HandleTypeDef),
            "::",
            stringify!(Extended)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NOR_HandleTypeDef>())).Init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NOR_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NOR_HandleTypeDef>())).Lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NOR_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NOR_HandleTypeDef>())).State as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(NOR_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NOR_HandleTypeDef>())).CommandSet as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NOR_HandleTypeDef),
            "::",
            stringify!(CommandSet)
        )
    );
}
impl Default for NOR_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @addtogroup NOR_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_NOR_Init(
        hnor: *mut NOR_HandleTypeDef,
        Timing: *mut FMC_NORSRAM_TimingTypeDef,
        ExtTiming: *mut FMC_NORSRAM_TimingTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NOR_DeInit(hnor: *mut NOR_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NOR_MspInit(hnor: *mut NOR_HandleTypeDef);
}
extern "C" {
    pub fn HAL_NOR_MspDeInit(hnor: *mut NOR_HandleTypeDef);
}
extern "C" {
    pub fn HAL_NOR_MspWait(hnor: *mut NOR_HandleTypeDef, Timeout: u32);
}
extern "C" {
    #[doc = " @addtogroup NOR_Exported_Functions_Group2 Input and Output functions"]
    #[doc = " @{"]
    pub fn HAL_NOR_Read_ID(
        hnor: *mut NOR_HandleTypeDef,
        pNOR_ID: *mut NOR_IDTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NOR_ReturnToReadMode(hnor: *mut NOR_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NOR_Read(
        hnor: *mut NOR_HandleTypeDef,
        pAddress: *mut u32,
        pData: *mut u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NOR_Program(
        hnor: *mut NOR_HandleTypeDef,
        pAddress: *mut u32,
        pData: *mut u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NOR_ReadBuffer(
        hnor: *mut NOR_HandleTypeDef,
        uwAddress: u32,
        pData: *mut u16,
        uwBufferSize: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NOR_ProgramBuffer(
        hnor: *mut NOR_HandleTypeDef,
        uwAddress: u32,
        pData: *mut u16,
        uwBufferSize: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NOR_Erase_Block(
        hnor: *mut NOR_HandleTypeDef,
        BlockAddress: u32,
        Address: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NOR_Erase_Chip(hnor: *mut NOR_HandleTypeDef, Address: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NOR_Read_CFI(
        hnor: *mut NOR_HandleTypeDef,
        pNOR_CFI: *mut NOR_CFITypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup NOR_Exported_Functions_Group3 NOR Control functions"]
    #[doc = " @{"]
    pub fn HAL_NOR_WriteOperation_Enable(hnor: *mut NOR_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_NOR_WriteOperation_Disable(hnor: *mut NOR_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup NOR_Exported_Functions_Group4 NOR State functions"]
    #[doc = " @{"]
    pub fn HAL_NOR_GetState(hnor: *mut NOR_HandleTypeDef) -> HAL_NOR_StateTypeDef;
}
extern "C" {
    pub fn HAL_NOR_GetStatus(
        hnor: *mut NOR_HandleTypeDef,
        Address: u32,
        Timeout: u32,
    ) -> HAL_NOR_StatusTypeDef;
}
#[doc = " @brief  OPAMP Init structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OPAMP_InitTypeDef {
    #[doc = "< Specifies the power supply range: above or under 2.4V."]
    #[doc = "This parameter must be a value of @ref OPAMP_PowerSupplyRange"]
    #[doc = "Caution: This parameter is common to all OPAMP instances: a modification of this parameter for the selected OPAMP impacts the other OPAMP instances."]
    pub PowerSupplyRange: u32,
    #[doc = "< Specifies the power mode Normal or Low-Power."]
    #[doc = "This parameter must be a value of @ref OPAMP_PowerMode"]
    pub PowerMode: u32,
    #[doc = "< Specifies the OPAMP mode"]
    #[doc = "This parameter must be a value of @ref OPAMP_Mode"]
    #[doc = "mode is either Standalone, - Follower or PGA"]
    pub Mode: u32,
    #[doc = "< Specifies the inverting input in Standalone & PGA modes"]
    #[doc = "- In Standalone mode:   i.e. when mode is OPAMP_STANDALONE_MODE"]
    #[doc = "& PGA mode:           i.e. when mode is OPAMP_PGA_MODE"]
    #[doc = "This parameter must be a value of @ref OPAMP_InvertingInput"]
    #[doc = "- In Follower mode    i.e. when mode is OPAMP_FOLLOWER_MODE"]
    #[doc = "This parameter is Not Applicable"]
    pub InvertingInput: u32,
    #[doc = "< Specifies the non inverting input of the opamp:"]
    #[doc = "This parameter must be a value of @ref OPAMP_NonInvertingInput"]
    pub NonInvertingInput: u32,
    #[doc = "< Specifies the gain in PGA mode"]
    #[doc = "i.e. when mode is OPAMP_PGA_MODE."]
    #[doc = "This parameter must be a value of @ref OPAMP_PgaGain (2, 4, 8 or 16 )"]
    pub PgaGain: u32,
    #[doc = "< Specifies the trimming mode"]
    #[doc = "This parameter must be a value of @ref OPAMP_UserTrimming"]
    #[doc = "UserTrimming is either factory or user trimming."]
    pub UserTrimming: u32,
    #[doc = "< Specifies the offset trimming value (PMOS)"]
    #[doc = "i.e. when UserTrimming is OPAMP_TRIMMING_USER."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 31"]
    #[doc = "16 is typical default value"]
    pub TrimmingValueP: u32,
    #[doc = "< Specifies the offset trimming value (NMOS)"]
    #[doc = "i.e. when UserTrimming is OPAMP_TRIMMING_USER."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 31"]
    #[doc = "16 is typical default value"]
    pub TrimmingValueN: u32,
    #[doc = "< Specifies the offset trimming value (PMOS)"]
    #[doc = "i.e. when UserTrimming is OPAMP_TRIMMING_USER."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 31"]
    #[doc = "16 is typical default value"]
    pub TrimmingValuePLowPower: u32,
    #[doc = "< Specifies the offset trimming value (NMOS)"]
    #[doc = "i.e. when UserTrimming is OPAMP_TRIMMING_USER."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 31"]
    #[doc = "16 is typical default value"]
    pub TrimmingValueNLowPower: u32,
}
#[test]
fn bindgen_test_layout_OPAMP_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<OPAMP_InitTypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(OPAMP_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<OPAMP_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(OPAMP_InitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OPAMP_InitTypeDef>())).PowerSupplyRange as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_InitTypeDef),
            "::",
            stringify!(PowerSupplyRange)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OPAMP_InitTypeDef>())).PowerMode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_InitTypeDef),
            "::",
            stringify!(PowerMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OPAMP_InitTypeDef>())).Mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OPAMP_InitTypeDef>())).InvertingInput as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_InitTypeDef),
            "::",
            stringify!(InvertingInput)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OPAMP_InitTypeDef>())).NonInvertingInput as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_InitTypeDef),
            "::",
            stringify!(NonInvertingInput)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OPAMP_InitTypeDef>())).PgaGain as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_InitTypeDef),
            "::",
            stringify!(PgaGain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OPAMP_InitTypeDef>())).UserTrimming as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_InitTypeDef),
            "::",
            stringify!(UserTrimming)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OPAMP_InitTypeDef>())).TrimmingValueP as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_InitTypeDef),
            "::",
            stringify!(TrimmingValueP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OPAMP_InitTypeDef>())).TrimmingValueN as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_InitTypeDef),
            "::",
            stringify!(TrimmingValueN)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OPAMP_InitTypeDef>())).TrimmingValuePLowPower as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_InitTypeDef),
            "::",
            stringify!(TrimmingValuePLowPower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OPAMP_InitTypeDef>())).TrimmingValueNLowPower as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_InitTypeDef),
            "::",
            stringify!(TrimmingValueNLowPower)
        )
    );
}
#[doc = "< OPAMP is not yet Initialized"]
pub const HAL_OPAMP_StateTypeDef_HAL_OPAMP_STATE_RESET: HAL_OPAMP_StateTypeDef = 0;
#[doc = "< OPAMP is initialized and ready for use"]
pub const HAL_OPAMP_StateTypeDef_HAL_OPAMP_STATE_READY: HAL_OPAMP_StateTypeDef = 1;
#[doc = "< OPAMP is enabled in auto calibration mode"]
pub const HAL_OPAMP_StateTypeDef_HAL_OPAMP_STATE_CALIBBUSY: HAL_OPAMP_StateTypeDef = 2;
#[doc = "< OPAMP is enabled and running in normal mode"]
pub const HAL_OPAMP_StateTypeDef_HAL_OPAMP_STATE_BUSY: HAL_OPAMP_StateTypeDef = 4;
#[doc = "< OPAMP is locked"]
#[doc = "only system reset allows reconfiguring the opamp."]
pub const HAL_OPAMP_StateTypeDef_HAL_OPAMP_STATE_BUSYLOCKED: HAL_OPAMP_StateTypeDef = 5;
#[doc = " @brief  HAL State structures definition"]
pub type HAL_OPAMP_StateTypeDef = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OPAMP_HandleTypeDef {
    #[doc = "< OPAMP instance's registers base address"]
    pub Instance: *mut OPAMP_TypeDef,
    #[doc = "< OPAMP required parameters"]
    pub Init: OPAMP_InitTypeDef,
    #[doc = "< OPAMP peripheral status"]
    pub Status: HAL_StatusTypeDef,
    #[doc = "< Locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< OPAMP communication state"]
    pub State: HAL_OPAMP_StateTypeDef,
}
#[test]
fn bindgen_test_layout_OPAMP_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<OPAMP_HandleTypeDef>(),
        60usize,
        concat!("Size of: ", stringify!(OPAMP_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<OPAMP_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(OPAMP_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OPAMP_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OPAMP_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OPAMP_HandleTypeDef>())).Status as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_HandleTypeDef),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OPAMP_HandleTypeDef>())).Lock as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OPAMP_HandleTypeDef>())).State as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OPAMP_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
}
impl Default for OPAMP_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief HAl_OPAMP_TrimmingValueTypeDef definition"]
pub type HAL_OPAMP_TrimmingValueTypeDef = u32;
extern "C" {
    #[doc = " @addtogroup OPAMPEx_Exported_Functions_Group1 Extended Input and Output operation functions"]
    #[doc = " @{"]
    pub fn HAL_OPAMPEx_SelfCalibrateAll(
        hopamp1: *mut OPAMP_HandleTypeDef,
        hopamp2: *mut OPAMP_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup OPAMPEx_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_OPAMPEx_Unlock(hopamp: *mut OPAMP_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup OPAMP_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_OPAMP_Init(hopamp: *mut OPAMP_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_OPAMP_DeInit(hopamp: *mut OPAMP_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_OPAMP_MspInit(hopamp: *mut OPAMP_HandleTypeDef);
}
extern "C" {
    pub fn HAL_OPAMP_MspDeInit(hopamp: *mut OPAMP_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup OPAMP_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_OPAMP_Start(hopamp: *mut OPAMP_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_OPAMP_Stop(hopamp: *mut OPAMP_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_OPAMP_SelfCalibrate(hopamp: *mut OPAMP_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_OPAMP_Lock(hopamp: *mut OPAMP_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_OPAMP_GetTrimOffset(
        hopamp: *mut OPAMP_HandleTypeDef,
        trimmingoffset: u32,
    ) -> HAL_OPAMP_TrimmingValueTypeDef;
}
extern "C" {
    #[doc = " @addtogroup OPAMP_Exported_Functions_Group4"]
    #[doc = " @{"]
    pub fn HAL_OPAMP_GetState(hopamp: *mut OPAMP_HandleTypeDef) -> HAL_OPAMP_StateTypeDef;
}
pub const PCD_StateTypeDef_HAL_PCD_STATE_RESET: PCD_StateTypeDef = 0;
pub const PCD_StateTypeDef_HAL_PCD_STATE_READY: PCD_StateTypeDef = 1;
pub const PCD_StateTypeDef_HAL_PCD_STATE_ERROR: PCD_StateTypeDef = 2;
pub const PCD_StateTypeDef_HAL_PCD_STATE_BUSY: PCD_StateTypeDef = 3;
pub const PCD_StateTypeDef_HAL_PCD_STATE_TIMEOUT: PCD_StateTypeDef = 4;
#[doc = " @brief  PCD State structure definition"]
pub type PCD_StateTypeDef = libc::c_uint;
pub const PCD_LPM_StateTypeDef_LPM_L0: PCD_LPM_StateTypeDef = 0;
pub const PCD_LPM_StateTypeDef_LPM_L1: PCD_LPM_StateTypeDef = 1;
pub const PCD_LPM_StateTypeDef_LPM_L2: PCD_LPM_StateTypeDef = 2;
pub const PCD_LPM_StateTypeDef_LPM_L3: PCD_LPM_StateTypeDef = 3;
pub type PCD_LPM_StateTypeDef = libc::c_uint;
pub const PCD_LPM_MsgTypeDef_PCD_LPM_L0_ACTIVE: PCD_LPM_MsgTypeDef = 0;
pub const PCD_LPM_MsgTypeDef_PCD_LPM_L1_ACTIVE: PCD_LPM_MsgTypeDef = 1;
pub type PCD_LPM_MsgTypeDef = libc::c_uint;
pub const PCD_BCD_MsgTypeDef_PCD_BCD_ERROR: PCD_BCD_MsgTypeDef = 255;
pub const PCD_BCD_MsgTypeDef_PCD_BCD_CONTACT_DETECTION: PCD_BCD_MsgTypeDef = 254;
pub const PCD_BCD_MsgTypeDef_PCD_BCD_STD_DOWNSTREAM_PORT: PCD_BCD_MsgTypeDef = 253;
pub const PCD_BCD_MsgTypeDef_PCD_BCD_CHARGING_DOWNSTREAM_PORT: PCD_BCD_MsgTypeDef = 252;
pub const PCD_BCD_MsgTypeDef_PCD_BCD_DEDICATED_CHARGING_PORT: PCD_BCD_MsgTypeDef = 251;
pub const PCD_BCD_MsgTypeDef_PCD_BCD_DISCOVERY_COMPLETED: PCD_BCD_MsgTypeDef = 0;
pub type PCD_BCD_MsgTypeDef = libc::c_uint;
pub type PCD_TypeDef = USB_OTG_GlobalTypeDef;
pub type PCD_InitTypeDef = USB_OTG_CfgTypeDef;
pub type PCD_EPTypeDef = USB_OTG_EPTypeDef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCD_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut PCD_TypeDef,
    #[doc = "< PCD required parameters"]
    pub Init: PCD_InitTypeDef,
    #[doc = "< USB Address"]
    pub USB_Address: u8,
    #[doc = "< IN endpoint parameters"]
    pub IN_ep: [PCD_EPTypeDef; 16usize],
    #[doc = "< OUT endpoint parameters"]
    pub OUT_ep: [PCD_EPTypeDef; 16usize],
    #[doc = "< PCD peripheral status"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< PCD communication state"]
    pub State: PCD_StateTypeDef,
    #[doc = "< PCD Error code"]
    pub ErrorCode: u32,
    #[doc = "< Setup packet buffer"]
    pub Setup: [u32; 12usize],
    #[doc = "< LPM State"]
    pub LPM_State: PCD_LPM_StateTypeDef,
    pub BESL: u32,
    #[doc = "< Enable or disable the Link Power Management ."]
    #[doc = "This parameter can be set to ENABLE or DISABLE"]
    pub lpm_active: u32,
    #[doc = "< Enable or disable Battery charging."]
    #[doc = "This parameter can be set to ENABLE or DISABLE"]
    pub battery_charging_active: u32,
    #[doc = "< Pointer to upper stack Handler"]
    pub pData: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_PCD_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<PCD_HandleTypeDef>(),
        1036usize,
        concat!("Size of: ", stringify!(PCD_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<PCD_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(PCD_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCD_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PCD_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCD_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PCD_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCD_HandleTypeDef>())).USB_Address as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PCD_HandleTypeDef),
            "::",
            stringify!(USB_Address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCD_HandleTypeDef>())).IN_ep as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(PCD_HandleTypeDef),
            "::",
            stringify!(IN_ep)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCD_HandleTypeDef>())).OUT_ep as *const _ as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(PCD_HandleTypeDef),
            "::",
            stringify!(OUT_ep)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCD_HandleTypeDef>())).Lock as *const _ as usize },
        956usize,
        concat!(
            "Offset of field: ",
            stringify!(PCD_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCD_HandleTypeDef>())).State as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(PCD_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCD_HandleTypeDef>())).ErrorCode as *const _ as usize },
        964usize,
        concat!(
            "Offset of field: ",
            stringify!(PCD_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCD_HandleTypeDef>())).Setup as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(PCD_HandleTypeDef),
            "::",
            stringify!(Setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCD_HandleTypeDef>())).LPM_State as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(PCD_HandleTypeDef),
            "::",
            stringify!(LPM_State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCD_HandleTypeDef>())).BESL as *const _ as usize },
        1020usize,
        concat!(
            "Offset of field: ",
            stringify!(PCD_HandleTypeDef),
            "::",
            stringify!(BESL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCD_HandleTypeDef>())).lpm_active as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(PCD_HandleTypeDef),
            "::",
            stringify!(lpm_active)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PCD_HandleTypeDef>())).battery_charging_active as *const _
                as usize
        },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(PCD_HandleTypeDef),
            "::",
            stringify!(battery_charging_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCD_HandleTypeDef>())).pData as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(PCD_HandleTypeDef),
            "::",
            stringify!(pData)
        )
    );
}
impl Default for PCD_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn HAL_PCDEx_SetTxFiFo(
        hpcd: *mut PCD_HandleTypeDef,
        fifo: u8,
        size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCDEx_SetRxFiFo(hpcd: *mut PCD_HandleTypeDef, size: u16) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCDEx_ActivateLPM(hpcd: *mut PCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCDEx_DeActivateLPM(hpcd: *mut PCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCDEx_ActivateBCD(hpcd: *mut PCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCDEx_DeActivateBCD(hpcd: *mut PCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCDEx_BCD_VBUSDetect(hpcd: *mut PCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_PCDEx_LPM_Callback(hpcd: *mut PCD_HandleTypeDef, msg: PCD_LPM_MsgTypeDef);
}
extern "C" {
    pub fn HAL_PCDEx_BCD_Callback(hpcd: *mut PCD_HandleTypeDef, msg: PCD_BCD_MsgTypeDef);
}
extern "C" {
    #[doc = " @addtogroup PCD_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_PCD_Init(hpcd: *mut PCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_DeInit(hpcd: *mut PCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_MspInit(hpcd: *mut PCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_PCD_MspDeInit(hpcd: *mut PCD_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup PCD_Exported_Functions_Group2 Input and Output operation functions"]
    #[doc = " @{"]
    pub fn HAL_PCD_Start(hpcd: *mut PCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_Stop(hpcd: *mut PCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_IRQHandler(hpcd: *mut PCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_PCD_SOFCallback(hpcd: *mut PCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_PCD_SetupStageCallback(hpcd: *mut PCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_PCD_ResetCallback(hpcd: *mut PCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_PCD_SuspendCallback(hpcd: *mut PCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_PCD_ResumeCallback(hpcd: *mut PCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_PCD_ConnectCallback(hpcd: *mut PCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_PCD_DisconnectCallback(hpcd: *mut PCD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_PCD_DataOutStageCallback(hpcd: *mut PCD_HandleTypeDef, epnum: u8);
}
extern "C" {
    pub fn HAL_PCD_DataInStageCallback(hpcd: *mut PCD_HandleTypeDef, epnum: u8);
}
extern "C" {
    pub fn HAL_PCD_ISOOUTIncompleteCallback(hpcd: *mut PCD_HandleTypeDef, epnum: u8);
}
extern "C" {
    pub fn HAL_PCD_ISOINIncompleteCallback(hpcd: *mut PCD_HandleTypeDef, epnum: u8);
}
extern "C" {
    #[doc = " @addtogroup PCD_Exported_Functions_Group3 Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_PCD_DevConnect(hpcd: *mut PCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_DevDisconnect(hpcd: *mut PCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_SetAddress(hpcd: *mut PCD_HandleTypeDef, address: u8) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_EP_Open(
        hpcd: *mut PCD_HandleTypeDef,
        ep_addr: u8,
        ep_mps: u16,
        ep_type: u8,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_EP_Close(hpcd: *mut PCD_HandleTypeDef, ep_addr: u8) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_EP_Receive(
        hpcd: *mut PCD_HandleTypeDef,
        ep_addr: u8,
        pBuf: *mut u8,
        len: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_EP_Transmit(
        hpcd: *mut PCD_HandleTypeDef,
        ep_addr: u8,
        pBuf: *mut u8,
        len: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_EP_SetStall(hpcd: *mut PCD_HandleTypeDef, ep_addr: u8) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_EP_ClrStall(hpcd: *mut PCD_HandleTypeDef, ep_addr: u8) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_EP_Flush(hpcd: *mut PCD_HandleTypeDef, ep_addr: u8) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_ActivateRemoteWakeup(hpcd: *mut PCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_DeActivateRemoteWakeup(hpcd: *mut PCD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PCD_EP_GetRxCount(hpcd: *mut PCD_HandleTypeDef, ep_addr: u8) -> u32;
}
extern "C" {
    #[doc = " @addtogroup PCD_Exported_Functions_Group4 Peripheral State functions"]
    #[doc = " @{"]
    pub fn HAL_PCD_GetState(hpcd: *mut PCD_HandleTypeDef) -> PCD_StateTypeDef;
}
#[doc = " @brief  PWR PVD configuration structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PWR_PVDTypeDef {
    #[doc = "< PVDLevel: Specifies the PVD detection level."]
    #[doc = "This parameter can be a value of @ref PWR_PVD_detection_level."]
    pub PVDLevel: u32,
    #[doc = "< Mode: Specifies the operating mode for the selected pins."]
    #[doc = "This parameter can be a value of @ref PWR_PVD_Mode."]
    pub Mode: u32,
}
#[test]
fn bindgen_test_layout_PWR_PVDTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<PWR_PVDTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(PWR_PVDTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<PWR_PVDTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(PWR_PVDTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_PVDTypeDef>())).PVDLevel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_PVDTypeDef),
            "::",
            stringify!(PVDLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_PVDTypeDef>())).Mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_PVDTypeDef),
            "::",
            stringify!(Mode)
        )
    );
}
#[doc = " @brief  PWR PVM configuration structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PWR_PVMTypeDef {
    #[doc = "< PVMType: Specifies which voltage is monitored and against which threshold."]
    #[doc = "This parameter can be a value of @ref PWREx_PVM_Type."]
    #[doc = "@arg @ref PWR_PVM_1 Peripheral Voltage Monitoring 1 enable: VDDUSB versus 1.2 V (applicable when USB feature is supported)."]
    #[doc = "@if STM32L486xx"]
    #[doc = "@arg @ref PWR_PVM_2 Peripheral Voltage Monitoring 2 enable: VDDIO2 versus 0.9 V (applicable when VDDIO2 is present on device)."]
    #[doc = "@endif"]
    #[doc = "@arg @ref PWR_PVM_3 Peripheral Voltage Monitoring 3 enable: VDDA versus 1.62 V."]
    #[doc = "@arg @ref PWR_PVM_4 Peripheral Voltage Monitoring 4 enable: VDDA versus 2.2 V."]
    pub PVMType: u32,
    #[doc = "< Mode: Specifies the operating mode for the selected pins."]
    #[doc = "This parameter can be a value of @ref PWREx_PVM_Mode."]
    pub Mode: u32,
}
#[test]
fn bindgen_test_layout_PWR_PVMTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<PWR_PVMTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(PWR_PVMTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<PWR_PVMTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(PWR_PVMTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_PVMTypeDef>())).PVMType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_PVMTypeDef),
            "::",
            stringify!(PVMType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PWR_PVMTypeDef>())).Mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_PVMTypeDef),
            "::",
            stringify!(Mode)
        )
    );
}
extern "C" {
    #[doc = " @addtogroup PWREx_Exported_Functions_Group1 Extended Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_PWREx_GetVoltageRange() -> u32;
}
extern "C" {
    pub fn HAL_PWREx_ControlVoltageScaling(VoltageScaling: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PWREx_EnableBatteryCharging(ResistorSelection: u32);
}
extern "C" {
    pub fn HAL_PWREx_DisableBatteryCharging();
}
extern "C" {
    pub fn HAL_PWREx_EnableVddUSB();
}
extern "C" {
    pub fn HAL_PWREx_DisableVddUSB();
}
extern "C" {
    pub fn HAL_PWREx_EnableVddIO2();
}
extern "C" {
    pub fn HAL_PWREx_DisableVddIO2();
}
extern "C" {
    pub fn HAL_PWREx_EnableInternalWakeUpLine();
}
extern "C" {
    pub fn HAL_PWREx_DisableInternalWakeUpLine();
}
extern "C" {
    pub fn HAL_PWREx_EnableGPIOPullUp(GPIO: u32, GPIONumber: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PWREx_DisableGPIOPullUp(GPIO: u32, GPIONumber: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PWREx_EnableGPIOPullDown(GPIO: u32, GPIONumber: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PWREx_DisableGPIOPullDown(GPIO: u32, GPIONumber: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PWREx_EnablePullUpPullDownConfig();
}
extern "C" {
    pub fn HAL_PWREx_DisablePullUpPullDownConfig();
}
extern "C" {
    pub fn HAL_PWREx_EnableSRAM2ContentRetention();
}
extern "C" {
    pub fn HAL_PWREx_DisableSRAM2ContentRetention();
}
extern "C" {
    pub fn HAL_PWREx_SetSRAM2ContentRetention(SRAM2Size: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PWREx_EnablePVM1();
}
extern "C" {
    pub fn HAL_PWREx_DisablePVM1();
}
extern "C" {
    pub fn HAL_PWREx_EnablePVM2();
}
extern "C" {
    pub fn HAL_PWREx_DisablePVM2();
}
extern "C" {
    pub fn HAL_PWREx_EnablePVM3();
}
extern "C" {
    pub fn HAL_PWREx_DisablePVM3();
}
extern "C" {
    pub fn HAL_PWREx_EnablePVM4();
}
extern "C" {
    pub fn HAL_PWREx_DisablePVM4();
}
extern "C" {
    pub fn HAL_PWREx_ConfigPVM(sConfigPVM: *mut PWR_PVMTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PWREx_EnableLowPowerRunMode();
}
extern "C" {
    pub fn HAL_PWREx_DisableLowPowerRunMode() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PWREx_EnterSTOP0Mode(STOPEntry: u8);
}
extern "C" {
    pub fn HAL_PWREx_EnterSTOP1Mode(STOPEntry: u8);
}
extern "C" {
    pub fn HAL_PWREx_EnterSTOP2Mode(STOPEntry: u8);
}
extern "C" {
    pub fn HAL_PWREx_EnterSHUTDOWNMode();
}
extern "C" {
    pub fn HAL_PWREx_PVD_PVM_IRQHandler();
}
extern "C" {
    pub fn HAL_PWREx_PVM1Callback();
}
extern "C" {
    pub fn HAL_PWREx_PVM2Callback();
}
extern "C" {
    pub fn HAL_PWREx_PVM3Callback();
}
extern "C" {
    pub fn HAL_PWREx_PVM4Callback();
}
extern "C" {
    #[doc = " @addtogroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_PWR_DeInit();
}
extern "C" {
    pub fn HAL_PWR_EnableBkUpAccess();
}
extern "C" {
    pub fn HAL_PWR_DisableBkUpAccess();
}
extern "C" {
    #[doc = " @addtogroup PWR_Exported_Functions_Group2 Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_PWR_ConfigPVD(sConfigPVD: *mut PWR_PVDTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PWR_EnablePVD();
}
extern "C" {
    pub fn HAL_PWR_DisablePVD();
}
extern "C" {
    pub fn HAL_PWR_EnableWakeUpPin(WakeUpPinPolarity: u32);
}
extern "C" {
    pub fn HAL_PWR_DisableWakeUpPin(WakeUpPinx: u32);
}
extern "C" {
    pub fn HAL_PWR_EnterSLEEPMode(Regulator: u32, SLEEPEntry: u8);
}
extern "C" {
    pub fn HAL_PWR_EnterSTOPMode(Regulator: u32, STOPEntry: u8);
}
extern "C" {
    pub fn HAL_PWR_EnterSTANDBYMode();
}
extern "C" {
    pub fn HAL_PWR_EnableSleepOnExit();
}
extern "C" {
    pub fn HAL_PWR_DisableSleepOnExit();
}
extern "C" {
    pub fn HAL_PWR_EnableSEVOnPend();
}
extern "C" {
    pub fn HAL_PWR_DisableSEVOnPend();
}
extern "C" {
    pub fn HAL_PWR_PVDCallback();
}
#[doc = " @brief  QSPI Init structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QSPI_InitTypeDef {
    pub ClockPrescaler: u32,
    pub FifoThreshold: u32,
    pub SampleShifting: u32,
    pub FlashSize: u32,
    pub ChipSelectHighTime: u32,
    pub ClockMode: u32,
}
#[test]
fn bindgen_test_layout_QSPI_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<QSPI_InitTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(QSPI_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<QSPI_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(QSPI_InitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_InitTypeDef>())).ClockPrescaler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_InitTypeDef),
            "::",
            stringify!(ClockPrescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_InitTypeDef>())).FifoThreshold as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_InitTypeDef),
            "::",
            stringify!(FifoThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_InitTypeDef>())).SampleShifting as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_InitTypeDef),
            "::",
            stringify!(SampleShifting)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_InitTypeDef>())).FlashSize as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_InitTypeDef),
            "::",
            stringify!(FlashSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_InitTypeDef>())).ChipSelectHighTime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_InitTypeDef),
            "::",
            stringify!(ChipSelectHighTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_InitTypeDef>())).ClockMode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_InitTypeDef),
            "::",
            stringify!(ClockMode)
        )
    );
}
#[doc = "< Peripheral not initialized"]
pub const HAL_QSPI_StateTypeDef_HAL_QSPI_STATE_RESET: HAL_QSPI_StateTypeDef = 0;
#[doc = "< Peripheral initialized and ready for use"]
pub const HAL_QSPI_StateTypeDef_HAL_QSPI_STATE_READY: HAL_QSPI_StateTypeDef = 1;
#[doc = "< Peripheral in indirect mode and busy"]
pub const HAL_QSPI_StateTypeDef_HAL_QSPI_STATE_BUSY: HAL_QSPI_StateTypeDef = 2;
#[doc = "< Peripheral in indirect mode with transmission ongoing"]
pub const HAL_QSPI_StateTypeDef_HAL_QSPI_STATE_BUSY_INDIRECT_TX: HAL_QSPI_StateTypeDef = 18;
#[doc = "< Peripheral in indirect mode with reception ongoing"]
pub const HAL_QSPI_StateTypeDef_HAL_QSPI_STATE_BUSY_INDIRECT_RX: HAL_QSPI_StateTypeDef = 34;
#[doc = "< Peripheral in auto polling mode ongoing"]
pub const HAL_QSPI_StateTypeDef_HAL_QSPI_STATE_BUSY_AUTO_POLLING: HAL_QSPI_StateTypeDef = 66;
#[doc = "< Peripheral in memory mapped mode ongoing"]
pub const HAL_QSPI_StateTypeDef_HAL_QSPI_STATE_BUSY_MEM_MAPPED: HAL_QSPI_StateTypeDef = 130;
#[doc = "< Peripheral with abort request ongoing"]
pub const HAL_QSPI_StateTypeDef_HAL_QSPI_STATE_ABORT: HAL_QSPI_StateTypeDef = 8;
#[doc = "< Peripheral in error"]
pub const HAL_QSPI_StateTypeDef_HAL_QSPI_STATE_ERROR: HAL_QSPI_StateTypeDef = 4;
#[doc = " @brief HAL QSPI State structures definition"]
pub type HAL_QSPI_StateTypeDef = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QSPI_HandleTypeDef {
    pub Instance: *mut QUADSPI_TypeDef,
    pub Init: QSPI_InitTypeDef,
    pub pTxBuffPtr: *mut u8,
    pub TxXferSize: u32,
    pub TxXferCount: u32,
    pub pRxBuffPtr: *mut u8,
    pub RxXferSize: u32,
    pub RxXferCount: u32,
    pub hdma: *mut DMA_HandleTypeDef,
    pub Lock: HAL_LockTypeDef,
    pub State: HAL_QSPI_StateTypeDef,
    pub ErrorCode: u32,
    pub Timeout: u32,
}
#[test]
fn bindgen_test_layout_QSPI_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<QSPI_HandleTypeDef>(),
        72usize,
        concat!("Size of: ", stringify!(QSPI_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<QSPI_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(QSPI_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_HandleTypeDef>())).pTxBuffPtr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_HandleTypeDef),
            "::",
            stringify!(pTxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_HandleTypeDef>())).TxXferSize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_HandleTypeDef),
            "::",
            stringify!(TxXferSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_HandleTypeDef>())).TxXferCount as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_HandleTypeDef),
            "::",
            stringify!(TxXferCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_HandleTypeDef>())).pRxBuffPtr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_HandleTypeDef),
            "::",
            stringify!(pRxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_HandleTypeDef>())).RxXferSize as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_HandleTypeDef),
            "::",
            stringify!(RxXferSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_HandleTypeDef>())).RxXferCount as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_HandleTypeDef),
            "::",
            stringify!(RxXferCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_HandleTypeDef>())).hdma as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_HandleTypeDef),
            "::",
            stringify!(hdma)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_HandleTypeDef>())).Lock as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_HandleTypeDef>())).State as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_HandleTypeDef>())).ErrorCode as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_HandleTypeDef>())).Timeout as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_HandleTypeDef),
            "::",
            stringify!(Timeout)
        )
    );
}
impl Default for QSPI_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  QSPI Command structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QSPI_CommandTypeDef {
    pub Instruction: u32,
    pub Address: u32,
    pub AlternateBytes: u32,
    pub AddressSize: u32,
    pub AlternateBytesSize: u32,
    pub DummyCycles: u32,
    pub InstructionMode: u32,
    pub AddressMode: u32,
    pub AlternateByteMode: u32,
    pub DataMode: u32,
    pub NbData: u32,
    pub DdrMode: u32,
    pub DdrHoldHalfCycle: u32,
    pub SIOOMode: u32,
}
#[test]
fn bindgen_test_layout_QSPI_CommandTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<QSPI_CommandTypeDef>(),
        56usize,
        concat!("Size of: ", stringify!(QSPI_CommandTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<QSPI_CommandTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(QSPI_CommandTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_CommandTypeDef>())).Instruction as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_CommandTypeDef),
            "::",
            stringify!(Instruction)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_CommandTypeDef>())).Address as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_CommandTypeDef),
            "::",
            stringify!(Address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_CommandTypeDef>())).AlternateBytes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_CommandTypeDef),
            "::",
            stringify!(AlternateBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_CommandTypeDef>())).AddressSize as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_CommandTypeDef),
            "::",
            stringify!(AddressSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_CommandTypeDef>())).AlternateBytesSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_CommandTypeDef),
            "::",
            stringify!(AlternateBytesSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_CommandTypeDef>())).DummyCycles as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_CommandTypeDef),
            "::",
            stringify!(DummyCycles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_CommandTypeDef>())).InstructionMode as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_CommandTypeDef),
            "::",
            stringify!(InstructionMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_CommandTypeDef>())).AddressMode as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_CommandTypeDef),
            "::",
            stringify!(AddressMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_CommandTypeDef>())).AlternateByteMode as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_CommandTypeDef),
            "::",
            stringify!(AlternateByteMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_CommandTypeDef>())).DataMode as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_CommandTypeDef),
            "::",
            stringify!(DataMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_CommandTypeDef>())).NbData as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_CommandTypeDef),
            "::",
            stringify!(NbData)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_CommandTypeDef>())).DdrMode as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_CommandTypeDef),
            "::",
            stringify!(DdrMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_CommandTypeDef>())).DdrHoldHalfCycle as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_CommandTypeDef),
            "::",
            stringify!(DdrHoldHalfCycle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_CommandTypeDef>())).SIOOMode as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_CommandTypeDef),
            "::",
            stringify!(SIOOMode)
        )
    );
}
#[doc = " @brief  QSPI Auto Polling mode configuration structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QSPI_AutoPollingTypeDef {
    pub Match: u32,
    pub Mask: u32,
    pub Interval: u32,
    pub StatusBytesSize: u32,
    pub MatchMode: u32,
    pub AutomaticStop: u32,
}
#[test]
fn bindgen_test_layout_QSPI_AutoPollingTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<QSPI_AutoPollingTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(QSPI_AutoPollingTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<QSPI_AutoPollingTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(QSPI_AutoPollingTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_AutoPollingTypeDef>())).Match as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_AutoPollingTypeDef),
            "::",
            stringify!(Match)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QSPI_AutoPollingTypeDef>())).Mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_AutoPollingTypeDef),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_AutoPollingTypeDef>())).Interval as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_AutoPollingTypeDef),
            "::",
            stringify!(Interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_AutoPollingTypeDef>())).StatusBytesSize as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_AutoPollingTypeDef),
            "::",
            stringify!(StatusBytesSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_AutoPollingTypeDef>())).MatchMode as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_AutoPollingTypeDef),
            "::",
            stringify!(MatchMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_AutoPollingTypeDef>())).AutomaticStop as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_AutoPollingTypeDef),
            "::",
            stringify!(AutomaticStop)
        )
    );
}
#[doc = " @brief  QSPI Memory Mapped mode configuration structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QSPI_MemoryMappedTypeDef {
    pub TimeOutPeriod: u32,
    pub TimeOutActivation: u32,
}
#[test]
fn bindgen_test_layout_QSPI_MemoryMappedTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<QSPI_MemoryMappedTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(QSPI_MemoryMappedTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<QSPI_MemoryMappedTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(QSPI_MemoryMappedTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_MemoryMappedTypeDef>())).TimeOutPeriod as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_MemoryMappedTypeDef),
            "::",
            stringify!(TimeOutPeriod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<QSPI_MemoryMappedTypeDef>())).TimeOutActivation as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(QSPI_MemoryMappedTypeDef),
            "::",
            stringify!(TimeOutActivation)
        )
    );
}
extern "C" {
    #[doc = " @addtogroup QSPI_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_QSPI_Init(hqspi: *mut QSPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_DeInit(hqspi: *mut QSPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_MspInit(hqspi: *mut QSPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_QSPI_MspDeInit(hqspi: *mut QSPI_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup QSPI_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_QSPI_IRQHandler(hqspi: *mut QSPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_QSPI_Command(
        hqspi: *mut QSPI_HandleTypeDef,
        cmd: *mut QSPI_CommandTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_Transmit(
        hqspi: *mut QSPI_HandleTypeDef,
        pData: *mut u8,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_Receive(
        hqspi: *mut QSPI_HandleTypeDef,
        pData: *mut u8,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_Command_IT(
        hqspi: *mut QSPI_HandleTypeDef,
        cmd: *mut QSPI_CommandTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_Transmit_IT(
        hqspi: *mut QSPI_HandleTypeDef,
        pData: *mut u8,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_Receive_IT(hqspi: *mut QSPI_HandleTypeDef, pData: *mut u8)
        -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_Transmit_DMA(
        hqspi: *mut QSPI_HandleTypeDef,
        pData: *mut u8,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_Receive_DMA(
        hqspi: *mut QSPI_HandleTypeDef,
        pData: *mut u8,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_AutoPolling(
        hqspi: *mut QSPI_HandleTypeDef,
        cmd: *mut QSPI_CommandTypeDef,
        cfg: *mut QSPI_AutoPollingTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_AutoPolling_IT(
        hqspi: *mut QSPI_HandleTypeDef,
        cmd: *mut QSPI_CommandTypeDef,
        cfg: *mut QSPI_AutoPollingTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_MemoryMapped(
        hqspi: *mut QSPI_HandleTypeDef,
        cmd: *mut QSPI_CommandTypeDef,
        cfg: *mut QSPI_MemoryMappedTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_ErrorCallback(hqspi: *mut QSPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_QSPI_AbortCpltCallback(hqspi: *mut QSPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_QSPI_FifoThresholdCallback(hqspi: *mut QSPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_QSPI_CmdCpltCallback(hqspi: *mut QSPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_QSPI_RxCpltCallback(hqspi: *mut QSPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_QSPI_TxCpltCallback(hqspi: *mut QSPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_QSPI_RxHalfCpltCallback(hqspi: *mut QSPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_QSPI_TxHalfCpltCallback(hqspi: *mut QSPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_QSPI_StatusMatchCallback(hqspi: *mut QSPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_QSPI_TimeOutCallback(hqspi: *mut QSPI_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup QSPI_Exported_Functions_Group3"]
    #[doc = " @{"]
    pub fn HAL_QSPI_GetState(hqspi: *mut QSPI_HandleTypeDef) -> HAL_QSPI_StateTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_GetError(hqspi: *mut QSPI_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_QSPI_Abort(hqspi: *mut QSPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_Abort_IT(hqspi: *mut QSPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_SetTimeout(hqspi: *mut QSPI_HandleTypeDef, Timeout: u32);
}
extern "C" {
    pub fn HAL_QSPI_SetFifoThreshold(
        hqspi: *mut QSPI_HandleTypeDef,
        Threshold: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_QSPI_GetFifoThreshold(hqspi: *mut QSPI_HandleTypeDef) -> u32;
}
#[doc = "< RNG not yet initialized or disabled"]
pub const HAL_RNG_StateTypeDef_HAL_RNG_STATE_RESET: HAL_RNG_StateTypeDef = 0;
#[doc = "< RNG initialized and ready for use"]
pub const HAL_RNG_StateTypeDef_HAL_RNG_STATE_READY: HAL_RNG_StateTypeDef = 1;
#[doc = "< RNG internal process is ongoing"]
pub const HAL_RNG_StateTypeDef_HAL_RNG_STATE_BUSY: HAL_RNG_StateTypeDef = 2;
#[doc = "< RNG timeout state"]
pub const HAL_RNG_StateTypeDef_HAL_RNG_STATE_TIMEOUT: HAL_RNG_StateTypeDef = 3;
#[doc = "< RNG error state"]
pub const HAL_RNG_StateTypeDef_HAL_RNG_STATE_ERROR: HAL_RNG_StateTypeDef = 4;
#[doc = " @defgroup RNG_Exported_Types_Group2 RNG State Structure definition"]
#[doc = " @{"]
pub type HAL_RNG_StateTypeDef = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RNG_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut RNG_TypeDef,
    #[doc = "< RNG locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< RNG communication state"]
    pub State: HAL_RNG_StateTypeDef,
    #[doc = "< RNG Error code"]
    pub ErrorCode: u32,
    #[doc = "< Last Generated RNG Data"]
    pub RandomNumber: u32,
}
#[test]
fn bindgen_test_layout_RNG_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RNG_HandleTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(RNG_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RNG_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RNG_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RNG_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RNG_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RNG_HandleTypeDef>())).Lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RNG_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RNG_HandleTypeDef>())).State as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RNG_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RNG_HandleTypeDef>())).ErrorCode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RNG_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RNG_HandleTypeDef>())).RandomNumber as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RNG_HandleTypeDef),
            "::",
            stringify!(RandomNumber)
        )
    );
}
impl Default for RNG_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @defgroup RNG_Exported_Functions_Group1 Initialization and configuration functions"]
    #[doc = " @{"]
    pub fn HAL_RNG_Init(hrng: *mut RNG_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RNG_DeInit(hrng: *mut RNG_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RNG_MspInit(hrng: *mut RNG_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RNG_MspDeInit(hrng: *mut RNG_HandleTypeDef);
}
extern "C" {
    #[doc = " @defgroup RNG_Exported_Functions_Group2 Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_RNG_GetRandomNumber(hrng: *mut RNG_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_RNG_GetRandomNumber_IT(hrng: *mut RNG_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_RNG_GenerateRandomNumber(
        hrng: *mut RNG_HandleTypeDef,
        random32bit: *mut u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RNG_GenerateRandomNumber_IT(hrng: *mut RNG_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RNG_ReadLastRandomNumber(hrng: *mut RNG_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_RNG_IRQHandler(hrng: *mut RNG_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RNG_ErrorCallback(hrng: *mut RNG_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RNG_ReadyDataCallback(hrng: *mut RNG_HandleTypeDef, random32bit: u32);
}
extern "C" {
    #[doc = " @defgroup RNG_Exported_Functions_Group3 Peripheral State functions"]
    #[doc = " @{"]
    pub fn HAL_RNG_GetState(hrng: *mut RNG_HandleTypeDef) -> HAL_RNG_StateTypeDef;
}
extern "C" {
    pub fn HAL_RNG_GetError(hrng: *mut RNG_HandleTypeDef) -> u32;
}
#[doc = "< RTC not yet initialized or disabled"]
pub const HAL_RTCStateTypeDef_HAL_RTC_STATE_RESET: HAL_RTCStateTypeDef = 0;
#[doc = "< RTC initialized and ready for use"]
pub const HAL_RTCStateTypeDef_HAL_RTC_STATE_READY: HAL_RTCStateTypeDef = 1;
#[doc = "< RTC process is ongoing"]
pub const HAL_RTCStateTypeDef_HAL_RTC_STATE_BUSY: HAL_RTCStateTypeDef = 2;
#[doc = "< RTC timeout state"]
pub const HAL_RTCStateTypeDef_HAL_RTC_STATE_TIMEOUT: HAL_RTCStateTypeDef = 3;
#[doc = "< RTC error state"]
pub const HAL_RTCStateTypeDef_HAL_RTC_STATE_ERROR: HAL_RTCStateTypeDef = 4;
#[doc = " @brief  HAL State structures definition"]
pub type HAL_RTCStateTypeDef = libc::c_uint;
#[doc = " @brief  RTC Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTC_InitTypeDef {
    #[doc = "< Specifies the RTC Hour Format."]
    #[doc = "This parameter can be a value of @ref RTC_Hour_Formats"]
    pub HourFormat: u32,
    #[doc = "< Specifies the RTC Asynchronous Predivider value."]
    #[doc = "This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7F"]
    pub AsynchPrediv: u32,
    #[doc = "< Specifies the RTC Synchronous Predivider value."]
    #[doc = "This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7FFF"]
    pub SynchPrediv: u32,
    #[doc = "< Specifies which signal will be routed to the RTC output."]
    #[doc = "This parameter can be a value of @ref RTCEx_Output_selection_Definitions"]
    pub OutPut: u32,
    #[doc = "< Specifies the remap for RTC output."]
    #[doc = "This parameter can be a value of @ref  RTC_Output_ALARM_OUT_Remap"]
    pub OutPutRemap: u32,
    #[doc = "< Specifies the polarity of the output signal."]
    #[doc = "This parameter can be a value of @ref RTC_Output_Polarity_Definitions"]
    pub OutPutPolarity: u32,
    #[doc = "< Specifies the RTC Output Pin mode."]
    #[doc = "This parameter can be a value of @ref RTC_Output_Type_ALARM_OUT"]
    pub OutPutType: u32,
}
#[test]
fn bindgen_test_layout_RTC_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RTC_InitTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(RTC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_InitTypeDef>())).HourFormat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_InitTypeDef),
            "::",
            stringify!(HourFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_InitTypeDef>())).AsynchPrediv as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_InitTypeDef),
            "::",
            stringify!(AsynchPrediv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_InitTypeDef>())).SynchPrediv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_InitTypeDef),
            "::",
            stringify!(SynchPrediv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_InitTypeDef>())).OutPut as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_InitTypeDef),
            "::",
            stringify!(OutPut)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_InitTypeDef>())).OutPutRemap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_InitTypeDef),
            "::",
            stringify!(OutPutRemap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_InitTypeDef>())).OutPutPolarity as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_InitTypeDef),
            "::",
            stringify!(OutPutPolarity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_InitTypeDef>())).OutPutType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_InitTypeDef),
            "::",
            stringify!(OutPutType)
        )
    );
}
#[doc = " @brief  RTC Time structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTC_TimeTypeDef {
    #[doc = "< Specifies the RTC Time Hour."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 12 if the RTC_HourFormat_12 is selected."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 23 if the RTC_HourFormat_24 is selected"]
    pub Hours: u8,
    #[doc = "< Specifies the RTC Time Minutes."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 59"]
    pub Minutes: u8,
    #[doc = "< Specifies the RTC Time Seconds."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 59"]
    pub Seconds: u8,
    #[doc = "< Specifies the RTC AM/PM Time."]
    #[doc = "This parameter can be a value of @ref RTC_AM_PM_Definitions"]
    pub TimeFormat: u8,
    #[doc = "< Specifies the RTC_SSR RTC Sub Second register content."]
    #[doc = "This parameter corresponds to a time unit range between [0-1] Second"]
    #[doc = "with [1 Sec / SecondFraction +1] granularity"]
    pub SubSeconds: u32,
    #[doc = "< Specifies the range or granularity of Sub Second register content"]
    #[doc = "corresponding to Synchronous pre-scaler factor value (PREDIV_S)"]
    #[doc = "This parameter corresponds to a time unit range between [0-1] Second"]
    #[doc = "with [1 Sec / SecondFraction +1] granularity."]
    #[doc = "This field will be used only by HAL_RTC_GetTime function"]
    pub SecondFraction: u32,
    #[doc = "< This interface is deprecated. To manage Daylight Saving Time, please use HAL_RTC_DST_xxx functions"]
    pub DayLightSaving: u32,
    #[doc = "< This interface is deprecated. To manage Daylight Saving Time, please use HAL_RTC_DST_xxx functions"]
    pub StoreOperation: u32,
}
#[test]
fn bindgen_test_layout_RTC_TimeTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RTC_TimeTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(RTC_TimeTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_TimeTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_TimeTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TimeTypeDef>())).Hours as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TimeTypeDef),
            "::",
            stringify!(Hours)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TimeTypeDef>())).Minutes as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TimeTypeDef),
            "::",
            stringify!(Minutes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TimeTypeDef>())).Seconds as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TimeTypeDef),
            "::",
            stringify!(Seconds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TimeTypeDef>())).TimeFormat as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TimeTypeDef),
            "::",
            stringify!(TimeFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TimeTypeDef>())).SubSeconds as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TimeTypeDef),
            "::",
            stringify!(SubSeconds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TimeTypeDef>())).SecondFraction as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TimeTypeDef),
            "::",
            stringify!(SecondFraction)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TimeTypeDef>())).DayLightSaving as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TimeTypeDef),
            "::",
            stringify!(DayLightSaving)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TimeTypeDef>())).StoreOperation as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TimeTypeDef),
            "::",
            stringify!(StoreOperation)
        )
    );
}
#[doc = " @brief  RTC Date structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTC_DateTypeDef {
    #[doc = "< Specifies the RTC Date WeekDay."]
    #[doc = "This parameter can be a value of @ref RTC_WeekDay_Definitions"]
    pub WeekDay: u8,
    #[doc = "< Specifies the RTC Date Month (in BCD format)."]
    #[doc = "This parameter can be a value of @ref RTC_Month_Date_Definitions"]
    pub Month: u8,
    #[doc = "< Specifies the RTC Date."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 31"]
    pub Date: u8,
    #[doc = "< Specifies the RTC Date Year."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 99"]
    pub Year: u8,
}
#[test]
fn bindgen_test_layout_RTC_DateTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RTC_DateTypeDef>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_DateTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_DateTypeDef>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_DateTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_DateTypeDef>())).WeekDay as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_DateTypeDef),
            "::",
            stringify!(WeekDay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_DateTypeDef>())).Month as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_DateTypeDef),
            "::",
            stringify!(Month)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_DateTypeDef>())).Date as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_DateTypeDef),
            "::",
            stringify!(Date)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_DateTypeDef>())).Year as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_DateTypeDef),
            "::",
            stringify!(Year)
        )
    );
}
#[doc = " @brief  RTC Alarm structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTC_AlarmTypeDef {
    #[doc = "< Specifies the RTC Alarm Time members"]
    pub AlarmTime: RTC_TimeTypeDef,
    #[doc = "< Specifies the RTC Alarm Masks."]
    #[doc = "This parameter can be a value of @ref RTC_AlarmMask_Definitions"]
    pub AlarmMask: u32,
    #[doc = "< Specifies the RTC_SSR RTC Sub Second register content."]
    pub SubSeconds: u32,
    #[doc = "< Specifies the RTC Alarm SubSeconds Masks."]
    #[doc = "This parameter can be a value of @ref RTC_Alarm_Sub_Seconds_Masks_Definitions"]
    pub AlarmSubSecondMask: u32,
    #[doc = "< Specifies the RTC Alarm is on Date or WeekDay."]
    #[doc = "This parameter can be a value of @ref RTC_AlarmDateWeekDay_Definitions"]
    pub AlarmDateWeekDaySel: u32,
    #[doc = "< Specifies the RTC Alarm Date/WeekDay."]
    #[doc = "If the Alarm Date is selected, this parameter must be set to a value in the 1-31 range."]
    #[doc = "If the Alarm WeekDay is selected, this parameter can be a value of @ref RTC_WeekDay_Definitions"]
    pub AlarmDateWeekDay: u8,
    #[doc = "< Specifies the alarm ."]
    #[doc = "This parameter can be a value of @ref RTC_Alarms_Definitions"]
    pub Alarm: u32,
}
#[test]
fn bindgen_test_layout_RTC_AlarmTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RTC_AlarmTypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(RTC_AlarmTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_AlarmTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_AlarmTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_AlarmTypeDef>())).AlarmTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_AlarmTypeDef),
            "::",
            stringify!(AlarmTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_AlarmTypeDef>())).AlarmMask as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_AlarmTypeDef),
            "::",
            stringify!(AlarmMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_AlarmTypeDef>())).SubSeconds as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_AlarmTypeDef),
            "::",
            stringify!(SubSeconds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RTC_AlarmTypeDef>())).AlarmSubSecondMask as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_AlarmTypeDef),
            "::",
            stringify!(AlarmSubSecondMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RTC_AlarmTypeDef>())).AlarmDateWeekDaySel as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_AlarmTypeDef),
            "::",
            stringify!(AlarmDateWeekDaySel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RTC_AlarmTypeDef>())).AlarmDateWeekDay as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_AlarmTypeDef),
            "::",
            stringify!(AlarmDateWeekDay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_AlarmTypeDef>())).Alarm as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_AlarmTypeDef),
            "::",
            stringify!(Alarm)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut RTC_TypeDef,
    #[doc = "< RTC required parameters"]
    pub Init: RTC_InitTypeDef,
    #[doc = "< RTC locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< Time communication state"]
    pub State: HAL_RTCStateTypeDef,
}
#[test]
fn bindgen_test_layout_RTC_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RTC_HandleTypeDef>(),
        40usize,
        concat!("Size of: ", stringify!(RTC_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_HandleTypeDef>())).Lock as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_HandleTypeDef>())).State as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
}
impl Default for RTC_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @defgroup RTCEx_Tamper_structure_definition RTCEx Tamper structure definition"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTC_TamperTypeDef {
    #[doc = "< Specifies the Tamper Pin."]
    #[doc = "This parameter can be a value of @ref RTCEx_Tamper_Pins_Definitions"]
    pub Tamper: u32,
    #[doc = "< Specifies the Tamper Interrupt."]
    #[doc = "This parameter can be a value of @ref  RTCEx_Tamper_Interrupt_Definitions"]
    pub Interrupt: u32,
    #[doc = "< Specifies the Tamper Trigger."]
    #[doc = "This parameter can be a value of @ref RTCEx_Tamper_Trigger_Definitions"]
    pub Trigger: u32,
    #[doc = "< Specifies the Tamper no erase mode."]
    #[doc = "This parameter can be a value of @ref RTCEx_Tamper_EraseBackUp_Definitions"]
    pub NoErase: u32,
    #[doc = "< Specifies the Tamper Flag masking."]
    #[doc = "This parameter can be a value of @ref RTCEx_Tamper_MaskFlag_Definitions"]
    pub MaskFlag: u32,
    #[doc = "< Specifies the TAMP Filter Tamper."]
    #[doc = "This parameter can be a value of @ref RTCEx_Tamper_Filter_Definitions"]
    pub Filter: u32,
    #[doc = "< Specifies the sampling frequency."]
    #[doc = "This parameter can be a value of @ref RTCEx_Tamper_Sampling_Frequencies_Definitions"]
    pub SamplingFrequency: u32,
    #[doc = "< Specifies the Precharge Duration ."]
    #[doc = "This parameter can be a value of @ref RTCEx_Tamper_Pin_Precharge_Duration_Definitions"]
    pub PrechargeDuration: u32,
    #[doc = "< Specifies the Tamper PullUp ."]
    #[doc = "This parameter can be a value of @ref RTCEx_Tamper_Pull_UP_Definitions"]
    pub TamperPullUp: u32,
    #[doc = "< Specifies the TimeStampOnTamperDetection."]
    #[doc = "This parameter can be a value of @ref RTCEx_Tamper_TimeStampOnTamperDetection_Definitions"]
    pub TimeStampOnTamperDetection: u32,
}
#[test]
fn bindgen_test_layout_RTC_TamperTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<RTC_TamperTypeDef>(),
        40usize,
        concat!("Size of: ", stringify!(RTC_TamperTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_TamperTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_TamperTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TamperTypeDef>())).Tamper as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TamperTypeDef),
            "::",
            stringify!(Tamper)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TamperTypeDef>())).Interrupt as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TamperTypeDef),
            "::",
            stringify!(Interrupt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TamperTypeDef>())).Trigger as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TamperTypeDef),
            "::",
            stringify!(Trigger)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TamperTypeDef>())).NoErase as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TamperTypeDef),
            "::",
            stringify!(NoErase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TamperTypeDef>())).MaskFlag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TamperTypeDef),
            "::",
            stringify!(MaskFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TamperTypeDef>())).Filter as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TamperTypeDef),
            "::",
            stringify!(Filter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RTC_TamperTypeDef>())).SamplingFrequency as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TamperTypeDef),
            "::",
            stringify!(SamplingFrequency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RTC_TamperTypeDef>())).PrechargeDuration as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TamperTypeDef),
            "::",
            stringify!(PrechargeDuration)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_TamperTypeDef>())).TamperPullUp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TamperTypeDef),
            "::",
            stringify!(TamperPullUp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RTC_TamperTypeDef>())).TimeStampOnTamperDetection as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TamperTypeDef),
            "::",
            stringify!(TimeStampOnTamperDetection)
        )
    );
}
extern "C" {
    #[doc = " @defgroup RTCEx_Exported_Functions_Group1 Extended RTC TimeStamp functions"]
    #[doc = " @{"]
    pub fn HAL_RTCEx_SetTimeStamp(
        hrtc: *mut RTC_HandleTypeDef,
        TimeStampEdge: u32,
        RTC_TimeStampPin: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_SetTimeStamp_IT(
        hrtc: *mut RTC_HandleTypeDef,
        TimeStampEdge: u32,
        RTC_TimeStampPin: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_DeactivateTimeStamp(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_SetInternalTimeStamp(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_DeactivateInternalTimeStamp(hrtc: *mut RTC_HandleTypeDef)
        -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_GetTimeStamp(
        hrtc: *mut RTC_HandleTypeDef,
        sTimeStamp: *mut RTC_TimeTypeDef,
        sTimeStampDate: *mut RTC_DateTypeDef,
        Format: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_TamperTimeStampIRQHandler(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTCEx_TimeStampEventCallback(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTCEx_PollForTimeStampEvent(
        hrtc: *mut RTC_HandleTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup RTCEx_Exported_Functions_Group2 Extended RTC Wake-up functions"]
    #[doc = " @{"]
    pub fn HAL_RTCEx_SetWakeUpTimer(
        hrtc: *mut RTC_HandleTypeDef,
        WakeUpCounter: u32,
        WakeUpClock: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_SetWakeUpTimer_IT(
        hrtc: *mut RTC_HandleTypeDef,
        WakeUpCounter: u32,
        WakeUpClock: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_DeactivateWakeUpTimer(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_GetWakeUpTimer(hrtc: *mut RTC_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_RTCEx_WakeUpTimerIRQHandler(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTCEx_WakeUpTimerEventCallback(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTCEx_PollForWakeUpTimerEvent(
        hrtc: *mut RTC_HandleTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup RTCEx_Exported_Functions_Group3 Extended Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_RTCEx_SetSmoothCalib(
        hrtc: *mut RTC_HandleTypeDef,
        SmoothCalibPeriod: u32,
        SmoothCalibPlusPulses: u32,
        SmoothCalibMinusPulsesValue: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_SetSynchroShift(
        hrtc: *mut RTC_HandleTypeDef,
        ShiftAdd1S: u32,
        ShiftSubFS: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_SetCalibrationOutPut(
        hrtc: *mut RTC_HandleTypeDef,
        CalibOutput: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_DeactivateCalibrationOutPut(hrtc: *mut RTC_HandleTypeDef)
        -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_SetRefClock(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_DeactivateRefClock(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_EnableBypassShadow(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_DisableBypassShadow(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup RTCEx_Exported_Functions_Group4 Extended features functions"]
    #[doc = " @{"]
    pub fn HAL_RTCEx_AlarmBEventCallback(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTCEx_PollForAlarmBEvent(
        hrtc: *mut RTC_HandleTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup RTCEx_Exported_Functions_Group5 Extended RTC Tamper functions"]
    #[doc = " @{"]
    pub fn HAL_RTCEx_SetTamper(
        hrtc: *mut RTC_HandleTypeDef,
        sTamper: *mut RTC_TamperTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_SetTamper_IT(
        hrtc: *mut RTC_HandleTypeDef,
        sTamper: *mut RTC_TamperTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_DeactivateTamper(
        hrtc: *mut RTC_HandleTypeDef,
        Tamper: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_PollForTamper1Event(
        hrtc: *mut RTC_HandleTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_PollForTamper2Event(
        hrtc: *mut RTC_HandleTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_PollForTamper3Event(
        hrtc: *mut RTC_HandleTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_Tamper1EventCallback(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTCEx_Tamper2EventCallback(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTCEx_Tamper3EventCallback(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    #[doc = " @defgroup RTCEx_Exported_Functions_Group6 Extended RTC Backup register functions"]
    #[doc = " @{"]
    pub fn HAL_RTCEx_BKUPWrite(hrtc: *mut RTC_HandleTypeDef, BackupRegister: u32, Data: u32);
}
extern "C" {
    pub fn HAL_RTCEx_BKUPRead(hrtc: *mut RTC_HandleTypeDef, BackupRegister: u32) -> u32;
}
extern "C" {
    #[doc = " @defgroup RTC_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_RTC_Init(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_DeInit(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_MspInit(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTC_MspDeInit(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    #[doc = " @defgroup RTC_Exported_Functions_Group2 RTC Time and Date functions"]
    #[doc = " @{"]
    pub fn HAL_RTC_SetTime(
        hrtc: *mut RTC_HandleTypeDef,
        sTime: *mut RTC_TimeTypeDef,
        Format: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_GetTime(
        hrtc: *mut RTC_HandleTypeDef,
        sTime: *mut RTC_TimeTypeDef,
        Format: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_SetDate(
        hrtc: *mut RTC_HandleTypeDef,
        sDate: *mut RTC_DateTypeDef,
        Format: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_GetDate(
        hrtc: *mut RTC_HandleTypeDef,
        sDate: *mut RTC_DateTypeDef,
        Format: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_DST_Add1Hour(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTC_DST_Sub1Hour(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTC_DST_SetStoreOperation(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTC_DST_ClearStoreOperation(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTC_DST_ReadStoreOperation(hrtc: *mut RTC_HandleTypeDef) -> u32;
}
extern "C" {
    #[doc = " @defgroup RTC_Exported_Functions_Group3 RTC Alarm functions"]
    #[doc = " @{"]
    pub fn HAL_RTC_SetAlarm(
        hrtc: *mut RTC_HandleTypeDef,
        sAlarm: *mut RTC_AlarmTypeDef,
        Format: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_SetAlarm_IT(
        hrtc: *mut RTC_HandleTypeDef,
        sAlarm: *mut RTC_AlarmTypeDef,
        Format: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_DeactivateAlarm(hrtc: *mut RTC_HandleTypeDef, Alarm: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_GetAlarm(
        hrtc: *mut RTC_HandleTypeDef,
        sAlarm: *mut RTC_AlarmTypeDef,
        Alarm: u32,
        Format: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_AlarmIRQHandler(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTC_AlarmAEventCallback(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTC_PollForAlarmAEvent(
        hrtc: *mut RTC_HandleTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup  RTC_Exported_Functions_Group4 Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_RTC_WaitForSynchro(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup RTC_Exported_Functions_Group5 Peripheral State functions"]
    #[doc = " @{"]
    pub fn HAL_RTC_GetState(hrtc: *mut RTC_HandleTypeDef) -> HAL_RTCStateTypeDef;
}
extern "C" {
    #[doc = " @defgroup RTC_Private_Functions RTC Private Functions"]
    #[doc = " @{"]
    pub fn RTC_EnterInitMode(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn RTC_ExitInitMode(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn RTC_ByteToBcd2(Value: u8) -> u8;
}
extern "C" {
    pub fn RTC_Bcd2ToByte(Value: u8) -> u8;
}
#[doc = "< SAI not yet initialized or disabled"]
pub const HAL_SAI_StateTypeDef_HAL_SAI_STATE_RESET: HAL_SAI_StateTypeDef = 0;
#[doc = "< SAI initialized and ready for use"]
pub const HAL_SAI_StateTypeDef_HAL_SAI_STATE_READY: HAL_SAI_StateTypeDef = 1;
#[doc = "< SAI internal process is ongoing"]
pub const HAL_SAI_StateTypeDef_HAL_SAI_STATE_BUSY: HAL_SAI_StateTypeDef = 2;
#[doc = "< Data transmission process is ongoing"]
pub const HAL_SAI_StateTypeDef_HAL_SAI_STATE_BUSY_TX: HAL_SAI_StateTypeDef = 18;
#[doc = "< Data reception process is ongoing"]
pub const HAL_SAI_StateTypeDef_HAL_SAI_STATE_BUSY_RX: HAL_SAI_StateTypeDef = 34;
#[doc = " @brief  HAL State structures definition"]
pub type HAL_SAI_StateTypeDef = libc::c_uint;
#[doc = " @brief  SAI Callback prototype"]
pub type SAIcallback = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " @defgroup SAI_Init_Structure_definition SAI Init Structure definition"]
#[doc = " @brief  SAI Init Structure definition"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SAI_InitTypeDef {
    #[doc = "< Specifies the SAI Block audio Mode."]
    #[doc = "This parameter can be a value of @ref SAI_Block_Mode"]
    pub AudioMode: u32,
    #[doc = "< Specifies SAI Block synchronization"]
    #[doc = "This parameter can be a value of @ref SAI_Block_Synchronization"]
    pub Synchro: u32,
    #[doc = "< Specifies SAI external output synchronization, this setup is common"]
    #[doc = "for BlockA and BlockB"]
    #[doc = "This parameter can be a value of @ref SAI_Block_SyncExt"]
    #[doc = "@note If both audio blocks of same SAI are used, this parameter has"]
    #[doc = "to be set to the same value for each audio block"]
    pub SynchroExt: u32,
    #[doc = "< Specifies when SAI Block outputs are driven."]
    #[doc = "This parameter can be a value of @ref SAI_Block_Output_Drive"]
    #[doc = "@note This value has to be set before enabling the audio block"]
    #[doc = "but after the audio block configuration."]
    pub OutputDrive: u32,
    #[doc = "< Specifies whether master clock will be divided or not."]
    #[doc = "This parameter can be a value of @ref SAI_Block_NoDivider"]
    #[doc = "@note For STM32L4Rx/STM32L4Sx devices :"]
    #[doc = "If bit NOMCK in the SAI_xCR1 register is cleared, the frame length"]
    #[doc = "should be aligned to a number equal to a power of 2, from 8 to 256."]
    #[doc = "If bit NOMCK in the SAI_xCR1 register is set, the frame length can"]
    #[doc = "take any of the values without constraint. There is no MCLK_x clock"]
    #[doc = "which can be output."]
    #[doc = "For other devices :"]
    #[doc = "If bit NODIV in the SAI_xCR1 register is cleared, the frame length"]
    #[doc = "should be aligned to a number equal to a power of 2, from 8 to 256."]
    #[doc = "If bit NODIV in the SAI_xCR1 register is set, the frame length can"]
    #[doc = "take any of the values without constraint since the input clock of"]
    #[doc = "the audio block should be equal to the bit clock."]
    #[doc = "There is no MCLK_x clock which can be output."]
    pub NoDivider: u32,
    #[doc = "< Specifies SAI Block FIFO threshold."]
    #[doc = "This parameter can be a value of @ref SAI_Block_Fifo_Threshold"]
    pub FIFOThreshold: u32,
    #[doc = "< Specifies the audio frequency sampling."]
    #[doc = "This parameter can be a value of @ref SAI_Audio_Frequency"]
    pub AudioFrequency: u32,
    #[doc = "< Specifies the master clock divider."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 63 on STM32L4Rx/STM32L4Sx devices."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 15 on other devices."]
    #[doc = "@note This parameter is used only if AudioFrequency is set to"]
    #[doc = "SAI_AUDIO_FREQUENCY_MCKDIV otherwise it is internally computed."]
    pub Mckdiv: u32,
    #[doc = "< Specifies if the mono or stereo mode is selected."]
    #[doc = "This parameter can be a value of @ref SAI_Mono_Stereo_Mode"]
    pub MonoStereoMode: u32,
    #[doc = "< Specifies the companding mode type."]
    #[doc = "This parameter can be a value of @ref SAI_Block_Companding_Mode"]
    pub CompandingMode: u32,
    #[doc = "< Specifies the companding mode type."]
    #[doc = "This parameter can be a value of @ref SAI_TRIState_Management"]
    pub TriState: u32,
    #[doc = "< Specifies the SAI Block protocol."]
    #[doc = "This parameter can be a value of @ref SAI_Block_Protocol"]
    pub Protocol: u32,
    #[doc = "< Specifies the SAI Block data size."]
    #[doc = "This parameter can be a value of @ref SAI_Block_Data_Size"]
    pub DataSize: u32,
    #[doc = "< Specifies whether data transfers start from MSB or LSB bit."]
    #[doc = "This parameter can be a value of @ref SAI_Block_MSB_LSB_transmission"]
    pub FirstBit: u32,
    #[doc = "< Specifies the SAI Block clock strobing edge sensitivity."]
    #[doc = "This parameter can be a value of @ref SAI_Block_Clock_Strobing"]
    pub ClockStrobing: u32,
}
#[test]
fn bindgen_test_layout_SAI_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SAI_InitTypeDef>(),
        60usize,
        concat!("Size of: ", stringify!(SAI_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SAI_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SAI_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_InitTypeDef>())).AudioMode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_InitTypeDef),
            "::",
            stringify!(AudioMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_InitTypeDef>())).Synchro as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_InitTypeDef),
            "::",
            stringify!(Synchro)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_InitTypeDef>())).SynchroExt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_InitTypeDef),
            "::",
            stringify!(SynchroExt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_InitTypeDef>())).OutputDrive as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_InitTypeDef),
            "::",
            stringify!(OutputDrive)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_InitTypeDef>())).NoDivider as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_InitTypeDef),
            "::",
            stringify!(NoDivider)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_InitTypeDef>())).FIFOThreshold as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_InitTypeDef),
            "::",
            stringify!(FIFOThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_InitTypeDef>())).AudioFrequency as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_InitTypeDef),
            "::",
            stringify!(AudioFrequency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_InitTypeDef>())).Mckdiv as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_InitTypeDef),
            "::",
            stringify!(Mckdiv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_InitTypeDef>())).MonoStereoMode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_InitTypeDef),
            "::",
            stringify!(MonoStereoMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_InitTypeDef>())).CompandingMode as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_InitTypeDef),
            "::",
            stringify!(CompandingMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_InitTypeDef>())).TriState as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_InitTypeDef),
            "::",
            stringify!(TriState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_InitTypeDef>())).Protocol as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_InitTypeDef),
            "::",
            stringify!(Protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_InitTypeDef>())).DataSize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_InitTypeDef),
            "::",
            stringify!(DataSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_InitTypeDef>())).FirstBit as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_InitTypeDef),
            "::",
            stringify!(FirstBit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_InitTypeDef>())).ClockStrobing as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_InitTypeDef),
            "::",
            stringify!(ClockStrobing)
        )
    );
}
#[doc = " @defgroup SAI_Frame_Structure_definition SAI Frame Structure definition"]
#[doc = " @brief  SAI Frame Init structure definition"]
#[doc = " @note   For SPDIF and AC97 protocol, these parameters are not used (set by hardware)."]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SAI_FrameInitTypeDef {
    #[doc = "< Specifies the Frame length, the number of SCK clocks for each audio frame."]
    #[doc = "This parameter must be a number between Min_Data = 8 and Max_Data = 256."]
    #[doc = "@note If master clock MCLK_x pin is declared as an output, the frame length"]
    #[doc = "should be aligned to a number equal to power of 2 in order to keep"]
    #[doc = "in an audio frame, an integer number of MCLK pulses by bit Clock."]
    pub FrameLength: u32,
    #[doc = "< Specifies the Frame synchronization active level length."]
    #[doc = "This Parameter specifies the length in number of bit clock (SCK + 1)"]
    #[doc = "of the active level of FS signal in audio frame."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 128"]
    pub ActiveFrameLength: u32,
    #[doc = "< Specifies the Frame synchronization definition."]
    #[doc = "This parameter can be a value of @ref SAI_Block_FS_Definition"]
    pub FSDefinition: u32,
    #[doc = "< Specifies the Frame synchronization Polarity."]
    #[doc = "This parameter can be a value of @ref SAI_Block_FS_Polarity"]
    pub FSPolarity: u32,
    #[doc = "< Specifies the Frame synchronization Offset."]
    #[doc = "This parameter can be a value of @ref SAI_Block_FS_Offset"]
    pub FSOffset: u32,
}
#[test]
fn bindgen_test_layout_SAI_FrameInitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SAI_FrameInitTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(SAI_FrameInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SAI_FrameInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SAI_FrameInitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SAI_FrameInitTypeDef>())).FrameLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_FrameInitTypeDef),
            "::",
            stringify!(FrameLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SAI_FrameInitTypeDef>())).ActiveFrameLength as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_FrameInitTypeDef),
            "::",
            stringify!(ActiveFrameLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SAI_FrameInitTypeDef>())).FSDefinition as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_FrameInitTypeDef),
            "::",
            stringify!(FSDefinition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SAI_FrameInitTypeDef>())).FSPolarity as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_FrameInitTypeDef),
            "::",
            stringify!(FSPolarity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_FrameInitTypeDef>())).FSOffset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_FrameInitTypeDef),
            "::",
            stringify!(FSOffset)
        )
    );
}
#[doc = " @defgroup SAI_Slot_Structure_definition SAI Slot Structure definition"]
#[doc = " @brief   SAI Block Slot Init Structure definition"]
#[doc = " @note    For SPDIF protocol, these parameters are not used (set by hardware)."]
#[doc = " @note    For AC97 protocol, only SlotActive parameter is used (the others are set by hardware)."]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SAI_SlotInitTypeDef {
    #[doc = "< Specifies the position of first data transfer bit in the slot."]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 24"]
    pub FirstBitOffset: u32,
    #[doc = "< Specifies the Slot Size."]
    #[doc = "This parameter can be a value of @ref SAI_Block_Slot_Size"]
    pub SlotSize: u32,
    #[doc = "< Specifies the number of slot in the audio frame."]
    #[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 16"]
    pub SlotNumber: u32,
    #[doc = "< Specifies the slots in audio frame that will be activated."]
    #[doc = "This parameter can be a value of @ref SAI_Block_Slot_Active"]
    pub SlotActive: u32,
}
#[test]
fn bindgen_test_layout_SAI_SlotInitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SAI_SlotInitTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(SAI_SlotInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SAI_SlotInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SAI_SlotInitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SAI_SlotInitTypeDef>())).FirstBitOffset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_SlotInitTypeDef),
            "::",
            stringify!(FirstBitOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_SlotInitTypeDef>())).SlotSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_SlotInitTypeDef),
            "::",
            stringify!(SlotSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_SlotInitTypeDef>())).SlotNumber as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_SlotInitTypeDef),
            "::",
            stringify!(SlotNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SAI_SlotInitTypeDef>())).SlotActive as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SAI_SlotInitTypeDef),
            "::",
            stringify!(SlotActive)
        )
    );
}
#[doc = " @defgroup SAI_Handle_Structure_definition SAI Handle Structure definition"]
#[doc = " @brief  SAI handle Structure definition"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __SAI_HandleTypeDef {
    #[doc = "< SAI Blockx registers base address"]
    pub Instance: *mut SAI_Block_TypeDef,
    #[doc = "< SAI communication parameters"]
    pub Init: SAI_InitTypeDef,
    #[doc = "< SAI Frame configuration parameters"]
    pub FrameInit: SAI_FrameInitTypeDef,
    #[doc = "< SAI Slot configuration parameters"]
    pub SlotInit: SAI_SlotInitTypeDef,
    #[doc = "< Pointer to SAI transfer Buffer"]
    pub pBuffPtr: *mut u8,
    #[doc = "< SAI transfer size"]
    pub XferSize: u16,
    #[doc = "< SAI transfer counter"]
    pub XferCount: u16,
    #[doc = "< SAI Tx DMA handle parameters"]
    pub hdmatx: *mut DMA_HandleTypeDef,
    #[doc = "< SAI Rx DMA handle parameters"]
    pub hdmarx: *mut DMA_HandleTypeDef,
    #[doc = "< SAI mute callback"]
    pub mutecallback: SAIcallback,
    pub InterruptServiceRoutine:
        ::core::option::Option<unsafe extern "C" fn(hsai: *mut __SAI_HandleTypeDef)>,
    #[doc = "< SAI locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< SAI communication state"]
    pub State: HAL_SAI_StateTypeDef,
    #[doc = "< SAI Error code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout___SAI_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<__SAI_HandleTypeDef>(),
        136usize,
        concat!("Size of: ", stringify!(__SAI_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<__SAI_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(__SAI_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SAI_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SAI_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SAI_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__SAI_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SAI_HandleTypeDef>())).FrameInit as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__SAI_HandleTypeDef),
            "::",
            stringify!(FrameInit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SAI_HandleTypeDef>())).SlotInit as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__SAI_HandleTypeDef),
            "::",
            stringify!(SlotInit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SAI_HandleTypeDef>())).pBuffPtr as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__SAI_HandleTypeDef),
            "::",
            stringify!(pBuffPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SAI_HandleTypeDef>())).XferSize as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__SAI_HandleTypeDef),
            "::",
            stringify!(XferSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SAI_HandleTypeDef>())).XferCount as *const _ as usize },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(__SAI_HandleTypeDef),
            "::",
            stringify!(XferCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SAI_HandleTypeDef>())).hdmatx as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(__SAI_HandleTypeDef),
            "::",
            stringify!(hdmatx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SAI_HandleTypeDef>())).hdmarx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__SAI_HandleTypeDef),
            "::",
            stringify!(hdmarx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SAI_HandleTypeDef>())).mutecallback as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__SAI_HandleTypeDef),
            "::",
            stringify!(mutecallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SAI_HandleTypeDef>())).InterruptServiceRoutine as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__SAI_HandleTypeDef),
            "::",
            stringify!(InterruptServiceRoutine)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SAI_HandleTypeDef>())).Lock as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(__SAI_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SAI_HandleTypeDef>())).State as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__SAI_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SAI_HandleTypeDef>())).ErrorCode as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(__SAI_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl Default for __SAI_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @defgroup SAI_Handle_Structure_definition SAI Handle Structure definition"]
#[doc = " @brief  SAI handle Structure definition"]
#[doc = " @{"]
pub type SAI_HandleTypeDef = __SAI_HandleTypeDef;
extern "C" {
    #[doc = " @addtogroup SAI_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_SAI_InitProtocol(
        hsai: *mut SAI_HandleTypeDef,
        protocol: u32,
        datasize: u32,
        nbslot: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_Init(hsai: *mut SAI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_DeInit(hsai: *mut SAI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_MspInit(hsai: *mut SAI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SAI_MspDeInit(hsai: *mut SAI_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup SAI_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_SAI_Transmit(
        hsai: *mut SAI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_Receive(
        hsai: *mut SAI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_Transmit_IT(
        hsai: *mut SAI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_Receive_IT(
        hsai: *mut SAI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_Transmit_DMA(
        hsai: *mut SAI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_Receive_DMA(
        hsai: *mut SAI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_DMAPause(hsai: *mut SAI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_DMAResume(hsai: *mut SAI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_DMAStop(hsai: *mut SAI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_Abort(hsai: *mut SAI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_EnableTxMuteMode(hsai: *mut SAI_HandleTypeDef, val: u16) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_DisableTxMuteMode(hsai: *mut SAI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_EnableRxMuteMode(
        hsai: *mut SAI_HandleTypeDef,
        callback: SAIcallback,
        counter: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_DisableRxMuteMode(hsai: *mut SAI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SAI_IRQHandler(hsai: *mut SAI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SAI_TxHalfCpltCallback(hsai: *mut SAI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SAI_TxCpltCallback(hsai: *mut SAI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SAI_RxHalfCpltCallback(hsai: *mut SAI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SAI_RxCpltCallback(hsai: *mut SAI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SAI_ErrorCallback(hsai: *mut SAI_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup SAI_Exported_Functions_Group3"]
    #[doc = " @{"]
    pub fn HAL_SAI_GetState(hsai: *mut SAI_HandleTypeDef) -> HAL_SAI_StateTypeDef;
}
extern "C" {
    pub fn HAL_SAI_GetError(hsai: *mut SAI_HandleTypeDef) -> u32;
}
#[doc = "< SD not yet initialized or disabled"]
pub const HAL_SD_StateTypeDef_HAL_SD_STATE_RESET: HAL_SD_StateTypeDef = 0;
#[doc = "< SD initialized and ready for use"]
pub const HAL_SD_StateTypeDef_HAL_SD_STATE_READY: HAL_SD_StateTypeDef = 1;
#[doc = "< SD Timeout state"]
pub const HAL_SD_StateTypeDef_HAL_SD_STATE_TIMEOUT: HAL_SD_StateTypeDef = 2;
#[doc = "< SD process ongoing"]
pub const HAL_SD_StateTypeDef_HAL_SD_STATE_BUSY: HAL_SD_StateTypeDef = 3;
#[doc = "< SD Programming State"]
pub const HAL_SD_StateTypeDef_HAL_SD_STATE_PROGRAMMING: HAL_SD_StateTypeDef = 4;
#[doc = "< SD Receiving State"]
pub const HAL_SD_StateTypeDef_HAL_SD_STATE_RECEIVING: HAL_SD_StateTypeDef = 5;
#[doc = "< SD Transfert State"]
pub const HAL_SD_StateTypeDef_HAL_SD_STATE_TRANSFER: HAL_SD_StateTypeDef = 6;
#[doc = "< SD is in error state"]
pub const HAL_SD_StateTypeDef_HAL_SD_STATE_ERROR: HAL_SD_StateTypeDef = 15;
#[doc = " @defgroup SD_Exported_Types_Group1 SD State enumeration structure"]
#[doc = " @{"]
pub type HAL_SD_StateTypeDef = libc::c_uint;
#[doc = " @defgroup SD_Exported_Types_Group2 SD Card State enumeration structure"]
#[doc = " @{"]
pub type HAL_SD_CardStateTypeDef = u32;
#[doc = " @brief  SD Card Information Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_SD_CardInfoTypeDef {
    #[doc = "< Specifies the card Type"]
    pub CardType: u32,
    #[doc = "< Specifies the card version"]
    pub CardVersion: u32,
    #[doc = "< Specifies the class of the card class"]
    pub Class: u32,
    #[doc = "< Specifies the Relative Card Address"]
    pub RelCardAdd: u32,
    #[doc = "< Specifies the Card Capacity in blocks"]
    pub BlockNbr: u32,
    #[doc = "< Specifies one block size in bytes"]
    pub BlockSize: u32,
    #[doc = "< Specifies the Card logical Capacity in blocks"]
    pub LogBlockNbr: u32,
    #[doc = "< Specifies logical block size in bytes"]
    pub LogBlockSize: u32,
}
#[test]
fn bindgen_test_layout_HAL_SD_CardInfoTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<HAL_SD_CardInfoTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(HAL_SD_CardInfoTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<HAL_SD_CardInfoTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_SD_CardInfoTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardInfoTypeDef>())).CardType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardInfoTypeDef),
            "::",
            stringify!(CardType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardInfoTypeDef>())).CardVersion as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardInfoTypeDef),
            "::",
            stringify!(CardVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_SD_CardInfoTypeDef>())).Class as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardInfoTypeDef),
            "::",
            stringify!(Class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardInfoTypeDef>())).RelCardAdd as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardInfoTypeDef),
            "::",
            stringify!(RelCardAdd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardInfoTypeDef>())).BlockNbr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardInfoTypeDef),
            "::",
            stringify!(BlockNbr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardInfoTypeDef>())).BlockSize as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardInfoTypeDef),
            "::",
            stringify!(BlockSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardInfoTypeDef>())).LogBlockNbr as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardInfoTypeDef),
            "::",
            stringify!(LogBlockNbr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardInfoTypeDef>())).LogBlockSize as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardInfoTypeDef),
            "::",
            stringify!(LogBlockSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SD_HandleTypeDef {
    #[doc = "< SD registers base address"]
    pub Instance: *mut SDMMC_TypeDef,
    #[doc = "< SD required parameters"]
    pub Init: SDMMC_InitTypeDef,
    #[doc = "< SD locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< Pointer to SD Tx transfer Buffer"]
    pub pTxBuffPtr: *mut u8,
    #[doc = "< SD Tx Transfer size"]
    pub TxXferSize: u32,
    #[doc = "< Pointer to SD Rx transfer Buffer"]
    pub pRxBuffPtr: *mut u8,
    #[doc = "< SD Rx Transfer size"]
    pub RxXferSize: u32,
    #[doc = "< SD transfer context"]
    pub Context: u32,
    #[doc = "< SD card State"]
    pub State: HAL_SD_StateTypeDef,
    #[doc = "< SD Card Error codes"]
    pub ErrorCode: u32,
    #[doc = "< SD Tx DMA handle parameters"]
    pub hdmatx: *mut DMA_HandleTypeDef,
    #[doc = "< SD Rx DMA handle parameters"]
    pub hdmarx: *mut DMA_HandleTypeDef,
    #[doc = "< SD Card information"]
    pub SdCard: HAL_SD_CardInfoTypeDef,
    #[doc = "< SD card specific data table"]
    pub CSD: [u32; 4usize],
    #[doc = "< SD card identification number table"]
    pub CID: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_SD_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SD_HandleTypeDef>(),
        132usize,
        concat!("Size of: ", stringify!(SD_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SD_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SD_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SD_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SD_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SD_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SD_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SD_HandleTypeDef>())).Lock as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SD_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SD_HandleTypeDef>())).pTxBuffPtr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SD_HandleTypeDef),
            "::",
            stringify!(pTxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SD_HandleTypeDef>())).TxXferSize as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SD_HandleTypeDef),
            "::",
            stringify!(TxXferSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SD_HandleTypeDef>())).pRxBuffPtr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SD_HandleTypeDef),
            "::",
            stringify!(pRxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SD_HandleTypeDef>())).RxXferSize as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SD_HandleTypeDef),
            "::",
            stringify!(RxXferSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SD_HandleTypeDef>())).Context as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SD_HandleTypeDef),
            "::",
            stringify!(Context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SD_HandleTypeDef>())).State as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SD_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SD_HandleTypeDef>())).ErrorCode as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SD_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SD_HandleTypeDef>())).hdmatx as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SD_HandleTypeDef),
            "::",
            stringify!(hdmatx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SD_HandleTypeDef>())).hdmarx as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SD_HandleTypeDef),
            "::",
            stringify!(hdmarx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SD_HandleTypeDef>())).SdCard as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SD_HandleTypeDef),
            "::",
            stringify!(SdCard)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SD_HandleTypeDef>())).CSD as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(SD_HandleTypeDef),
            "::",
            stringify!(CSD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SD_HandleTypeDef>())).CID as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(SD_HandleTypeDef),
            "::",
            stringify!(CID)
        )
    );
}
impl Default for SD_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @defgroup SD_Exported_Types_Group4 Card Specific Data: CSD Register"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_SD_CardCSDTypeDef {
    #[doc = "< CSD structure"]
    pub CSDStruct: u8,
    #[doc = "< System specification version"]
    pub SysSpecVersion: u8,
    #[doc = "< Reserved"]
    pub Reserved1: u8,
    #[doc = "< Data read access time 1"]
    pub TAAC: u8,
    #[doc = "< Data read access time 2 in CLK cycles"]
    pub NSAC: u8,
    #[doc = "< Max. bus clock frequency"]
    pub MaxBusClkFrec: u8,
    #[doc = "< Card command classes"]
    pub CardComdClasses: u16,
    #[doc = "< Max. read data block length"]
    pub RdBlockLen: u8,
    #[doc = "< Partial blocks for read allowed"]
    pub PartBlockRead: u8,
    #[doc = "< Write block misalignment"]
    pub WrBlockMisalign: u8,
    #[doc = "< Read block misalignment"]
    pub RdBlockMisalign: u8,
    #[doc = "< DSR implemented"]
    pub DSRImpl: u8,
    #[doc = "< Reserved"]
    pub Reserved2: u8,
    #[doc = "< Device Size"]
    pub DeviceSize: u32,
    #[doc = "< Max. read current @ VDD min"]
    pub MaxRdCurrentVDDMin: u8,
    #[doc = "< Max. read current @ VDD max"]
    pub MaxRdCurrentVDDMax: u8,
    #[doc = "< Max. write current @ VDD min"]
    pub MaxWrCurrentVDDMin: u8,
    #[doc = "< Max. write current @ VDD max"]
    pub MaxWrCurrentVDDMax: u8,
    #[doc = "< Device size multiplier"]
    pub DeviceSizeMul: u8,
    #[doc = "< Erase group size"]
    pub EraseGrSize: u8,
    #[doc = "< Erase group size multiplier"]
    pub EraseGrMul: u8,
    #[doc = "< Write protect group size"]
    pub WrProtectGrSize: u8,
    #[doc = "< Write protect group enable"]
    pub WrProtectGrEnable: u8,
    #[doc = "< Manufacturer default ECC"]
    pub ManDeflECC: u8,
    #[doc = "< Write speed factor"]
    pub WrSpeedFact: u8,
    #[doc = "< Max. write data block length"]
    pub MaxWrBlockLen: u8,
    #[doc = "< Partial blocks for write allowed"]
    pub WriteBlockPaPartial: u8,
    #[doc = "< Reserved"]
    pub Reserved3: u8,
    #[doc = "< Content protection application"]
    pub ContentProtectAppli: u8,
    #[doc = "< File format group"]
    pub FileFormatGroup: u8,
    #[doc = "< Copy flag (OTP)"]
    pub CopyFlag: u8,
    #[doc = "< Permanent write protection"]
    pub PermWrProtect: u8,
    #[doc = "< Temporary write protection"]
    pub TempWrProtect: u8,
    #[doc = "< File format"]
    pub FileFormat: u8,
    #[doc = "< ECC code"]
    pub ECC: u8,
    #[doc = "< CSD CRC"]
    pub CSD_CRC: u8,
    #[doc = "< Always 1"]
    pub Reserved4: u8,
}
#[test]
fn bindgen_test_layout_HAL_SD_CardCSDTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<HAL_SD_CardCSDTypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(HAL_SD_CardCSDTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<HAL_SD_CardCSDTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_SD_CardCSDTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).CSDStruct as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(CSDStruct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).SysSpecVersion as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(SysSpecVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).Reserved1 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).TAAC as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(TAAC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).NSAC as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(NSAC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).MaxBusClkFrec as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(MaxBusClkFrec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).CardComdClasses as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(CardComdClasses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).RdBlockLen as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(RdBlockLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).PartBlockRead as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(PartBlockRead)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).WrBlockMisalign as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(WrBlockMisalign)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).RdBlockMisalign as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(RdBlockMisalign)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).DSRImpl as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(DSRImpl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).Reserved2 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).DeviceSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(DeviceSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).MaxRdCurrentVDDMin as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(MaxRdCurrentVDDMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).MaxRdCurrentVDDMax as *const _
                as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(MaxRdCurrentVDDMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).MaxWrCurrentVDDMin as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(MaxWrCurrentVDDMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).MaxWrCurrentVDDMax as *const _
                as usize
        },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(MaxWrCurrentVDDMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).DeviceSizeMul as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(DeviceSizeMul)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).EraseGrSize as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(EraseGrSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).EraseGrMul as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(EraseGrMul)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).WrProtectGrSize as *const _ as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(WrProtectGrSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).WrProtectGrEnable as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(WrProtectGrEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).ManDeflECC as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(ManDeflECC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).WrSpeedFact as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(WrSpeedFact)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).MaxWrBlockLen as *const _ as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(MaxWrBlockLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).WriteBlockPaPartial as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(WriteBlockPaPartial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).Reserved3 as *const _ as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).ContentProtectAppli as *const _
                as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(ContentProtectAppli)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).FileFormatGroup as *const _ as usize
        },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(FileFormatGroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).CopyFlag as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(CopyFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).PermWrProtect as *const _ as usize
        },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(PermWrProtect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).TempWrProtect as *const _ as usize
        },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(TempWrProtect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).FileFormat as *const _ as usize
        },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(FileFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).ECC as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(ECC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).CSD_CRC as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(CSD_CRC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCSDTypeDef>())).Reserved4 as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCSDTypeDef),
            "::",
            stringify!(Reserved4)
        )
    );
}
#[doc = " @defgroup SD_Exported_Types_Group5 Card Identification Data: CID Register"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_SD_CardCIDTypeDef {
    #[doc = "< Manufacturer ID"]
    pub ManufacturerID: u8,
    #[doc = "< OEM/Application ID"]
    pub OEM_AppliID: u16,
    #[doc = "< Product Name part1"]
    pub ProdName1: u32,
    #[doc = "< Product Name part2"]
    pub ProdName2: u8,
    #[doc = "< Product Revision"]
    pub ProdRev: u8,
    #[doc = "< Product Serial Number"]
    pub ProdSN: u32,
    #[doc = "< Reserved1"]
    pub Reserved1: u8,
    #[doc = "< Manufacturing Date"]
    pub ManufactDate: u16,
    #[doc = "< CID CRC"]
    pub CID_CRC: u8,
    #[doc = "< Always 1"]
    pub Reserved2: u8,
}
#[test]
fn bindgen_test_layout_HAL_SD_CardCIDTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<HAL_SD_CardCIDTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(HAL_SD_CardCIDTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<HAL_SD_CardCIDTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_SD_CardCIDTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCIDTypeDef>())).ManufacturerID as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCIDTypeDef),
            "::",
            stringify!(ManufacturerID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCIDTypeDef>())).OEM_AppliID as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCIDTypeDef),
            "::",
            stringify!(OEM_AppliID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCIDTypeDef>())).ProdName1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCIDTypeDef),
            "::",
            stringify!(ProdName1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCIDTypeDef>())).ProdName2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCIDTypeDef),
            "::",
            stringify!(ProdName2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_SD_CardCIDTypeDef>())).ProdRev as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCIDTypeDef),
            "::",
            stringify!(ProdRev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_SD_CardCIDTypeDef>())).ProdSN as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCIDTypeDef),
            "::",
            stringify!(ProdSN)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCIDTypeDef>())).Reserved1 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCIDTypeDef),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCIDTypeDef>())).ManufactDate as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCIDTypeDef),
            "::",
            stringify!(ManufactDate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HAL_SD_CardCIDTypeDef>())).CID_CRC as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCIDTypeDef),
            "::",
            stringify!(CID_CRC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardCIDTypeDef>())).Reserved2 as *const _ as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardCIDTypeDef),
            "::",
            stringify!(Reserved2)
        )
    );
}
#[doc = " @defgroup SD_Exported_Types_Group6 SD Card Status returned by ACMD13"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_SD_CardStatusTypeDef {
    #[doc = "< Shows the currently defined data bus width"]
    pub DataBusWidth: u8,
    #[doc = "< Card is in secured mode of operation"]
    pub SecuredMode: u8,
    #[doc = "< Carries information about card type"]
    pub CardType: u16,
    #[doc = "< Carries information about the capacity of protected area"]
    pub ProtectedAreaSize: u32,
    #[doc = "< Carries information about the speed class of the card"]
    pub SpeedClass: u8,
    #[doc = "< Carries information about the card's performance move"]
    pub PerformanceMove: u8,
    #[doc = "< Carries information about the card's allocation unit size"]
    pub AllocationUnitSize: u8,
    #[doc = "< Determines the number of AUs to be erased in one operation"]
    pub EraseSize: u16,
    #[doc = "< Determines the timeout for any number of AU erase"]
    pub EraseTimeout: u8,
    #[doc = "< Carries information about the erase offset"]
    pub EraseOffset: u8,
}
#[test]
fn bindgen_test_layout_HAL_SD_CardStatusTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<HAL_SD_CardStatusTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(HAL_SD_CardStatusTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<HAL_SD_CardStatusTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_SD_CardStatusTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardStatusTypeDef>())).DataBusWidth as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardStatusTypeDef),
            "::",
            stringify!(DataBusWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardStatusTypeDef>())).SecuredMode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardStatusTypeDef),
            "::",
            stringify!(SecuredMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardStatusTypeDef>())).CardType as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardStatusTypeDef),
            "::",
            stringify!(CardType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardStatusTypeDef>())).ProtectedAreaSize as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardStatusTypeDef),
            "::",
            stringify!(ProtectedAreaSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardStatusTypeDef>())).SpeedClass as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardStatusTypeDef),
            "::",
            stringify!(SpeedClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardStatusTypeDef>())).PerformanceMove as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardStatusTypeDef),
            "::",
            stringify!(PerformanceMove)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardStatusTypeDef>())).AllocationUnitSize as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardStatusTypeDef),
            "::",
            stringify!(AllocationUnitSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardStatusTypeDef>())).EraseSize as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardStatusTypeDef),
            "::",
            stringify!(EraseSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardStatusTypeDef>())).EraseTimeout as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardStatusTypeDef),
            "::",
            stringify!(EraseTimeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HAL_SD_CardStatusTypeDef>())).EraseOffset as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_SD_CardStatusTypeDef),
            "::",
            stringify!(EraseOffset)
        )
    );
}
extern "C" {
    #[doc = " @defgroup SD_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_SD_Init(hsd: *mut SD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_InitCard(hsd: *mut SD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_DeInit(hsd: *mut SD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_MspInit(hsd: *mut SD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SD_MspDeInit(hsd: *mut SD_HandleTypeDef);
}
extern "C" {
    #[doc = " @defgroup SD_Exported_Functions_Group2 Input and Output operation functions"]
    #[doc = " @{"]
    pub fn HAL_SD_ReadBlocks(
        hsd: *mut SD_HandleTypeDef,
        pData: *mut u8,
        BlockAdd: u32,
        NumberOfBlocks: u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_WriteBlocks(
        hsd: *mut SD_HandleTypeDef,
        pData: *mut u8,
        BlockAdd: u32,
        NumberOfBlocks: u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_Erase(
        hsd: *mut SD_HandleTypeDef,
        BlockStartAdd: u32,
        BlockEndAdd: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_ReadBlocks_IT(
        hsd: *mut SD_HandleTypeDef,
        pData: *mut u8,
        BlockAdd: u32,
        NumberOfBlocks: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_WriteBlocks_IT(
        hsd: *mut SD_HandleTypeDef,
        pData: *mut u8,
        BlockAdd: u32,
        NumberOfBlocks: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_ReadBlocks_DMA(
        hsd: *mut SD_HandleTypeDef,
        pData: *mut u8,
        BlockAdd: u32,
        NumberOfBlocks: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_WriteBlocks_DMA(
        hsd: *mut SD_HandleTypeDef,
        pData: *mut u8,
        BlockAdd: u32,
        NumberOfBlocks: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_IRQHandler(hsd: *mut SD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SD_TxCpltCallback(hsd: *mut SD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SD_RxCpltCallback(hsd: *mut SD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SD_ErrorCallback(hsd: *mut SD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SD_AbortCallback(hsd: *mut SD_HandleTypeDef);
}
extern "C" {
    #[doc = " @defgroup SD_Exported_Functions_Group3 Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_SD_ConfigWideBusOperation(
        hsd: *mut SD_HandleTypeDef,
        WideMode: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_ConfigSpeedBusOperation(
        hsd: *mut SD_HandleTypeDef,
        SpeedMode: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup SD_Exported_Functions_Group4 SD card related functions"]
    #[doc = " @{"]
    pub fn HAL_SD_SendSDStatus(
        hsd: *mut SD_HandleTypeDef,
        pSDstatus: *mut u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_GetCardState(hsd: *mut SD_HandleTypeDef) -> HAL_SD_CardStateTypeDef;
}
extern "C" {
    pub fn HAL_SD_GetCardCID(
        hsd: *mut SD_HandleTypeDef,
        pCID: *mut HAL_SD_CardCIDTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_GetCardCSD(
        hsd: *mut SD_HandleTypeDef,
        pCSD: *mut HAL_SD_CardCSDTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_GetCardStatus(
        hsd: *mut SD_HandleTypeDef,
        pStatus: *mut HAL_SD_CardStatusTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_GetCardInfo(
        hsd: *mut SD_HandleTypeDef,
        pCardInfo: *mut HAL_SD_CardInfoTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup SD_Exported_Functions_Group5 Peripheral State and Errors functions"]
    #[doc = " @{"]
    pub fn HAL_SD_GetState(hsd: *mut SD_HandleTypeDef) -> HAL_SD_StateTypeDef;
}
extern "C" {
    pub fn HAL_SD_GetError(hsd: *mut SD_HandleTypeDef) -> u32;
}
extern "C" {
    #[doc = " @defgroup SD_Exported_Functions_Group6 Perioheral Abort management"]
    #[doc = " @{"]
    pub fn HAL_SD_Abort(hsd: *mut SD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SD_Abort_IT(hsd: *mut SD_HandleTypeDef) -> HAL_StatusTypeDef;
}
#[doc = " @brief SMARTCARD Init Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SMARTCARD_InitTypeDef {
    #[doc = "< Configures the SmartCard communication baud rate."]
    #[doc = "The baud rate register is computed using the following formula:"]
    #[doc = "Baud Rate Register = ((usart_ker_ckpres) / ((hsmartcard->Init.BaudRate)))"]
    #[doc = "where usart_ker_ckpres is the USART input clock divided by a prescaler"]
    pub BaudRate: u32,
    #[doc = "< Specifies the number of data bits transmitted or received in a frame."]
    #[doc = "This parameter @ref SMARTCARD_Word_Length can only be set to 9 (8 data + 1 parity bits)."]
    pub WordLength: u32,
    #[doc = "< Specifies the number of stop bits."]
    #[doc = "This parameter can be a value of @ref SMARTCARD_Stop_Bits."]
    pub StopBits: u32,
    #[doc = "< Specifies the parity mode."]
    #[doc = "This parameter can be a value of @ref SMARTCARD_Parity"]
    #[doc = "@note The parity is enabled by default (PCE is forced to 1)."]
    #[doc = "Since the WordLength is forced to 8 bits + parity, M is"]
    #[doc = "forced to 1 and the parity bit is the 9th bit."]
    pub Parity: u16,
    #[doc = "< Specifies whether the Receive or Transmit mode is enabled or disabled."]
    #[doc = "This parameter can be a value of @ref SMARTCARD_Mode"]
    pub Mode: u16,
    #[doc = "< Specifies the steady state of the serial clock."]
    #[doc = "This parameter can be a value of @ref SMARTCARD_Clock_Polarity"]
    pub CLKPolarity: u16,
    #[doc = "< Specifies the clock transition on which the bit capture is made."]
    #[doc = "This parameter can be a value of @ref SMARTCARD_Clock_Phase"]
    pub CLKPhase: u16,
    #[doc = "< Specifies whether the clock pulse corresponding to the last transmitted"]
    #[doc = "data bit (MSB) has to be output on the SCLK pin in synchronous mode."]
    #[doc = "This parameter can be a value of @ref SMARTCARD_Last_Bit"]
    pub CLKLastBit: u16,
    #[doc = "< Specifies whether a single sample or three samples' majority vote is selected."]
    #[doc = "Selecting the single sample method increases the receiver tolerance to clock"]
    #[doc = "deviations. This parameter can be a value of @ref SMARTCARD_OneBit_Sampling."]
    pub OneBitSampling: u16,
    #[doc = "< Specifies the SmartCard Prescaler."]
    #[doc = "This parameter can be any value from 0x01 to 0x1F. Prescaler value is multiplied"]
    #[doc = "by 2 to give the division factor of the source clock frequency"]
    pub Prescaler: u8,
    #[doc = "< Specifies the SmartCard Guard Time applied after stop bits."]
    pub GuardTime: u8,
    #[doc = "< Specifies whether the SmartCard NACK transmission is enabled"]
    #[doc = "in case of parity error."]
    #[doc = "This parameter can be a value of @ref SMARTCARD_NACK_Enable"]
    pub NACKEnable: u16,
    #[doc = "< Specifies whether the receiver timeout is enabled."]
    #[doc = "This parameter can be a value of @ref SMARTCARD_Timeout_Enable"]
    pub TimeOutEnable: u32,
    #[doc = "< Specifies the receiver time out value in number of baud blocks:"]
    #[doc = "it is used to implement the Character Wait Time (CWT) and"]
    #[doc = "Block Wait Time (BWT). It is coded over 24 bits."]
    pub TimeOutValue: u32,
    #[doc = "< Specifies the SmartCard Block Length in T=1 Reception mode."]
    #[doc = "This parameter can be any value from 0x0 to 0xFF"]
    pub BlockLength: u8,
    #[doc = "< Specifies the SmartCard auto-retry count (number of retries in"]
    #[doc = "receive and transmit mode). When set to 0, retransmission is"]
    #[doc = "disabled. Otherwise, its maximum value is 7 (before signalling"]
    #[doc = "an error)"]
    pub AutoRetryCount: u8,
}
#[test]
fn bindgen_test_layout_SMARTCARD_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SMARTCARD_InitTypeDef>(),
        40usize,
        concat!("Size of: ", stringify!(SMARTCARD_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SMARTCARD_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SMARTCARD_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).BaudRate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(BaudRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).WordLength as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(WordLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).StopBits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(StopBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).Parity as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(Parity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).Mode as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).CLKPolarity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(CLKPolarity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).CLKPhase as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(CLKPhase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).CLKLastBit as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(CLKLastBit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).OneBitSampling as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(OneBitSampling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).Prescaler as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).GuardTime as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(GuardTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).NACKEnable as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(NACKEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).TimeOutEnable as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(TimeOutEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).TimeOutValue as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(TimeOutValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).BlockLength as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(BlockLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_InitTypeDef>())).AutoRetryCount as *const _ as usize
        },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_InitTypeDef),
            "::",
            stringify!(AutoRetryCount)
        )
    );
}
#[doc = " @brief  SMARTCARD advanced features initialization structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SMARTCARD_AdvFeatureInitTypeDef {
    #[doc = "< Specifies which advanced SMARTCARD features is initialized. Several"]
    #[doc = "advanced features may be initialized at the same time. This parameter"]
    #[doc = "can be a value of @ref SMARTCARDEx_Advanced_Features_Initialization_Type"]
    pub AdvFeatureInit: u32,
    #[doc = "< Specifies whether the TX pin active level is inverted."]
    #[doc = "This parameter can be a value of @ref SMARTCARD_Tx_Inv"]
    pub TxPinLevelInvert: u32,
    #[doc = "< Specifies whether the RX pin active level is inverted."]
    #[doc = "This parameter can be a value of @ref SMARTCARD_Rx_Inv"]
    pub RxPinLevelInvert: u32,
    #[doc = "< Specifies whether data are inverted (positive/direct logic"]
    #[doc = "vs negative/inverted logic)."]
    #[doc = "This parameter can be a value of @ref SMARTCARD_Data_Inv"]
    pub DataInvert: u32,
    #[doc = "< Specifies whether TX and RX pins are swapped."]
    #[doc = "This parameter can be a value of @ref SMARTCARD_Rx_Tx_Swap"]
    pub Swap: u32,
    #[doc = "< Specifies whether the reception overrun detection is disabled."]
    #[doc = "This parameter can be a value of @ref SMARTCARD_Overrun_Disable"]
    pub OverrunDisable: u32,
    #[doc = "< Specifies whether the DMA is disabled in case of reception error."]
    #[doc = "This parameter can be a value of @ref SMARTCARD_DMA_Disable_on_Rx_Error"]
    pub DMADisableonRxError: u32,
    #[doc = "< Specifies whether MSB is sent first on UART line."]
    #[doc = "This parameter can be a value of @ref SMARTCARD_MSB_First"]
    pub MSBFirst: u32,
    #[doc = "< Specifies which transmission completion indication is used: before (when"]
    #[doc = "relevant flag is available) or once guard time period has elapsed."]
    #[doc = "This parameter can be a value of @ref SMARTCARDEx_Transmission_Completion_Indication."]
    pub TxCompletionIndication: u16,
}
#[test]
fn bindgen_test_layout_SMARTCARD_AdvFeatureInitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SMARTCARD_AdvFeatureInitTypeDef>(),
        36usize,
        concat!("Size of: ", stringify!(SMARTCARD_AdvFeatureInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SMARTCARD_AdvFeatureInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SMARTCARD_AdvFeatureInitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_AdvFeatureInitTypeDef>())).AdvFeatureInit as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_AdvFeatureInitTypeDef),
            "::",
            stringify!(AdvFeatureInit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_AdvFeatureInitTypeDef>())).TxPinLevelInvert
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_AdvFeatureInitTypeDef),
            "::",
            stringify!(TxPinLevelInvert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_AdvFeatureInitTypeDef>())).RxPinLevelInvert
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_AdvFeatureInitTypeDef),
            "::",
            stringify!(RxPinLevelInvert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_AdvFeatureInitTypeDef>())).DataInvert as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_AdvFeatureInitTypeDef),
            "::",
            stringify!(DataInvert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_AdvFeatureInitTypeDef>())).Swap as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_AdvFeatureInitTypeDef),
            "::",
            stringify!(Swap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_AdvFeatureInitTypeDef>())).OverrunDisable as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_AdvFeatureInitTypeDef),
            "::",
            stringify!(OverrunDisable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_AdvFeatureInitTypeDef>())).DMADisableonRxError
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_AdvFeatureInitTypeDef),
            "::",
            stringify!(DMADisableonRxError)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_AdvFeatureInitTypeDef>())).MSBFirst as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_AdvFeatureInitTypeDef),
            "::",
            stringify!(MSBFirst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMARTCARD_AdvFeatureInitTypeDef>())).TxCompletionIndication
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SMARTCARD_AdvFeatureInitTypeDef),
            "::",
            stringify!(TxCompletionIndication)
        )
    );
}
#[doc = " @brief HAL SMARTCARD State definition"]
#[doc = " @note  HAL SMARTCARD State value is a combination of 2 different substates: gState and RxState (see @ref SMARTCARD_State_Definition)."]
#[doc = "        - gState contains SMARTCARD state information related to global Handle management"]
#[doc = "          and also information related to Tx operations."]
#[doc = "          gState value coding follow below described bitmap :"]
#[doc = "          b7-b6  Error information"]
#[doc = "             00 : No Error"]
#[doc = "             01 : (Not Used)"]
#[doc = "             10 : Timeout"]
#[doc = "             11 : Error"]
#[doc = "          b5     Peripheral initialization status"]
#[doc = "             0  : Reset (Peripheral not initialized)"]
#[doc = "             1  : Init done (Peripheral initialized. HAL SMARTCARD Init function already called)"]
#[doc = "          b4-b3  (not used)"]
#[doc = "             xx : Should be set to 00"]
#[doc = "          b2     Intrinsic process state"]
#[doc = "             0  : Ready"]
#[doc = "             1  : Busy (Peripheral busy with some configuration or internal operations)"]
#[doc = "          b1     (not used)"]
#[doc = "             x  : Should be set to 0"]
#[doc = "          b0     Tx state"]
#[doc = "             0  : Ready (no Tx operation ongoing)"]
#[doc = "             1  : Busy (Tx operation ongoing)"]
#[doc = "        - RxState contains information related to Rx operations."]
#[doc = "          RxState value coding follow below described bitmap :"]
#[doc = "          b7-b6  (not used)"]
#[doc = "             xx : Should be set to 00"]
#[doc = "          b5     Peripheral initialization status"]
#[doc = "             0  : Reset (Peripheral not initialized)"]
#[doc = "             1  : Init done (Peripheral initialized)"]
#[doc = "          b4-b2  (not used)"]
#[doc = "            xxx : Should be set to 000"]
#[doc = "          b1     Rx state"]
#[doc = "             0  : Ready (no Rx operation ongoing)"]
#[doc = "             1  : Busy (Rx operation ongoing)"]
#[doc = "          b0     (not used)"]
#[doc = "             x  : Should be set to 0."]
pub type HAL_SMARTCARD_StateTypeDef = u32;
#[doc = " @brief  SMARTCARD handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __SMARTCARD_HandleTypeDef {
    #[doc = "< USART registers base address"]
    pub Instance: *mut USART_TypeDef,
    #[doc = "< SmartCard communication parameters"]
    pub Init: SMARTCARD_InitTypeDef,
    #[doc = "< SmartCard advanced features initialization parameters"]
    pub AdvancedInit: SMARTCARD_AdvFeatureInitTypeDef,
    #[doc = "< Pointer to SmartCard Tx transfer Buffer"]
    pub pTxBuffPtr: *mut u8,
    #[doc = "< SmartCard Tx Transfer size"]
    pub TxXferSize: u16,
    #[doc = "< SmartCard Tx Transfer Counter"]
    pub TxXferCount: u16,
    #[doc = "< Pointer to SmartCard Rx transfer Buffer"]
    pub pRxBuffPtr: *mut u8,
    #[doc = "< SmartCard Rx Transfer size"]
    pub RxXferSize: u16,
    #[doc = "< SmartCard Rx Transfer Counter"]
    pub RxXferCount: u16,
    #[doc = "< Function pointer on Rx IRQ handler"]
    pub RxISR: ::core::option::Option<unsafe extern "C" fn(huart: *mut __SMARTCARD_HandleTypeDef)>,
    #[doc = "< Function pointer on Tx IRQ handler"]
    pub TxISR: ::core::option::Option<unsafe extern "C" fn(huart: *mut __SMARTCARD_HandleTypeDef)>,
    #[doc = "< SmartCard Tx DMA Handle parameters"]
    pub hdmatx: *mut DMA_HandleTypeDef,
    #[doc = "< SmartCard Rx DMA Handle parameters"]
    pub hdmarx: *mut DMA_HandleTypeDef,
    #[doc = "< Locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< SmartCard state information related to global Handle management"]
    #[doc = "and also related to Tx operations."]
    #[doc = "This parameter can be a value of @ref HAL_SMARTCARD_StateTypeDef"]
    pub gState: HAL_SMARTCARD_StateTypeDef,
    #[doc = "< SmartCard state information related to Rx operations."]
    #[doc = "This parameter can be a value of @ref HAL_SMARTCARD_StateTypeDef"]
    pub RxState: HAL_SMARTCARD_StateTypeDef,
    #[doc = "< SmartCard Error code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout___SMARTCARD_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<__SMARTCARD_HandleTypeDef>(),
        128usize,
        concat!("Size of: ", stringify!(__SMARTCARD_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<__SMARTCARD_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(__SMARTCARD_HandleTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).Instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).AdvancedInit as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(AdvancedInit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).pTxBuffPtr as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(pTxBuffPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).TxXferSize as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(TxXferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).TxXferCount as *const _ as usize
        },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(TxXferCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).pRxBuffPtr as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(pRxBuffPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).RxXferSize as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(RxXferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).RxXferCount as *const _ as usize
        },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(RxXferCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).RxISR as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(RxISR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).TxISR as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(TxISR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).hdmatx as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(hdmatx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).hdmarx as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(hdmarx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).Lock as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).gState as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(gState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).RxState as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(RxState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SMARTCARD_HandleTypeDef>())).ErrorCode as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(__SMARTCARD_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl Default for __SMARTCARD_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  SMARTCARD handle Structure definition"]
pub type SMARTCARD_HandleTypeDef = __SMARTCARD_HandleTypeDef;
#[doc = "< PCLK1 clock source"]
pub const SMARTCARD_ClockSourceTypeDef_SMARTCARD_CLOCKSOURCE_PCLK1: SMARTCARD_ClockSourceTypeDef =
    0;
#[doc = "< PCLK2 clock source"]
pub const SMARTCARD_ClockSourceTypeDef_SMARTCARD_CLOCKSOURCE_PCLK2: SMARTCARD_ClockSourceTypeDef =
    1;
#[doc = "< HSI clock source"]
pub const SMARTCARD_ClockSourceTypeDef_SMARTCARD_CLOCKSOURCE_HSI: SMARTCARD_ClockSourceTypeDef = 2;
#[doc = "< SYSCLK clock source"]
pub const SMARTCARD_ClockSourceTypeDef_SMARTCARD_CLOCKSOURCE_SYSCLK: SMARTCARD_ClockSourceTypeDef =
    4;
#[doc = "< LSE clock source"]
pub const SMARTCARD_ClockSourceTypeDef_SMARTCARD_CLOCKSOURCE_LSE: SMARTCARD_ClockSourceTypeDef = 8;
#[doc = "< undefined clock source"]
pub const SMARTCARD_ClockSourceTypeDef_SMARTCARD_CLOCKSOURCE_UNDEFINED:
    SMARTCARD_ClockSourceTypeDef = 16;
#[doc = " @brief  SMARTCARD clock sources"]
pub type SMARTCARD_ClockSourceTypeDef = libc::c_uint;
extern "C" {
    #[doc = " @addtogroup SMARTCARDEx_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_SMARTCARDEx_BlockLength_Config(
        hsmartcard: *mut SMARTCARD_HandleTypeDef,
        BlockLength: u8,
    );
}
extern "C" {
    pub fn HAL_SMARTCARDEx_TimeOut_Config(
        hsmartcard: *mut SMARTCARD_HandleTypeDef,
        TimeOutValue: u32,
    );
}
extern "C" {
    pub fn HAL_SMARTCARDEx_EnableReceiverTimeOut(
        hsmartcard: *mut SMARTCARD_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARDEx_DisableReceiverTimeOut(
        hsmartcard: *mut SMARTCARD_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup SMARTCARD_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_SMARTCARD_Init(hsmartcard: *mut SMARTCARD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARD_DeInit(hsmartcard: *mut SMARTCARD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARD_MspInit(hsmartcard: *mut SMARTCARD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMARTCARD_MspDeInit(hsmartcard: *mut SMARTCARD_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup SMARTCARD_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_SMARTCARD_Transmit(
        hsmartcard: *mut SMARTCARD_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARD_Receive(
        hsmartcard: *mut SMARTCARD_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARD_Transmit_IT(
        hsmartcard: *mut SMARTCARD_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARD_Receive_IT(
        hsmartcard: *mut SMARTCARD_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARD_Transmit_DMA(
        hsmartcard: *mut SMARTCARD_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARD_Receive_DMA(
        hsmartcard: *mut SMARTCARD_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARD_Abort(hsmartcard: *mut SMARTCARD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARD_AbortTransmit(
        hsmartcard: *mut SMARTCARD_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARD_AbortReceive(
        hsmartcard: *mut SMARTCARD_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARD_Abort_IT(hsmartcard: *mut SMARTCARD_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARD_AbortTransmit_IT(
        hsmartcard: *mut SMARTCARD_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARD_AbortReceive_IT(
        hsmartcard: *mut SMARTCARD_HandleTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARD_IRQHandler(hsmartcard: *mut SMARTCARD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMARTCARD_TxCpltCallback(hsmartcard: *mut SMARTCARD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMARTCARD_RxCpltCallback(hsmartcard: *mut SMARTCARD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMARTCARD_ErrorCallback(hsmartcard: *mut SMARTCARD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMARTCARD_AbortCpltCallback(hsmartcard: *mut SMARTCARD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMARTCARD_AbortTransmitCpltCallback(hsmartcard: *mut SMARTCARD_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMARTCARD_AbortReceiveCpltCallback(hsmartcard: *mut SMARTCARD_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup SMARTCARD_Exported_Functions_Group4"]
    #[doc = " @{"]
    pub fn HAL_SMARTCARD_GetState(
        hsmartcard: *mut SMARTCARD_HandleTypeDef,
    ) -> HAL_SMARTCARD_StateTypeDef;
}
extern "C" {
    pub fn HAL_SMARTCARD_GetError(hsmartcard: *mut SMARTCARD_HandleTypeDef) -> u32;
}
extern "C" {
    #[doc = " @addtogroup SMBUSEx_Exported_Functions_Group3 SMBUS Extended FastModePlus Functions"]
    #[doc = " @{"]
    pub fn HAL_SMBUSEx_EnableFastModePlus(ConfigFastModePlus: u32);
}
extern "C" {
    pub fn HAL_SMBUSEx_DisableFastModePlus(ConfigFastModePlus: u32);
}
#[doc = " @defgroup SMBUS_Configuration_Structure_definition SMBUS Configuration Structure definition"]
#[doc = " @brief  SMBUS Configuration Structure definition"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SMBUS_InitTypeDef {
    #[doc = "< Specifies the SMBUS_TIMINGR_register value."]
    #[doc = "This parameter calculated by referring to SMBUS initialization"]
    #[doc = "section in Reference manual"]
    pub Timing: u32,
    #[doc = "< Specifies if Analog Filter is enable or not."]
    #[doc = "This parameter can be a value of @ref SMBUS_Analog_Filter"]
    pub AnalogFilter: u32,
    #[doc = "< Specifies the first device own address."]
    #[doc = "This parameter can be a 7-bit or 10-bit address."]
    pub OwnAddress1: u32,
    #[doc = "< Specifies if 7-bit or 10-bit addressing mode for master is selected."]
    #[doc = "This parameter can be a value of @ref SMBUS_addressing_mode"]
    pub AddressingMode: u32,
    #[doc = "< Specifies if dual addressing mode is selected."]
    #[doc = "This parameter can be a value of @ref SMBUS_dual_addressing_mode"]
    pub DualAddressMode: u32,
    #[doc = "< Specifies the second device own address if dual addressing mode is selected"]
    #[doc = "This parameter can be a 7-bit address."]
    pub OwnAddress2: u32,
    #[doc = "< Specifies the acknowledge mask address second device own address if dual addressing mode is selected"]
    #[doc = "This parameter can be a value of @ref SMBUS_own_address2_masks."]
    pub OwnAddress2Masks: u32,
    #[doc = "< Specifies if general call mode is selected."]
    #[doc = "This parameter can be a value of @ref SMBUS_general_call_addressing_mode."]
    pub GeneralCallMode: u32,
    #[doc = "< Specifies if nostretch mode is selected."]
    #[doc = "This parameter can be a value of @ref SMBUS_nostretch_mode"]
    pub NoStretchMode: u32,
    #[doc = "< Specifies if Packet Error Check mode is selected."]
    #[doc = "This parameter can be a value of @ref SMBUS_packet_error_check_mode"]
    pub PacketErrorCheckMode: u32,
    #[doc = "< Specifies which mode of Periphal is selected."]
    #[doc = "This parameter can be a value of @ref SMBUS_peripheral_mode"]
    pub PeripheralMode: u32,
    #[doc = "< Specifies the content of the 32 Bits SMBUS_TIMEOUT_register value."]
    #[doc = "(Enable bits and different timeout values)"]
    #[doc = "This parameter calculated by referring to SMBUS initialization"]
    #[doc = "section in Reference manual"]
    pub SMBusTimeout: u32,
}
#[test]
fn bindgen_test_layout_SMBUS_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SMBUS_InitTypeDef>(),
        48usize,
        concat!("Size of: ", stringify!(SMBUS_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SMBUS_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SMBUS_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMBUS_InitTypeDef>())).Timing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_InitTypeDef),
            "::",
            stringify!(Timing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMBUS_InitTypeDef>())).AnalogFilter as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_InitTypeDef),
            "::",
            stringify!(AnalogFilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMBUS_InitTypeDef>())).OwnAddress1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_InitTypeDef),
            "::",
            stringify!(OwnAddress1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMBUS_InitTypeDef>())).AddressingMode as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_InitTypeDef),
            "::",
            stringify!(AddressingMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMBUS_InitTypeDef>())).DualAddressMode as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_InitTypeDef),
            "::",
            stringify!(DualAddressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMBUS_InitTypeDef>())).OwnAddress2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_InitTypeDef),
            "::",
            stringify!(OwnAddress2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMBUS_InitTypeDef>())).OwnAddress2Masks as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_InitTypeDef),
            "::",
            stringify!(OwnAddress2Masks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMBUS_InitTypeDef>())).GeneralCallMode as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_InitTypeDef),
            "::",
            stringify!(GeneralCallMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMBUS_InitTypeDef>())).NoStretchMode as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_InitTypeDef),
            "::",
            stringify!(NoStretchMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMBUS_InitTypeDef>())).PacketErrorCheckMode as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_InitTypeDef),
            "::",
            stringify!(PacketErrorCheckMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMBUS_InitTypeDef>())).PeripheralMode as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_InitTypeDef),
            "::",
            stringify!(PeripheralMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMBUS_InitTypeDef>())).SMBusTimeout as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_InitTypeDef),
            "::",
            stringify!(SMBusTimeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMBUS_HandleTypeDef {
    #[doc = "< SMBUS registers base address"]
    pub Instance: *mut I2C_TypeDef,
    #[doc = "< SMBUS communication parameters"]
    pub Init: SMBUS_InitTypeDef,
    #[doc = "< Pointer to SMBUS transfer buffer"]
    pub pBuffPtr: *mut u8,
    #[doc = "< SMBUS transfer size"]
    pub XferSize: u16,
    #[doc = "< SMBUS transfer counter"]
    pub XferCount: u16,
    #[doc = "< SMBUS transfer options"]
    pub XferOptions: u32,
    #[doc = "< SMBUS communication Previous state"]
    pub PreviousState: u32,
    #[doc = "< SMBUS locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< SMBUS communication state"]
    pub State: u32,
    #[doc = "< SMBUS Error code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout_SMBUS_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SMBUS_HandleTypeDef>(),
        80usize,
        concat!("Size of: ", stringify!(SMBUS_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SMBUS_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SMBUS_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMBUS_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMBUS_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMBUS_HandleTypeDef>())).pBuffPtr as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_HandleTypeDef),
            "::",
            stringify!(pBuffPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMBUS_HandleTypeDef>())).XferSize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_HandleTypeDef),
            "::",
            stringify!(XferSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMBUS_HandleTypeDef>())).XferCount as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_HandleTypeDef),
            "::",
            stringify!(XferCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMBUS_HandleTypeDef>())).XferOptions as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_HandleTypeDef),
            "::",
            stringify!(XferOptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SMBUS_HandleTypeDef>())).PreviousState as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_HandleTypeDef),
            "::",
            stringify!(PreviousState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMBUS_HandleTypeDef>())).Lock as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMBUS_HandleTypeDef>())).State as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SMBUS_HandleTypeDef>())).ErrorCode as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SMBUS_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl Default for SMBUS_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @addtogroup SMBUS_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_SMBUS_Init(hsmbus: *mut SMBUS_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMBUS_DeInit(hsmbus: *mut SMBUS_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMBUS_MspInit(hsmbus: *mut SMBUS_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMBUS_MspDeInit(hsmbus: *mut SMBUS_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMBUS_ConfigAnalogFilter(
        hsmbus: *mut SMBUS_HandleTypeDef,
        AnalogFilter: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMBUS_ConfigDigitalFilter(
        hsmbus: *mut SMBUS_HandleTypeDef,
        DigitalFilter: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup Blocking_mode_Polling Blocking mode Polling"]
    #[doc = " @{"]
    pub fn HAL_SMBUS_IsDeviceReady(
        hsmbus: *mut SMBUS_HandleTypeDef,
        DevAddress: u16,
        Trials: u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup Non-Blocking_mode_Interrupt Non-Blocking mode Interrupt"]
    #[doc = " @{"]
    pub fn HAL_SMBUS_Master_Transmit_IT(
        hsmbus: *mut SMBUS_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMBUS_Master_Receive_IT(
        hsmbus: *mut SMBUS_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMBUS_Master_Abort_IT(
        hsmbus: *mut SMBUS_HandleTypeDef,
        DevAddress: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMBUS_Slave_Transmit_IT(
        hsmbus: *mut SMBUS_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMBUS_Slave_Receive_IT(
        hsmbus: *mut SMBUS_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMBUS_EnableAlert_IT(hsmbus: *mut SMBUS_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMBUS_DisableAlert_IT(hsmbus: *mut SMBUS_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMBUS_EnableListen_IT(hsmbus: *mut SMBUS_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SMBUS_DisableListen_IT(hsmbus: *mut SMBUS_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup SMBUS_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks"]
    #[doc = " @{"]
    pub fn HAL_SMBUS_EV_IRQHandler(hsmbus: *mut SMBUS_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMBUS_ER_IRQHandler(hsmbus: *mut SMBUS_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMBUS_MasterTxCpltCallback(hsmbus: *mut SMBUS_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMBUS_MasterRxCpltCallback(hsmbus: *mut SMBUS_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMBUS_SlaveTxCpltCallback(hsmbus: *mut SMBUS_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMBUS_SlaveRxCpltCallback(hsmbus: *mut SMBUS_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMBUS_AddrCallback(
        hsmbus: *mut SMBUS_HandleTypeDef,
        TransferDirection: u8,
        AddrMatchCode: u16,
    );
}
extern "C" {
    pub fn HAL_SMBUS_ListenCpltCallback(hsmbus: *mut SMBUS_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SMBUS_ErrorCallback(hsmbus: *mut SMBUS_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup SMBUS_Exported_Functions_Group3 Peripheral State and Errors functions"]
    #[doc = "  @{"]
    pub fn HAL_SMBUS_GetState(hsmbus: *mut SMBUS_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_SMBUS_GetError(hsmbus: *mut SMBUS_HandleTypeDef) -> u32;
}
#[doc = " @brief  SPI Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SPI_InitTypeDef {
    #[doc = "< Specifies the SPI operating mode."]
    #[doc = "This parameter can be a value of @ref SPI_Mode"]
    pub Mode: u32,
    #[doc = "< Specifies the SPI bidirectional mode state."]
    #[doc = "This parameter can be a value of @ref SPI_Direction"]
    pub Direction: u32,
    #[doc = "< Specifies the SPI data size."]
    #[doc = "This parameter can be a value of @ref SPI_Data_Size"]
    pub DataSize: u32,
    #[doc = "< Specifies the serial clock steady state."]
    #[doc = "This parameter can be a value of @ref SPI_Clock_Polarity"]
    pub CLKPolarity: u32,
    #[doc = "< Specifies the clock active edge for the bit capture."]
    #[doc = "This parameter can be a value of @ref SPI_Clock_Phase"]
    pub CLKPhase: u32,
    #[doc = "< Specifies whether the NSS signal is managed by"]
    #[doc = "hardware (NSS pin) or by software using the SSI bit."]
    #[doc = "This parameter can be a value of @ref SPI_Slave_Select_management"]
    pub NSS: u32,
    #[doc = "< Specifies the Baud Rate prescaler value which will be"]
    #[doc = "used to configure the transmit and receive SCK clock."]
    #[doc = "This parameter can be a value of @ref SPI_BaudRate_Prescaler"]
    #[doc = "@note The communication clock is derived from the master"]
    #[doc = "clock. The slave clock does not need to be set."]
    pub BaudRatePrescaler: u32,
    #[doc = "< Specifies whether data transfers start from MSB or LSB bit."]
    #[doc = "This parameter can be a value of @ref SPI_MSB_LSB_transmission"]
    pub FirstBit: u32,
    #[doc = "< Specifies if the TI mode is enabled or not."]
    #[doc = "This parameter can be a value of @ref SPI_TI_mode"]
    pub TIMode: u32,
    #[doc = "< Specifies if the CRC calculation is enabled or not."]
    #[doc = "This parameter can be a value of @ref SPI_CRC_Calculation"]
    pub CRCCalculation: u32,
    #[doc = "< Specifies the polynomial used for the CRC calculation."]
    #[doc = "This parameter must be an odd number between Min_Data = 1 and Max_Data = 65535"]
    pub CRCPolynomial: u32,
    #[doc = "< Specifies the CRC Length used for the CRC calculation."]
    #[doc = "CRC Length is only used with Data8 and Data16, not other data size"]
    #[doc = "This parameter can be a value of @ref SPI_CRC_length"]
    pub CRCLength: u32,
    #[doc = "< Specifies whether the NSSP signal is enabled or not ."]
    #[doc = "This parameter can be a value of @ref SPI_NSSP_Mode"]
    #[doc = "This mode is activated by the NSSP bit in the SPIx_CR2 register and"]
    #[doc = "it takes effect only if the SPI interface is configured as Motorola SPI"]
    #[doc = "master (FRF=0) with capture on the first edge (SPIx_CR1 CPHA = 0,"]
    #[doc = "CPOL setting is ignored).."]
    pub NSSPMode: u32,
}
#[test]
fn bindgen_test_layout_SPI_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SPI_InitTypeDef>(),
        52usize,
        concat!("Size of: ", stringify!(SPI_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SPI_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SPI_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_InitTypeDef>())).Mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_InitTypeDef>())).Direction as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(Direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_InitTypeDef>())).DataSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(DataSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_InitTypeDef>())).CLKPolarity as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(CLKPolarity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_InitTypeDef>())).CLKPhase as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(CLKPhase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_InitTypeDef>())).NSS as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(NSS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SPI_InitTypeDef>())).BaudRatePrescaler as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(BaudRatePrescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_InitTypeDef>())).FirstBit as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(FirstBit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_InitTypeDef>())).TIMode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(TIMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_InitTypeDef>())).CRCCalculation as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(CRCCalculation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_InitTypeDef>())).CRCPolynomial as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(CRCPolynomial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_InitTypeDef>())).CRCLength as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(CRCLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SPI_InitTypeDef>())).NSSPMode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(NSSPMode)
        )
    );
}
#[doc = "< Peripheral not Initialized"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_RESET: HAL_SPI_StateTypeDef = 0;
#[doc = "< Peripheral Initialized and ready for use"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_READY: HAL_SPI_StateTypeDef = 1;
#[doc = "< an internal process is ongoing"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_BUSY: HAL_SPI_StateTypeDef = 2;
#[doc = "< Data Transmission process is ongoing"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_BUSY_TX: HAL_SPI_StateTypeDef = 3;
#[doc = "< Data Reception process is ongoing"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_BUSY_RX: HAL_SPI_StateTypeDef = 4;
#[doc = "< Data Transmission and Reception process is ongoing"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_BUSY_TX_RX: HAL_SPI_StateTypeDef = 5;
#[doc = "< SPI error state"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_ERROR: HAL_SPI_StateTypeDef = 6;
#[doc = "< SPI abort is ongoing"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_ABORT: HAL_SPI_StateTypeDef = 7;
#[doc = " @brief  HAL SPI State structure definition"]
pub type HAL_SPI_StateTypeDef = libc::c_uint;
#[doc = " @brief  SPI handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __SPI_HandleTypeDef {
    #[doc = "< SPI registers base address"]
    pub Instance: *mut SPI_TypeDef,
    #[doc = "< SPI communication parameters"]
    pub Init: SPI_InitTypeDef,
    #[doc = "< Pointer to SPI Tx transfer Buffer"]
    pub pTxBuffPtr: *mut u8,
    #[doc = "< SPI Tx Transfer size"]
    pub TxXferSize: u16,
    #[doc = "< SPI Tx Transfer Counter"]
    pub TxXferCount: u16,
    #[doc = "< Pointer to SPI Rx transfer Buffer"]
    pub pRxBuffPtr: *mut u8,
    #[doc = "< SPI Rx Transfer size"]
    pub RxXferSize: u16,
    #[doc = "< SPI Rx Transfer Counter"]
    pub RxXferCount: u16,
    #[doc = "< SPI CRC size used for the transfer"]
    pub CRCSize: u32,
    #[doc = "< function pointer on Rx ISR"]
    pub RxISR: ::core::option::Option<unsafe extern "C" fn(hspi: *mut __SPI_HandleTypeDef)>,
    #[doc = "< function pointer on Tx ISR"]
    pub TxISR: ::core::option::Option<unsafe extern "C" fn(hspi: *mut __SPI_HandleTypeDef)>,
    #[doc = "< SPI Tx DMA Handle parameters"]
    pub hdmatx: *mut DMA_HandleTypeDef,
    #[doc = "< SPI Rx DMA Handle parameters"]
    pub hdmarx: *mut DMA_HandleTypeDef,
    #[doc = "< Locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< SPI communication state"]
    pub State: HAL_SPI_StateTypeDef,
    #[doc = "< SPI Error code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout___SPI_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<__SPI_HandleTypeDef>(),
        104usize,
        concat!("Size of: ", stringify!(__SPI_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<__SPI_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(__SPI_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).pTxBuffPtr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(pTxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).TxXferSize as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(TxXferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).TxXferCount as *const _ as usize
        },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(TxXferCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).pRxBuffPtr as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(pRxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).RxXferSize as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(RxXferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).RxXferCount as *const _ as usize
        },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(RxXferCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).CRCSize as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(CRCSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).RxISR as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(RxISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).TxISR as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(TxISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).hdmatx as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(hdmatx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).hdmarx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(hdmarx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).Lock as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).State as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__SPI_HandleTypeDef>())).ErrorCode as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl Default for __SPI_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  SPI handle Structure definition"]
pub type SPI_HandleTypeDef = __SPI_HandleTypeDef;
extern "C" {
    #[doc = " @addtogroup SPIEx_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_SPIEx_FlushRxFifo(hspi: *mut SPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup SPI_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_SPI_Init(hspi: *mut SPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_DeInit(hspi: *mut SPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_MspInit(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_MspDeInit(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup SPI_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_SPI_Transmit(
        hspi: *mut SPI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_Receive(
        hspi: *mut SPI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_TransmitReceive(
        hspi: *mut SPI_HandleTypeDef,
        pTxData: *mut u8,
        pRxData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_Transmit_IT(
        hspi: *mut SPI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_Receive_IT(
        hspi: *mut SPI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_TransmitReceive_IT(
        hspi: *mut SPI_HandleTypeDef,
        pTxData: *mut u8,
        pRxData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_Transmit_DMA(
        hspi: *mut SPI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_Receive_DMA(
        hspi: *mut SPI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_TransmitReceive_DMA(
        hspi: *mut SPI_HandleTypeDef,
        pTxData: *mut u8,
        pRxData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_DMAPause(hspi: *mut SPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_DMAResume(hspi: *mut SPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_DMAStop(hspi: *mut SPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_Abort(hspi: *mut SPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_Abort_IT(hspi: *mut SPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_IRQHandler(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_TxCpltCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_RxCpltCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_TxRxCpltCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_TxHalfCpltCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_RxHalfCpltCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_TxRxHalfCpltCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_ErrorCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_AbortCpltCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup SPI_Exported_Functions_Group3"]
    #[doc = " @{"]
    pub fn HAL_SPI_GetState(hspi: *mut SPI_HandleTypeDef) -> HAL_SPI_StateTypeDef;
}
extern "C" {
    pub fn HAL_SPI_GetError(hspi: *mut SPI_HandleTypeDef) -> u32;
}
#[doc = "< SRAM not yet initialized or disabled"]
pub const HAL_SRAM_StateTypeDef_HAL_SRAM_STATE_RESET: HAL_SRAM_StateTypeDef = 0;
#[doc = "< SRAM initialized and ready for use"]
pub const HAL_SRAM_StateTypeDef_HAL_SRAM_STATE_READY: HAL_SRAM_StateTypeDef = 1;
#[doc = "< SRAM internal process is ongoing"]
pub const HAL_SRAM_StateTypeDef_HAL_SRAM_STATE_BUSY: HAL_SRAM_StateTypeDef = 2;
#[doc = "< SRAM error state"]
pub const HAL_SRAM_StateTypeDef_HAL_SRAM_STATE_ERROR: HAL_SRAM_StateTypeDef = 3;
#[doc = "< SRAM peripheral NORSRAM device write protected"]
pub const HAL_SRAM_StateTypeDef_HAL_SRAM_STATE_PROTECTED: HAL_SRAM_StateTypeDef = 4;
#[doc = " @defgroup SRAM_Exported_Types SRAM Exported Types"]
#[doc = " @{"]
#[doc = " @brief  HAL SRAM State structures definition"]
pub type HAL_SRAM_StateTypeDef = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SRAM_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut FMC_Bank1_TypeDef,
    #[doc = "< Extended mode register base address"]
    pub Extended: *mut FMC_Bank1E_TypeDef,
    #[doc = "< SRAM device control configuration parameters"]
    pub Init: FMC_NORSRAM_InitTypeDef,
    #[doc = "< SRAM locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< SRAM device access state"]
    pub State: HAL_SRAM_StateTypeDef,
    #[doc = "< Pointer DMA handler"]
    pub hdma: *mut DMA_HandleTypeDef,
}
#[test]
fn bindgen_test_layout_SRAM_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SRAM_HandleTypeDef>(),
        84usize,
        concat!("Size of: ", stringify!(SRAM_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SRAM_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SRAM_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SRAM_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SRAM_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SRAM_HandleTypeDef>())).Extended as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SRAM_HandleTypeDef),
            "::",
            stringify!(Extended)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SRAM_HandleTypeDef>())).Init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SRAM_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SRAM_HandleTypeDef>())).Lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SRAM_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SRAM_HandleTypeDef>())).State as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SRAM_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SRAM_HandleTypeDef>())).hdma as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SRAM_HandleTypeDef),
            "::",
            stringify!(hdma)
        )
    );
}
impl Default for SRAM_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @addtogroup SRAM_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_SRAM_Init(
        hsram: *mut SRAM_HandleTypeDef,
        Timing: *mut FMC_NORSRAM_TimingTypeDef,
        ExtTiming: *mut FMC_NORSRAM_TimingTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SRAM_DeInit(hsram: *mut SRAM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SRAM_MspInit(hsram: *mut SRAM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SRAM_MspDeInit(hsram: *mut SRAM_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup SRAM_Exported_Functions_Group2 Input Output and memory control functions"]
    #[doc = " @{"]
    pub fn HAL_SRAM_Read_8b(
        hsram: *mut SRAM_HandleTypeDef,
        pAddress: *mut u32,
        pDstBuffer: *mut u8,
        BufferSize: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SRAM_Write_8b(
        hsram: *mut SRAM_HandleTypeDef,
        pAddress: *mut u32,
        pSrcBuffer: *mut u8,
        BufferSize: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SRAM_Read_16b(
        hsram: *mut SRAM_HandleTypeDef,
        pAddress: *mut u32,
        pDstBuffer: *mut u16,
        BufferSize: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SRAM_Write_16b(
        hsram: *mut SRAM_HandleTypeDef,
        pAddress: *mut u32,
        pSrcBuffer: *mut u16,
        BufferSize: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SRAM_Read_32b(
        hsram: *mut SRAM_HandleTypeDef,
        pAddress: *mut u32,
        pDstBuffer: *mut u32,
        BufferSize: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SRAM_Write_32b(
        hsram: *mut SRAM_HandleTypeDef,
        pAddress: *mut u32,
        pSrcBuffer: *mut u32,
        BufferSize: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SRAM_Read_DMA(
        hsram: *mut SRAM_HandleTypeDef,
        pAddress: *mut u32,
        pDstBuffer: *mut u32,
        BufferSize: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SRAM_Write_DMA(
        hsram: *mut SRAM_HandleTypeDef,
        pAddress: *mut u32,
        pSrcBuffer: *mut u32,
        BufferSize: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SRAM_DMA_XferCpltCallback(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SRAM_DMA_XferErrorCallback(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup SRAM_Exported_Functions_Group3 Control functions"]
    #[doc = " @{"]
    pub fn HAL_SRAM_WriteOperation_Enable(hsram: *mut SRAM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SRAM_WriteOperation_Disable(hsram: *mut SRAM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup SRAM_Exported_Functions_Group4 Peripheral State functions"]
    #[doc = " @{"]
    pub fn HAL_SRAM_GetState(hsram: *mut SRAM_HandleTypeDef) -> HAL_SRAM_StateTypeDef;
}
#[doc = " @brief SWPMI Init Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SWPMI_InitTypeDef {
    #[doc = "< Specifies the SWP Voltage Class."]
    #[doc = "This parameter can be a value of @ref SWPMI_Voltage_Class"]
    pub VoltageClass: u32,
    #[doc = "< Specifies the SWPMI Bitrate."]
    #[doc = "This parameter must be a number between 0 and 63U."]
    #[doc = "The Bitrate is computed using the following formula:"]
    #[doc = "SWPMI_freq = SWPMI_clk / (((BitRate) + 1)  * 4)"]
    pub BitRate: u32,
    #[doc = "< Specifies the transmission buffering mode."]
    #[doc = "This parameter can be a value of @ref SWPMI_Tx_Buffering_Mode"]
    pub TxBufferingMode: u32,
    #[doc = "< Specifies the reception buffering mode."]
    #[doc = "This parameter can be a value of @ref SWPMI_Rx_Buffering_Mode"]
    pub RxBufferingMode: u32,
}
#[test]
fn bindgen_test_layout_SWPMI_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SWPMI_InitTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(SWPMI_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SWPMI_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SWPMI_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_InitTypeDef>())).VoltageClass as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_InitTypeDef),
            "::",
            stringify!(VoltageClass)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_InitTypeDef>())).BitRate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_InitTypeDef),
            "::",
            stringify!(BitRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SWPMI_InitTypeDef>())).TxBufferingMode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_InitTypeDef),
            "::",
            stringify!(TxBufferingMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SWPMI_InitTypeDef>())).RxBufferingMode as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_InitTypeDef),
            "::",
            stringify!(RxBufferingMode)
        )
    );
}
#[doc = "< Peripheral Reset state"]
pub const HAL_SWPMI_StateTypeDef_HAL_SWPMI_STATE_RESET: HAL_SWPMI_StateTypeDef = 0;
#[doc = "< Peripheral Initialized and ready for use"]
pub const HAL_SWPMI_StateTypeDef_HAL_SWPMI_STATE_READY: HAL_SWPMI_StateTypeDef = 1;
#[doc = "< an internal process is ongoing"]
pub const HAL_SWPMI_StateTypeDef_HAL_SWPMI_STATE_BUSY: HAL_SWPMI_StateTypeDef = 2;
#[doc = "< Data Transmission process is ongoing"]
pub const HAL_SWPMI_StateTypeDef_HAL_SWPMI_STATE_BUSY_TX: HAL_SWPMI_StateTypeDef = 18;
#[doc = "< Data Reception process is ongoing"]
pub const HAL_SWPMI_StateTypeDef_HAL_SWPMI_STATE_BUSY_RX: HAL_SWPMI_StateTypeDef = 34;
#[doc = "< Data Transmission and Reception process is ongoing"]
pub const HAL_SWPMI_StateTypeDef_HAL_SWPMI_STATE_BUSY_TX_RX: HAL_SWPMI_StateTypeDef = 50;
#[doc = "< Timeout state"]
pub const HAL_SWPMI_StateTypeDef_HAL_SWPMI_STATE_TIMEOUT: HAL_SWPMI_StateTypeDef = 3;
#[doc = "< Error"]
pub const HAL_SWPMI_StateTypeDef_HAL_SWPMI_STATE_ERROR: HAL_SWPMI_StateTypeDef = 4;
#[doc = " @brief HAL SWPMI State structures definition"]
pub type HAL_SWPMI_StateTypeDef = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SWPMI_HandleTypeDef {
    #[doc = "< SWPMI registers base address"]
    pub Instance: *mut SWPMI_TypeDef,
    #[doc = "< SWPMI communication parameters"]
    pub Init: SWPMI_InitTypeDef,
    #[doc = "< Pointer to SWPMI Tx transfer Buffer"]
    pub pTxBuffPtr: *mut u32,
    #[doc = "< SWPMI Tx Transfer size"]
    pub TxXferSize: u32,
    #[doc = "< SWPMI Tx Transfer Counter"]
    pub TxXferCount: u32,
    #[doc = "< Pointer to SWPMI Rx transfer Buffer"]
    pub pRxBuffPtr: *mut u32,
    #[doc = "< SWPMI Rx Transfer size"]
    pub RxXferSize: u32,
    #[doc = "< SWPMI Rx Transfer Counter"]
    pub RxXferCount: u32,
    #[doc = "< SWPMI Tx DMA Handle parameters"]
    pub hdmatx: *mut DMA_HandleTypeDef,
    #[doc = "< SWPMI Rx DMA Handle parameters"]
    pub hdmarx: *mut DMA_HandleTypeDef,
    #[doc = "< SWPMI object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< SWPMI communication state"]
    pub State: HAL_SWPMI_StateTypeDef,
    #[doc = "< SWPMI Error code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout_SWPMI_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<SWPMI_HandleTypeDef>(),
        64usize,
        concat!("Size of: ", stringify!(SWPMI_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SWPMI_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SWPMI_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_HandleTypeDef>())).pTxBuffPtr as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_HandleTypeDef),
            "::",
            stringify!(pTxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_HandleTypeDef>())).TxXferSize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_HandleTypeDef),
            "::",
            stringify!(TxXferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SWPMI_HandleTypeDef>())).TxXferCount as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_HandleTypeDef),
            "::",
            stringify!(TxXferCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_HandleTypeDef>())).pRxBuffPtr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_HandleTypeDef),
            "::",
            stringify!(pRxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_HandleTypeDef>())).RxXferSize as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_HandleTypeDef),
            "::",
            stringify!(RxXferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SWPMI_HandleTypeDef>())).RxXferCount as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_HandleTypeDef),
            "::",
            stringify!(RxXferCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_HandleTypeDef>())).hdmatx as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_HandleTypeDef),
            "::",
            stringify!(hdmatx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_HandleTypeDef>())).hdmarx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_HandleTypeDef),
            "::",
            stringify!(hdmarx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_HandleTypeDef>())).Lock as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_HandleTypeDef>())).State as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SWPMI_HandleTypeDef>())).ErrorCode as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SWPMI_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl Default for SWPMI_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @defgroup SWPMI_Exported_Functions SWPMI Exported Functions"]
    #[doc = " @{"]
    pub fn HAL_SWPMI_Init(hswpmi: *mut SWPMI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SWPMI_DeInit(hswpmi: *mut SWPMI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SWPMI_MspInit(hswpmi: *mut SWPMI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SWPMI_MspDeInit(hswpmi: *mut SWPMI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SWPMI_Transmit(
        hswpmi: *mut SWPMI_HandleTypeDef,
        pData: *mut u32,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SWPMI_Receive(
        hswpmi: *mut SWPMI_HandleTypeDef,
        pData: *mut u32,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SWPMI_Transmit_IT(
        hswpmi: *mut SWPMI_HandleTypeDef,
        pData: *mut u32,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SWPMI_Receive_IT(
        hswpmi: *mut SWPMI_HandleTypeDef,
        pData: *mut u32,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SWPMI_Transmit_DMA(
        hswpmi: *mut SWPMI_HandleTypeDef,
        pData: *mut u32,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SWPMI_Receive_DMA(
        hswpmi: *mut SWPMI_HandleTypeDef,
        pData: *mut u32,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SWPMI_DMAStop(hswpmi: *mut SWPMI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SWPMI_EnableLoopback(hswpmi: *mut SWPMI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SWPMI_DisableLoopback(hswpmi: *mut SWPMI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SWPMI_IRQHandler(hswpmi: *mut SWPMI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SWPMI_TxCpltCallback(hswpmi: *mut SWPMI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SWPMI_TxHalfCpltCallback(hswpmi: *mut SWPMI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SWPMI_RxCpltCallback(hswpmi: *mut SWPMI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SWPMI_RxHalfCpltCallback(hswpmi: *mut SWPMI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SWPMI_ErrorCallback(hswpmi: *mut SWPMI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SWPMI_GetState(hswpmi: *mut SWPMI_HandleTypeDef) -> HAL_SWPMI_StateTypeDef;
}
extern "C" {
    pub fn HAL_SWPMI_GetError(hswpmi: *mut SWPMI_HandleTypeDef) -> u32;
}
#[doc = " @brief  TIM Time base Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TIM_Base_InitTypeDef {
    #[doc = "< Specifies the prescaler value used to divide the TIM clock."]
    #[doc = "This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF"]
    pub Prescaler: u32,
    #[doc = "< Specifies the counter mode."]
    #[doc = "This parameter can be a value of @ref TIM_Counter_Mode"]
    pub CounterMode: u32,
    #[doc = "< Specifies the period value to be loaded into the active"]
    #[doc = "Auto-Reload Register at the next update event."]
    #[doc = "This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF."]
    pub Period: u32,
    #[doc = "< Specifies the clock division."]
    #[doc = "This parameter can be a value of @ref TIM_ClockDivision"]
    pub ClockDivision: u32,
    #[doc = "< Specifies the repetition counter value. Each time the RCR downcounter"]
    #[doc = "reaches zero, an update event is generated and counting restarts"]
    #[doc = "from the RCR value (N)."]
    #[doc = "This means in PWM mode that (N+1) corresponds to:"]
    #[doc = "- the number of PWM periods in edge-aligned mode"]
    #[doc = "- the number of half PWM period in center-aligned mode"]
    #[doc = "GP timers: this parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF."]
    #[doc = "Advanced timers: this parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF."]
    pub RepetitionCounter: u32,
    #[doc = "< Specifies the auto-reload preload."]
    #[doc = "This parameter can be a value of @ref TIM_AutoReloadPreload"]
    pub AutoReloadPreload: u32,
}
#[test]
fn bindgen_test_layout_TIM_Base_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TIM_Base_InitTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(TIM_Base_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_Base_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_Base_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_Base_InitTypeDef>())).Prescaler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Base_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_Base_InitTypeDef>())).CounterMode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Base_InitTypeDef),
            "::",
            stringify!(CounterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_Base_InitTypeDef>())).Period as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Base_InitTypeDef),
            "::",
            stringify!(Period)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_Base_InitTypeDef>())).ClockDivision as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Base_InitTypeDef),
            "::",
            stringify!(ClockDivision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_Base_InitTypeDef>())).RepetitionCounter as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Base_InitTypeDef),
            "::",
            stringify!(RepetitionCounter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_Base_InitTypeDef>())).AutoReloadPreload as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Base_InitTypeDef),
            "::",
            stringify!(AutoReloadPreload)
        )
    );
}
#[doc = " @brief  TIM Output Compare Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TIM_OC_InitTypeDef {
    #[doc = "< Specifies the TIM mode."]
    #[doc = "This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes"]
    pub OCMode: u32,
    #[doc = "< Specifies the pulse value to be loaded into the Capture Compare Register."]
    #[doc = "This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF"]
    pub Pulse: u32,
    #[doc = "< Specifies the output polarity."]
    #[doc = "This parameter can be a value of @ref TIM_Output_Compare_Polarity"]
    pub OCPolarity: u32,
    #[doc = "< Specifies the complementary output polarity."]
    #[doc = "This parameter can be a value of @ref TIM_Output_Compare_N_Polarity"]
    #[doc = "@note This parameter is valid only for timer instances supporting break feature."]
    pub OCNPolarity: u32,
    #[doc = "< Specifies the Fast mode state."]
    #[doc = "This parameter can be a value of @ref TIM_Output_Fast_State"]
    #[doc = "@note This parameter is valid only in PWM1 and PWM2 mode."]
    pub OCFastMode: u32,
    #[doc = "< Specifies the TIM Output Compare pin state during Idle state."]
    #[doc = "This parameter can be a value of @ref TIM_Output_Compare_Idle_State"]
    #[doc = "@note This parameter is valid only for timer instances supporting break feature."]
    pub OCIdleState: u32,
    #[doc = "< Specifies the TIM Output Compare pin state during Idle state."]
    #[doc = "This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State"]
    #[doc = "@note This parameter is valid only for timer instances supporting break feature."]
    pub OCNIdleState: u32,
}
#[test]
fn bindgen_test_layout_TIM_OC_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TIM_OC_InitTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(TIM_OC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_OC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_OC_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_OC_InitTypeDef>())).OCMode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OC_InitTypeDef),
            "::",
            stringify!(OCMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_OC_InitTypeDef>())).Pulse as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OC_InitTypeDef),
            "::",
            stringify!(Pulse)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_OC_InitTypeDef>())).OCPolarity as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OC_InitTypeDef),
            "::",
            stringify!(OCPolarity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_OC_InitTypeDef>())).OCNPolarity as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OC_InitTypeDef),
            "::",
            stringify!(OCNPolarity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_OC_InitTypeDef>())).OCFastMode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OC_InitTypeDef),
            "::",
            stringify!(OCFastMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_OC_InitTypeDef>())).OCIdleState as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OC_InitTypeDef),
            "::",
            stringify!(OCIdleState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_OC_InitTypeDef>())).OCNIdleState as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OC_InitTypeDef),
            "::",
            stringify!(OCNIdleState)
        )
    );
}
#[doc = " @brief  TIM One Pulse Mode Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TIM_OnePulse_InitTypeDef {
    #[doc = "< Specifies the TIM mode."]
    #[doc = "This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes"]
    pub OCMode: u32,
    #[doc = "< Specifies the pulse value to be loaded into the Capture Compare Register."]
    #[doc = "This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF"]
    pub Pulse: u32,
    #[doc = "< Specifies the output polarity."]
    #[doc = "This parameter can be a value of @ref TIM_Output_Compare_Polarity"]
    pub OCPolarity: u32,
    #[doc = "< Specifies the complementary output polarity."]
    #[doc = "This parameter can be a value of @ref TIM_Output_Compare_N_Polarity"]
    #[doc = "@note This parameter is valid only for timer instances supporting break feature."]
    pub OCNPolarity: u32,
    #[doc = "< Specifies the TIM Output Compare pin state during Idle state."]
    #[doc = "This parameter can be a value of @ref TIM_Output_Compare_Idle_State"]
    #[doc = "@note This parameter is valid only for timer instances supporting break feature."]
    pub OCIdleState: u32,
    #[doc = "< Specifies the TIM Output Compare pin state during Idle state."]
    #[doc = "This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State"]
    #[doc = "@note This parameter is valid only for timer instances supporting break feature."]
    pub OCNIdleState: u32,
    #[doc = "< Specifies the active edge of the input signal."]
    #[doc = "This parameter can be a value of @ref TIM_Input_Capture_Polarity"]
    pub ICPolarity: u32,
    #[doc = "< Specifies the input."]
    #[doc = "This parameter can be a value of @ref TIM_Input_Capture_Selection"]
    pub ICSelection: u32,
    #[doc = "< Specifies the input capture filter."]
    #[doc = "This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub ICFilter: u32,
}
#[test]
fn bindgen_test_layout_TIM_OnePulse_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TIM_OnePulse_InitTypeDef>(),
        36usize,
        concat!("Size of: ", stringify!(TIM_OnePulse_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_OnePulse_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_OnePulse_InitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_OnePulse_InitTypeDef>())).OCMode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(OCMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_OnePulse_InitTypeDef>())).Pulse as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(Pulse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_OnePulse_InitTypeDef>())).OCPolarity as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(OCPolarity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_OnePulse_InitTypeDef>())).OCNPolarity as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(OCNPolarity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_OnePulse_InitTypeDef>())).OCIdleState as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(OCIdleState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_OnePulse_InitTypeDef>())).OCNIdleState as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(OCNIdleState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_OnePulse_InitTypeDef>())).ICPolarity as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(ICPolarity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_OnePulse_InitTypeDef>())).ICSelection as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(ICSelection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_OnePulse_InitTypeDef>())).ICFilter as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(ICFilter)
        )
    );
}
#[doc = " @brief  TIM Input Capture Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TIM_IC_InitTypeDef {
    #[doc = "< Specifies the active edge of the input signal."]
    #[doc = "This parameter can be a value of @ref TIM_Input_Capture_Polarity"]
    pub ICPolarity: u32,
    #[doc = "< Specifies the input."]
    #[doc = "This parameter can be a value of @ref TIM_Input_Capture_Selection"]
    pub ICSelection: u32,
    #[doc = "< Specifies the Input Capture Prescaler."]
    #[doc = "This parameter can be a value of @ref TIM_Input_Capture_Prescaler"]
    pub ICPrescaler: u32,
    #[doc = "< Specifies the input capture filter."]
    #[doc = "This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub ICFilter: u32,
}
#[test]
fn bindgen_test_layout_TIM_IC_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TIM_IC_InitTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(TIM_IC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_IC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_IC_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_IC_InitTypeDef>())).ICPolarity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_IC_InitTypeDef),
            "::",
            stringify!(ICPolarity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_IC_InitTypeDef>())).ICSelection as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_IC_InitTypeDef),
            "::",
            stringify!(ICSelection)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_IC_InitTypeDef>())).ICPrescaler as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_IC_InitTypeDef),
            "::",
            stringify!(ICPrescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_IC_InitTypeDef>())).ICFilter as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_IC_InitTypeDef),
            "::",
            stringify!(ICFilter)
        )
    );
}
#[doc = " @brief  TIM Encoder Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TIM_Encoder_InitTypeDef {
    #[doc = "< Specifies the active edge of the input signal."]
    #[doc = "This parameter can be a value of @ref TIM_Encoder_Mode"]
    pub EncoderMode: u32,
    #[doc = "< Specifies the active edge of the input signal."]
    #[doc = "This parameter can be a value of @ref TIM_Encoder_Input_Polarity"]
    pub IC1Polarity: u32,
    #[doc = "< Specifies the input."]
    #[doc = "This parameter can be a value of @ref TIM_Input_Capture_Selection"]
    pub IC1Selection: u32,
    #[doc = "< Specifies the Input Capture Prescaler."]
    #[doc = "This parameter can be a value of @ref TIM_Input_Capture_Prescaler"]
    pub IC1Prescaler: u32,
    #[doc = "< Specifies the input capture filter."]
    #[doc = "This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub IC1Filter: u32,
    #[doc = "< Specifies the active edge of the input signal."]
    #[doc = "This parameter can be a value of @ref TIM_Encoder_Input_Polarity"]
    pub IC2Polarity: u32,
    #[doc = "< Specifies the input."]
    #[doc = "This parameter can be a value of @ref TIM_Input_Capture_Selection"]
    pub IC2Selection: u32,
    #[doc = "< Specifies the Input Capture Prescaler."]
    #[doc = "This parameter can be a value of @ref TIM_Input_Capture_Prescaler"]
    pub IC2Prescaler: u32,
    #[doc = "< Specifies the input capture filter."]
    #[doc = "This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub IC2Filter: u32,
}
#[test]
fn bindgen_test_layout_TIM_Encoder_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TIM_Encoder_InitTypeDef>(),
        36usize,
        concat!("Size of: ", stringify!(TIM_Encoder_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_Encoder_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_Encoder_InitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_Encoder_InitTypeDef>())).EncoderMode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(EncoderMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_Encoder_InitTypeDef>())).IC1Polarity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC1Polarity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_Encoder_InitTypeDef>())).IC1Selection as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC1Selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_Encoder_InitTypeDef>())).IC1Prescaler as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC1Prescaler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_Encoder_InitTypeDef>())).IC1Filter as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC1Filter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_Encoder_InitTypeDef>())).IC2Polarity as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC2Polarity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_Encoder_InitTypeDef>())).IC2Selection as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC2Selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_Encoder_InitTypeDef>())).IC2Prescaler as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC2Prescaler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_Encoder_InitTypeDef>())).IC2Filter as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC2Filter)
        )
    );
}
#[doc = " @brief  Clock Configuration Handle Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TIM_ClockConfigTypeDef {
    #[doc = "< TIM clock sources"]
    #[doc = "This parameter can be a value of @ref TIM_Clock_Source"]
    pub ClockSource: u32,
    #[doc = "< TIM clock polarity"]
    #[doc = "This parameter can be a value of @ref TIM_Clock_Polarity"]
    pub ClockPolarity: u32,
    #[doc = "< TIM clock prescaler"]
    #[doc = "This parameter can be a value of @ref TIM_Clock_Prescaler"]
    pub ClockPrescaler: u32,
    #[doc = "< TIM clock filter"]
    #[doc = "This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub ClockFilter: u32,
}
#[test]
fn bindgen_test_layout_TIM_ClockConfigTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TIM_ClockConfigTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(TIM_ClockConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_ClockConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_ClockConfigTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_ClockConfigTypeDef>())).ClockSource as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClockConfigTypeDef),
            "::",
            stringify!(ClockSource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_ClockConfigTypeDef>())).ClockPolarity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClockConfigTypeDef),
            "::",
            stringify!(ClockPolarity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_ClockConfigTypeDef>())).ClockPrescaler as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClockConfigTypeDef),
            "::",
            stringify!(ClockPrescaler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_ClockConfigTypeDef>())).ClockFilter as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClockConfigTypeDef),
            "::",
            stringify!(ClockFilter)
        )
    );
}
#[doc = " @brief  TIM Clear Input Configuration Handle Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TIM_ClearInputConfigTypeDef {
    #[doc = "< TIM clear Input state"]
    #[doc = "This parameter can be ENABLE or DISABLE"]
    pub ClearInputState: u32,
    #[doc = "< TIM clear Input sources"]
    #[doc = "This parameter can be a value of @ref TIM_ClearInput_Source"]
    pub ClearInputSource: u32,
    #[doc = "< TIM Clear Input polarity"]
    #[doc = "This parameter can be a value of @ref TIM_ClearInput_Polarity"]
    pub ClearInputPolarity: u32,
    #[doc = "< TIM Clear Input prescaler"]
    #[doc = "This parameter must be 0: When OCRef clear feature is used with ETR source, ETR prescaler must be off"]
    pub ClearInputPrescaler: u32,
    #[doc = "< TIM Clear Input filter"]
    #[doc = "This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub ClearInputFilter: u32,
}
#[test]
fn bindgen_test_layout_TIM_ClearInputConfigTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TIM_ClearInputConfigTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(TIM_ClearInputConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_ClearInputConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_ClearInputConfigTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_ClearInputConfigTypeDef>())).ClearInputState as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClearInputConfigTypeDef),
            "::",
            stringify!(ClearInputState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_ClearInputConfigTypeDef>())).ClearInputSource as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClearInputConfigTypeDef),
            "::",
            stringify!(ClearInputSource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_ClearInputConfigTypeDef>())).ClearInputPolarity as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClearInputConfigTypeDef),
            "::",
            stringify!(ClearInputPolarity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_ClearInputConfigTypeDef>())).ClearInputPrescaler as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClearInputConfigTypeDef),
            "::",
            stringify!(ClearInputPrescaler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_ClearInputConfigTypeDef>())).ClearInputFilter as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClearInputConfigTypeDef),
            "::",
            stringify!(ClearInputFilter)
        )
    );
}
#[doc = " @brief  TIM Master configuration Structure definition"]
#[doc = " @note   Advanced timers provide TRGO2 internal line which is redirected"]
#[doc = "         to the ADC"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TIM_MasterConfigTypeDef {
    #[doc = "< Trigger output (TRGO) selection"]
    #[doc = "This parameter can be a value of @ref TIM_Master_Mode_Selection"]
    pub MasterOutputTrigger: u32,
    #[doc = "< Trigger output2 (TRGO2) selection"]
    #[doc = "This parameter can be a value of @ref TIM_Master_Mode_Selection_2"]
    pub MasterOutputTrigger2: u32,
    #[doc = "< Master/slave mode selection"]
    #[doc = "This parameter can be a value of @ref TIM_Master_Slave_Mode"]
    #[doc = "@note When the Master/slave mode is enabled, the effect of"]
    #[doc = "an event on the trigger input (TRGI) is delayed to allow a"]
    #[doc = "perfect synchronization between the current timer and its"]
    #[doc = "slaves (through TRGO). It is not mandatory in case of timer"]
    #[doc = "synchronization mode."]
    pub MasterSlaveMode: u32,
}
#[test]
fn bindgen_test_layout_TIM_MasterConfigTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TIM_MasterConfigTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(TIM_MasterConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_MasterConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_MasterConfigTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_MasterConfigTypeDef>())).MasterOutputTrigger as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_MasterConfigTypeDef),
            "::",
            stringify!(MasterOutputTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_MasterConfigTypeDef>())).MasterOutputTrigger2 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_MasterConfigTypeDef),
            "::",
            stringify!(MasterOutputTrigger2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_MasterConfigTypeDef>())).MasterSlaveMode as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_MasterConfigTypeDef),
            "::",
            stringify!(MasterSlaveMode)
        )
    );
}
#[doc = " @brief  TIM Slave configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TIM_SlaveConfigTypeDef {
    #[doc = "< Slave mode selection"]
    #[doc = "This parameter can be a value of @ref TIM_Slave_Mode"]
    pub SlaveMode: u32,
    #[doc = "< Input Trigger source"]
    #[doc = "This parameter can be a value of @ref TIM_Trigger_Selection"]
    pub InputTrigger: u32,
    #[doc = "< Input Trigger polarity"]
    #[doc = "This parameter can be a value of @ref TIM_Trigger_Polarity"]
    pub TriggerPolarity: u32,
    #[doc = "< Input trigger prescaler"]
    #[doc = "This parameter can be a value of @ref TIM_Trigger_Prescaler"]
    pub TriggerPrescaler: u32,
    #[doc = "< Input trigger filter"]
    #[doc = "This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub TriggerFilter: u32,
}
#[test]
fn bindgen_test_layout_TIM_SlaveConfigTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TIM_SlaveConfigTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(TIM_SlaveConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_SlaveConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_SlaveConfigTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_SlaveConfigTypeDef>())).SlaveMode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_SlaveConfigTypeDef),
            "::",
            stringify!(SlaveMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_SlaveConfigTypeDef>())).InputTrigger as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_SlaveConfigTypeDef),
            "::",
            stringify!(InputTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_SlaveConfigTypeDef>())).TriggerPolarity as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_SlaveConfigTypeDef),
            "::",
            stringify!(TriggerPolarity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_SlaveConfigTypeDef>())).TriggerPrescaler as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_SlaveConfigTypeDef),
            "::",
            stringify!(TriggerPrescaler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_SlaveConfigTypeDef>())).TriggerFilter as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_SlaveConfigTypeDef),
            "::",
            stringify!(TriggerFilter)
        )
    );
}
#[doc = " @brief  TIM Break input(s) and Dead time configuration Structure definition"]
#[doc = " @note   2 break inputs can be configured (BKIN and BKIN2) with configurable"]
#[doc = "        filter and polarity."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TIM_BreakDeadTimeConfigTypeDef {
    #[doc = "< TIM off state in run mode"]
    #[doc = "This parameter can be a value of @ref TIM_OSSR_Off_State_Selection_for_Run_mode_state"]
    pub OffStateRunMode: u32,
    #[doc = "< TIM off state in IDLE mode"]
    #[doc = "This parameter can be a value of @ref TIM_OSSI_Off_State_Selection_for_Idle_mode_state"]
    pub OffStateIDLEMode: u32,
    #[doc = "< TIM Lock level"]
    #[doc = "This parameter can be a value of @ref TIM_Lock_level"]
    pub LockLevel: u32,
    #[doc = "< TIM dead Time"]
    #[doc = "This parameter can be a number between Min_Data = 0x00 and Max_Data = 0xFF"]
    pub DeadTime: u32,
    #[doc = "< TIM Break State"]
    #[doc = "This parameter can be a value of @ref TIM_Break_Input_enable_disable"]
    pub BreakState: u32,
    #[doc = "< TIM Break input polarity"]
    #[doc = "This parameter can be a value of @ref TIM_Break_Polarity"]
    pub BreakPolarity: u32,
    #[doc = "< Specifies the break input filter."]
    #[doc = "This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub BreakFilter: u32,
    #[doc = "< TIM Break2 State"]
    #[doc = "This parameter can be a value of @ref TIM_Break2_Input_enable_disable"]
    pub Break2State: u32,
    #[doc = "< TIM Break2 input polarity"]
    #[doc = "This parameter can be a value of @ref TIM_Break2_Polarity"]
    pub Break2Polarity: u32,
    #[doc = "< TIM break2 input filter."]
    #[doc = "This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub Break2Filter: u32,
    #[doc = "< TIM Automatic Output Enable state"]
    #[doc = "This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset"]
    pub AutomaticOutput: u32,
}
#[test]
fn bindgen_test_layout_TIM_BreakDeadTimeConfigTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TIM_BreakDeadTimeConfigTypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(TIM_BreakDeadTimeConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_BreakDeadTimeConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_BreakDeadTimeConfigTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_BreakDeadTimeConfigTypeDef>())).OffStateRunMode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(OffStateRunMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_BreakDeadTimeConfigTypeDef>())).OffStateIDLEMode as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(OffStateIDLEMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_BreakDeadTimeConfigTypeDef>())).LockLevel as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(LockLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_BreakDeadTimeConfigTypeDef>())).DeadTime as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(DeadTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_BreakDeadTimeConfigTypeDef>())).BreakState as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(BreakState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_BreakDeadTimeConfigTypeDef>())).BreakPolarity as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(BreakPolarity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_BreakDeadTimeConfigTypeDef>())).BreakFilter as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(BreakFilter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_BreakDeadTimeConfigTypeDef>())).Break2State as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(Break2State)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_BreakDeadTimeConfigTypeDef>())).Break2Polarity as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(Break2Polarity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_BreakDeadTimeConfigTypeDef>())).Break2Filter as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(Break2Filter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_BreakDeadTimeConfigTypeDef>())).AutomaticOutput as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(AutomaticOutput)
        )
    );
}
#[doc = "< Peripheral not yet initialized or disabled"]
pub const HAL_TIM_StateTypeDef_HAL_TIM_STATE_RESET: HAL_TIM_StateTypeDef = 0;
#[doc = "< Peripheral Initialized and ready for use"]
pub const HAL_TIM_StateTypeDef_HAL_TIM_STATE_READY: HAL_TIM_StateTypeDef = 1;
#[doc = "< An internal process is ongoing"]
pub const HAL_TIM_StateTypeDef_HAL_TIM_STATE_BUSY: HAL_TIM_StateTypeDef = 2;
#[doc = "< Timeout state"]
pub const HAL_TIM_StateTypeDef_HAL_TIM_STATE_TIMEOUT: HAL_TIM_StateTypeDef = 3;
#[doc = "< Reception process is ongoing"]
pub const HAL_TIM_StateTypeDef_HAL_TIM_STATE_ERROR: HAL_TIM_StateTypeDef = 4;
#[doc = " @brief  HAL State structures definition"]
pub type HAL_TIM_StateTypeDef = libc::c_uint;
#[doc = "< TIM Channel initial state"]
pub const HAL_TIM_ChannelStateTypeDef_HAL_TIM_CHANNEL_STATE_RESET: HAL_TIM_ChannelStateTypeDef = 0;
#[doc = "< TIM Channel ready for use"]
pub const HAL_TIM_ChannelStateTypeDef_HAL_TIM_CHANNEL_STATE_READY: HAL_TIM_ChannelStateTypeDef = 1;
#[doc = "< An internal process is ongoing on the TIM channel"]
pub const HAL_TIM_ChannelStateTypeDef_HAL_TIM_CHANNEL_STATE_BUSY: HAL_TIM_ChannelStateTypeDef = 2;
#[doc = " @brief  TIM Channel States definition"]
pub type HAL_TIM_ChannelStateTypeDef = libc::c_uint;
#[doc = "< DMA Burst initial state"]
pub const HAL_TIM_DMABurstStateTypeDef_HAL_DMA_BURST_STATE_RESET: HAL_TIM_DMABurstStateTypeDef = 0;
#[doc = "< DMA Burst ready for use"]
pub const HAL_TIM_DMABurstStateTypeDef_HAL_DMA_BURST_STATE_READY: HAL_TIM_DMABurstStateTypeDef = 1;
#[doc = "< Ongoing DMA Burst"]
pub const HAL_TIM_DMABurstStateTypeDef_HAL_DMA_BURST_STATE_BUSY: HAL_TIM_DMABurstStateTypeDef = 2;
#[doc = " @brief  DMA Burst States definition"]
pub type HAL_TIM_DMABurstStateTypeDef = libc::c_uint;
#[doc = "< The active channel is 1"]
pub const HAL_TIM_ActiveChannel_HAL_TIM_ACTIVE_CHANNEL_1: HAL_TIM_ActiveChannel = 1;
#[doc = "< The active channel is 2"]
pub const HAL_TIM_ActiveChannel_HAL_TIM_ACTIVE_CHANNEL_2: HAL_TIM_ActiveChannel = 2;
#[doc = "< The active channel is 3"]
pub const HAL_TIM_ActiveChannel_HAL_TIM_ACTIVE_CHANNEL_3: HAL_TIM_ActiveChannel = 4;
#[doc = "< The active channel is 4"]
pub const HAL_TIM_ActiveChannel_HAL_TIM_ACTIVE_CHANNEL_4: HAL_TIM_ActiveChannel = 8;
#[doc = "< The active channel is 5"]
pub const HAL_TIM_ActiveChannel_HAL_TIM_ACTIVE_CHANNEL_5: HAL_TIM_ActiveChannel = 16;
#[doc = "< The active channel is 6"]
pub const HAL_TIM_ActiveChannel_HAL_TIM_ACTIVE_CHANNEL_6: HAL_TIM_ActiveChannel = 32;
#[doc = "< All active channels cleared"]
pub const HAL_TIM_ActiveChannel_HAL_TIM_ACTIVE_CHANNEL_CLEARED: HAL_TIM_ActiveChannel = 0;
#[doc = " @brief  HAL Active channel structures definition"]
pub type HAL_TIM_ActiveChannel = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut TIM_TypeDef,
    #[doc = "< TIM Time Base required parameters"]
    pub Init: TIM_Base_InitTypeDef,
    #[doc = "< Active channel"]
    pub Channel: HAL_TIM_ActiveChannel,
    #[doc = "< DMA Handlers array"]
    #[doc = "This array is accessed by a @ref DMA_Handle_index"]
    pub hdma: [*mut DMA_HandleTypeDef; 7usize],
    #[doc = "< Locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< TIM operation state"]
    pub State: HAL_TIM_StateTypeDef,
    #[doc = "< TIM channel operation state"]
    pub ChannelState: [HAL_TIM_ChannelStateTypeDef; 6usize],
    #[doc = "< TIM complementary channel operation state"]
    pub ChannelNState: [HAL_TIM_ChannelStateTypeDef; 4usize],
    #[doc = "< DMA burst operation state"]
    pub DMABurstState: HAL_TIM_DMABurstStateTypeDef,
}
#[test]
fn bindgen_test_layout_TIM_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TIM_HandleTypeDef>(),
        112usize,
        concat!("Size of: ", stringify!(TIM_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_HandleTypeDef>())).Channel as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HandleTypeDef),
            "::",
            stringify!(Channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_HandleTypeDef>())).hdma as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HandleTypeDef),
            "::",
            stringify!(hdma)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_HandleTypeDef>())).Lock as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_HandleTypeDef>())).State as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TIM_HandleTypeDef>())).ChannelState as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HandleTypeDef),
            "::",
            stringify!(ChannelState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_HandleTypeDef>())).ChannelNState as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HandleTypeDef),
            "::",
            stringify!(ChannelNState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_HandleTypeDef>())).DMABurstState as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HandleTypeDef),
            "::",
            stringify!(DMABurstState)
        )
    );
}
impl Default for TIM_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  TIM Hall sensor Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TIM_HallSensor_InitTypeDef {
    #[doc = "< Specifies the active edge of the input signal."]
    #[doc = "This parameter can be a value of @ref TIM_Input_Capture_Polarity"]
    pub IC1Polarity: u32,
    #[doc = "< Specifies the Input Capture Prescaler."]
    #[doc = "This parameter can be a value of @ref TIM_Input_Capture_Prescaler"]
    pub IC1Prescaler: u32,
    #[doc = "< Specifies the input capture filter."]
    #[doc = "This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub IC1Filter: u32,
    #[doc = "< Specifies the pulse value to be loaded into the Capture Compare Register."]
    #[doc = "This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF"]
    pub Commutation_Delay: u32,
}
#[test]
fn bindgen_test_layout_TIM_HallSensor_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TIM_HallSensor_InitTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(TIM_HallSensor_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_HallSensor_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_HallSensor_InitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_HallSensor_InitTypeDef>())).IC1Polarity as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HallSensor_InitTypeDef),
            "::",
            stringify!(IC1Polarity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_HallSensor_InitTypeDef>())).IC1Prescaler as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HallSensor_InitTypeDef),
            "::",
            stringify!(IC1Prescaler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_HallSensor_InitTypeDef>())).IC1Filter as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HallSensor_InitTypeDef),
            "::",
            stringify!(IC1Filter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIM_HallSensor_InitTypeDef>())).Commutation_Delay as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HallSensor_InitTypeDef),
            "::",
            stringify!(Commutation_Delay)
        )
    );
}
#[doc = " @brief  TIM Break/Break2 input configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TIMEx_BreakInputConfigTypeDef {
    #[doc = "< Specifies the source of the timer break input."]
    #[doc = "This parameter can be a value of @ref TIMEx_Break_Input_Source"]
    pub Source: u32,
    #[doc = "< Specifies whether or not the break input source is enabled."]
    #[doc = "This parameter can be a value of @ref TIMEx_Break_Input_Source_Enable"]
    pub Enable: u32,
    #[doc = "< Specifies the break input source polarity."]
    #[doc = "This parameter can be a value of @ref TIMEx_Break_Input_Source_Polarity"]
    #[doc = "Not relevant when analog watchdog output of the DFSDM1 used as break input source"]
    pub Polarity: u32,
}
#[test]
fn bindgen_test_layout_TIMEx_BreakInputConfigTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TIMEx_BreakInputConfigTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(TIMEx_BreakInputConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIMEx_BreakInputConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIMEx_BreakInputConfigTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIMEx_BreakInputConfigTypeDef>())).Source as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIMEx_BreakInputConfigTypeDef),
            "::",
            stringify!(Source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIMEx_BreakInputConfigTypeDef>())).Enable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIMEx_BreakInputConfigTypeDef),
            "::",
            stringify!(Enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TIMEx_BreakInputConfigTypeDef>())).Polarity as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIMEx_BreakInputConfigTypeDef),
            "::",
            stringify!(Polarity)
        )
    );
}
extern "C" {
    #[doc = " @addtogroup TIMEx_Exported_Functions_Group1 Extended Timer Hall Sensor functions"]
    #[doc = "  @brief    Timer Hall Sensor functions"]
    #[doc = " @{"]
    pub fn HAL_TIMEx_HallSensor_Init(
        htim: *mut TIM_HandleTypeDef,
        sConfig: *mut TIM_HallSensor_InitTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_DeInit(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_MspInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_MspDeInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_Start(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_Stop(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_Start_IT(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_Stop_IT(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        pData: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_Stop_DMA(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIMEx_Exported_Functions_Group2 Extended Timer Complementary Output Compare functions"]
    #[doc = "  @brief   Timer Complementary Output Compare functions"]
    #[doc = " @{"]
    pub fn HAL_TIMEx_OCN_Start(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OCN_Stop(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OCN_Start_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OCN_Stop_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OCN_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
        pData: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OCN_Stop_DMA(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIMEx_Exported_Functions_Group3 Extended Timer Complementary PWM functions"]
    #[doc = "  @brief    Timer Complementary PWM functions"]
    #[doc = " @{"]
    pub fn HAL_TIMEx_PWMN_Start(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_PWMN_Stop(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_PWMN_Start_IT(htim: *mut TIM_HandleTypeDef, Channel: u32)
        -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_PWMN_Stop_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_PWMN_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
        pData: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_PWMN_Stop_DMA(htim: *mut TIM_HandleTypeDef, Channel: u32)
        -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIMEx_Exported_Functions_Group4 Extended Timer Complementary One Pulse functions"]
    #[doc = "  @brief    Timer Complementary One Pulse functions"]
    #[doc = " @{"]
    pub fn HAL_TIMEx_OnePulseN_Start(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OnePulseN_Stop(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OnePulseN_Start_IT(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OnePulseN_Stop_IT(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIMEx_Exported_Functions_Group5 Extended Peripheral Control functions"]
    #[doc = "  @brief    Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_TIMEx_ConfigCommutEvent(
        htim: *mut TIM_HandleTypeDef,
        InputTrigger: u32,
        CommutationSource: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_ConfigCommutEvent_IT(
        htim: *mut TIM_HandleTypeDef,
        InputTrigger: u32,
        CommutationSource: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_ConfigCommutEvent_DMA(
        htim: *mut TIM_HandleTypeDef,
        InputTrigger: u32,
        CommutationSource: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_MasterConfigSynchronization(
        htim: *mut TIM_HandleTypeDef,
        sMasterConfig: *mut TIM_MasterConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_ConfigBreakDeadTime(
        htim: *mut TIM_HandleTypeDef,
        sBreakDeadTimeConfig: *mut TIM_BreakDeadTimeConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_ConfigBreakInput(
        htim: *mut TIM_HandleTypeDef,
        BreakInput: u32,
        sBreakInputConfig: *mut TIMEx_BreakInputConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_GroupChannel5(
        htim: *mut TIM_HandleTypeDef,
        Channels: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_RemapConfig(htim: *mut TIM_HandleTypeDef, Remap: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIMEx_Exported_Functions_Group6 Extended Callbacks functions"]
    #[doc = " @brief    Extended Callbacks functions"]
    #[doc = " @{"]
    pub fn HAL_TIMEx_CommutCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIMEx_CommutHalfCpltCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIMEx_BreakCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIMEx_Break2Callback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup TIMEx_Exported_Functions_Group7 Extended Peripheral State functions"]
    #[doc = " @brief    Extended Peripheral State functions"]
    #[doc = " @{"]
    pub fn HAL_TIMEx_HallSensor_GetState(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_StateTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_GetChannelNState(
        htim: *mut TIM_HandleTypeDef,
        ChannelN: u32,
    ) -> HAL_TIM_ChannelStateTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIMEx_Private_Functions TIMEx Private Functions"]
    #[doc = " @{"]
    pub fn TIMEx_DMACommutationCplt(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn TIMEx_DMACommutationHalfCplt(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup TIM_Exported_Functions_Group1 TIM Time Base functions"]
    #[doc = "  @brief   Time Base functions"]
    #[doc = " @{"]
    pub fn HAL_TIM_Base_Init(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Base_DeInit(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Base_MspInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_Base_MspDeInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_Base_Start(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Base_Stop(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Base_Start_IT(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Base_Stop_IT(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Base_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        pData: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Base_Stop_DMA(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIM_Exported_Functions_Group2 TIM Output Compare functions"]
    #[doc = "  @brief   TIM Output Compare functions"]
    #[doc = " @{"]
    pub fn HAL_TIM_OC_Init(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_DeInit(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_MspInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_OC_MspDeInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_OC_Start(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_Stop(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_Start_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_Stop_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
        pData: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_Stop_DMA(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIM_Exported_Functions_Group3 TIM PWM functions"]
    #[doc = "  @brief   TIM PWM functions"]
    #[doc = " @{"]
    pub fn HAL_TIM_PWM_Init(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_DeInit(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_MspInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_PWM_MspDeInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_PWM_Start(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_Stop(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_Start_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_Stop_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
        pData: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_Stop_DMA(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIM_Exported_Functions_Group4 TIM Input Capture functions"]
    #[doc = "  @brief   TIM Input Capture functions"]
    #[doc = " @{"]
    pub fn HAL_TIM_IC_Init(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_DeInit(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_MspInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_IC_MspDeInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_IC_Start(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_Stop(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_Start_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_Stop_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
        pData: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_Stop_DMA(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIM_Exported_Functions_Group5 TIM One Pulse functions"]
    #[doc = "  @brief   TIM One Pulse functions"]
    #[doc = " @{"]
    pub fn HAL_TIM_OnePulse_Init(
        htim: *mut TIM_HandleTypeDef,
        OnePulseMode: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OnePulse_DeInit(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OnePulse_MspInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_OnePulse_MspDeInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_OnePulse_Start(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OnePulse_Stop(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OnePulse_Start_IT(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OnePulse_Stop_IT(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIM_Exported_Functions_Group6 TIM Encoder functions"]
    #[doc = "  @brief   TIM Encoder functions"]
    #[doc = " @{"]
    pub fn HAL_TIM_Encoder_Init(
        htim: *mut TIM_HandleTypeDef,
        sConfig: *mut TIM_Encoder_InitTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_DeInit(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_MspInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_Encoder_MspDeInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_Encoder_Start(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_Stop(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_Start_IT(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_Stop_IT(htim: *mut TIM_HandleTypeDef, Channel: u32)
        -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
        pData1: *mut u32,
        pData2: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_Stop_DMA(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIM_Exported_Functions_Group7 TIM IRQ handler management"]
    #[doc = "  @brief   IRQ handler management"]
    #[doc = " @{"]
    pub fn HAL_TIM_IRQHandler(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    #[doc = " @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions"]
    #[doc = "  @brief   Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_TIM_OC_ConfigChannel(
        htim: *mut TIM_HandleTypeDef,
        sConfig: *mut TIM_OC_InitTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_ConfigChannel(
        htim: *mut TIM_HandleTypeDef,
        sConfig: *mut TIM_OC_InitTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_ConfigChannel(
        htim: *mut TIM_HandleTypeDef,
        sConfig: *mut TIM_IC_InitTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OnePulse_ConfigChannel(
        htim: *mut TIM_HandleTypeDef,
        sConfig: *mut TIM_OnePulse_InitTypeDef,
        OutputChannel: u32,
        InputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_ConfigOCrefClear(
        htim: *mut TIM_HandleTypeDef,
        sClearInputConfig: *mut TIM_ClearInputConfigTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_ConfigClockSource(
        htim: *mut TIM_HandleTypeDef,
        sClockSourceConfig: *mut TIM_ClockConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_ConfigTI1Input(
        htim: *mut TIM_HandleTypeDef,
        TI1_Selection: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_SlaveConfigSynchro(
        htim: *mut TIM_HandleTypeDef,
        sSlaveConfig: *mut TIM_SlaveConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_SlaveConfigSynchro_IT(
        htim: *mut TIM_HandleTypeDef,
        sSlaveConfig: *mut TIM_SlaveConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_DMABurst_WriteStart(
        htim: *mut TIM_HandleTypeDef,
        BurstBaseAddress: u32,
        BurstRequestSrc: u32,
        BurstBuffer: *mut u32,
        BurstLength: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_DMABurst_MultiWriteStart(
        htim: *mut TIM_HandleTypeDef,
        BurstBaseAddress: u32,
        BurstRequestSrc: u32,
        BurstBuffer: *mut u32,
        BurstLength: u32,
        DataLength: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_DMABurst_WriteStop(
        htim: *mut TIM_HandleTypeDef,
        BurstRequestSrc: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_DMABurst_ReadStart(
        htim: *mut TIM_HandleTypeDef,
        BurstBaseAddress: u32,
        BurstRequestSrc: u32,
        BurstBuffer: *mut u32,
        BurstLength: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_DMABurst_MultiReadStart(
        htim: *mut TIM_HandleTypeDef,
        BurstBaseAddress: u32,
        BurstRequestSrc: u32,
        BurstBuffer: *mut u32,
        BurstLength: u32,
        DataLength: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_DMABurst_ReadStop(
        htim: *mut TIM_HandleTypeDef,
        BurstRequestSrc: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_GenerateEvent(
        htim: *mut TIM_HandleTypeDef,
        EventSource: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_ReadCapturedValue(htim: *mut TIM_HandleTypeDef, Channel: u32) -> u32;
}
extern "C" {
    #[doc = " @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions"]
    #[doc = "  @brief   TIM Callbacks functions"]
    #[doc = " @{"]
    pub fn HAL_TIM_PeriodElapsedCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_PeriodElapsedHalfCpltCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_OC_DelayElapsedCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_IC_CaptureCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_IC_CaptureHalfCpltCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_PWM_PulseFinishedCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_TriggerCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_TriggerHalfCpltCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_ErrorCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    #[doc = " @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions"]
    #[doc = "  @brief  Peripheral State functions"]
    #[doc = " @{"]
    pub fn HAL_TIM_Base_GetState(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_StateTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_GetState(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_StateTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_GetState(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_StateTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_GetState(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_StateTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OnePulse_GetState(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_StateTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_GetState(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_StateTypeDef;
}
extern "C" {
    pub fn HAL_TIM_GetActiveChannel(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_ActiveChannel;
}
extern "C" {
    pub fn HAL_TIM_GetChannelState(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
    ) -> HAL_TIM_ChannelStateTypeDef;
}
extern "C" {
    pub fn HAL_TIM_DMABurstState(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_DMABurstStateTypeDef;
}
extern "C" {
    #[doc = " @defgroup TIM_Private_Functions TIM Private Functions"]
    #[doc = " @{"]
    pub fn TIM_Base_SetConfig(TIMx: *mut TIM_TypeDef, Structure: *mut TIM_Base_InitTypeDef);
}
extern "C" {
    pub fn TIM_TI1_SetConfig(
        TIMx: *mut TIM_TypeDef,
        TIM_ICPolarity: u32,
        TIM_ICSelection: u32,
        TIM_ICFilter: u32,
    );
}
extern "C" {
    pub fn TIM_OC2_SetConfig(TIMx: *mut TIM_TypeDef, OC_Config: *mut TIM_OC_InitTypeDef);
}
extern "C" {
    pub fn TIM_ETR_SetConfig(
        TIMx: *mut TIM_TypeDef,
        TIM_ExtTRGPrescaler: u32,
        TIM_ExtTRGPolarity: u32,
        ExtTRGFilter: u32,
    );
}
extern "C" {
    pub fn TIM_DMADelayPulseHalfCplt(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn TIM_DMAError(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn TIM_DMACaptureCplt(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn TIM_DMACaptureHalfCplt(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn TIM_CCxChannelCmd(TIMx: *mut TIM_TypeDef, Channel: u32, ChannelState: u32);
}
#[doc = "< TSC registers have their reset value"]
pub const HAL_TSC_StateTypeDef_HAL_TSC_STATE_RESET: HAL_TSC_StateTypeDef = 0;
#[doc = "< TSC registers are initialized or acquisition is completed with success"]
pub const HAL_TSC_StateTypeDef_HAL_TSC_STATE_READY: HAL_TSC_StateTypeDef = 1;
#[doc = "< TSC initialization or acquisition is on-going"]
pub const HAL_TSC_StateTypeDef_HAL_TSC_STATE_BUSY: HAL_TSC_StateTypeDef = 2;
#[doc = "< Acquisition is completed with max count error"]
pub const HAL_TSC_StateTypeDef_HAL_TSC_STATE_ERROR: HAL_TSC_StateTypeDef = 3;
#[doc = " @brief TSC state structure definition"]
pub type HAL_TSC_StateTypeDef = libc::c_uint;
#[doc = "< Acquisition on group is on-going or not started"]
pub const TSC_GroupStatusTypeDef_TSC_GROUP_ONGOING: TSC_GroupStatusTypeDef = 0;
#[doc = "< Acquisition on group is completed with success (no max count error)"]
pub const TSC_GroupStatusTypeDef_TSC_GROUP_COMPLETED: TSC_GroupStatusTypeDef = 1;
#[doc = " @brief TSC group status structure definition"]
pub type TSC_GroupStatusTypeDef = libc::c_uint;
#[doc = " @brief TSC init structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSC_InitTypeDef {
    #[doc = "< Charge-transfer high pulse length"]
    #[doc = "This parameter can be a value of @ref TSC_CTPulseHL_Config"]
    pub CTPulseHighLength: u32,
    #[doc = "< Charge-transfer low pulse length"]
    #[doc = "This parameter can be a value of @ref TSC_CTPulseLL_Config"]
    pub CTPulseLowLength: u32,
    #[doc = "< Spread spectrum activation"]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    pub SpreadSpectrum: FunctionalState,
    #[doc = "< Spread spectrum deviation"]
    #[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 127"]
    pub SpreadSpectrumDeviation: u32,
    #[doc = "< Spread spectrum prescaler"]
    #[doc = "This parameter can be a value of @ref TSC_SpreadSpec_Prescaler"]
    pub SpreadSpectrumPrescaler: u32,
    #[doc = "< Pulse generator prescaler"]
    #[doc = "This parameter can be a value of @ref TSC_PulseGenerator_Prescaler"]
    pub PulseGeneratorPrescaler: u32,
    #[doc = "< Max count value"]
    #[doc = "This parameter can be a value of @ref TSC_MaxCount_Value"]
    pub MaxCountValue: u32,
    #[doc = "< IO default mode"]
    #[doc = "This parameter can be a value of @ref TSC_IO_Default_Mode"]
    pub IODefaultMode: u32,
    #[doc = "< Synchro pin polarity"]
    #[doc = "This parameter can be a value of @ref TSC_Synchro_Pin_Polarity"]
    pub SynchroPinPolarity: u32,
    #[doc = "< Acquisition mode"]
    #[doc = "This parameter can be a value of @ref TSC_Acquisition_Mode"]
    pub AcquisitionMode: u32,
    #[doc = "< Max count interrupt activation"]
    #[doc = "This parameter can be set to ENABLE or DISABLE."]
    pub MaxCountInterrupt: FunctionalState,
    #[doc = "< Channel IOs mask"]
    pub ChannelIOs: u32,
    #[doc = "< Shield IOs mask"]
    pub ShieldIOs: u32,
    #[doc = "< Sampling IOs mask"]
    pub SamplingIOs: u32,
}
#[test]
fn bindgen_test_layout_TSC_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TSC_InitTypeDef>(),
        56usize,
        concat!("Size of: ", stringify!(TSC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TSC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TSC_InitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TSC_InitTypeDef>())).CTPulseHighLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_InitTypeDef),
            "::",
            stringify!(CTPulseHighLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TSC_InitTypeDef>())).CTPulseLowLength as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_InitTypeDef),
            "::",
            stringify!(CTPulseLowLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_InitTypeDef>())).SpreadSpectrum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_InitTypeDef),
            "::",
            stringify!(SpreadSpectrum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TSC_InitTypeDef>())).SpreadSpectrumDeviation as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_InitTypeDef),
            "::",
            stringify!(SpreadSpectrumDeviation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TSC_InitTypeDef>())).SpreadSpectrumPrescaler as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_InitTypeDef),
            "::",
            stringify!(SpreadSpectrumPrescaler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TSC_InitTypeDef>())).PulseGeneratorPrescaler as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_InitTypeDef),
            "::",
            stringify!(PulseGeneratorPrescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_InitTypeDef>())).MaxCountValue as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_InitTypeDef),
            "::",
            stringify!(MaxCountValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_InitTypeDef>())).IODefaultMode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_InitTypeDef),
            "::",
            stringify!(IODefaultMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TSC_InitTypeDef>())).SynchroPinPolarity as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_InitTypeDef),
            "::",
            stringify!(SynchroPinPolarity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TSC_InitTypeDef>())).AcquisitionMode as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_InitTypeDef),
            "::",
            stringify!(AcquisitionMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TSC_InitTypeDef>())).MaxCountInterrupt as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_InitTypeDef),
            "::",
            stringify!(MaxCountInterrupt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_InitTypeDef>())).ChannelIOs as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_InitTypeDef),
            "::",
            stringify!(ChannelIOs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_InitTypeDef>())).ShieldIOs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_InitTypeDef),
            "::",
            stringify!(ShieldIOs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_InitTypeDef>())).SamplingIOs as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_InitTypeDef),
            "::",
            stringify!(SamplingIOs)
        )
    );
}
impl Default for TSC_InitTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief TSC IOs configuration structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TSC_IOConfigTypeDef {
    #[doc = "< Channel IOs mask"]
    pub ChannelIOs: u32,
    #[doc = "< Shield IOs mask"]
    pub ShieldIOs: u32,
    #[doc = "< Sampling IOs mask"]
    pub SamplingIOs: u32,
}
#[test]
fn bindgen_test_layout_TSC_IOConfigTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TSC_IOConfigTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(TSC_IOConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TSC_IOConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TSC_IOConfigTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_IOConfigTypeDef>())).ChannelIOs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_IOConfigTypeDef),
            "::",
            stringify!(ChannelIOs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_IOConfigTypeDef>())).ShieldIOs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_IOConfigTypeDef),
            "::",
            stringify!(ShieldIOs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TSC_IOConfigTypeDef>())).SamplingIOs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_IOConfigTypeDef),
            "::",
            stringify!(SamplingIOs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSC_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut TSC_TypeDef,
    #[doc = "< Initialization parameters"]
    pub Init: TSC_InitTypeDef,
    #[doc = "< Peripheral state"]
    pub State: HAL_TSC_StateTypeDef,
    #[doc = "< Lock feature"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< TSC Error code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout_TSC_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<TSC_HandleTypeDef>(),
        72usize,
        concat!("Size of: ", stringify!(TSC_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TSC_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TSC_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_HandleTypeDef>())).State as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_HandleTypeDef>())).Lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TSC_HandleTypeDef>())).ErrorCode as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(TSC_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl Default for TSC_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TSC_GROUP1_IDX: libc::c_uint = 0;
pub const TSC_GROUP2_IDX: libc::c_uint = 1;
pub const TSC_GROUP3_IDX: libc::c_uint = 2;
pub const TSC_GROUP4_IDX: libc::c_uint = 3;
pub const TSC_GROUP5_IDX: libc::c_uint = 4;
pub const TSC_GROUP6_IDX: libc::c_uint = 5;
pub const TSC_GROUP7_IDX: libc::c_uint = 6;
pub const TSC_GROUP8_IDX: libc::c_uint = 7;
pub const TSC_NB_OF_GROUPS: libc::c_uint = 8;
pub type _bindgen_ty_1 = libc::c_uint;
extern "C" {
    #[doc = " @addtogroup TSC_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_TSC_Init(htsc: *mut TSC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TSC_DeInit(htsc: *mut TSC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TSC_MspInit(htsc: *mut TSC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TSC_MspDeInit(htsc: *mut TSC_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup TSC_Exported_Functions_Group2 Input and Output operation functions"]
    #[doc = " @{"]
    pub fn HAL_TSC_Start(htsc: *mut TSC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TSC_Start_IT(htsc: *mut TSC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TSC_Stop(htsc: *mut TSC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TSC_Stop_IT(htsc: *mut TSC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TSC_PollForAcquisition(htsc: *mut TSC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TSC_GroupGetStatus(
        htsc: *mut TSC_HandleTypeDef,
        gx_index: u32,
    ) -> TSC_GroupStatusTypeDef;
}
extern "C" {
    pub fn HAL_TSC_GroupGetValue(htsc: *mut TSC_HandleTypeDef, gx_index: u32) -> u32;
}
extern "C" {
    #[doc = " @addtogroup TSC_Exported_Functions_Group3 Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_TSC_IOConfig(
        htsc: *mut TSC_HandleTypeDef,
        config: *mut TSC_IOConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TSC_IODischarge(
        htsc: *mut TSC_HandleTypeDef,
        choice: FunctionalState,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TSC_Exported_Functions_Group4 Peripheral State and Errors functions"]
    #[doc = " @{"]
    pub fn HAL_TSC_GetState(htsc: *mut TSC_HandleTypeDef) -> HAL_TSC_StateTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TSC_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks"]
    #[doc = " @{"]
    pub fn HAL_TSC_IRQHandler(htsc: *mut TSC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TSC_ConvCpltCallback(htsc: *mut TSC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TSC_ErrorCallback(htsc: *mut TSC_HandleTypeDef);
}
#[doc = " @brief UART Init Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UART_InitTypeDef {
    #[doc = "< This member configures the UART communication baud rate."]
    #[doc = "The baud rate register is computed using the following formula:"]
    #[doc = "LPUART:"]
    #[doc = "======="]
    #[doc = "Baud Rate Register = ((256 * lpuart_ker_ckpres) / ((huart->Init.BaudRate)))"]
    #[doc = "where lpuart_ker_ck_pres is the UART input clock"]
    #[doc = "(divided by a prescaler if applicable)"]
    #[doc = "UART:"]
    #[doc = "====="]
    #[doc = "- If oversampling is 16 or in LIN mode,"]
    #[doc = "Baud Rate Register = ((uart_ker_ckpres) / ((huart->Init.BaudRate)))"]
    #[doc = "- If oversampling is 8,"]
    #[doc = "Baud Rate Register[15:4] = ((2 * uart_ker_ckpres) / ((huart->Init.BaudRate)))[15:4]"]
    #[doc = "Baud Rate Register[3] =  0"]
    #[doc = "Baud Rate Register[2:0] =  (((2 * uart_ker_ckpres) / ((huart->Init.BaudRate)))[3:0]) >> 1"]
    #[doc = "where uart_ker_ck_pres is the UART input clock (divided by a prescaler if applicable)"]
    pub BaudRate: u32,
    #[doc = "< Specifies the number of data bits transmitted or received in a frame."]
    #[doc = "This parameter can be a value of @ref UARTEx_Word_Length."]
    pub WordLength: u32,
    #[doc = "< Specifies the number of stop bits transmitted."]
    #[doc = "This parameter can be a value of @ref UART_Stop_Bits."]
    pub StopBits: u32,
    #[doc = "< Specifies the parity mode."]
    #[doc = "This parameter can be a value of @ref UART_Parity"]
    #[doc = "@note When parity is enabled, the computed parity is inserted"]
    #[doc = "at the MSB position of the transmitted data (9th bit when"]
    #[doc = "the word length is set to 9 data bits; 8th bit when the"]
    #[doc = "word length is set to 8 data bits)."]
    pub Parity: u32,
    #[doc = "< Specifies whether the Receive or Transmit mode is enabled or disabled."]
    #[doc = "This parameter can be a value of @ref UART_Mode."]
    pub Mode: u32,
    #[doc = "< Specifies whether the hardware flow control mode is enabled"]
    #[doc = "or disabled."]
    #[doc = "This parameter can be a value of @ref UART_Hardware_Flow_Control."]
    pub HwFlowCtl: u32,
    #[doc = "< Specifies whether the Over sampling 8 is enabled or disabled,"]
    #[doc = "to achieve higher speed (up to f_PCLK/8)."]
    #[doc = "This parameter can be a value of @ref UART_Over_Sampling."]
    pub OverSampling: u32,
    #[doc = "< Specifies whether a single sample or three samples' majority vote is selected."]
    #[doc = "Selecting the single sample method increases the receiver tolerance to clock"]
    #[doc = "deviations. This parameter can be a value of @ref UART_OneBit_Sampling."]
    pub OneBitSampling: u32,
}
#[test]
fn bindgen_test_layout_UART_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<UART_InitTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(UART_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<UART_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(UART_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UART_InitTypeDef>())).BaudRate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_InitTypeDef),
            "::",
            stringify!(BaudRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UART_InitTypeDef>())).WordLength as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_InitTypeDef),
            "::",
            stringify!(WordLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UART_InitTypeDef>())).StopBits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_InitTypeDef),
            "::",
            stringify!(StopBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UART_InitTypeDef>())).Parity as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_InitTypeDef),
            "::",
            stringify!(Parity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UART_InitTypeDef>())).Mode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UART_InitTypeDef>())).HwFlowCtl as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_InitTypeDef),
            "::",
            stringify!(HwFlowCtl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UART_InitTypeDef>())).OverSampling as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_InitTypeDef),
            "::",
            stringify!(OverSampling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UART_InitTypeDef>())).OneBitSampling as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_InitTypeDef),
            "::",
            stringify!(OneBitSampling)
        )
    );
}
#[doc = " @brief  UART Advanced Features initialization structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UART_AdvFeatureInitTypeDef {
    #[doc = "< Specifies which advanced UART features is initialized. Several"]
    #[doc = "Advanced Features may be initialized at the same time ."]
    #[doc = "This parameter can be a value of"]
    #[doc = "@ref UART_Advanced_Features_Initialization_Type."]
    pub AdvFeatureInit: u32,
    #[doc = "< Specifies whether the TX pin active level is inverted."]
    #[doc = "This parameter can be a value of @ref UART_Tx_Inv."]
    pub TxPinLevelInvert: u32,
    #[doc = "< Specifies whether the RX pin active level is inverted."]
    #[doc = "This parameter can be a value of @ref UART_Rx_Inv."]
    pub RxPinLevelInvert: u32,
    #[doc = "< Specifies whether data are inverted (positive/direct logic"]
    #[doc = "vs negative/inverted logic)."]
    #[doc = "This parameter can be a value of @ref UART_Data_Inv."]
    pub DataInvert: u32,
    #[doc = "< Specifies whether TX and RX pins are swapped."]
    #[doc = "This parameter can be a value of @ref UART_Rx_Tx_Swap."]
    pub Swap: u32,
    #[doc = "< Specifies whether the reception overrun detection is disabled."]
    #[doc = "This parameter can be a value of @ref UART_Overrun_Disable."]
    pub OverrunDisable: u32,
    #[doc = "< Specifies whether the DMA is disabled in case of reception error."]
    #[doc = "This parameter can be a value of @ref UART_DMA_Disable_on_Rx_Error."]
    pub DMADisableonRxError: u32,
    #[doc = "< Specifies whether auto Baud rate detection is enabled."]
    #[doc = "This parameter can be a value of @ref UART_AutoBaudRate_Enable."]
    pub AutoBaudRateEnable: u32,
    #[doc = "< If auto Baud rate detection is enabled, specifies how the rate"]
    #[doc = "detection is carried out."]
    #[doc = "This parameter can be a value of @ref UART_AutoBaud_Rate_Mode."]
    pub AutoBaudRateMode: u32,
    #[doc = "< Specifies whether MSB is sent first on UART line."]
    #[doc = "This parameter can be a value of @ref UART_MSB_First."]
    pub MSBFirst: u32,
}
#[test]
fn bindgen_test_layout_UART_AdvFeatureInitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<UART_AdvFeatureInitTypeDef>(),
        40usize,
        concat!("Size of: ", stringify!(UART_AdvFeatureInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<UART_AdvFeatureInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(UART_AdvFeatureInitTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UART_AdvFeatureInitTypeDef>())).AdvFeatureInit as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_AdvFeatureInitTypeDef),
            "::",
            stringify!(AdvFeatureInit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UART_AdvFeatureInitTypeDef>())).TxPinLevelInvert as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_AdvFeatureInitTypeDef),
            "::",
            stringify!(TxPinLevelInvert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UART_AdvFeatureInitTypeDef>())).RxPinLevelInvert as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_AdvFeatureInitTypeDef),
            "::",
            stringify!(RxPinLevelInvert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UART_AdvFeatureInitTypeDef>())).DataInvert as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_AdvFeatureInitTypeDef),
            "::",
            stringify!(DataInvert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UART_AdvFeatureInitTypeDef>())).Swap as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_AdvFeatureInitTypeDef),
            "::",
            stringify!(Swap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UART_AdvFeatureInitTypeDef>())).OverrunDisable as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_AdvFeatureInitTypeDef),
            "::",
            stringify!(OverrunDisable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UART_AdvFeatureInitTypeDef>())).DMADisableonRxError as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_AdvFeatureInitTypeDef),
            "::",
            stringify!(DMADisableonRxError)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UART_AdvFeatureInitTypeDef>())).AutoBaudRateEnable as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_AdvFeatureInitTypeDef),
            "::",
            stringify!(AutoBaudRateEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UART_AdvFeatureInitTypeDef>())).AutoBaudRateMode as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_AdvFeatureInitTypeDef),
            "::",
            stringify!(AutoBaudRateMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UART_AdvFeatureInitTypeDef>())).MSBFirst as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_AdvFeatureInitTypeDef),
            "::",
            stringify!(MSBFirst)
        )
    );
}
#[doc = " @brief HAL UART State definition"]
#[doc = " @note  HAL UART State value is a combination of 2 different substates:"]
#[doc = "        gState and RxState (see @ref UART_State_Definition)."]
#[doc = "        - gState contains UART state information related to global Handle management"]
#[doc = "          and also information related to Tx operations."]
#[doc = "          gState value coding follow below described bitmap :"]
#[doc = "          b7-b6  Error information"]
#[doc = "             00 : No Error"]
#[doc = "             01 : (Not Used)"]
#[doc = "             10 : Timeout"]
#[doc = "             11 : Error"]
#[doc = "          b5     Peripheral initialization status"]
#[doc = "             0  : Reset (Peripheral not initialized)"]
#[doc = "             1  : Init done (Peripheral initialized. HAL UART Init function already called)"]
#[doc = "          b4-b3  (not used)"]
#[doc = "             xx : Should be set to 00"]
#[doc = "          b2     Intrinsic process state"]
#[doc = "             0  : Ready"]
#[doc = "             1  : Busy (Peripheral busy with some configuration or internal operations)"]
#[doc = "          b1     (not used)"]
#[doc = "             x  : Should be set to 0"]
#[doc = "          b0     Tx state"]
#[doc = "             0  : Ready (no Tx operation ongoing)"]
#[doc = "             1  : Busy (Tx operation ongoing)"]
#[doc = "        - RxState contains information related to Rx operations."]
#[doc = "          RxState value coding follow below described bitmap :"]
#[doc = "          b7-b6  (not used)"]
#[doc = "             xx : Should be set to 00"]
#[doc = "          b5     Peripheral initialization status"]
#[doc = "             0  : Reset (Peripheral not initialized)"]
#[doc = "             1  : Init done (Peripheral initialized)"]
#[doc = "          b4-b2  (not used)"]
#[doc = "            xxx : Should be set to 000"]
#[doc = "          b1     Rx state"]
#[doc = "             0  : Ready (no Rx operation ongoing)"]
#[doc = "             1  : Busy (Rx operation ongoing)"]
#[doc = "          b0     (not used)"]
#[doc = "             x  : Should be set to 0."]
pub type HAL_UART_StateTypeDef = u32;
#[doc = "< PCLK1 clock source"]
pub const UART_ClockSourceTypeDef_UART_CLOCKSOURCE_PCLK1: UART_ClockSourceTypeDef = 0;
#[doc = "< PCLK2 clock source"]
pub const UART_ClockSourceTypeDef_UART_CLOCKSOURCE_PCLK2: UART_ClockSourceTypeDef = 1;
#[doc = "< HSI clock source"]
pub const UART_ClockSourceTypeDef_UART_CLOCKSOURCE_HSI: UART_ClockSourceTypeDef = 2;
#[doc = "< SYSCLK clock source"]
pub const UART_ClockSourceTypeDef_UART_CLOCKSOURCE_SYSCLK: UART_ClockSourceTypeDef = 4;
#[doc = "< LSE clock source"]
pub const UART_ClockSourceTypeDef_UART_CLOCKSOURCE_LSE: UART_ClockSourceTypeDef = 8;
#[doc = "< Undefined clock source"]
pub const UART_ClockSourceTypeDef_UART_CLOCKSOURCE_UNDEFINED: UART_ClockSourceTypeDef = 16;
#[doc = " @brief UART clock sources definition"]
pub type UART_ClockSourceTypeDef = libc::c_uint;
#[doc = " @brief HAL UART Reception type definition"]
#[doc = " @note  HAL UART Reception type value aims to identify which type of Reception is ongoing."]
#[doc = "        It is expected to admit following values :"]
#[doc = "           HAL_UART_RECEPTION_STANDARD         = 0x00U,"]
#[doc = "           HAL_UART_RECEPTION_TOIDLE           = 0x01U,"]
#[doc = "           HAL_UART_RECEPTION_TORTO            = 0x02U,"]
#[doc = "           HAL_UART_RECEPTION_TOCHARMATCH      = 0x03U,"]
pub type HAL_UART_RxTypeTypeDef = u32;
#[doc = " @brief  UART handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __UART_HandleTypeDef {
    #[doc = "< UART registers base address"]
    pub Instance: *mut USART_TypeDef,
    #[doc = "< UART communication parameters"]
    pub Init: UART_InitTypeDef,
    #[doc = "< UART Advanced Features initialization parameters"]
    pub AdvancedInit: UART_AdvFeatureInitTypeDef,
    #[doc = "< Pointer to UART Tx transfer Buffer"]
    pub pTxBuffPtr: *mut u8,
    #[doc = "< UART Tx Transfer size"]
    pub TxXferSize: u16,
    #[doc = "< UART Tx Transfer Counter"]
    pub TxXferCount: u16,
    #[doc = "< Pointer to UART Rx transfer Buffer"]
    pub pRxBuffPtr: *mut u8,
    #[doc = "< UART Rx Transfer size"]
    pub RxXferSize: u16,
    #[doc = "< UART Rx Transfer Counter"]
    pub RxXferCount: u16,
    #[doc = "< UART Rx RDR register mask"]
    pub Mask: u16,
    #[doc = "< Type of ongoing reception"]
    pub ReceptionType: HAL_UART_RxTypeTypeDef,
    #[doc = "< Function pointer on Rx IRQ handler"]
    pub RxISR: ::core::option::Option<unsafe extern "C" fn(huart: *mut __UART_HandleTypeDef)>,
    #[doc = "< Function pointer on Tx IRQ handler"]
    pub TxISR: ::core::option::Option<unsafe extern "C" fn(huart: *mut __UART_HandleTypeDef)>,
    #[doc = "< UART Tx DMA Handle parameters"]
    pub hdmatx: *mut DMA_HandleTypeDef,
    #[doc = "< UART Rx DMA Handle parameters"]
    pub hdmarx: *mut DMA_HandleTypeDef,
    #[doc = "< Locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< UART state information related to global Handle management"]
    #[doc = "and also related to Tx operations. This parameter"]
    #[doc = "can be a value of @ref HAL_UART_StateTypeDef"]
    pub gState: HAL_UART_StateTypeDef,
    #[doc = "< UART state information related to Rx operations. This"]
    #[doc = "parameter can be a value of @ref HAL_UART_StateTypeDef"]
    pub RxState: HAL_UART_StateTypeDef,
    #[doc = "< UART Error code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout___UART_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<__UART_HandleTypeDef>(),
        132usize,
        concat!("Size of: ", stringify!(__UART_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<__UART_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(__UART_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__UART_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__UART_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__UART_HandleTypeDef>())).AdvancedInit as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(AdvancedInit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__UART_HandleTypeDef>())).pTxBuffPtr as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(pTxBuffPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__UART_HandleTypeDef>())).TxXferSize as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(TxXferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__UART_HandleTypeDef>())).TxXferCount as *const _ as usize
        },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(TxXferCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__UART_HandleTypeDef>())).pRxBuffPtr as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(pRxBuffPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__UART_HandleTypeDef>())).RxXferSize as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(RxXferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__UART_HandleTypeDef>())).RxXferCount as *const _ as usize
        },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(RxXferCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__UART_HandleTypeDef>())).Mask as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__UART_HandleTypeDef>())).ReceptionType as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(ReceptionType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__UART_HandleTypeDef>())).RxISR as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(RxISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__UART_HandleTypeDef>())).TxISR as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(TxISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__UART_HandleTypeDef>())).hdmatx as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(hdmatx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__UART_HandleTypeDef>())).hdmarx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(hdmarx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__UART_HandleTypeDef>())).Lock as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__UART_HandleTypeDef>())).gState as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(gState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__UART_HandleTypeDef>())).RxState as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(RxState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__UART_HandleTypeDef>())).ErrorCode as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl Default for __UART_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  UART handle Structure definition"]
pub type UART_HandleTypeDef = __UART_HandleTypeDef;
#[doc = " @brief  UART wake up from stop mode parameters"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UART_WakeUpTypeDef {
    #[doc = "< Specifies which event will activate the Wakeup from Stop mode flag (WUF)."]
    #[doc = "This parameter can be a value of @ref UART_WakeUp_from_Stop_Selection."]
    #[doc = "If set to UART_WAKEUP_ON_ADDRESS, the two other fields below must"]
    #[doc = "be filled up."]
    pub WakeUpEvent: u32,
    #[doc = "< Specifies whether the address is 4 or 7-bit long."]
    #[doc = "This parameter can be a value of @ref UARTEx_WakeUp_Address_Length."]
    pub AddressLength: u16,
    #[doc = "< UART/USART node address (7-bit long max)."]
    pub Address: u8,
}
#[test]
fn bindgen_test_layout_UART_WakeUpTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<UART_WakeUpTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(UART_WakeUpTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<UART_WakeUpTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(UART_WakeUpTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UART_WakeUpTypeDef>())).WakeUpEvent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_WakeUpTypeDef),
            "::",
            stringify!(WakeUpEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UART_WakeUpTypeDef>())).AddressLength as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_WakeUpTypeDef),
            "::",
            stringify!(AddressLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UART_WakeUpTypeDef>())).Address as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_WakeUpTypeDef),
            "::",
            stringify!(Address)
        )
    );
}
extern "C" {
    #[doc = " @addtogroup UARTEx_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_RS485Ex_Init(
        huart: *mut UART_HandleTypeDef,
        Polarity: u32,
        AssertionTime: u32,
        DeassertionTime: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup UARTEx_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_UARTEx_WakeupCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup UARTEx_Exported_Functions_Group3"]
    #[doc = " @{"]
    pub fn HAL_UARTEx_StopModeWakeUpSourceConfig(
        huart: *mut UART_HandleTypeDef,
        WakeUpSelection: UART_WakeUpTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UARTEx_EnableStopMode(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UARTEx_DisableStopMode(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UARTEx_EnableClockStopMode(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UARTEx_DisableClockStopMode(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MultiProcessorEx_AddressLength_Set(
        huart: *mut UART_HandleTypeDef,
        AddressLength: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UARTEx_ReceiveToIdle(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        RxLen: *mut u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UARTEx_ReceiveToIdle_IT(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UARTEx_ReceiveToIdle_DMA(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup UART_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_UART_Init(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_HalfDuplex_Init(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LIN_Init(
        huart: *mut UART_HandleTypeDef,
        BreakDetectLength: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MultiProcessor_Init(
        huart: *mut UART_HandleTypeDef,
        Address: u8,
        WakeUpMethod: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_DeInit(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_MspInit(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_MspDeInit(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup UART_Exported_Functions_Group2 IO operation functions"]
    #[doc = " @{"]
    pub fn HAL_UART_Transmit(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_Receive(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_Transmit_IT(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_Receive_IT(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_Transmit_DMA(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_Receive_DMA(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_DMAPause(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_DMAResume(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_DMAStop(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_Abort(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_AbortTransmit(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_AbortReceive(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_Abort_IT(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_AbortTransmit_IT(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_AbortReceive_IT(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_IRQHandler(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_TxHalfCpltCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_TxCpltCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_RxHalfCpltCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_RxCpltCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_ErrorCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_AbortCpltCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_AbortTransmitCpltCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_AbortReceiveCpltCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UARTEx_RxEventCallback(huart: *mut UART_HandleTypeDef, Size: u16);
}
extern "C" {
    #[doc = " @addtogroup UART_Exported_Functions_Group3 Peripheral Control functions"]
    #[doc = " @{"]
    pub fn HAL_UART_ReceiverTimeout_Config(huart: *mut UART_HandleTypeDef, TimeoutValue: u32);
}
extern "C" {
    pub fn HAL_UART_EnableReceiverTimeout(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_DisableReceiverTimeout(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LIN_SendBreak(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MultiProcessor_EnableMuteMode(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MultiProcessor_DisableMuteMode(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MultiProcessor_EnterMuteMode(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_HalfDuplex_EnableTransmitter(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_HalfDuplex_EnableReceiver(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup UART_Exported_Functions_Group4 Peripheral State and Error functions"]
    #[doc = " @{"]
    pub fn HAL_UART_GetState(huart: *mut UART_HandleTypeDef) -> HAL_UART_StateTypeDef;
}
extern "C" {
    pub fn HAL_UART_GetError(huart: *mut UART_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn UART_SetConfig(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn UART_CheckIdleState(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn UART_WaitOnFlagUntilTimeout(
        huart: *mut UART_HandleTypeDef,
        Flag: u32,
        Status: FlagStatus,
        Tickstart: u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn UART_AdvFeatureConfig(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn UART_Start_Receive_IT(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn UART_Start_Receive_DMA(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
#[doc = " @brief USART Init Structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USART_InitTypeDef {
    #[doc = "< This member configures the Usart communication baud rate."]
    #[doc = "The baud rate is computed using the following formula:"]
    #[doc = "Baud Rate Register[15:4] = ((2 * fclk_pres) / ((huart->Init.BaudRate)))[15:4]"]
    #[doc = "Baud Rate Register[3]    = 0"]
    #[doc = "Baud Rate Register[2:0]  =  (((2 * fclk_pres) / ((huart->Init.BaudRate)))[3:0]) >> 1"]
    #[doc = "where fclk_pres is the USART input clock frequency (fclk) (divided by a prescaler if applicable)"]
    #[doc = "@note  Oversampling by 8 is systematically applied to achieve high baud rates."]
    pub BaudRate: u32,
    #[doc = "< Specifies the number of data bits transmitted or received in a frame."]
    #[doc = "This parameter can be a value of @ref USARTEx_Word_Length."]
    pub WordLength: u32,
    #[doc = "< Specifies the number of stop bits transmitted."]
    #[doc = "This parameter can be a value of @ref USART_Stop_Bits."]
    pub StopBits: u32,
    #[doc = "< Specifies the parity mode."]
    #[doc = "This parameter can be a value of @ref USART_Parity"]
    #[doc = "@note When parity is enabled, the computed parity is inserted"]
    #[doc = "at the MSB position of the transmitted data (9th bit when"]
    #[doc = "the word length is set to 9 data bits; 8th bit when the"]
    #[doc = "word length is set to 8 data bits)."]
    pub Parity: u32,
    #[doc = "< Specifies whether the Receive or Transmit mode is enabled or disabled."]
    #[doc = "This parameter can be a value of @ref USART_Mode."]
    pub Mode: u32,
    #[doc = "< Specifies the steady state of the serial clock."]
    #[doc = "This parameter can be a value of @ref USART_Clock_Polarity."]
    pub CLKPolarity: u32,
    #[doc = "< Specifies the clock transition on which the bit capture is made."]
    #[doc = "This parameter can be a value of @ref USART_Clock_Phase."]
    pub CLKPhase: u32,
    #[doc = "< Specifies whether the clock pulse corresponding to the last transmitted"]
    #[doc = "data bit (MSB) has to be output on the SCLK pin in synchronous mode."]
    #[doc = "This parameter can be a value of @ref USART_Last_Bit."]
    pub CLKLastBit: u32,
}
#[test]
fn bindgen_test_layout_USART_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<USART_InitTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(USART_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USART_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USART_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_InitTypeDef>())).BaudRate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_InitTypeDef),
            "::",
            stringify!(BaudRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_InitTypeDef>())).WordLength as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_InitTypeDef),
            "::",
            stringify!(WordLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_InitTypeDef>())).StopBits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_InitTypeDef),
            "::",
            stringify!(StopBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_InitTypeDef>())).Parity as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_InitTypeDef),
            "::",
            stringify!(Parity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_InitTypeDef>())).Mode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_InitTypeDef>())).CLKPolarity as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_InitTypeDef),
            "::",
            stringify!(CLKPolarity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_InitTypeDef>())).CLKPhase as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_InitTypeDef),
            "::",
            stringify!(CLKPhase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USART_InitTypeDef>())).CLKLastBit as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_InitTypeDef),
            "::",
            stringify!(CLKLastBit)
        )
    );
}
#[doc = "< Peripheral is not initialized"]
pub const HAL_USART_StateTypeDef_HAL_USART_STATE_RESET: HAL_USART_StateTypeDef = 0;
#[doc = "< Peripheral Initialized and ready for use"]
pub const HAL_USART_StateTypeDef_HAL_USART_STATE_READY: HAL_USART_StateTypeDef = 1;
#[doc = "< an internal process is ongoing"]
pub const HAL_USART_StateTypeDef_HAL_USART_STATE_BUSY: HAL_USART_StateTypeDef = 2;
#[doc = "< Data Transmission process is ongoing"]
pub const HAL_USART_StateTypeDef_HAL_USART_STATE_BUSY_TX: HAL_USART_StateTypeDef = 18;
#[doc = "< Data Reception process is ongoing"]
pub const HAL_USART_StateTypeDef_HAL_USART_STATE_BUSY_RX: HAL_USART_StateTypeDef = 34;
#[doc = "< Data Transmission Reception process is ongoing"]
pub const HAL_USART_StateTypeDef_HAL_USART_STATE_BUSY_TX_RX: HAL_USART_StateTypeDef = 50;
#[doc = "< Timeout state"]
pub const HAL_USART_StateTypeDef_HAL_USART_STATE_TIMEOUT: HAL_USART_StateTypeDef = 3;
#[doc = "< Error"]
pub const HAL_USART_StateTypeDef_HAL_USART_STATE_ERROR: HAL_USART_StateTypeDef = 4;
#[doc = " @brief HAL USART State structures definition"]
pub type HAL_USART_StateTypeDef = libc::c_uint;
#[doc = "< PCLK1 clock source"]
pub const USART_ClockSourceTypeDef_USART_CLOCKSOURCE_PCLK1: USART_ClockSourceTypeDef = 0;
#[doc = "< PCLK2 clock source"]
pub const USART_ClockSourceTypeDef_USART_CLOCKSOURCE_PCLK2: USART_ClockSourceTypeDef = 1;
#[doc = "< HSI clock source"]
pub const USART_ClockSourceTypeDef_USART_CLOCKSOURCE_HSI: USART_ClockSourceTypeDef = 2;
#[doc = "< SYSCLK clock source"]
pub const USART_ClockSourceTypeDef_USART_CLOCKSOURCE_SYSCLK: USART_ClockSourceTypeDef = 4;
#[doc = "< LSE clock source"]
pub const USART_ClockSourceTypeDef_USART_CLOCKSOURCE_LSE: USART_ClockSourceTypeDef = 8;
#[doc = "< Undefined clock source"]
pub const USART_ClockSourceTypeDef_USART_CLOCKSOURCE_UNDEFINED: USART_ClockSourceTypeDef = 16;
#[doc = " @brief  USART clock sources definitions"]
pub type USART_ClockSourceTypeDef = libc::c_uint;
#[doc = " @brief  USART handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __USART_HandleTypeDef {
    #[doc = "< USART registers base address"]
    pub Instance: *mut USART_TypeDef,
    #[doc = "< USART communication parameters"]
    pub Init: USART_InitTypeDef,
    #[doc = "< Pointer to USART Tx transfer Buffer"]
    pub pTxBuffPtr: *mut u8,
    #[doc = "< USART Tx Transfer size"]
    pub TxXferSize: u16,
    #[doc = "< USART Tx Transfer Counter"]
    pub TxXferCount: u16,
    #[doc = "< Pointer to USART Rx transfer Buffer"]
    pub pRxBuffPtr: *mut u8,
    #[doc = "< USART Rx Transfer size"]
    pub RxXferSize: u16,
    #[doc = "< USART Rx Transfer Counter"]
    pub RxXferCount: u16,
    #[doc = "< USART Rx RDR register mask"]
    pub Mask: u16,
    #[doc = "< Function pointer on Rx IRQ handler"]
    pub RxISR: ::core::option::Option<unsafe extern "C" fn(husart: *mut __USART_HandleTypeDef)>,
    #[doc = "< Function pointer on Tx IRQ handler"]
    pub TxISR: ::core::option::Option<unsafe extern "C" fn(husart: *mut __USART_HandleTypeDef)>,
    #[doc = "< USART Tx DMA Handle parameters"]
    pub hdmatx: *mut DMA_HandleTypeDef,
    #[doc = "< USART Rx DMA Handle parameters"]
    pub hdmarx: *mut DMA_HandleTypeDef,
    #[doc = "< Locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< USART communication state"]
    pub State: HAL_USART_StateTypeDef,
    #[doc = "< USART Error code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout___USART_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<__USART_HandleTypeDef>(),
        84usize,
        concat!("Size of: ", stringify!(__USART_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<__USART_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(__USART_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__USART_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__USART_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__USART_HandleTypeDef>())).pTxBuffPtr as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(pTxBuffPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__USART_HandleTypeDef>())).TxXferSize as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(TxXferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__USART_HandleTypeDef>())).TxXferCount as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(TxXferCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__USART_HandleTypeDef>())).pRxBuffPtr as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(pRxBuffPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__USART_HandleTypeDef>())).RxXferSize as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(RxXferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__USART_HandleTypeDef>())).RxXferCount as *const _ as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(RxXferCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__USART_HandleTypeDef>())).Mask as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__USART_HandleTypeDef>())).RxISR as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(RxISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__USART_HandleTypeDef>())).TxISR as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(TxISR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__USART_HandleTypeDef>())).hdmatx as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(hdmatx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__USART_HandleTypeDef>())).hdmarx as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(hdmarx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__USART_HandleTypeDef>())).Lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__USART_HandleTypeDef>())).State as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__USART_HandleTypeDef>())).ErrorCode as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__USART_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl Default for __USART_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  USART handle Structure definition"]
pub type USART_HandleTypeDef = __USART_HandleTypeDef;
extern "C" {
    #[doc = " @addtogroup USART_Exported_Functions_Group1 Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn HAL_USART_Init(husart: *mut USART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_DeInit(husart: *mut USART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_MspInit(husart: *mut USART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_USART_MspDeInit(husart: *mut USART_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup USART_Exported_Functions_Group2 IO operation functions"]
    #[doc = " @{"]
    pub fn HAL_USART_Transmit(
        husart: *mut USART_HandleTypeDef,
        pTxData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_Receive(
        husart: *mut USART_HandleTypeDef,
        pRxData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_TransmitReceive(
        husart: *mut USART_HandleTypeDef,
        pTxData: *mut u8,
        pRxData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_Transmit_IT(
        husart: *mut USART_HandleTypeDef,
        pTxData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_Receive_IT(
        husart: *mut USART_HandleTypeDef,
        pRxData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_TransmitReceive_IT(
        husart: *mut USART_HandleTypeDef,
        pTxData: *mut u8,
        pRxData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_Transmit_DMA(
        husart: *mut USART_HandleTypeDef,
        pTxData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_Receive_DMA(
        husart: *mut USART_HandleTypeDef,
        pRxData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_TransmitReceive_DMA(
        husart: *mut USART_HandleTypeDef,
        pTxData: *mut u8,
        pRxData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_DMAPause(husart: *mut USART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_DMAResume(husart: *mut USART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_DMAStop(husart: *mut USART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_Abort(husart: *mut USART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_Abort_IT(husart: *mut USART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_USART_IRQHandler(husart: *mut USART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_USART_TxHalfCpltCallback(husart: *mut USART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_USART_TxCpltCallback(husart: *mut USART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_USART_RxCpltCallback(husart: *mut USART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_USART_RxHalfCpltCallback(husart: *mut USART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_USART_TxRxCpltCallback(husart: *mut USART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_USART_ErrorCallback(husart: *mut USART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_USART_AbortCpltCallback(husart: *mut USART_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup USART_Exported_Functions_Group4 Peripheral State and Error functions"]
    #[doc = " @{"]
    pub fn HAL_USART_GetState(husart: *mut USART_HandleTypeDef) -> HAL_USART_StateTypeDef;
}
extern "C" {
    pub fn HAL_USART_GetError(husart: *mut USART_HandleTypeDef) -> u32;
}
#[doc = " @brief  WWDG Init structure definition"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WWDG_InitTypeDef {
    #[doc = "< Specifies the prescaler value of the WWDG."]
    #[doc = "This parameter can be a value of @ref WWDG_Prescaler"]
    pub Prescaler: u32,
    #[doc = "< Specifies the WWDG window value to be compared to the downcounter."]
    #[doc = "This parameter must be a number Min_Data = 0x40 and Max_Data = 0x7F"]
    pub Window: u32,
    #[doc = "< Specifies the WWDG free-running downcounter  value."]
    #[doc = "This parameter must be a number between Min_Data = 0x40 and Max_Data = 0x7F"]
    pub Counter: u32,
    #[doc = "< Specifies if WWDG Early Wakeup Interrupt is enable or not."]
    #[doc = "This parameter can be a value of @ref WWDG_EWI_Mode"]
    pub EWIMode: u32,
}
#[test]
fn bindgen_test_layout_WWDG_InitTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<WWDG_InitTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(WWDG_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<WWDG_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(WWDG_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WWDG_InitTypeDef>())).Prescaler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WWDG_InitTypeDef>())).Window as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_InitTypeDef),
            "::",
            stringify!(Window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WWDG_InitTypeDef>())).Counter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_InitTypeDef),
            "::",
            stringify!(Counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WWDG_InitTypeDef>())).EWIMode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_InitTypeDef),
            "::",
            stringify!(EWIMode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WWDG_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut WWDG_TypeDef,
    #[doc = "< WWDG required parameters"]
    pub Init: WWDG_InitTypeDef,
}
#[test]
fn bindgen_test_layout_WWDG_HandleTypeDef() {
    assert_eq!(
        ::core::mem::size_of::<WWDG_HandleTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(WWDG_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<WWDG_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(WWDG_HandleTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WWDG_HandleTypeDef>())).Instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WWDG_HandleTypeDef>())).Init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
}
impl Default for WWDG_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @addtogroup WWDG_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_WWDG_Init(hwwdg: *mut WWDG_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_WWDG_MspInit(hwwdg: *mut WWDG_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup WWDG_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_WWDG_Refresh(hwwdg: *mut WWDG_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_WWDG_IRQHandler(hwwdg: *mut WWDG_HandleTypeDef);
}
extern "C" {
    pub fn HAL_WWDG_EarlyWakeupCallback(hwwdg: *mut WWDG_HandleTypeDef);
}
pub const HAL_TickFreqTypeDef_HAL_TICK_FREQ_10HZ: HAL_TickFreqTypeDef = 100;
pub const HAL_TickFreqTypeDef_HAL_TICK_FREQ_100HZ: HAL_TickFreqTypeDef = 10;
pub const HAL_TickFreqTypeDef_HAL_TICK_FREQ_1KHZ: HAL_TickFreqTypeDef = 1;
pub const HAL_TickFreqTypeDef_HAL_TICK_FREQ_DEFAULT: HAL_TickFreqTypeDef = 1;
#[doc = " @defgroup HAL_TICK_FREQ Tick Frequency"]
#[doc = " @{"]
pub type HAL_TickFreqTypeDef = libc::c_uint;
extern "C" {
    #[doc = " @addtogroup HAL_Exported_Variables"]
    #[doc = " @{"]
    pub static mut uwTick: u32;
}
extern "C" {
    pub static mut uwTickPrio: u32;
}
extern "C" {
    pub static mut uwTickFreq: HAL_TickFreqTypeDef;
}
extern "C" {
    #[doc = " @addtogroup HAL_Exported_Functions_Group1"]
    #[doc = " @{"]
    pub fn HAL_Init() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DeInit() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MspInit();
}
extern "C" {
    pub fn HAL_MspDeInit();
}
extern "C" {
    pub fn HAL_InitTick(TickPriority: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup HAL_Exported_Functions_Group2"]
    #[doc = " @{"]
    pub fn HAL_IncTick();
}
extern "C" {
    pub fn HAL_Delay(Delay: u32);
}
extern "C" {
    pub fn HAL_GetTick() -> u32;
}
extern "C" {
    pub fn HAL_GetTickPrio() -> u32;
}
extern "C" {
    pub fn HAL_SetTickFreq(Freq: HAL_TickFreqTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_GetTickFreq() -> HAL_TickFreqTypeDef;
}
extern "C" {
    pub fn HAL_SuspendTick();
}
extern "C" {
    pub fn HAL_ResumeTick();
}
extern "C" {
    pub fn HAL_GetHalVersion() -> u32;
}
extern "C" {
    pub fn HAL_GetREVID() -> u32;
}
extern "C" {
    pub fn HAL_GetDEVID() -> u32;
}
extern "C" {
    pub fn HAL_GetUIDw0() -> u32;
}
extern "C" {
    pub fn HAL_GetUIDw1() -> u32;
}
extern "C" {
    pub fn HAL_GetUIDw2() -> u32;
}
extern "C" {
    #[doc = " @addtogroup HAL_Exported_Functions_Group3"]
    #[doc = " @{"]
    pub fn HAL_DBGMCU_EnableDBGSleepMode();
}
extern "C" {
    pub fn HAL_DBGMCU_DisableDBGSleepMode();
}
extern "C" {
    pub fn HAL_DBGMCU_EnableDBGStopMode();
}
extern "C" {
    pub fn HAL_DBGMCU_DisableDBGStopMode();
}
extern "C" {
    pub fn HAL_DBGMCU_EnableDBGStandbyMode();
}
extern "C" {
    pub fn HAL_DBGMCU_DisableDBGStandbyMode();
}
extern "C" {
    #[doc = " @addtogroup HAL_Exported_Functions_Group4"]
    #[doc = " @{"]
    pub fn HAL_SYSCFG_SRAM2Erase();
}
extern "C" {
    pub fn HAL_SYSCFG_EnableMemorySwappingBank();
}
extern "C" {
    pub fn HAL_SYSCFG_DisableMemorySwappingBank();
}
extern "C" {
    pub fn HAL_SYSCFG_VREFBUF_VoltageScalingConfig(VoltageScaling: u32);
}
extern "C" {
    pub fn HAL_SYSCFG_VREFBUF_HighImpedanceConfig(Mode: u32);
}
extern "C" {
    pub fn HAL_SYSCFG_VREFBUF_TrimmingConfig(TrimmingValue: u32);
}
extern "C" {
    pub fn HAL_SYSCFG_EnableVREFBUF() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SYSCFG_DisableVREFBUF();
}
extern "C" {
    pub fn HAL_SYSCFG_EnableIOAnalogSwitchBooster();
}
extern "C" {
    pub fn HAL_SYSCFG_DisableIOAnalogSwitchBooster();
}
extern "C" {
    pub fn HAL_RCC_RNG_CLK_ENABLE();
}
